{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\n\nexports.__esModule = true;\nexports.default = void 0;\n\nvar R = _interopRequireWildcard(require(\"ramda\"));\n\nvar P = _interopRequireWildcard(require(\"@react-pdf/primitives\"));\n\nvar _layoutText = _interopRequireDefault(require(\"../text/layoutText\"));\n\nconst isType = R.propEq('type');\nconst isSvg = isType(P.Svg);\nconst isText = isType(P.Text);\nconst isNotSvg = R.complement(isSvg);\n\nconst hasLines = node => node.props.fixed ? !R.isEmpty(node.lines) : !!node.lines;\n\nconst shouldLayoutText = node => isText(node) && !hasLines(node);\n/**\n * Performs text layout on text node if wasn't calculated before.\n * Text layout is usually performed on Yoga's layout process (via setMeasureFunc),\n * but we need to layout those nodes with fixed width and height.\n *\n * @param {Object} node\n * @returns {Object} layout node\n */\n\n\nconst resolveTextLayout = (node, fontStore) => {\n  const mapChild = child => resolveTextLayout(child, fontStore);\n\n  return R.compose(R.evolve({\n    children: R.map(R.when(isNotSvg, mapChild))\n  }), R.when(shouldLayoutText, R.compose(R.converge(R.assoc('lines'), [R.converge(_layoutText.default, [R.identity, R.path(['box', 'width']), R.path(['box', 'height']), R.always(fontStore)]), R.identity]))))(node);\n};\n\nvar _default = resolveTextLayout;\nexports.default = _default;","map":{"version":3,"sources":["/Users/kaja/Code/mallar/app/node_modules/@react-pdf/layout/lib/steps/resolveTextLayout.js"],"names":["_interopRequireDefault","require","_interopRequireWildcard","exports","__esModule","default","R","P","_layoutText","isType","propEq","isSvg","Svg","isText","Text","isNotSvg","complement","hasLines","node","props","fixed","isEmpty","lines","shouldLayoutText","resolveTextLayout","fontStore","mapChild","child","compose","evolve","children","map","when","converge","assoc","identity","path","always","_default"],"mappings":"AAAA;;AAEA,IAAIA,sBAAsB,GAAGC,OAAO,CAAC,8CAAD,CAApC;;AAEA,IAAIC,uBAAuB,GAAGD,OAAO,CAAC,+CAAD,CAArC;;AAEAE,OAAO,CAACC,UAAR,GAAqB,IAArB;AACAD,OAAO,CAACE,OAAR,GAAkB,KAAK,CAAvB;;AAEA,IAAIC,CAAC,GAAGJ,uBAAuB,CAACD,OAAO,CAAC,OAAD,CAAR,CAA/B;;AAEA,IAAIM,CAAC,GAAGL,uBAAuB,CAACD,OAAO,CAAC,uBAAD,CAAR,CAA/B;;AAEA,IAAIO,WAAW,GAAGR,sBAAsB,CAACC,OAAO,CAAC,oBAAD,CAAR,CAAxC;;AAEA,MAAMQ,MAAM,GAAGH,CAAC,CAACI,MAAF,CAAS,MAAT,CAAf;AACA,MAAMC,KAAK,GAAGF,MAAM,CAACF,CAAC,CAACK,GAAH,CAApB;AACA,MAAMC,MAAM,GAAGJ,MAAM,CAACF,CAAC,CAACO,IAAH,CAArB;AACA,MAAMC,QAAQ,GAAGT,CAAC,CAACU,UAAF,CAAaL,KAAb,CAAjB;;AAEA,MAAMM,QAAQ,GAAGC,IAAI,IAAIA,IAAI,CAACC,KAAL,CAAWC,KAAX,GAAmB,CAACd,CAAC,CAACe,OAAF,CAAUH,IAAI,CAACI,KAAf,CAApB,GAA4C,CAAC,CAACJ,IAAI,CAACI,KAA5E;;AAEA,MAAMC,gBAAgB,GAAGL,IAAI,IAAIL,MAAM,CAACK,IAAD,CAAN,IAAgB,CAACD,QAAQ,CAACC,IAAD,CAA1D;AACA;;;;;;;;;;AAUA,MAAMM,iBAAiB,GAAG,CAACN,IAAD,EAAOO,SAAP,KAAqB;AAC7C,QAAMC,QAAQ,GAAGC,KAAK,IAAIH,iBAAiB,CAACG,KAAD,EAAQF,SAAR,CAA3C;;AAEA,SAAOnB,CAAC,CAACsB,OAAF,CAAUtB,CAAC,CAACuB,MAAF,CAAS;AACxBC,IAAAA,QAAQ,EAAExB,CAAC,CAACyB,GAAF,CAAMzB,CAAC,CAAC0B,IAAF,CAAOjB,QAAP,EAAiBW,QAAjB,CAAN;AADc,GAAT,CAAV,EAEHpB,CAAC,CAAC0B,IAAF,CAAOT,gBAAP,EAAyBjB,CAAC,CAACsB,OAAF,CAAUtB,CAAC,CAAC2B,QAAF,CAAW3B,CAAC,CAAC4B,KAAF,CAAQ,OAAR,CAAX,EAA6B,CAAC5B,CAAC,CAAC2B,QAAF,CAAWzB,WAAW,CAACH,OAAvB,EAAgC,CAACC,CAAC,CAAC6B,QAAH,EAAa7B,CAAC,CAAC8B,IAAF,CAAO,CAAC,KAAD,EAAQ,OAAR,CAAP,CAAb,EAAuC9B,CAAC,CAAC8B,IAAF,CAAO,CAAC,KAAD,EAAQ,QAAR,CAAP,CAAvC,EAAkE9B,CAAC,CAAC+B,MAAF,CAASZ,SAAT,CAAlE,CAAhC,CAAD,EAA0HnB,CAAC,CAAC6B,QAA5H,CAA7B,CAAV,CAAzB,CAFG,EAEuMjB,IAFvM,CAAP;AAGD,CAND;;AAQA,IAAIoB,QAAQ,GAAGd,iBAAf;AACArB,OAAO,CAACE,OAAR,GAAkBiC,QAAlB","sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\n\nexports.__esModule = true;\nexports.default = void 0;\n\nvar R = _interopRequireWildcard(require(\"ramda\"));\n\nvar P = _interopRequireWildcard(require(\"@react-pdf/primitives\"));\n\nvar _layoutText = _interopRequireDefault(require(\"../text/layoutText\"));\n\nconst isType = R.propEq('type');\nconst isSvg = isType(P.Svg);\nconst isText = isType(P.Text);\nconst isNotSvg = R.complement(isSvg);\n\nconst hasLines = node => node.props.fixed ? !R.isEmpty(node.lines) : !!node.lines;\n\nconst shouldLayoutText = node => isText(node) && !hasLines(node);\n/**\n * Performs text layout on text node if wasn't calculated before.\n * Text layout is usually performed on Yoga's layout process (via setMeasureFunc),\n * but we need to layout those nodes with fixed width and height.\n *\n * @param {Object} node\n * @returns {Object} layout node\n */\n\n\nconst resolveTextLayout = (node, fontStore) => {\n  const mapChild = child => resolveTextLayout(child, fontStore);\n\n  return R.compose(R.evolve({\n    children: R.map(R.when(isNotSvg, mapChild))\n  }), R.when(shouldLayoutText, R.compose(R.converge(R.assoc('lines'), [R.converge(_layoutText.default, [R.identity, R.path(['box', 'width']), R.path(['box', 'height']), R.always(fontStore)]), R.identity]))))(node);\n};\n\nvar _default = resolveTextLayout;\nexports.default = _default;"]},"metadata":{},"sourceType":"script"}