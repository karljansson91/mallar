{"ast":null,"code":"var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n;\n\n(function (exports) {\n  'use strict';\n\n  var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;\n  var PLUS = '+'.charCodeAt(0);\n  var SLASH = '/'.charCodeAt(0);\n  var NUMBER = '0'.charCodeAt(0);\n  var LOWER = 'a'.charCodeAt(0);\n  var UPPER = 'A'.charCodeAt(0);\n  var PLUS_URL_SAFE = '-'.charCodeAt(0);\n  var SLASH_URL_SAFE = '_'.charCodeAt(0);\n\n  function decode(elt) {\n    var code = elt.charCodeAt(0);\n    if (code === PLUS || code === PLUS_URL_SAFE) return 62; // '+'\n\n    if (code === SLASH || code === SLASH_URL_SAFE) return 63; // '/'\n\n    if (code < NUMBER) return -1; //no match\n\n    if (code < NUMBER + 10) return code - NUMBER + 26 + 26;\n    if (code < UPPER + 26) return code - UPPER;\n    if (code < LOWER + 26) return code - LOWER + 26;\n  }\n\n  function b64ToByteArray(b64) {\n    var i, j, l, tmp, placeHolders, arr;\n\n    if (b64.length % 4 > 0) {\n      throw new Error('Invalid string. Length must be a multiple of 4');\n    } // the number of equal signs (place holders)\n    // if there are two placeholders, than the two characters before it\n    // represent one byte\n    // if there is only one, then the three characters before it represent 2 bytes\n    // this is just a cheap hack to not do indexOf twice\n\n\n    var len = b64.length;\n    placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0; // base64 is 4/3 + up to two characters of the original data\n\n    arr = new Arr(b64.length * 3 / 4 - placeHolders); // if there are placeholders, only get up to the last complete 4 chars\n\n    l = placeHolders > 0 ? b64.length - 4 : b64.length;\n    var L = 0;\n\n    function push(v) {\n      arr[L++] = v;\n    }\n\n    for (i = 0, j = 0; i < l; i += 4, j += 3) {\n      tmp = decode(b64.charAt(i)) << 18 | decode(b64.charAt(i + 1)) << 12 | decode(b64.charAt(i + 2)) << 6 | decode(b64.charAt(i + 3));\n      push((tmp & 0xFF0000) >> 16);\n      push((tmp & 0xFF00) >> 8);\n      push(tmp & 0xFF);\n    }\n\n    if (placeHolders === 2) {\n      tmp = decode(b64.charAt(i)) << 2 | decode(b64.charAt(i + 1)) >> 4;\n      push(tmp & 0xFF);\n    } else if (placeHolders === 1) {\n      tmp = decode(b64.charAt(i)) << 10 | decode(b64.charAt(i + 1)) << 4 | decode(b64.charAt(i + 2)) >> 2;\n      push(tmp >> 8 & 0xFF);\n      push(tmp & 0xFF);\n    }\n\n    return arr;\n  }\n\n  function uint8ToBase64(uint8) {\n    var i,\n        extraBytes = uint8.length % 3,\n        // if we have 1 byte left, pad 2 bytes\n    output = \"\",\n        temp,\n        length;\n\n    function encode(num) {\n      return lookup.charAt(num);\n    }\n\n    function tripletToBase64(num) {\n      return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F);\n    } // go through the array every three bytes, we'll deal with trailing stuff later\n\n\n    for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {\n      temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + uint8[i + 2];\n      output += tripletToBase64(temp);\n    } // pad the end with zeros, but make sure to not forget the extra bytes\n\n\n    switch (extraBytes) {\n      case 1:\n        temp = uint8[uint8.length - 1];\n        output += encode(temp >> 2);\n        output += encode(temp << 4 & 0x3F);\n        output += '==';\n        break;\n\n      case 2:\n        temp = (uint8[uint8.length - 2] << 8) + uint8[uint8.length - 1];\n        output += encode(temp >> 10);\n        output += encode(temp >> 4 & 0x3F);\n        output += encode(temp << 2 & 0x3F);\n        output += '=';\n        break;\n    }\n\n    return output;\n  }\n\n  exports.toByteArray = b64ToByteArray;\n  exports.fromByteArray = uint8ToBase64;\n})(typeof exports === 'undefined' ? this.base64js = {} : exports);","map":{"version":3,"sources":["/Users/kaja/Code/mallar/node_modules/linebreak/node_modules/base64-js/lib/b64.js"],"names":["lookup","exports","Arr","Uint8Array","Array","PLUS","charCodeAt","SLASH","NUMBER","LOWER","UPPER","PLUS_URL_SAFE","SLASH_URL_SAFE","decode","elt","code","b64ToByteArray","b64","i","j","l","tmp","placeHolders","arr","length","Error","len","charAt","L","push","v","uint8ToBase64","uint8","extraBytes","output","temp","encode","num","tripletToBase64","toByteArray","fromByteArray","base64js"],"mappings":"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","sourcesContent":["var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\n;(function (exports) {\n\t'use strict';\n\n  var Arr = (typeof Uint8Array !== 'undefined')\n    ? Uint8Array\n    : Array\n\n\tvar PLUS   = '+'.charCodeAt(0)\n\tvar SLASH  = '/'.charCodeAt(0)\n\tvar NUMBER = '0'.charCodeAt(0)\n\tvar LOWER  = 'a'.charCodeAt(0)\n\tvar UPPER  = 'A'.charCodeAt(0)\n\tvar PLUS_URL_SAFE = '-'.charCodeAt(0)\n\tvar SLASH_URL_SAFE = '_'.charCodeAt(0)\n\n\tfunction decode (elt) {\n\t\tvar code = elt.charCodeAt(0)\n\t\tif (code === PLUS ||\n\t\t    code === PLUS_URL_SAFE)\n\t\t\treturn 62 // '+'\n\t\tif (code === SLASH ||\n\t\t    code === SLASH_URL_SAFE)\n\t\t\treturn 63 // '/'\n\t\tif (code < NUMBER)\n\t\t\treturn -1 //no match\n\t\tif (code < NUMBER + 10)\n\t\t\treturn code - NUMBER + 26 + 26\n\t\tif (code < UPPER + 26)\n\t\t\treturn code - UPPER\n\t\tif (code < LOWER + 26)\n\t\t\treturn code - LOWER + 26\n\t}\n\n\tfunction b64ToByteArray (b64) {\n\t\tvar i, j, l, tmp, placeHolders, arr\n\n\t\tif (b64.length % 4 > 0) {\n\t\t\tthrow new Error('Invalid string. Length must be a multiple of 4')\n\t\t}\n\n\t\t// the number of equal signs (place holders)\n\t\t// if there are two placeholders, than the two characters before it\n\t\t// represent one byte\n\t\t// if there is only one, then the three characters before it represent 2 bytes\n\t\t// this is just a cheap hack to not do indexOf twice\n\t\tvar len = b64.length\n\t\tplaceHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0\n\n\t\t// base64 is 4/3 + up to two characters of the original data\n\t\tarr = new Arr(b64.length * 3 / 4 - placeHolders)\n\n\t\t// if there are placeholders, only get up to the last complete 4 chars\n\t\tl = placeHolders > 0 ? b64.length - 4 : b64.length\n\n\t\tvar L = 0\n\n\t\tfunction push (v) {\n\t\t\tarr[L++] = v\n\t\t}\n\n\t\tfor (i = 0, j = 0; i < l; i += 4, j += 3) {\n\t\t\ttmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))\n\t\t\tpush((tmp & 0xFF0000) >> 16)\n\t\t\tpush((tmp & 0xFF00) >> 8)\n\t\t\tpush(tmp & 0xFF)\n\t\t}\n\n\t\tif (placeHolders === 2) {\n\t\t\ttmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)\n\t\t\tpush(tmp & 0xFF)\n\t\t} else if (placeHolders === 1) {\n\t\t\ttmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)\n\t\t\tpush((tmp >> 8) & 0xFF)\n\t\t\tpush(tmp & 0xFF)\n\t\t}\n\n\t\treturn arr\n\t}\n\n\tfunction uint8ToBase64 (uint8) {\n\t\tvar i,\n\t\t\textraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes\n\t\t\toutput = \"\",\n\t\t\ttemp, length\n\n\t\tfunction encode (num) {\n\t\t\treturn lookup.charAt(num)\n\t\t}\n\n\t\tfunction tripletToBase64 (num) {\n\t\t\treturn encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)\n\t\t}\n\n\t\t// go through the array every three bytes, we'll deal with trailing stuff later\n\t\tfor (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {\n\t\t\ttemp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])\n\t\t\toutput += tripletToBase64(temp)\n\t\t}\n\n\t\t// pad the end with zeros, but make sure to not forget the extra bytes\n\t\tswitch (extraBytes) {\n\t\t\tcase 1:\n\t\t\t\ttemp = uint8[uint8.length - 1]\n\t\t\t\toutput += encode(temp >> 2)\n\t\t\t\toutput += encode((temp << 4) & 0x3F)\n\t\t\t\toutput += '=='\n\t\t\t\tbreak\n\t\t\tcase 2:\n\t\t\t\ttemp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])\n\t\t\t\toutput += encode(temp >> 10)\n\t\t\t\toutput += encode((temp >> 4) & 0x3F)\n\t\t\t\toutput += encode((temp << 2) & 0x3F)\n\t\t\t\toutput += '='\n\t\t\t\tbreak\n\t\t}\n\n\t\treturn output\n\t}\n\n\texports.toByteArray = b64ToByteArray\n\texports.fromByteArray = uint8ToBase64\n}(typeof exports === 'undefined' ? (this.base64js = {}) : exports))\n"]},"metadata":{},"sourceType":"script"}