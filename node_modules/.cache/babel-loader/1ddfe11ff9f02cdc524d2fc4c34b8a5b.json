{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\n\nexports.__esModule = true;\nexports.default = void 0;\n\nvar R = _interopRequireWildcard(require(\"ramda\")); // This constant is used to approximate a symmetrical arc using a cubic\n// Bezier curve.\n\n\nconst KAPPA = 4.0 * ((Math.sqrt(2) - 1.0) / 3.0);\n\nconst clipNode = (ctx, node) => {\n  if (!node.style) return node;\n  const {\n    top,\n    left,\n    width,\n    height\n  } = node.box;\n  const {\n    borderTopLeftRadius = 0,\n    borderTopRightRadius = 0,\n    borderBottomRightRadius = 0,\n    borderBottomLeftRadius = 0\n  } = node.style; // Border top\n\n  const rtr = Math.min(borderTopRightRadius, 0.5 * width, 0.5 * height);\n  const ctr = rtr * (1.0 - KAPPA);\n  ctx.moveTo(left + rtr, top);\n  ctx.lineTo(left + width - rtr, top);\n  ctx.bezierCurveTo(left + width - ctr, top, left + width, top + ctr, left + width, top + rtr); // Border right\n\n  const rbr = Math.min(borderBottomRightRadius, 0.5 * width, 0.5 * height);\n  const cbr = rbr * (1.0 - KAPPA);\n  ctx.lineTo(left + width, top + height - rbr);\n  ctx.bezierCurveTo(left + width, top + height - cbr, left + width - cbr, top + height, left + width - rbr, top + height); // Border bottom\n\n  const rbl = Math.min(borderBottomLeftRadius, 0.5 * width, 0.5 * height);\n  const cbl = rbl * (1.0 - KAPPA);\n  ctx.lineTo(left + rbl, top + height);\n  ctx.bezierCurveTo(left + cbl, top + height, left, top + height - cbl, left, top + height - rbl); // Border left\n\n  const rtl = Math.min(borderTopLeftRadius, 0.5 * width, 0.5 * height);\n  const ctl = rtl * (1.0 - KAPPA);\n  ctx.lineTo(left, top + rtl);\n  ctx.bezierCurveTo(left, top + ctl, left + ctl, top, left + rtl, top);\n  ctx.closePath();\n  ctx.clip();\n  return node;\n};\n\nvar _default = R.curryN(2, clipNode);\n\nexports.default = _default;","map":{"version":3,"sources":["/Users/kaja/Code/mallar/app/node_modules/@react-pdf/render/lib/operations/clipNode.js"],"names":["_interopRequireWildcard","require","exports","__esModule","default","R","KAPPA","Math","sqrt","clipNode","ctx","node","style","top","left","width","height","box","borderTopLeftRadius","borderTopRightRadius","borderBottomRightRadius","borderBottomLeftRadius","rtr","min","ctr","moveTo","lineTo","bezierCurveTo","rbr","cbr","rbl","cbl","rtl","ctl","closePath","clip","_default","curryN"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\n\nexports.__esModule = true;\nexports.default = void 0;\n\nvar R = _interopRequireWildcard(require(\"ramda\"));\n\n// This constant is used to approximate a symmetrical arc using a cubic\n// Bezier curve.\nconst KAPPA = 4.0 * ((Math.sqrt(2) - 1.0) / 3.0);\n\nconst clipNode = (ctx, node) => {\n  if (!node.style) return node;\n  const {\n    top,\n    left,\n    width,\n    height\n  } = node.box;\n  const {\n    borderTopLeftRadius = 0,\n    borderTopRightRadius = 0,\n    borderBottomRightRadius = 0,\n    borderBottomLeftRadius = 0\n  } = node.style; // Border top\n\n  const rtr = Math.min(borderTopRightRadius, 0.5 * width, 0.5 * height);\n  const ctr = rtr * (1.0 - KAPPA);\n  ctx.moveTo(left + rtr, top);\n  ctx.lineTo(left + width - rtr, top);\n  ctx.bezierCurveTo(left + width - ctr, top, left + width, top + ctr, left + width, top + rtr); // Border right\n\n  const rbr = Math.min(borderBottomRightRadius, 0.5 * width, 0.5 * height);\n  const cbr = rbr * (1.0 - KAPPA);\n  ctx.lineTo(left + width, top + height - rbr);\n  ctx.bezierCurveTo(left + width, top + height - cbr, left + width - cbr, top + height, left + width - rbr, top + height); // Border bottom\n\n  const rbl = Math.min(borderBottomLeftRadius, 0.5 * width, 0.5 * height);\n  const cbl = rbl * (1.0 - KAPPA);\n  ctx.lineTo(left + rbl, top + height);\n  ctx.bezierCurveTo(left + cbl, top + height, left, top + height - cbl, left, top + height - rbl); // Border left\n\n  const rtl = Math.min(borderTopLeftRadius, 0.5 * width, 0.5 * height);\n  const ctl = rtl * (1.0 - KAPPA);\n  ctx.lineTo(left, top + rtl);\n  ctx.bezierCurveTo(left, top + ctl, left + ctl, top, left + rtl, top);\n  ctx.closePath();\n  ctx.clip();\n  return node;\n};\n\nvar _default = R.curryN(2, clipNode);\n\nexports.default = _default;"]},"metadata":{},"sourceType":"script"}