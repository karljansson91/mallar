{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\n\nexports.__esModule = true;\nexports.default = void 0;\n\nvar R = _interopRequireWildcard(require(\"ramda\")); // TODO: Implement using only matrices to support skew and even more operations than css.\n\n\nconst getRotation = transform => {\n  const match = /rotate\\((-?\\d+.?\\d+)(.+)\\)/g.exec(transform);\n\n  if (match && match[1] && match[2]) {\n    const value = match[1];\n    return match[2] === 'rad' ? value * 180 / Math.PI : value;\n  }\n\n  return 0;\n};\n\nconst getTranslateX = transform => {\n  const matchX = /translateX\\((-?\\d+\\.?d*)\\)/g.exec(transform);\n  const matchGeneric = /translate\\((-?\\d+\\.?d*).*(,|\\s)\\s*(-?\\d+\\.?d*).*\\)/g.exec(transform);\n  if (matchX && matchX[1]) return matchX[1];\n  if (matchGeneric && matchGeneric[1]) return matchGeneric[1];\n  return 0;\n};\n\nconst getTranslateY = transform => {\n  const matchY = /translateY\\((-?\\d+\\.?\\d*)\\)/g.exec(transform);\n  const matchGeneric = /translate\\((-?\\d+\\.?\\d*).*(,|\\s)\\s*(-?\\d+\\.?\\d*).*\\)/g.exec(transform);\n  if (matchY && matchY[1]) return matchY[1];\n  if (matchGeneric && matchGeneric[3]) return matchGeneric[3];\n  return 0;\n};\n\nconst getScaleX = transform => {\n  const matchX = /scaleX\\((-?\\d+\\.?\\d*)\\)/g.exec(transform);\n  const matchGeneric = /scale\\((-?\\d+\\.?\\d*).*,?\\s*(-?\\d+\\.?\\d*).*\\)/g.exec(transform);\n  if (matchX && matchX[1]) return matchX[1];\n  if (matchGeneric && matchGeneric[1]) return matchGeneric[1];\n  return 1;\n};\n\nconst getScaleY = transform => {\n  const matchY = /scaleY\\((-?\\d+\\.?\\d*)\\)/g.exec(transform);\n  const matchGeneric = /scale\\((-?\\d+\\.?\\d*).*,?\\s*(-?\\d+\\.?\\d*).*\\)/g.exec(transform);\n  if (matchY && matchY[1]) return matchY[1];\n  if (matchGeneric && matchGeneric[2]) return matchGeneric[2];\n  return 1;\n};\n\nconst getMatrix = transform => {\n  const match = /matrix\\(([^,]+),([^,]+),([^,]+),([^,]+),([^,]+),([^,]+)\\)/g.exec(transform);\n  if (match) return match.slice(1, 7);\n  return null;\n};\n\nconst applySingleTransformation = (ctx, transform, origin) => {\n  if (/rotate/g.test(transform)) {\n    ctx.rotate(getRotation(transform), {\n      origin\n    });\n  } else if (/scaleX/g.test(transform)) {\n    ctx.scale(getScaleX(transform), 1, {\n      origin\n    });\n  } else if (/scaleY/g.test(transform)) {\n    ctx.scale(1, getScaleY(transform), {\n      origin\n    });\n  } else if (/scale/g.test(transform)) {\n    ctx.scale(getScaleX(transform), getScaleY(transform), {\n      origin\n    });\n  } else if (/translateX/g.test(transform)) {\n    ctx.translate(getTranslateX(transform), 1, {\n      origin\n    });\n  } else if (/translateY/g.test(transform)) {\n    ctx.translate(1, getTranslateY(transform), {\n      origin\n    });\n  } else if (/translate/g.test(transform)) {\n    ctx.translate(getTranslateX(transform), getTranslateY(transform), {\n      origin\n    });\n  } else if (/matrix/g.test(transform)) {\n    ctx.transform(...getMatrix(transform));\n  }\n};\n\nconst applyTransformations = (ctx, node) => {\n  if (!node.origin) return node;\n  let match;\n  const re = /[a-zA-Z]+\\([^)]+\\)/g;\n  const origin = [node.origin.left, node.origin.top];\n  const transform = node.style && node.style.transform || node.props && node.props.transform || '';\n\n  while ((match = re.exec(transform)) != null) {\n    applySingleTransformation(ctx, match[0], origin);\n  }\n\n  return node;\n};\n\nvar _default = R.curryN(2, applyTransformations);\n\nexports.default = _default;","map":{"version":3,"sources":["/Users/kaja/Code/mallar/app/node_modules/@react-pdf/render/lib/operations/transform.js"],"names":["_interopRequireWildcard","require","exports","__esModule","default","R","getRotation","transform","match","exec","value","Math","PI","getTranslateX","matchX","matchGeneric","getTranslateY","matchY","getScaleX","getScaleY","getMatrix","slice","applySingleTransformation","ctx","origin","test","rotate","scale","translate","applyTransformations","node","re","left","top","style","props","_default","curryN"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\n\nexports.__esModule = true;\nexports.default = void 0;\n\nvar R = _interopRequireWildcard(require(\"ramda\"));\n\n// TODO: Implement using only matrices to support skew and even more operations than css.\nconst getRotation = transform => {\n  const match = /rotate\\((-?\\d+.?\\d+)(.+)\\)/g.exec(transform);\n\n  if (match && match[1] && match[2]) {\n    const value = match[1];\n    return match[2] === 'rad' ? value * 180 / Math.PI : value;\n  }\n\n  return 0;\n};\n\nconst getTranslateX = transform => {\n  const matchX = /translateX\\((-?\\d+\\.?d*)\\)/g.exec(transform);\n  const matchGeneric = /translate\\((-?\\d+\\.?d*).*(,|\\s)\\s*(-?\\d+\\.?d*).*\\)/g.exec(transform);\n  if (matchX && matchX[1]) return matchX[1];\n  if (matchGeneric && matchGeneric[1]) return matchGeneric[1];\n  return 0;\n};\n\nconst getTranslateY = transform => {\n  const matchY = /translateY\\((-?\\d+\\.?\\d*)\\)/g.exec(transform);\n  const matchGeneric = /translate\\((-?\\d+\\.?\\d*).*(,|\\s)\\s*(-?\\d+\\.?\\d*).*\\)/g.exec(transform);\n  if (matchY && matchY[1]) return matchY[1];\n  if (matchGeneric && matchGeneric[3]) return matchGeneric[3];\n  return 0;\n};\n\nconst getScaleX = transform => {\n  const matchX = /scaleX\\((-?\\d+\\.?\\d*)\\)/g.exec(transform);\n  const matchGeneric = /scale\\((-?\\d+\\.?\\d*).*,?\\s*(-?\\d+\\.?\\d*).*\\)/g.exec(transform);\n  if (matchX && matchX[1]) return matchX[1];\n  if (matchGeneric && matchGeneric[1]) return matchGeneric[1];\n  return 1;\n};\n\nconst getScaleY = transform => {\n  const matchY = /scaleY\\((-?\\d+\\.?\\d*)\\)/g.exec(transform);\n  const matchGeneric = /scale\\((-?\\d+\\.?\\d*).*,?\\s*(-?\\d+\\.?\\d*).*\\)/g.exec(transform);\n  if (matchY && matchY[1]) return matchY[1];\n  if (matchGeneric && matchGeneric[2]) return matchGeneric[2];\n  return 1;\n};\n\nconst getMatrix = transform => {\n  const match = /matrix\\(([^,]+),([^,]+),([^,]+),([^,]+),([^,]+),([^,]+)\\)/g.exec(transform);\n  if (match) return match.slice(1, 7);\n  return null;\n};\n\nconst applySingleTransformation = (ctx, transform, origin) => {\n  if (/rotate/g.test(transform)) {\n    ctx.rotate(getRotation(transform), {\n      origin\n    });\n  } else if (/scaleX/g.test(transform)) {\n    ctx.scale(getScaleX(transform), 1, {\n      origin\n    });\n  } else if (/scaleY/g.test(transform)) {\n    ctx.scale(1, getScaleY(transform), {\n      origin\n    });\n  } else if (/scale/g.test(transform)) {\n    ctx.scale(getScaleX(transform), getScaleY(transform), {\n      origin\n    });\n  } else if (/translateX/g.test(transform)) {\n    ctx.translate(getTranslateX(transform), 1, {\n      origin\n    });\n  } else if (/translateY/g.test(transform)) {\n    ctx.translate(1, getTranslateY(transform), {\n      origin\n    });\n  } else if (/translate/g.test(transform)) {\n    ctx.translate(getTranslateX(transform), getTranslateY(transform), {\n      origin\n    });\n  } else if (/matrix/g.test(transform)) {\n    ctx.transform(...getMatrix(transform));\n  }\n};\n\nconst applyTransformations = (ctx, node) => {\n  if (!node.origin) return node;\n  let match;\n  const re = /[a-zA-Z]+\\([^)]+\\)/g;\n  const origin = [node.origin.left, node.origin.top];\n  const transform = node.style && node.style.transform || node.props && node.props.transform || '';\n\n  while ((match = re.exec(transform)) != null) {\n    applySingleTransformation(ctx, match[0], origin);\n  }\n\n  return node;\n};\n\nvar _default = R.curryN(2, applyTransformations);\n\nexports.default = _default;"]},"metadata":{},"sourceType":"script"}