{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\n\nexports.__esModule = true;\nexports.default = void 0;\n\nvar R = _interopRequireWildcard(require(\"ramda\")); // Ref: https://www.w3.org/TR/css-backgrounds-3/#borders\n// This constant is used to approximate a symmetrical arc using a cubic Bezier curve.\n\n\nconst KAPPA = 4.0 * ((Math.sqrt(2) - 1.0) / 3.0);\n\nconst clipBorderTop = (ctx, layout, style, rtr, rtl) => {\n  const {\n    top,\n    left,\n    width,\n    height\n  } = layout;\n  const {\n    borderTopWidth,\n    borderRightWidth,\n    borderLeftWidth\n  } = style; // Clip outer top border edge\n\n  ctx.moveTo(left + rtl, top);\n  ctx.lineTo(left + width - rtr, top); // Ellipse coefficients outer top right cap\n\n  const c0 = rtr * (1.0 - KAPPA); // Clip outer top right cap\n\n  ctx.bezierCurveTo(left + width - c0, top, left + width, top + c0, left + width, top + rtr); // Move down in case the margin exceedes the radius\n\n  const topRightYCoord = top + Math.max(borderTopWidth, rtr);\n  ctx.lineTo(left + width, topRightYCoord); // Clip inner top right cap\n\n  ctx.lineTo(left + width - borderRightWidth, topRightYCoord); // Ellipse coefficients inner top right cap\n\n  const innerTopRightRadiusX = Math.max(rtr - borderRightWidth, 0);\n  const innerTopRightRadiusY = Math.max(rtr - borderTopWidth, 0);\n  const c1 = innerTopRightRadiusX * (1.0 - KAPPA);\n  const c2 = innerTopRightRadiusY * (1.0 - KAPPA); // Clip inner top right cap\n\n  ctx.bezierCurveTo(left + width - borderRightWidth, top + borderTopWidth + c2, left + width - borderRightWidth - c1, top + borderTopWidth, left + width - borderRightWidth - innerTopRightRadiusX, top + borderTopWidth); // Clip inner top border edge\n\n  ctx.lineTo(left + Math.max(rtl, borderLeftWidth), top + borderTopWidth); // Ellipse coefficients inner top left cap\n\n  const innerTopLeftRadiusX = Math.max(rtl - borderLeftWidth, 0);\n  const innerTopLeftRadiusY = Math.max(rtl - borderTopWidth, 0);\n  const c3 = innerTopLeftRadiusX * (1.0 - KAPPA);\n  const c4 = innerTopLeftRadiusY * (1.0 - KAPPA);\n  const topLeftYCoord = top + Math.max(borderTopWidth, rtl); // Clip inner top left cap\n\n  ctx.bezierCurveTo(left + borderLeftWidth + c3, top + borderTopWidth, left + borderLeftWidth, top + borderTopWidth + c4, left + borderLeftWidth, topLeftYCoord);\n  ctx.lineTo(left, topLeftYCoord); // Move down in case the margin exceedes the radius\n\n  ctx.lineTo(left, top + rtl); // Ellipse coefficients outer top left cap\n\n  const c5 = rtl * (1.0 - KAPPA); // Clip outer top left cap\n\n  ctx.bezierCurveTo(left, top + c5, left + c5, top, left + rtl, top);\n  ctx.closePath();\n  ctx.clip(); // Clip border top cap joins\n\n  if (borderRightWidth) {\n    const trSlope = -borderTopWidth / borderRightWidth;\n    ctx.moveTo(left + width / 2, trSlope * (-width / 2) + top);\n    ctx.lineTo(left + width, top);\n    ctx.lineTo(left, top);\n    ctx.lineTo(left, top + height);\n    ctx.closePath();\n    ctx.clip();\n  }\n\n  if (borderLeftWidth) {\n    const trSlope = -borderTopWidth / borderLeftWidth;\n    ctx.moveTo(left + width / 2, trSlope * (-width / 2) + top);\n    ctx.lineTo(left, top);\n    ctx.lineTo(left + width, top);\n    ctx.lineTo(left + width, top + height);\n    ctx.closePath();\n    ctx.clip();\n  }\n};\n\nconst fillBorderTop = (ctx, layout, style, rtr, rtl) => {\n  const {\n    top,\n    left,\n    width\n  } = layout;\n  const {\n    borderTopColor,\n    borderTopWidth,\n    borderTopStyle,\n    borderRightWidth,\n    borderLeftWidth\n  } = style;\n  const c0 = rtl * (1.0 - KAPPA);\n  const c1 = rtr * (1.0 - KAPPA);\n  ctx.moveTo(left, top + Math.max(rtl, borderTopWidth));\n  ctx.bezierCurveTo(left, top + c0, left + c0, top, left + rtl, top);\n  ctx.lineTo(left + width - rtr, top);\n  ctx.bezierCurveTo(left + width - c1, top, left + width, top + c1, left + width, top + rtr);\n  ctx.strokeColor(borderTopColor);\n  ctx.lineWidth(Math.max(borderRightWidth, borderTopWidth, borderLeftWidth) * 2);\n\n  if (borderTopStyle === 'dashed') {\n    ctx.dash(borderTopWidth * 2, {\n      space: borderTopWidth * 1.2\n    });\n  } else if (borderTopStyle === 'dotted') {\n    ctx.dash(borderTopWidth, {\n      space: borderTopWidth * 1.2\n    });\n  }\n\n  ctx.stroke();\n  ctx.undash();\n};\n\nconst clipBorderRight = (ctx, layout, style, rtr, rbr) => {\n  const {\n    top,\n    left,\n    width,\n    height\n  } = layout;\n  const {\n    borderTopWidth,\n    borderRightWidth,\n    borderBottomWidth\n  } = style; // Clip outer right border edge\n\n  ctx.moveTo(left + width, top + rtr);\n  ctx.lineTo(left + width, top + height - rbr); // Ellipse coefficients outer bottom right cap\n\n  const c0 = rbr * (1.0 - KAPPA); // Clip outer top right cap\n\n  ctx.bezierCurveTo(left + width, top + height - c0, left + width - c0, top + height, left + width - rbr, top + height); // Move left in case the margin exceedes the radius\n\n  const topBottomXCoord = left + width - Math.max(borderRightWidth, rbr);\n  ctx.lineTo(topBottomXCoord, top + height); // Clip inner bottom right cap\n\n  ctx.lineTo(topBottomXCoord, top + height - borderBottomWidth); // Ellipse coefficients inner bottom right cap\n\n  const innerBottomRightRadiusX = Math.max(rbr - borderRightWidth, 0);\n  const innerBottomRightRadiusY = Math.max(rbr - borderBottomWidth, 0);\n  const c1 = innerBottomRightRadiusX * (1.0 - KAPPA);\n  const c2 = innerBottomRightRadiusY * (1.0 - KAPPA); // Clip inner top right cap\n\n  ctx.bezierCurveTo(left + width - borderRightWidth - c1, top + height - borderBottomWidth, left + width - borderRightWidth, top + height - borderBottomWidth - c2, left + width - borderRightWidth, top + height - Math.max(rbr, borderBottomWidth)); // Clip inner right border edge\n\n  ctx.lineTo(left + width - borderRightWidth, top + Math.max(rtr, borderTopWidth)); // Ellipse coefficients inner top right cap\n\n  const innerTopRightRadiusX = Math.max(rtr - borderRightWidth, 0);\n  const innerTopRightRadiusY = Math.max(rtr - borderTopWidth, 0);\n  const c3 = innerTopRightRadiusX * (1.0 - KAPPA);\n  const c4 = innerTopRightRadiusY * (1.0 - KAPPA);\n  const topRightXCoord = left + width - Math.max(rtr, borderRightWidth); // Clip inner top left cap\n\n  ctx.bezierCurveTo(left + width - borderRightWidth, top + borderTopWidth + c4, left + width - borderRightWidth - c3, top + borderTopWidth, topRightXCoord, top + borderTopWidth);\n  ctx.lineTo(topRightXCoord, top); // Move right in case the margin exceedes the radius\n\n  ctx.lineTo(left + width - rtr, top); // Ellipse coefficients outer top right cap\n\n  const c5 = rtr * (1.0 - KAPPA); // Clip outer top right cap\n\n  ctx.bezierCurveTo(left + width - c5, top, left + width, top + c5, left + width, top + rtr);\n  ctx.closePath();\n  ctx.clip(); // Clip border right cap joins\n\n  if (borderTopWidth) {\n    const trSlope = -borderTopWidth / borderRightWidth;\n    ctx.moveTo(left + width / 2, trSlope * (-width / 2) + top);\n    ctx.lineTo(left + width, top);\n    ctx.lineTo(left + width, top + height);\n    ctx.lineTo(left, top + height);\n    ctx.closePath();\n    ctx.clip();\n  }\n\n  if (borderBottomWidth) {\n    const brSlope = borderBottomWidth / borderRightWidth;\n    ctx.moveTo(left + width / 2, brSlope * (-width / 2) + top + height);\n    ctx.lineTo(left + width, top + height);\n    ctx.lineTo(left + width, top);\n    ctx.lineTo(left, top);\n    ctx.closePath();\n    ctx.clip();\n  }\n};\n\nconst fillBorderRight = (ctx, layout, style, rtr, rbr) => {\n  const {\n    top,\n    left,\n    width,\n    height\n  } = layout;\n  const {\n    borderRightColor,\n    borderRightStyle,\n    borderRightWidth,\n    borderTopWidth,\n    borderBottomWidth\n  } = style;\n  const c0 = rbr * (1.0 - KAPPA);\n  const c1 = rtr * (1.0 - KAPPA);\n  ctx.moveTo(left + width - rtr, top);\n  ctx.bezierCurveTo(left + width - c1, top, left + width, top + c1, left + width, top + rtr);\n  ctx.lineTo(left + width, top + height - rbr);\n  ctx.bezierCurveTo(left + width, top + height - c0, left + width - c0, top + height, left + width - rbr, top + height);\n  ctx.strokeColor(borderRightColor);\n  ctx.lineWidth(Math.max(borderRightWidth, borderTopWidth, borderBottomWidth) * 2);\n\n  if (borderRightStyle === 'dashed') {\n    ctx.dash(borderRightWidth * 2, {\n      space: borderRightWidth * 1.2\n    });\n  } else if (borderRightStyle === 'dotted') {\n    ctx.dash(borderRightWidth, {\n      space: borderRightWidth * 1.2\n    });\n  }\n\n  ctx.stroke();\n  ctx.undash();\n};\n\nconst clipBorderBottom = (ctx, layout, style, rbl, rbr) => {\n  const {\n    top,\n    left,\n    width,\n    height\n  } = layout;\n  const {\n    borderBottomWidth,\n    borderRightWidth,\n    borderLeftWidth\n  } = style; // Clip outer top border edge\n\n  ctx.moveTo(left + width - rbr, top + height);\n  ctx.lineTo(left + rbl, top + height); // Ellipse coefficients outer top right cap\n\n  const c0 = rbl * (1.0 - KAPPA); // Clip outer top right cap\n\n  ctx.bezierCurveTo(left + c0, top + height, left, top + height - c0, left, top + height - rbl); // Move up in case the margin exceedes the radius\n\n  const bottomLeftYCoord = top + height - Math.max(borderBottomWidth, rbl);\n  ctx.lineTo(left, bottomLeftYCoord); // Clip inner bottom left cap\n\n  ctx.lineTo(left + borderLeftWidth, bottomLeftYCoord); // Ellipse coefficients inner top right cap\n\n  const innerBottomLeftRadiusX = Math.max(rbl - borderLeftWidth, 0);\n  const innerBottomLeftRadiusY = Math.max(rbl - borderBottomWidth, 0);\n  const c1 = innerBottomLeftRadiusX * (1.0 - KAPPA);\n  const c2 = innerBottomLeftRadiusY * (1.0 - KAPPA); // Clip inner bottom left cap\n\n  ctx.bezierCurveTo(left + borderLeftWidth, top + height - borderBottomWidth - c2, left + borderLeftWidth + c1, top + height - borderBottomWidth, left + borderLeftWidth + innerBottomLeftRadiusX, top + height - borderBottomWidth); // Clip inner bottom border edge\n\n  ctx.lineTo(left + width - Math.max(rbr, borderRightWidth), top + height - borderBottomWidth); // Ellipse coefficients inner top left cap\n\n  const innerBottomRightRadiusX = Math.max(rbr - borderRightWidth, 0);\n  const innerBottomRightRadiusY = Math.max(rbr - borderBottomWidth, 0);\n  const c3 = innerBottomRightRadiusX * (1.0 - KAPPA);\n  const c4 = innerBottomRightRadiusY * (1.0 - KAPPA);\n  const bottomRightYCoord = top + height - Math.max(borderBottomWidth, rbr); // Clip inner top left cap\n\n  ctx.bezierCurveTo(left + width - borderRightWidth - c3, top + height - borderBottomWidth, left + width - borderRightWidth, top + height - borderBottomWidth - c4, left + width - borderRightWidth, bottomRightYCoord);\n  ctx.lineTo(left + width, bottomRightYCoord); // Move down in case the margin exceedes the radius\n\n  ctx.lineTo(left + width, top + height - rbr); // Ellipse coefficients outer top left cap\n\n  const c5 = rbr * (1.0 - KAPPA); // Clip outer top left cap\n\n  ctx.bezierCurveTo(left + width, top + height - c5, left + width - c5, top + height, left + width - rbr, top + height);\n  ctx.closePath();\n  ctx.clip(); // Clip border bottom cap joins\n\n  if (borderRightWidth) {\n    const brSlope = borderBottomWidth / borderRightWidth;\n    ctx.moveTo(left + width / 2, brSlope * (-width / 2) + top + height);\n    ctx.lineTo(left + width, top + height);\n    ctx.lineTo(left, top + height);\n    ctx.lineTo(left, top);\n    ctx.closePath();\n    ctx.clip();\n  }\n\n  if (borderLeftWidth) {\n    const trSlope = -borderBottomWidth / borderLeftWidth;\n    ctx.moveTo(left + width / 2, trSlope * (width / 2) + top + height);\n    ctx.lineTo(left, top + height);\n    ctx.lineTo(left + width, top + height);\n    ctx.lineTo(left + width, top);\n    ctx.closePath();\n    ctx.clip();\n  }\n};\n\nconst fillBorderBottom = (ctx, layout, style, rbl, rbr) => {\n  const {\n    top,\n    left,\n    width,\n    height\n  } = layout;\n  const {\n    borderBottomColor,\n    borderBottomStyle,\n    borderBottomWidth,\n    borderRightWidth,\n    borderLeftWidth\n  } = style;\n  const c0 = rbl * (1.0 - KAPPA);\n  const c1 = rbr * (1.0 - KAPPA);\n  ctx.moveTo(left + width, top + height - rbr);\n  ctx.bezierCurveTo(left + width, top + height - c1, left + width - c1, top + height, left + width - rbr, top + height);\n  ctx.lineTo(left + rbl, top + height);\n  ctx.bezierCurveTo(left + c0, top + height, left, top + height - c0, left, top + height - rbl);\n  ctx.strokeColor(borderBottomColor);\n  ctx.lineWidth(Math.max(borderBottomWidth, borderRightWidth, borderLeftWidth) * 2);\n\n  if (borderBottomStyle === 'dashed') {\n    ctx.dash(borderBottomWidth * 2, {\n      space: borderBottomWidth * 1.2\n    });\n  } else if (borderBottomStyle === 'dotted') {\n    ctx.dash(borderBottomWidth, {\n      space: borderBottomWidth * 1.2\n    });\n  }\n\n  ctx.stroke();\n  ctx.undash();\n};\n\nconst clipBorderLeft = (ctx, layout, style, rbl, rtl) => {\n  const {\n    top,\n    left,\n    width,\n    height\n  } = layout;\n  const {\n    borderTopWidth,\n    borderLeftWidth,\n    borderBottomWidth\n  } = style; // Clip outer left border edge\n\n  ctx.moveTo(left, top + height - rbl);\n  ctx.lineTo(left, top + rtl); // Ellipse coefficients outer top left cap\n\n  const c0 = rtl * (1.0 - KAPPA); // Clip outer top left cap\n\n  ctx.bezierCurveTo(left, top + c0, left + c0, top, left + rtl, top); // Move right in case the margin exceedes the radius\n\n  const topLeftCoordX = left + Math.max(borderLeftWidth, rtl);\n  ctx.lineTo(topLeftCoordX, top); // Clip inner top left cap\n\n  ctx.lineTo(topLeftCoordX, top + borderTopWidth); // Ellipse coefficients inner top left cap\n\n  const innerTopLeftRadiusX = Math.max(rtl - borderLeftWidth, 0);\n  const innerTopLeftRadiusY = Math.max(rtl - borderTopWidth, 0);\n  const c1 = innerTopLeftRadiusX * (1.0 - KAPPA);\n  const c2 = innerTopLeftRadiusY * (1.0 - KAPPA); // Clip inner top right cap\n\n  ctx.bezierCurveTo(left + borderLeftWidth + c1, top + borderTopWidth, left + borderLeftWidth, top + borderTopWidth + c2, left + borderLeftWidth, top + Math.max(rtl, borderTopWidth)); // Clip inner left border edge\n\n  ctx.lineTo(left + borderLeftWidth, top + height - Math.max(rbl, borderBottomWidth)); // Ellipse coefficients inner bottom left cap\n\n  const innerBottomLeftRadiusX = Math.max(rbl - borderLeftWidth, 0);\n  const innerBottomLeftRadiusY = Math.max(rbl - borderBottomWidth, 0);\n  const c3 = innerBottomLeftRadiusX * (1.0 - KAPPA);\n  const c4 = innerBottomLeftRadiusY * (1.0 - KAPPA);\n  const bottomLeftXCoord = left + Math.max(rbl, borderLeftWidth); // Clip inner top left cap\n\n  ctx.bezierCurveTo(left + borderLeftWidth, top + height - borderBottomWidth - c4, left + borderLeftWidth + c3, top + height - borderBottomWidth, bottomLeftXCoord, top + height - borderBottomWidth);\n  ctx.lineTo(bottomLeftXCoord, top + height); // Move left in case the margin exceedes the radius\n\n  ctx.lineTo(left + rbl, top + height); // Ellipse coefficients outer top right cap\n\n  const c5 = rbl * (1.0 - KAPPA); // Clip outer top right cap\n\n  ctx.bezierCurveTo(left + c5, top + height, left, top + height - c5, left, top + height - rbl);\n  ctx.closePath();\n  ctx.clip(); // Clip border right cap joins\n\n  if (borderBottomWidth) {\n    const trSlope = -borderBottomWidth / borderLeftWidth;\n    ctx.moveTo(left + width / 2, trSlope * (width / 2) + top + height);\n    ctx.lineTo(left, top + height);\n    ctx.lineTo(left, top);\n    ctx.lineTo(left + width, top);\n    ctx.closePath();\n    ctx.clip();\n  }\n\n  if (borderBottomWidth) {\n    const trSlope = -borderTopWidth / borderLeftWidth;\n    ctx.moveTo(left + width / 2, trSlope * (-width / 2) + top);\n    ctx.lineTo(left, top);\n    ctx.lineTo(left, top + height);\n    ctx.lineTo(left + width, top + height);\n    ctx.closePath();\n    ctx.clip();\n  }\n};\n\nconst fillBorderLeft = (ctx, layout, style, rbl, rtl) => {\n  const {\n    top,\n    left,\n    height\n  } = layout;\n  const {\n    borderLeftColor,\n    borderLeftStyle,\n    borderLeftWidth,\n    borderTopWidth,\n    borderBottomWidth\n  } = style;\n  const c0 = rbl * (1.0 - KAPPA);\n  const c1 = rtl * (1.0 - KAPPA);\n  ctx.moveTo(left + rbl, top + height);\n  ctx.bezierCurveTo(left + c0, top + height, left, top + height - c0, left, top + height - rbl);\n  ctx.lineTo(left, top + rtl);\n  ctx.bezierCurveTo(left, top + c1, left + c1, top, left + rtl, top);\n  ctx.strokeColor(borderLeftColor);\n  ctx.lineWidth(Math.max(borderLeftWidth, borderTopWidth, borderBottomWidth) * 2);\n\n  if (borderLeftStyle === 'dashed') {\n    ctx.dash(borderLeftWidth * 2, {\n      space: borderLeftWidth * 1.2\n    });\n  } else if (borderLeftStyle === 'dotted') {\n    ctx.dash(borderLeftWidth, {\n      space: borderLeftWidth * 1.2\n    });\n  }\n\n  ctx.stroke();\n  ctx.undash();\n};\n\nconst shouldRenderBorders = node => node.box && (node.box.borderTopWidth || node.box.borderRightWidth || node.box.borderBottomWidth || node.box.borderLeftWidth);\n\nconst renderBorders = (ctx, node) => {\n  if (!shouldRenderBorders(node)) return node;\n  const {\n    width,\n    height,\n    borderTopWidth,\n    borderLeftWidth,\n    borderRightWidth,\n    borderBottomWidth\n  } = node.box;\n  const {\n    opacity,\n    borderTopLeftRadius = 0,\n    borderTopRightRadius = 0,\n    borderBottomLeftRadius = 0,\n    borderBottomRightRadius = 0,\n    borderTopColor = 'black',\n    borderTopStyle = 'solid',\n    borderLeftColor = 'black',\n    borderLeftStyle = 'solid',\n    borderRightColor = 'black',\n    borderRightStyle = 'solid',\n    borderBottomColor = 'black',\n    borderBottomStyle = 'solid'\n  } = node.style;\n  const style = {\n    borderTopColor,\n    borderTopWidth,\n    borderTopStyle,\n    borderLeftColor,\n    borderLeftWidth,\n    borderLeftStyle,\n    borderRightColor,\n    borderRightWidth,\n    borderRightStyle,\n    borderBottomColor,\n    borderBottomWidth,\n    borderBottomStyle,\n    borderTopLeftRadius,\n    borderTopRightRadius,\n    borderBottomLeftRadius,\n    borderBottomRightRadius\n  };\n  const rtr = Math.min(borderTopRightRadius, 0.5 * width, 0.5 * height);\n  const rtl = Math.min(borderTopLeftRadius, 0.5 * width, 0.5 * height);\n  const rbr = Math.min(borderBottomRightRadius, 0.5 * width, 0.5 * height);\n  const rbl = Math.min(borderBottomLeftRadius, 0.5 * width, 0.5 * height);\n  ctx.save();\n  ctx.strokeOpacity(opacity);\n\n  if (borderTopWidth) {\n    ctx.save();\n    clipBorderTop(ctx, node.box, style, rtr, rtl);\n    fillBorderTop(ctx, node.box, style, rtr, rtl);\n    ctx.restore();\n  }\n\n  if (borderRightWidth) {\n    ctx.save();\n    clipBorderRight(ctx, node.box, style, rtr, rbr);\n    fillBorderRight(ctx, node.box, style, rtr, rbr);\n    ctx.restore();\n  }\n\n  if (borderBottomWidth) {\n    ctx.save();\n    clipBorderBottom(ctx, node.box, style, rbl, rbr);\n    fillBorderBottom(ctx, node.box, style, rbl, rbr);\n    ctx.restore();\n  }\n\n  if (borderLeftWidth) {\n    ctx.save();\n    clipBorderLeft(ctx, node.box, style, rbl, rtl);\n    fillBorderLeft(ctx, node.box, style, rbl, rtl);\n    ctx.restore();\n  }\n\n  ctx.restore();\n  return node;\n};\n\nvar _default = R.curryN(2, renderBorders);\n\nexports.default = _default;","map":{"version":3,"sources":["/Users/kaja/Code/mallar/app/node_modules/@react-pdf/render/lib/primitives/renderBorders.js"],"names":["_interopRequireWildcard","require","exports","__esModule","default","R","KAPPA","Math","sqrt","clipBorderTop","ctx","layout","style","rtr","rtl","top","left","width","height","borderTopWidth","borderRightWidth","borderLeftWidth","moveTo","lineTo","c0","bezierCurveTo","topRightYCoord","max","innerTopRightRadiusX","innerTopRightRadiusY","c1","c2","innerTopLeftRadiusX","innerTopLeftRadiusY","c3","c4","topLeftYCoord","c5","closePath","clip","trSlope","fillBorderTop","borderTopColor","borderTopStyle","strokeColor","lineWidth","dash","space","stroke","undash","clipBorderRight","rbr","borderBottomWidth","topBottomXCoord","innerBottomRightRadiusX","innerBottomRightRadiusY","topRightXCoord","brSlope","fillBorderRight","borderRightColor","borderRightStyle","clipBorderBottom","rbl","bottomLeftYCoord","innerBottomLeftRadiusX","innerBottomLeftRadiusY","bottomRightYCoord","fillBorderBottom","borderBottomColor","borderBottomStyle","clipBorderLeft","topLeftCoordX","bottomLeftXCoord","fillBorderLeft","borderLeftColor","borderLeftStyle","shouldRenderBorders","node","box","renderBorders","opacity","borderTopLeftRadius","borderTopRightRadius","borderBottomLeftRadius","borderBottomRightRadius","min","save","strokeOpacity","restore","_default","curryN"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\n\nexports.__esModule = true;\nexports.default = void 0;\n\nvar R = _interopRequireWildcard(require(\"ramda\"));\n\n// Ref: https://www.w3.org/TR/css-backgrounds-3/#borders\n// This constant is used to approximate a symmetrical arc using a cubic Bezier curve.\nconst KAPPA = 4.0 * ((Math.sqrt(2) - 1.0) / 3.0);\n\nconst clipBorderTop = (ctx, layout, style, rtr, rtl) => {\n  const {\n    top,\n    left,\n    width,\n    height\n  } = layout;\n  const {\n    borderTopWidth,\n    borderRightWidth,\n    borderLeftWidth\n  } = style; // Clip outer top border edge\n\n  ctx.moveTo(left + rtl, top);\n  ctx.lineTo(left + width - rtr, top); // Ellipse coefficients outer top right cap\n\n  const c0 = rtr * (1.0 - KAPPA); // Clip outer top right cap\n\n  ctx.bezierCurveTo(left + width - c0, top, left + width, top + c0, left + width, top + rtr); // Move down in case the margin exceedes the radius\n\n  const topRightYCoord = top + Math.max(borderTopWidth, rtr);\n  ctx.lineTo(left + width, topRightYCoord); // Clip inner top right cap\n\n  ctx.lineTo(left + width - borderRightWidth, topRightYCoord); // Ellipse coefficients inner top right cap\n\n  const innerTopRightRadiusX = Math.max(rtr - borderRightWidth, 0);\n  const innerTopRightRadiusY = Math.max(rtr - borderTopWidth, 0);\n  const c1 = innerTopRightRadiusX * (1.0 - KAPPA);\n  const c2 = innerTopRightRadiusY * (1.0 - KAPPA); // Clip inner top right cap\n\n  ctx.bezierCurveTo(left + width - borderRightWidth, top + borderTopWidth + c2, left + width - borderRightWidth - c1, top + borderTopWidth, left + width - borderRightWidth - innerTopRightRadiusX, top + borderTopWidth); // Clip inner top border edge\n\n  ctx.lineTo(left + Math.max(rtl, borderLeftWidth), top + borderTopWidth); // Ellipse coefficients inner top left cap\n\n  const innerTopLeftRadiusX = Math.max(rtl - borderLeftWidth, 0);\n  const innerTopLeftRadiusY = Math.max(rtl - borderTopWidth, 0);\n  const c3 = innerTopLeftRadiusX * (1.0 - KAPPA);\n  const c4 = innerTopLeftRadiusY * (1.0 - KAPPA);\n  const topLeftYCoord = top + Math.max(borderTopWidth, rtl); // Clip inner top left cap\n\n  ctx.bezierCurveTo(left + borderLeftWidth + c3, top + borderTopWidth, left + borderLeftWidth, top + borderTopWidth + c4, left + borderLeftWidth, topLeftYCoord);\n  ctx.lineTo(left, topLeftYCoord); // Move down in case the margin exceedes the radius\n\n  ctx.lineTo(left, top + rtl); // Ellipse coefficients outer top left cap\n\n  const c5 = rtl * (1.0 - KAPPA); // Clip outer top left cap\n\n  ctx.bezierCurveTo(left, top + c5, left + c5, top, left + rtl, top);\n  ctx.closePath();\n  ctx.clip(); // Clip border top cap joins\n\n  if (borderRightWidth) {\n    const trSlope = -borderTopWidth / borderRightWidth;\n    ctx.moveTo(left + width / 2, trSlope * (-width / 2) + top);\n    ctx.lineTo(left + width, top);\n    ctx.lineTo(left, top);\n    ctx.lineTo(left, top + height);\n    ctx.closePath();\n    ctx.clip();\n  }\n\n  if (borderLeftWidth) {\n    const trSlope = -borderTopWidth / borderLeftWidth;\n    ctx.moveTo(left + width / 2, trSlope * (-width / 2) + top);\n    ctx.lineTo(left, top);\n    ctx.lineTo(left + width, top);\n    ctx.lineTo(left + width, top + height);\n    ctx.closePath();\n    ctx.clip();\n  }\n};\n\nconst fillBorderTop = (ctx, layout, style, rtr, rtl) => {\n  const {\n    top,\n    left,\n    width\n  } = layout;\n  const {\n    borderTopColor,\n    borderTopWidth,\n    borderTopStyle,\n    borderRightWidth,\n    borderLeftWidth\n  } = style;\n  const c0 = rtl * (1.0 - KAPPA);\n  const c1 = rtr * (1.0 - KAPPA);\n  ctx.moveTo(left, top + Math.max(rtl, borderTopWidth));\n  ctx.bezierCurveTo(left, top + c0, left + c0, top, left + rtl, top);\n  ctx.lineTo(left + width - rtr, top);\n  ctx.bezierCurveTo(left + width - c1, top, left + width, top + c1, left + width, top + rtr);\n  ctx.strokeColor(borderTopColor);\n  ctx.lineWidth(Math.max(borderRightWidth, borderTopWidth, borderLeftWidth) * 2);\n\n  if (borderTopStyle === 'dashed') {\n    ctx.dash(borderTopWidth * 2, {\n      space: borderTopWidth * 1.2\n    });\n  } else if (borderTopStyle === 'dotted') {\n    ctx.dash(borderTopWidth, {\n      space: borderTopWidth * 1.2\n    });\n  }\n\n  ctx.stroke();\n  ctx.undash();\n};\n\nconst clipBorderRight = (ctx, layout, style, rtr, rbr) => {\n  const {\n    top,\n    left,\n    width,\n    height\n  } = layout;\n  const {\n    borderTopWidth,\n    borderRightWidth,\n    borderBottomWidth\n  } = style; // Clip outer right border edge\n\n  ctx.moveTo(left + width, top + rtr);\n  ctx.lineTo(left + width, top + height - rbr); // Ellipse coefficients outer bottom right cap\n\n  const c0 = rbr * (1.0 - KAPPA); // Clip outer top right cap\n\n  ctx.bezierCurveTo(left + width, top + height - c0, left + width - c0, top + height, left + width - rbr, top + height); // Move left in case the margin exceedes the radius\n\n  const topBottomXCoord = left + width - Math.max(borderRightWidth, rbr);\n  ctx.lineTo(topBottomXCoord, top + height); // Clip inner bottom right cap\n\n  ctx.lineTo(topBottomXCoord, top + height - borderBottomWidth); // Ellipse coefficients inner bottom right cap\n\n  const innerBottomRightRadiusX = Math.max(rbr - borderRightWidth, 0);\n  const innerBottomRightRadiusY = Math.max(rbr - borderBottomWidth, 0);\n  const c1 = innerBottomRightRadiusX * (1.0 - KAPPA);\n  const c2 = innerBottomRightRadiusY * (1.0 - KAPPA); // Clip inner top right cap\n\n  ctx.bezierCurveTo(left + width - borderRightWidth - c1, top + height - borderBottomWidth, left + width - borderRightWidth, top + height - borderBottomWidth - c2, left + width - borderRightWidth, top + height - Math.max(rbr, borderBottomWidth)); // Clip inner right border edge\n\n  ctx.lineTo(left + width - borderRightWidth, top + Math.max(rtr, borderTopWidth)); // Ellipse coefficients inner top right cap\n\n  const innerTopRightRadiusX = Math.max(rtr - borderRightWidth, 0);\n  const innerTopRightRadiusY = Math.max(rtr - borderTopWidth, 0);\n  const c3 = innerTopRightRadiusX * (1.0 - KAPPA);\n  const c4 = innerTopRightRadiusY * (1.0 - KAPPA);\n  const topRightXCoord = left + width - Math.max(rtr, borderRightWidth); // Clip inner top left cap\n\n  ctx.bezierCurveTo(left + width - borderRightWidth, top + borderTopWidth + c4, left + width - borderRightWidth - c3, top + borderTopWidth, topRightXCoord, top + borderTopWidth);\n  ctx.lineTo(topRightXCoord, top); // Move right in case the margin exceedes the radius\n\n  ctx.lineTo(left + width - rtr, top); // Ellipse coefficients outer top right cap\n\n  const c5 = rtr * (1.0 - KAPPA); // Clip outer top right cap\n\n  ctx.bezierCurveTo(left + width - c5, top, left + width, top + c5, left + width, top + rtr);\n  ctx.closePath();\n  ctx.clip(); // Clip border right cap joins\n\n  if (borderTopWidth) {\n    const trSlope = -borderTopWidth / borderRightWidth;\n    ctx.moveTo(left + width / 2, trSlope * (-width / 2) + top);\n    ctx.lineTo(left + width, top);\n    ctx.lineTo(left + width, top + height);\n    ctx.lineTo(left, top + height);\n    ctx.closePath();\n    ctx.clip();\n  }\n\n  if (borderBottomWidth) {\n    const brSlope = borderBottomWidth / borderRightWidth;\n    ctx.moveTo(left + width / 2, brSlope * (-width / 2) + top + height);\n    ctx.lineTo(left + width, top + height);\n    ctx.lineTo(left + width, top);\n    ctx.lineTo(left, top);\n    ctx.closePath();\n    ctx.clip();\n  }\n};\n\nconst fillBorderRight = (ctx, layout, style, rtr, rbr) => {\n  const {\n    top,\n    left,\n    width,\n    height\n  } = layout;\n  const {\n    borderRightColor,\n    borderRightStyle,\n    borderRightWidth,\n    borderTopWidth,\n    borderBottomWidth\n  } = style;\n  const c0 = rbr * (1.0 - KAPPA);\n  const c1 = rtr * (1.0 - KAPPA);\n  ctx.moveTo(left + width - rtr, top);\n  ctx.bezierCurveTo(left + width - c1, top, left + width, top + c1, left + width, top + rtr);\n  ctx.lineTo(left + width, top + height - rbr);\n  ctx.bezierCurveTo(left + width, top + height - c0, left + width - c0, top + height, left + width - rbr, top + height);\n  ctx.strokeColor(borderRightColor);\n  ctx.lineWidth(Math.max(borderRightWidth, borderTopWidth, borderBottomWidth) * 2);\n\n  if (borderRightStyle === 'dashed') {\n    ctx.dash(borderRightWidth * 2, {\n      space: borderRightWidth * 1.2\n    });\n  } else if (borderRightStyle === 'dotted') {\n    ctx.dash(borderRightWidth, {\n      space: borderRightWidth * 1.2\n    });\n  }\n\n  ctx.stroke();\n  ctx.undash();\n};\n\nconst clipBorderBottom = (ctx, layout, style, rbl, rbr) => {\n  const {\n    top,\n    left,\n    width,\n    height\n  } = layout;\n  const {\n    borderBottomWidth,\n    borderRightWidth,\n    borderLeftWidth\n  } = style; // Clip outer top border edge\n\n  ctx.moveTo(left + width - rbr, top + height);\n  ctx.lineTo(left + rbl, top + height); // Ellipse coefficients outer top right cap\n\n  const c0 = rbl * (1.0 - KAPPA); // Clip outer top right cap\n\n  ctx.bezierCurveTo(left + c0, top + height, left, top + height - c0, left, top + height - rbl); // Move up in case the margin exceedes the radius\n\n  const bottomLeftYCoord = top + height - Math.max(borderBottomWidth, rbl);\n  ctx.lineTo(left, bottomLeftYCoord); // Clip inner bottom left cap\n\n  ctx.lineTo(left + borderLeftWidth, bottomLeftYCoord); // Ellipse coefficients inner top right cap\n\n  const innerBottomLeftRadiusX = Math.max(rbl - borderLeftWidth, 0);\n  const innerBottomLeftRadiusY = Math.max(rbl - borderBottomWidth, 0);\n  const c1 = innerBottomLeftRadiusX * (1.0 - KAPPA);\n  const c2 = innerBottomLeftRadiusY * (1.0 - KAPPA); // Clip inner bottom left cap\n\n  ctx.bezierCurveTo(left + borderLeftWidth, top + height - borderBottomWidth - c2, left + borderLeftWidth + c1, top + height - borderBottomWidth, left + borderLeftWidth + innerBottomLeftRadiusX, top + height - borderBottomWidth); // Clip inner bottom border edge\n\n  ctx.lineTo(left + width - Math.max(rbr, borderRightWidth), top + height - borderBottomWidth); // Ellipse coefficients inner top left cap\n\n  const innerBottomRightRadiusX = Math.max(rbr - borderRightWidth, 0);\n  const innerBottomRightRadiusY = Math.max(rbr - borderBottomWidth, 0);\n  const c3 = innerBottomRightRadiusX * (1.0 - KAPPA);\n  const c4 = innerBottomRightRadiusY * (1.0 - KAPPA);\n  const bottomRightYCoord = top + height - Math.max(borderBottomWidth, rbr); // Clip inner top left cap\n\n  ctx.bezierCurveTo(left + width - borderRightWidth - c3, top + height - borderBottomWidth, left + width - borderRightWidth, top + height - borderBottomWidth - c4, left + width - borderRightWidth, bottomRightYCoord);\n  ctx.lineTo(left + width, bottomRightYCoord); // Move down in case the margin exceedes the radius\n\n  ctx.lineTo(left + width, top + height - rbr); // Ellipse coefficients outer top left cap\n\n  const c5 = rbr * (1.0 - KAPPA); // Clip outer top left cap\n\n  ctx.bezierCurveTo(left + width, top + height - c5, left + width - c5, top + height, left + width - rbr, top + height);\n  ctx.closePath();\n  ctx.clip(); // Clip border bottom cap joins\n\n  if (borderRightWidth) {\n    const brSlope = borderBottomWidth / borderRightWidth;\n    ctx.moveTo(left + width / 2, brSlope * (-width / 2) + top + height);\n    ctx.lineTo(left + width, top + height);\n    ctx.lineTo(left, top + height);\n    ctx.lineTo(left, top);\n    ctx.closePath();\n    ctx.clip();\n  }\n\n  if (borderLeftWidth) {\n    const trSlope = -borderBottomWidth / borderLeftWidth;\n    ctx.moveTo(left + width / 2, trSlope * (width / 2) + top + height);\n    ctx.lineTo(left, top + height);\n    ctx.lineTo(left + width, top + height);\n    ctx.lineTo(left + width, top);\n    ctx.closePath();\n    ctx.clip();\n  }\n};\n\nconst fillBorderBottom = (ctx, layout, style, rbl, rbr) => {\n  const {\n    top,\n    left,\n    width,\n    height\n  } = layout;\n  const {\n    borderBottomColor,\n    borderBottomStyle,\n    borderBottomWidth,\n    borderRightWidth,\n    borderLeftWidth\n  } = style;\n  const c0 = rbl * (1.0 - KAPPA);\n  const c1 = rbr * (1.0 - KAPPA);\n  ctx.moveTo(left + width, top + height - rbr);\n  ctx.bezierCurveTo(left + width, top + height - c1, left + width - c1, top + height, left + width - rbr, top + height);\n  ctx.lineTo(left + rbl, top + height);\n  ctx.bezierCurveTo(left + c0, top + height, left, top + height - c0, left, top + height - rbl);\n  ctx.strokeColor(borderBottomColor);\n  ctx.lineWidth(Math.max(borderBottomWidth, borderRightWidth, borderLeftWidth) * 2);\n\n  if (borderBottomStyle === 'dashed') {\n    ctx.dash(borderBottomWidth * 2, {\n      space: borderBottomWidth * 1.2\n    });\n  } else if (borderBottomStyle === 'dotted') {\n    ctx.dash(borderBottomWidth, {\n      space: borderBottomWidth * 1.2\n    });\n  }\n\n  ctx.stroke();\n  ctx.undash();\n};\n\nconst clipBorderLeft = (ctx, layout, style, rbl, rtl) => {\n  const {\n    top,\n    left,\n    width,\n    height\n  } = layout;\n  const {\n    borderTopWidth,\n    borderLeftWidth,\n    borderBottomWidth\n  } = style; // Clip outer left border edge\n\n  ctx.moveTo(left, top + height - rbl);\n  ctx.lineTo(left, top + rtl); // Ellipse coefficients outer top left cap\n\n  const c0 = rtl * (1.0 - KAPPA); // Clip outer top left cap\n\n  ctx.bezierCurveTo(left, top + c0, left + c0, top, left + rtl, top); // Move right in case the margin exceedes the radius\n\n  const topLeftCoordX = left + Math.max(borderLeftWidth, rtl);\n  ctx.lineTo(topLeftCoordX, top); // Clip inner top left cap\n\n  ctx.lineTo(topLeftCoordX, top + borderTopWidth); // Ellipse coefficients inner top left cap\n\n  const innerTopLeftRadiusX = Math.max(rtl - borderLeftWidth, 0);\n  const innerTopLeftRadiusY = Math.max(rtl - borderTopWidth, 0);\n  const c1 = innerTopLeftRadiusX * (1.0 - KAPPA);\n  const c2 = innerTopLeftRadiusY * (1.0 - KAPPA); // Clip inner top right cap\n\n  ctx.bezierCurveTo(left + borderLeftWidth + c1, top + borderTopWidth, left + borderLeftWidth, top + borderTopWidth + c2, left + borderLeftWidth, top + Math.max(rtl, borderTopWidth)); // Clip inner left border edge\n\n  ctx.lineTo(left + borderLeftWidth, top + height - Math.max(rbl, borderBottomWidth)); // Ellipse coefficients inner bottom left cap\n\n  const innerBottomLeftRadiusX = Math.max(rbl - borderLeftWidth, 0);\n  const innerBottomLeftRadiusY = Math.max(rbl - borderBottomWidth, 0);\n  const c3 = innerBottomLeftRadiusX * (1.0 - KAPPA);\n  const c4 = innerBottomLeftRadiusY * (1.0 - KAPPA);\n  const bottomLeftXCoord = left + Math.max(rbl, borderLeftWidth); // Clip inner top left cap\n\n  ctx.bezierCurveTo(left + borderLeftWidth, top + height - borderBottomWidth - c4, left + borderLeftWidth + c3, top + height - borderBottomWidth, bottomLeftXCoord, top + height - borderBottomWidth);\n  ctx.lineTo(bottomLeftXCoord, top + height); // Move left in case the margin exceedes the radius\n\n  ctx.lineTo(left + rbl, top + height); // Ellipse coefficients outer top right cap\n\n  const c5 = rbl * (1.0 - KAPPA); // Clip outer top right cap\n\n  ctx.bezierCurveTo(left + c5, top + height, left, top + height - c5, left, top + height - rbl);\n  ctx.closePath();\n  ctx.clip(); // Clip border right cap joins\n\n  if (borderBottomWidth) {\n    const trSlope = -borderBottomWidth / borderLeftWidth;\n    ctx.moveTo(left + width / 2, trSlope * (width / 2) + top + height);\n    ctx.lineTo(left, top + height);\n    ctx.lineTo(left, top);\n    ctx.lineTo(left + width, top);\n    ctx.closePath();\n    ctx.clip();\n  }\n\n  if (borderBottomWidth) {\n    const trSlope = -borderTopWidth / borderLeftWidth;\n    ctx.moveTo(left + width / 2, trSlope * (-width / 2) + top);\n    ctx.lineTo(left, top);\n    ctx.lineTo(left, top + height);\n    ctx.lineTo(left + width, top + height);\n    ctx.closePath();\n    ctx.clip();\n  }\n};\n\nconst fillBorderLeft = (ctx, layout, style, rbl, rtl) => {\n  const {\n    top,\n    left,\n    height\n  } = layout;\n  const {\n    borderLeftColor,\n    borderLeftStyle,\n    borderLeftWidth,\n    borderTopWidth,\n    borderBottomWidth\n  } = style;\n  const c0 = rbl * (1.0 - KAPPA);\n  const c1 = rtl * (1.0 - KAPPA);\n  ctx.moveTo(left + rbl, top + height);\n  ctx.bezierCurveTo(left + c0, top + height, left, top + height - c0, left, top + height - rbl);\n  ctx.lineTo(left, top + rtl);\n  ctx.bezierCurveTo(left, top + c1, left + c1, top, left + rtl, top);\n  ctx.strokeColor(borderLeftColor);\n  ctx.lineWidth(Math.max(borderLeftWidth, borderTopWidth, borderBottomWidth) * 2);\n\n  if (borderLeftStyle === 'dashed') {\n    ctx.dash(borderLeftWidth * 2, {\n      space: borderLeftWidth * 1.2\n    });\n  } else if (borderLeftStyle === 'dotted') {\n    ctx.dash(borderLeftWidth, {\n      space: borderLeftWidth * 1.2\n    });\n  }\n\n  ctx.stroke();\n  ctx.undash();\n};\n\nconst shouldRenderBorders = node => node.box && (node.box.borderTopWidth || node.box.borderRightWidth || node.box.borderBottomWidth || node.box.borderLeftWidth);\n\nconst renderBorders = (ctx, node) => {\n  if (!shouldRenderBorders(node)) return node;\n  const {\n    width,\n    height,\n    borderTopWidth,\n    borderLeftWidth,\n    borderRightWidth,\n    borderBottomWidth\n  } = node.box;\n  const {\n    opacity,\n    borderTopLeftRadius = 0,\n    borderTopRightRadius = 0,\n    borderBottomLeftRadius = 0,\n    borderBottomRightRadius = 0,\n    borderTopColor = 'black',\n    borderTopStyle = 'solid',\n    borderLeftColor = 'black',\n    borderLeftStyle = 'solid',\n    borderRightColor = 'black',\n    borderRightStyle = 'solid',\n    borderBottomColor = 'black',\n    borderBottomStyle = 'solid'\n  } = node.style;\n  const style = {\n    borderTopColor,\n    borderTopWidth,\n    borderTopStyle,\n    borderLeftColor,\n    borderLeftWidth,\n    borderLeftStyle,\n    borderRightColor,\n    borderRightWidth,\n    borderRightStyle,\n    borderBottomColor,\n    borderBottomWidth,\n    borderBottomStyle,\n    borderTopLeftRadius,\n    borderTopRightRadius,\n    borderBottomLeftRadius,\n    borderBottomRightRadius\n  };\n  const rtr = Math.min(borderTopRightRadius, 0.5 * width, 0.5 * height);\n  const rtl = Math.min(borderTopLeftRadius, 0.5 * width, 0.5 * height);\n  const rbr = Math.min(borderBottomRightRadius, 0.5 * width, 0.5 * height);\n  const rbl = Math.min(borderBottomLeftRadius, 0.5 * width, 0.5 * height);\n  ctx.save();\n  ctx.strokeOpacity(opacity);\n\n  if (borderTopWidth) {\n    ctx.save();\n    clipBorderTop(ctx, node.box, style, rtr, rtl);\n    fillBorderTop(ctx, node.box, style, rtr, rtl);\n    ctx.restore();\n  }\n\n  if (borderRightWidth) {\n    ctx.save();\n    clipBorderRight(ctx, node.box, style, rtr, rbr);\n    fillBorderRight(ctx, node.box, style, rtr, rbr);\n    ctx.restore();\n  }\n\n  if (borderBottomWidth) {\n    ctx.save();\n    clipBorderBottom(ctx, node.box, style, rbl, rbr);\n    fillBorderBottom(ctx, node.box, style, rbl, rbr);\n    ctx.restore();\n  }\n\n  if (borderLeftWidth) {\n    ctx.save();\n    clipBorderLeft(ctx, node.box, style, rbl, rtl);\n    fillBorderLeft(ctx, node.box, style, rbl, rtl);\n    ctx.restore();\n  }\n\n  ctx.restore();\n  return node;\n};\n\nvar _default = R.curryN(2, renderBorders);\n\nexports.default = _default;"]},"metadata":{},"sourceType":"script"}