{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\n\nexports.__esModule = true;\nexports.default = void 0;\n\nvar R = _interopRequireWildcard(require(\"ramda\"));\n\nvar P = _interopRequireWildcard(require(\"@react-pdf/primitives\"));\n\nvar _attributedString = _interopRequireDefault(require(\"@react-pdf/textkit/attributedString\"));\n\nvar _emoji = require(\"./emoji\");\n\nvar _ignoreChars = _interopRequireDefault(require(\"./ignoreChars\"));\n\nvar _transformText = _interopRequireDefault(require(\"./transformText\"));\n\nconst PREPROCESSORS = [_ignoreChars.default, _emoji.embedEmojis];\nconst isType = R.propEq('type');\nconst isImage = isType(P.Image);\nconst isTextInstance = isType(P.TextInstance);\n/**\n * Get textkit framgents of given node object\n *\n * @param {Object} instance node\n * @returns {Array} text fragments\n */\n\nconst getFragments = (fontStore, instance) => {\n  if (!instance) return [{\n    string: ''\n  }];\n  let fragments = [];\n  const {\n    color = 'black',\n    backgroundColor,\n    fontFamily = 'Helvetica',\n    fontWeight,\n    fontStyle,\n    fontSize = 18,\n    textAlign = 'left',\n    lineHeight,\n    textDecoration,\n    textDecorationColor,\n    textDecorationStyle,\n    textTransform,\n    letterSpacing,\n    textIndent,\n    opacity\n  } = instance.style;\n  const opts = {\n    fontFamily,\n    fontWeight,\n    fontStyle\n  };\n  const obj = fontStore ? fontStore.getFont(opts) : null;\n  const font = obj ? obj.data : fontFamily;\n  const attributes = {\n    font,\n    color,\n    opacity,\n    fontSize,\n    backgroundColor,\n    align: textAlign,\n    indent: textIndent,\n    link: instance.src,\n    characterSpacing: letterSpacing,\n    underlineStyle: textDecorationStyle,\n    underline: textDecoration === 'underline',\n    underlineColor: textDecorationColor || color,\n    strike: textDecoration === 'line-through',\n    strikeStyle: textDecorationStyle,\n    strikeColor: textDecorationColor || color,\n    lineHeight: lineHeight ? lineHeight * fontSize : null\n  };\n\n  for (let i = 0; i < instance.children.length; i += 1) {\n    const child = instance.children[i];\n\n    if (isImage(child)) {\n      fragments.push({\n        string: String.fromCharCode(0xfffc),\n        attributes: { ...attributes,\n          attachment: {\n            width: child.style.width || fontSize,\n            height: child.style.height || fontSize,\n            image: child.image.data\n          }\n        }\n      });\n    } else if (isTextInstance(child)) {\n      fragments.push({\n        string: (0, _transformText.default)(child.value, textTransform),\n        attributes\n      });\n    } else if (child) {\n      fragments.push(...getFragments(child));\n    }\n  }\n\n  for (let i = 0; i < PREPROCESSORS.length; i += 1) {\n    const preprocessor = PREPROCESSORS[i];\n    fragments = preprocessor(fragments);\n  }\n\n  return fragments;\n};\n/**\n * Get textkit attributed string from text node\n *\n * @param {Object} instance node\n * @returns {Object} attributed string\n */\n\n\nconst getAttributedString = R.compose(_attributedString.default.fromFragments, getFragments);\n\nvar _default = R.curryN(2, getAttributedString);\n\nexports.default = _default;","map":{"version":3,"sources":["/Users/kaja/Code/mallar/app/node_modules/@react-pdf/layout/lib/text/getAttributedString.js"],"names":["_interopRequireDefault","require","_interopRequireWildcard","exports","__esModule","default","R","P","_attributedString","_emoji","_ignoreChars","_transformText","PREPROCESSORS","embedEmojis","isType","propEq","isImage","Image","isTextInstance","TextInstance","getFragments","fontStore","instance","string","fragments","color","backgroundColor","fontFamily","fontWeight","fontStyle","fontSize","textAlign","lineHeight","textDecoration","textDecorationColor","textDecorationStyle","textTransform","letterSpacing","textIndent","opacity","style","opts","obj","getFont","font","data","attributes","align","indent","link","src","characterSpacing","underlineStyle","underline","underlineColor","strike","strikeStyle","strikeColor","i","children","length","child","push","String","fromCharCode","attachment","width","height","image","value","preprocessor","getAttributedString","compose","fromFragments","_default","curryN"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\n\nexports.__esModule = true;\nexports.default = void 0;\n\nvar R = _interopRequireWildcard(require(\"ramda\"));\n\nvar P = _interopRequireWildcard(require(\"@react-pdf/primitives\"));\n\nvar _attributedString = _interopRequireDefault(require(\"@react-pdf/textkit/attributedString\"));\n\nvar _emoji = require(\"./emoji\");\n\nvar _ignoreChars = _interopRequireDefault(require(\"./ignoreChars\"));\n\nvar _transformText = _interopRequireDefault(require(\"./transformText\"));\n\nconst PREPROCESSORS = [_ignoreChars.default, _emoji.embedEmojis];\nconst isType = R.propEq('type');\nconst isImage = isType(P.Image);\nconst isTextInstance = isType(P.TextInstance);\n/**\n * Get textkit framgents of given node object\n *\n * @param {Object} instance node\n * @returns {Array} text fragments\n */\n\nconst getFragments = (fontStore, instance) => {\n  if (!instance) return [{\n    string: ''\n  }];\n  let fragments = [];\n  const {\n    color = 'black',\n    backgroundColor,\n    fontFamily = 'Helvetica',\n    fontWeight,\n    fontStyle,\n    fontSize = 18,\n    textAlign = 'left',\n    lineHeight,\n    textDecoration,\n    textDecorationColor,\n    textDecorationStyle,\n    textTransform,\n    letterSpacing,\n    textIndent,\n    opacity\n  } = instance.style;\n  const opts = {\n    fontFamily,\n    fontWeight,\n    fontStyle\n  };\n  const obj = fontStore ? fontStore.getFont(opts) : null;\n  const font = obj ? obj.data : fontFamily;\n  const attributes = {\n    font,\n    color,\n    opacity,\n    fontSize,\n    backgroundColor,\n    align: textAlign,\n    indent: textIndent,\n    link: instance.src,\n    characterSpacing: letterSpacing,\n    underlineStyle: textDecorationStyle,\n    underline: textDecoration === 'underline',\n    underlineColor: textDecorationColor || color,\n    strike: textDecoration === 'line-through',\n    strikeStyle: textDecorationStyle,\n    strikeColor: textDecorationColor || color,\n    lineHeight: lineHeight ? lineHeight * fontSize : null\n  };\n\n  for (let i = 0; i < instance.children.length; i += 1) {\n    const child = instance.children[i];\n\n    if (isImage(child)) {\n      fragments.push({\n        string: String.fromCharCode(0xfffc),\n        attributes: { ...attributes,\n          attachment: {\n            width: child.style.width || fontSize,\n            height: child.style.height || fontSize,\n            image: child.image.data\n          }\n        }\n      });\n    } else if (isTextInstance(child)) {\n      fragments.push({\n        string: (0, _transformText.default)(child.value, textTransform),\n        attributes\n      });\n    } else if (child) {\n      fragments.push(...getFragments(child));\n    }\n  }\n\n  for (let i = 0; i < PREPROCESSORS.length; i += 1) {\n    const preprocessor = PREPROCESSORS[i];\n    fragments = preprocessor(fragments);\n  }\n\n  return fragments;\n};\n/**\n * Get textkit attributed string from text node\n *\n * @param {Object} instance node\n * @returns {Object} attributed string\n */\n\n\nconst getAttributedString = R.compose(_attributedString.default.fromFragments, getFragments);\n\nvar _default = R.curryN(2, getAttributedString);\n\nexports.default = _default;"]},"metadata":{},"sourceType":"script"}