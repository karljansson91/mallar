{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\n\nexports.__esModule = true;\nexports.default = void 0;\n\nvar R = _interopRequireWildcard(require(\"ramda\"));\n\nvar _standardFont = _interopRequireDefault(require(\"./standardFont\"));\n\nconst fontCache = {};\nconst IGNORED_CODE_POINTS = [173];\nconst getFontSize = R.pathOr(12, ['attributes', 'fontSize']);\n\nconst getOrCreateFont = name => {\n  if (fontCache[name]) return fontCache[name];\n  const font = new _standardFont.default(name);\n  fontCache[name] = font;\n  return font;\n};\n\nconst getFallbackFont = () => getOrCreateFont('Helvetica');\n\nconst shouldFallbackToFont = (codePoint, font) => !IGNORED_CODE_POINTS.includes(codePoint) && !font.hasGlyphForCodePoint(codePoint) && getFallbackFont().hasGlyphForCodePoint(codePoint);\n\nconst fontSubstitution = () => ({\n  string,\n  runs\n}) => {\n  let lastFont = null;\n  let lastIndex = 0;\n  let index = 0;\n  const res = [];\n\n  for (const run of runs) {\n    const fontSize = getFontSize(run);\n    const defaultFont = typeof run.attributes.font === 'string' ? getOrCreateFont(run.attributes.font) : run.attributes.font;\n\n    if (string.length === 0) {\n      res.push({\n        start: 0,\n        end: 0,\n        attributes: {\n          font: defaultFont\n        }\n      });\n      break;\n    }\n\n    for (const char of string.slice(run.start, run.end)) {\n      const codePoint = char.codePointAt();\n      const shouldFallback = shouldFallbackToFont(codePoint, defaultFont);\n      const font = shouldFallback ? getFallbackFont() : defaultFont; // If the default font does not have a glyph and the fallback font does, we use it\n\n      if (font !== lastFont) {\n        if (lastFont) {\n          res.push({\n            start: lastIndex,\n            end: index,\n            attributes: {\n              font: lastFont,\n              scale: lastFont ? fontSize / lastFont.unitsPerEm : 0\n            }\n          });\n        }\n\n        lastFont = font;\n        lastIndex = index;\n      }\n\n      index += char.length;\n    }\n  }\n\n  if (lastIndex < string.length) {\n    const fontSize = getFontSize(R.last(runs));\n    res.push({\n      start: lastIndex,\n      end: string.length,\n      attributes: {\n        font: lastFont,\n        scale: lastFont ? fontSize / lastFont.unitsPerEm : 0\n      }\n    });\n  }\n\n  return {\n    string,\n    runs: res\n  };\n};\n\nvar _default = fontSubstitution;\nexports.default = _default;","map":{"version":3,"sources":["/Users/kaja/Code/mallar/app/node_modules/@react-pdf/layout/lib/text/fontSubstitution.js"],"names":["_interopRequireDefault","require","_interopRequireWildcard","exports","__esModule","default","R","_standardFont","fontCache","IGNORED_CODE_POINTS","getFontSize","pathOr","getOrCreateFont","name","font","getFallbackFont","shouldFallbackToFont","codePoint","includes","hasGlyphForCodePoint","fontSubstitution","string","runs","lastFont","lastIndex","index","res","run","fontSize","defaultFont","attributes","length","push","start","end","char","slice","codePointAt","shouldFallback","scale","unitsPerEm","last","_default"],"mappings":"AAAA;;AAEA,IAAIA,sBAAsB,GAAGC,OAAO,CAAC,8CAAD,CAApC;;AAEA,IAAIC,uBAAuB,GAAGD,OAAO,CAAC,+CAAD,CAArC;;AAEAE,OAAO,CAACC,UAAR,GAAqB,IAArB;AACAD,OAAO,CAACE,OAAR,GAAkB,KAAK,CAAvB;;AAEA,IAAIC,CAAC,GAAGJ,uBAAuB,CAACD,OAAO,CAAC,OAAD,CAAR,CAA/B;;AAEA,IAAIM,aAAa,GAAGP,sBAAsB,CAACC,OAAO,CAAC,gBAAD,CAAR,CAA1C;;AAEA,MAAMO,SAAS,GAAG,EAAlB;AACA,MAAMC,mBAAmB,GAAG,CAAC,GAAD,CAA5B;AACA,MAAMC,WAAW,GAAGJ,CAAC,CAACK,MAAF,CAAS,EAAT,EAAa,CAAC,YAAD,EAAe,UAAf,CAAb,CAApB;;AAEA,MAAMC,eAAe,GAAGC,IAAI,IAAI;AAC9B,MAAIL,SAAS,CAACK,IAAD,CAAb,EAAqB,OAAOL,SAAS,CAACK,IAAD,CAAhB;AACrB,QAAMC,IAAI,GAAG,IAAIP,aAAa,CAACF,OAAlB,CAA0BQ,IAA1B,CAAb;AACAL,EAAAA,SAAS,CAACK,IAAD,CAAT,GAAkBC,IAAlB;AACA,SAAOA,IAAP;AACD,CALD;;AAOA,MAAMC,eAAe,GAAG,MAAMH,eAAe,CAAC,WAAD,CAA7C;;AAEA,MAAMI,oBAAoB,GAAG,CAACC,SAAD,EAAYH,IAAZ,KAAqB,CAACL,mBAAmB,CAACS,QAApB,CAA6BD,SAA7B,CAAD,IAA4C,CAACH,IAAI,CAACK,oBAAL,CAA0BF,SAA1B,CAA7C,IAAqFF,eAAe,GAAGI,oBAAlB,CAAuCF,SAAvC,CAAvI;;AAEA,MAAMG,gBAAgB,GAAG,MAAM,CAAC;AAC9BC,EAAAA,MAD8B;AAE9BC,EAAAA;AAF8B,CAAD,KAGzB;AACJ,MAAIC,QAAQ,GAAG,IAAf;AACA,MAAIC,SAAS,GAAG,CAAhB;AACA,MAAIC,KAAK,GAAG,CAAZ;AACA,QAAMC,GAAG,GAAG,EAAZ;;AAEA,OAAK,MAAMC,GAAX,IAAkBL,IAAlB,EAAwB;AACtB,UAAMM,QAAQ,GAAGlB,WAAW,CAACiB,GAAD,CAA5B;AACA,UAAME,WAAW,GAAG,OAAOF,GAAG,CAACG,UAAJ,CAAehB,IAAtB,KAA+B,QAA/B,GAA0CF,eAAe,CAACe,GAAG,CAACG,UAAJ,CAAehB,IAAhB,CAAzD,GAAiFa,GAAG,CAACG,UAAJ,CAAehB,IAApH;;AAEA,QAAIO,MAAM,CAACU,MAAP,KAAkB,CAAtB,EAAyB;AACvBL,MAAAA,GAAG,CAACM,IAAJ,CAAS;AACPC,QAAAA,KAAK,EAAE,CADA;AAEPC,QAAAA,GAAG,EAAE,CAFE;AAGPJ,QAAAA,UAAU,EAAE;AACVhB,UAAAA,IAAI,EAAEe;AADI;AAHL,OAAT;AAOA;AACD;;AAED,SAAK,MAAMM,IAAX,IAAmBd,MAAM,CAACe,KAAP,CAAaT,GAAG,CAACM,KAAjB,EAAwBN,GAAG,CAACO,GAA5B,CAAnB,EAAqD;AACnD,YAAMjB,SAAS,GAAGkB,IAAI,CAACE,WAAL,EAAlB;AACA,YAAMC,cAAc,GAAGtB,oBAAoB,CAACC,SAAD,EAAYY,WAAZ,CAA3C;AACA,YAAMf,IAAI,GAAGwB,cAAc,GAAGvB,eAAe,EAAlB,GAAuBc,WAAlD,CAHmD,CAGY;;AAE/D,UAAIf,IAAI,KAAKS,QAAb,EAAuB;AACrB,YAAIA,QAAJ,EAAc;AACZG,UAAAA,GAAG,CAACM,IAAJ,CAAS;AACPC,YAAAA,KAAK,EAAET,SADA;AAEPU,YAAAA,GAAG,EAAET,KAFE;AAGPK,YAAAA,UAAU,EAAE;AACVhB,cAAAA,IAAI,EAAES,QADI;AAEVgB,cAAAA,KAAK,EAAEhB,QAAQ,GAAGK,QAAQ,GAAGL,QAAQ,CAACiB,UAAvB,GAAoC;AAFzC;AAHL,WAAT;AAQD;;AAEDjB,QAAAA,QAAQ,GAAGT,IAAX;AACAU,QAAAA,SAAS,GAAGC,KAAZ;AACD;;AAEDA,MAAAA,KAAK,IAAIU,IAAI,CAACJ,MAAd;AACD;AACF;;AAED,MAAIP,SAAS,GAAGH,MAAM,CAACU,MAAvB,EAA+B;AAC7B,UAAMH,QAAQ,GAAGlB,WAAW,CAACJ,CAAC,CAACmC,IAAF,CAAOnB,IAAP,CAAD,CAA5B;AACAI,IAAAA,GAAG,CAACM,IAAJ,CAAS;AACPC,MAAAA,KAAK,EAAET,SADA;AAEPU,MAAAA,GAAG,EAAEb,MAAM,CAACU,MAFL;AAGPD,MAAAA,UAAU,EAAE;AACVhB,QAAAA,IAAI,EAAES,QADI;AAEVgB,QAAAA,KAAK,EAAEhB,QAAQ,GAAGK,QAAQ,GAAGL,QAAQ,CAACiB,UAAvB,GAAoC;AAFzC;AAHL,KAAT;AAQD;;AAED,SAAO;AACLnB,IAAAA,MADK;AAELC,IAAAA,IAAI,EAAEI;AAFD,GAAP;AAID,CAjED;;AAmEA,IAAIgB,QAAQ,GAAGtB,gBAAf;AACAjB,OAAO,CAACE,OAAR,GAAkBqC,QAAlB","sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\n\nexports.__esModule = true;\nexports.default = void 0;\n\nvar R = _interopRequireWildcard(require(\"ramda\"));\n\nvar _standardFont = _interopRequireDefault(require(\"./standardFont\"));\n\nconst fontCache = {};\nconst IGNORED_CODE_POINTS = [173];\nconst getFontSize = R.pathOr(12, ['attributes', 'fontSize']);\n\nconst getOrCreateFont = name => {\n  if (fontCache[name]) return fontCache[name];\n  const font = new _standardFont.default(name);\n  fontCache[name] = font;\n  return font;\n};\n\nconst getFallbackFont = () => getOrCreateFont('Helvetica');\n\nconst shouldFallbackToFont = (codePoint, font) => !IGNORED_CODE_POINTS.includes(codePoint) && !font.hasGlyphForCodePoint(codePoint) && getFallbackFont().hasGlyphForCodePoint(codePoint);\n\nconst fontSubstitution = () => ({\n  string,\n  runs\n}) => {\n  let lastFont = null;\n  let lastIndex = 0;\n  let index = 0;\n  const res = [];\n\n  for (const run of runs) {\n    const fontSize = getFontSize(run);\n    const defaultFont = typeof run.attributes.font === 'string' ? getOrCreateFont(run.attributes.font) : run.attributes.font;\n\n    if (string.length === 0) {\n      res.push({\n        start: 0,\n        end: 0,\n        attributes: {\n          font: defaultFont\n        }\n      });\n      break;\n    }\n\n    for (const char of string.slice(run.start, run.end)) {\n      const codePoint = char.codePointAt();\n      const shouldFallback = shouldFallbackToFont(codePoint, defaultFont);\n      const font = shouldFallback ? getFallbackFont() : defaultFont; // If the default font does not have a glyph and the fallback font does, we use it\n\n      if (font !== lastFont) {\n        if (lastFont) {\n          res.push({\n            start: lastIndex,\n            end: index,\n            attributes: {\n              font: lastFont,\n              scale: lastFont ? fontSize / lastFont.unitsPerEm : 0\n            }\n          });\n        }\n\n        lastFont = font;\n        lastIndex = index;\n      }\n\n      index += char.length;\n    }\n  }\n\n  if (lastIndex < string.length) {\n    const fontSize = getFontSize(R.last(runs));\n    res.push({\n      start: lastIndex,\n      end: string.length,\n      attributes: {\n        font: lastFont,\n        scale: lastFont ? fontSize / lastFont.unitsPerEm : 0\n      }\n    });\n  }\n\n  return {\n    string,\n    runs: res\n  };\n};\n\nvar _default = fontSubstitution;\nexports.default = _default;"]},"metadata":{},"sourceType":"script"}