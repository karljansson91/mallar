{"ast":null,"code":"'use strict';\n\nfunction _interopDefault(ex) {\n  return ex && typeof ex === 'object' && 'default' in ex ? ex['default'] : ex;\n}\n\nvar r = _interopDefault(require('restructure'));\n\nvar _Object$getOwnPropertyDescriptor = _interopDefault(require('babel-runtime/core-js/object/get-own-property-descriptor'));\n\nvar _getIterator = _interopDefault(require('babel-runtime/core-js/get-iterator'));\n\nvar _Object$freeze = _interopDefault(require('babel-runtime/core-js/object/freeze'));\n\nvar _typeof = _interopDefault(require('babel-runtime/helpers/typeof'));\n\nvar _Object$keys = _interopDefault(require('babel-runtime/core-js/object/keys'));\n\nvar _Object$defineProperty = _interopDefault(require('babel-runtime/core-js/object/define-property'));\n\nvar _classCallCheck = _interopDefault(require('babel-runtime/helpers/classCallCheck'));\n\nvar _createClass = _interopDefault(require('babel-runtime/helpers/createClass'));\n\nvar _Map = _interopDefault(require('babel-runtime/core-js/map'));\n\nvar _possibleConstructorReturn = _interopDefault(require('babel-runtime/helpers/possibleConstructorReturn'));\n\nvar _inherits = _interopDefault(require('babel-runtime/helpers/inherits'));\n\nvar restructure_src_utils = require('restructure/src/utils');\n\nvar _Object$defineProperties = _interopDefault(require('babel-runtime/core-js/object/define-properties'));\n\nvar isEqual = _interopDefault(require('deep-equal'));\n\nvar _Object$assign = _interopDefault(require('babel-runtime/core-js/object/assign'));\n\nvar _String$fromCodePoint = _interopDefault(require('babel-runtime/core-js/string/from-code-point'));\n\nvar _Array$from = _interopDefault(require('babel-runtime/core-js/array/from'));\n\nvar _Set = _interopDefault(require('babel-runtime/core-js/set'));\n\nvar unicode = _interopDefault(require('unicode-properties'));\n\nvar UnicodeTrie = _interopDefault(require('unicode-trie'));\n\nvar StateMachine = _interopDefault(require('dfa'));\n\nvar _Number$EPSILON = _interopDefault(require('babel-runtime/core-js/number/epsilon'));\n\nvar cloneDeep = _interopDefault(require('clone'));\n\nvar _Promise = _interopDefault(require('babel-runtime/core-js/promise'));\n\nvar inflate = _interopDefault(require('tiny-inflate'));\n\nvar brotli = _interopDefault(require('brotli/decompress'));\n\nvar fs = require('fs');\n\nvar fontkit = {};\nfontkit.logErrors = false;\nvar formats = [];\n\nfontkit.registerFormat = function (format) {\n  formats.push(format);\n};\n\nfontkit.openSync = function (filename, postscriptName) {\n  var buffer = fs.readFileSync(filename);\n  return fontkit.create(buffer, postscriptName);\n};\n\nfontkit.open = function (filename, postscriptName, callback) {\n  if (typeof postscriptName === 'function') {\n    callback = postscriptName;\n    postscriptName = null;\n  }\n\n  fs.readFile(filename, function (err, buffer) {\n    if (err) {\n      return callback(err);\n    }\n\n    try {\n      var font = fontkit.create(buffer, postscriptName);\n    } catch (e) {\n      return callback(e);\n    }\n\n    return callback(null, font);\n  });\n  return;\n};\n\nfontkit.create = function (buffer, postscriptName) {\n  for (var i = 0; i < formats.length; i++) {\n    var format = formats[i];\n\n    if (format.probe(buffer)) {\n      var font = new format(new r.DecodeStream(buffer));\n\n      if (postscriptName) {\n        return font.getFont(postscriptName);\n      }\n\n      return font;\n    }\n  }\n\n  throw new Error('Unknown font format');\n};\n\nfontkit.defaultLanguage = 'en';\n\nfontkit.setDefaultLanguage = function () {\n  var lang = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'en';\n  fontkit.defaultLanguage = lang;\n};\n/**\n * This decorator caches the results of a getter or method such that\n * the results are lazily computed once, and then cached.\n * @private\n */\n\n\nfunction cache(target, key, descriptor) {\n  if (descriptor.get) {\n    var get = descriptor.get;\n\n    descriptor.get = function () {\n      var value = get.call(this);\n\n      _Object$defineProperty(this, key, {\n        value: value\n      });\n\n      return value;\n    };\n  } else if (typeof descriptor.value === 'function') {\n    var fn = descriptor.value;\n    return {\n      get: function get() {\n        var cache = new _Map();\n\n        function memoized() {\n          for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n            args[_key] = arguments[_key];\n          }\n\n          var key = args.length > 0 ? args[0] : 'value';\n\n          if (cache.has(key)) {\n            return cache.get(key);\n          }\n\n          var result = fn.apply(this, args);\n          cache.set(key, result);\n          return result;\n        }\n\n        ;\n\n        _Object$defineProperty(this, key, {\n          value: memoized\n        });\n\n        return memoized;\n      }\n    };\n  }\n}\n\nvar SubHeader = new r.Struct({\n  firstCode: r.uint16,\n  entryCount: r.uint16,\n  idDelta: r.int16,\n  idRangeOffset: r.uint16\n});\nvar CmapGroup = new r.Struct({\n  startCharCode: r.uint32,\n  endCharCode: r.uint32,\n  glyphID: r.uint32\n});\nvar UnicodeValueRange = new r.Struct({\n  startUnicodeValue: r.uint24,\n  additionalCount: r.uint8\n});\nvar UVSMapping = new r.Struct({\n  unicodeValue: r.uint24,\n  glyphID: r.uint16\n});\nvar DefaultUVS = new r.Array(UnicodeValueRange, r.uint32);\nvar NonDefaultUVS = new r.Array(UVSMapping, r.uint32);\nvar VarSelectorRecord = new r.Struct({\n  varSelector: r.uint24,\n  defaultUVS: new r.Pointer(r.uint32, DefaultUVS, {\n    type: 'parent'\n  }),\n  nonDefaultUVS: new r.Pointer(r.uint32, NonDefaultUVS, {\n    type: 'parent'\n  })\n});\nvar CmapSubtable = new r.VersionedStruct(r.uint16, {\n  0: {\n    // Byte encoding\n    length: r.uint16,\n    // Total table length in bytes (set to 262 for format 0)\n    language: r.uint16,\n    // Language code for this encoding subtable, or zero if language-independent\n    codeMap: new r.LazyArray(r.uint8, 256)\n  },\n  2: {\n    // High-byte mapping (CJK)\n    length: r.uint16,\n    language: r.uint16,\n    subHeaderKeys: new r.Array(r.uint16, 256),\n    subHeaderCount: function subHeaderCount(t) {\n      return Math.max.apply(Math, t.subHeaderKeys);\n    },\n    subHeaders: new r.LazyArray(SubHeader, 'subHeaderCount'),\n    glyphIndexArray: new r.LazyArray(r.uint16, 'subHeaderCount')\n  },\n  4: {\n    // Segment mapping to delta values\n    length: r.uint16,\n    // Total table length in bytes\n    language: r.uint16,\n    // Language code\n    segCountX2: r.uint16,\n    segCount: function segCount(t) {\n      return t.segCountX2 >> 1;\n    },\n    searchRange: r.uint16,\n    entrySelector: r.uint16,\n    rangeShift: r.uint16,\n    endCode: new r.LazyArray(r.uint16, 'segCount'),\n    reservedPad: new r.Reserved(r.uint16),\n    // This value should be zero\n    startCode: new r.LazyArray(r.uint16, 'segCount'),\n    idDelta: new r.LazyArray(r.int16, 'segCount'),\n    idRangeOffset: new r.LazyArray(r.uint16, 'segCount'),\n    glyphIndexArray: new r.LazyArray(r.uint16, function (t) {\n      return (t.length - t._currentOffset) / 2;\n    })\n  },\n  6: {\n    // Trimmed table\n    length: r.uint16,\n    language: r.uint16,\n    firstCode: r.uint16,\n    entryCount: r.uint16,\n    glyphIndices: new r.LazyArray(r.uint16, 'entryCount')\n  },\n  8: {\n    // mixed 16-bit and 32-bit coverage\n    reserved: new r.Reserved(r.uint16),\n    length: r.uint32,\n    language: r.uint16,\n    is32: new r.LazyArray(r.uint8, 8192),\n    nGroups: r.uint32,\n    groups: new r.LazyArray(CmapGroup, 'nGroups')\n  },\n  10: {\n    // Trimmed Array\n    reserved: new r.Reserved(r.uint16),\n    length: r.uint32,\n    language: r.uint32,\n    firstCode: r.uint32,\n    entryCount: r.uint32,\n    glyphIndices: new r.LazyArray(r.uint16, 'numChars')\n  },\n  12: {\n    // Segmented coverage\n    reserved: new r.Reserved(r.uint16),\n    length: r.uint32,\n    language: r.uint32,\n    nGroups: r.uint32,\n    groups: new r.LazyArray(CmapGroup, 'nGroups')\n  },\n  13: {\n    // Many-to-one range mappings (same as 12 except for group.startGlyphID)\n    reserved: new r.Reserved(r.uint16),\n    length: r.uint32,\n    language: r.uint32,\n    nGroups: r.uint32,\n    groups: new r.LazyArray(CmapGroup, 'nGroups')\n  },\n  14: {\n    // Unicode Variation Sequences\n    length: r.uint32,\n    numRecords: r.uint32,\n    varSelectors: new r.LazyArray(VarSelectorRecord, 'numRecords')\n  }\n});\nvar CmapEntry = new r.Struct({\n  platformID: r.uint16,\n  // Platform identifier\n  encodingID: r.uint16,\n  // Platform-specific encoding identifier\n  table: new r.Pointer(r.uint32, CmapSubtable, {\n    type: 'parent',\n    lazy: true\n  })\n}); // character to glyph mapping\n\nvar cmap = new r.Struct({\n  version: r.uint16,\n  numSubtables: r.uint16,\n  tables: new r.Array(CmapEntry, 'numSubtables')\n}); // font header\n\nvar head = new r.Struct({\n  version: r.int32,\n  // 0x00010000 (version 1.0)\n  revision: r.int32,\n  // set by font manufacturer\n  checkSumAdjustment: r.uint32,\n  magicNumber: r.uint32,\n  // set to 0x5F0F3CF5\n  flags: r.uint16,\n  unitsPerEm: r.uint16,\n  // range from 64 to 16384\n  created: new r.Array(r.int32, 2),\n  modified: new r.Array(r.int32, 2),\n  xMin: r.int16,\n  // for all glyph bounding boxes\n  yMin: r.int16,\n  // for all glyph bounding boxes\n  xMax: r.int16,\n  // for all glyph bounding boxes\n  yMax: r.int16,\n  // for all glyph bounding boxes\n  macStyle: new r.Bitfield(r.uint16, ['bold', 'italic', 'underline', 'outline', 'shadow', 'condensed', 'extended']),\n  lowestRecPPEM: r.uint16,\n  // smallest readable size in pixels\n  fontDirectionHint: r.int16,\n  indexToLocFormat: r.int16,\n  // 0 for short offsets, 1 for long\n  glyphDataFormat: r.int16 // 0 for current format\n\n}); // horizontal header\n\nvar hhea = new r.Struct({\n  version: r.int32,\n  ascent: r.int16,\n  // Distance from baseline of highest ascender\n  descent: r.int16,\n  // Distance from baseline of lowest descender\n  lineGap: r.int16,\n  // Typographic line gap\n  advanceWidthMax: r.uint16,\n  // Maximum advance width value in 'hmtx' table\n  minLeftSideBearing: r.int16,\n  // Maximum advance width value in 'hmtx' table\n  minRightSideBearing: r.int16,\n  // Minimum right sidebearing value\n  xMaxExtent: r.int16,\n  caretSlopeRise: r.int16,\n  // Used to calculate the slope of the cursor (rise/run); 1 for vertical\n  caretSlopeRun: r.int16,\n  // 0 for vertical\n  caretOffset: r.int16,\n  // Set to 0 for non-slanted fonts\n  reserved: new r.Reserved(r.int16, 4),\n  metricDataFormat: r.int16,\n  // 0 for current format\n  numberOfMetrics: r.uint16 // Number of advance widths in 'hmtx' table\n\n});\nvar HmtxEntry = new r.Struct({\n  advance: r.uint16,\n  bearing: r.int16\n});\nvar hmtx = new r.Struct({\n  metrics: new r.LazyArray(HmtxEntry, function (t) {\n    return t.parent.hhea.numberOfMetrics;\n  }),\n  bearings: new r.LazyArray(r.int16, function (t) {\n    return t.parent.maxp.numGlyphs - t.parent.hhea.numberOfMetrics;\n  })\n}); // maxiumum profile\n\nvar maxp = new r.Struct({\n  version: r.int32,\n  numGlyphs: r.uint16,\n  // The number of glyphs in the font\n  maxPoints: r.uint16,\n  // Maximum points in a non-composite glyph\n  maxContours: r.uint16,\n  // Maximum contours in a non-composite glyph\n  maxComponentPoints: r.uint16,\n  // Maximum points in a composite glyph\n  maxComponentContours: r.uint16,\n  // Maximum contours in a composite glyph\n  maxZones: r.uint16,\n  // 1 if instructions do not use the twilight zone, 2 otherwise\n  maxTwilightPoints: r.uint16,\n  // Maximum points used in Z0\n  maxStorage: r.uint16,\n  // Number of Storage Area locations\n  maxFunctionDefs: r.uint16,\n  // Number of FDEFs\n  maxInstructionDefs: r.uint16,\n  // Number of IDEFs\n  maxStackElements: r.uint16,\n  // Maximum stack depth\n  maxSizeOfInstructions: r.uint16,\n  // Maximum byte count for glyph instructions\n  maxComponentElements: r.uint16,\n  // Maximum number of components referenced at “top level” for any composite glyph\n  maxComponentDepth: r.uint16 // Maximum levels of recursion; 1 for simple components\n\n});\n/**\n * Gets an encoding name from platform, encoding, and language ids.\n * Returned encoding names can be used in iconv-lite to decode text.\n */\n\nfunction getEncoding(platformID, encodingID) {\n  var languageID = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\n  if (platformID === 1 && MAC_LANGUAGE_ENCODINGS[languageID]) {\n    return MAC_LANGUAGE_ENCODINGS[languageID];\n  }\n\n  return ENCODINGS[platformID][encodingID];\n} // Map of platform ids to encoding ids.\n\n\nvar ENCODINGS = [// unicode\n['utf16be', 'utf16be', 'utf16be', 'utf16be', 'utf16be', 'utf16be'], // macintosh\n// Mappings available at http://unicode.org/Public/MAPPINGS/VENDORS/APPLE/\n// 0\tRoman                 17\tMalayalam\n// 1\tJapanese\t            18\tSinhalese\n// 2\tTraditional Chinese\t  19\tBurmese\n// 3\tKorean\t              20\tKhmer\n// 4\tArabic\t              21\tThai\n// 5\tHebrew\t              22\tLaotian\n// 6\tGreek\t                23\tGeorgian\n// 7\tRussian\t              24\tArmenian\n// 8\tRSymbol\t              25\tSimplified Chinese\n// 9\tDevanagari\t          26\tTibetan\n// 10\tGurmukhi\t            27\tMongolian\n// 11\tGujarati\t            28\tGeez\n// 12\tOriya\t                29\tSlavic\n// 13\tBengali\t              30\tVietnamese\n// 14\tTamil\t                31\tSindhi\n// 15\tTelugu\t              32\t(Uninterpreted)\n// 16\tKannada\n['macroman', 'shift-jis', 'big5', 'euc-kr', 'iso-8859-6', 'iso-8859-8', 'macgreek', 'maccyrillic', 'symbol', 'Devanagari', 'Gurmukhi', 'Gujarati', 'Oriya', 'Bengali', 'Tamil', 'Telugu', 'Kannada', 'Malayalam', 'Sinhalese', 'Burmese', 'Khmer', 'macthai', 'Laotian', 'Georgian', 'Armenian', 'gb-2312-80', 'Tibetan', 'Mongolian', 'Geez', 'maccenteuro', 'Vietnamese', 'Sindhi'], // ISO (deprecated)\n['ascii'], // windows\n// Docs here: http://msdn.microsoft.com/en-us/library/system.text.encoding(v=vs.110).aspx\n['symbol', 'utf16be', 'shift-jis', 'gb18030', 'big5', 'wansung', 'johab', null, null, null, 'utf16be']]; // Overrides for Mac scripts by language id.\n// See http://unicode.org/Public/MAPPINGS/VENDORS/APPLE/Readme.txt\n\nvar MAC_LANGUAGE_ENCODINGS = {\n  15: 'maciceland',\n  17: 'macturkish',\n  18: 'maccroatian',\n  24: 'maccenteuro',\n  25: 'maccenteuro',\n  26: 'maccenteuro',\n  27: 'maccenteuro',\n  28: 'maccenteuro',\n  30: 'maciceland',\n  37: 'macromania',\n  38: 'maccenteuro',\n  39: 'maccenteuro',\n  40: 'maccenteuro',\n  143: 'macinuit',\n  // Unsupported by iconv-lite\n  146: 'macgaelic' // Unsupported by iconv-lite\n\n}; // Map of platform ids to BCP-47 language codes.\n\nvar LANGUAGES = [// unicode\n[], {\n  // macintosh\n  0: 'en',\n  30: 'fo',\n  60: 'ks',\n  90: 'rw',\n  1: 'fr',\n  31: 'fa',\n  61: 'ku',\n  91: 'rn',\n  2: 'de',\n  32: 'ru',\n  62: 'sd',\n  92: 'ny',\n  3: 'it',\n  33: 'zh',\n  63: 'bo',\n  93: 'mg',\n  4: 'nl',\n  34: 'nl-BE',\n  64: 'ne',\n  94: 'eo',\n  5: 'sv',\n  35: 'ga',\n  65: 'sa',\n  128: 'cy',\n  6: 'es',\n  36: 'sq',\n  66: 'mr',\n  129: 'eu',\n  7: 'da',\n  37: 'ro',\n  67: 'bn',\n  130: 'ca',\n  8: 'pt',\n  38: 'cz',\n  68: 'as',\n  131: 'la',\n  9: 'no',\n  39: 'sk',\n  69: 'gu',\n  132: 'qu',\n  10: 'he',\n  40: 'si',\n  70: 'pa',\n  133: 'gn',\n  11: 'ja',\n  41: 'yi',\n  71: 'or',\n  134: 'ay',\n  12: 'ar',\n  42: 'sr',\n  72: 'ml',\n  135: 'tt',\n  13: 'fi',\n  43: 'mk',\n  73: 'kn',\n  136: 'ug',\n  14: 'el',\n  44: 'bg',\n  74: 'ta',\n  137: 'dz',\n  15: 'is',\n  45: 'uk',\n  75: 'te',\n  138: 'jv',\n  16: 'mt',\n  46: 'be',\n  76: 'si',\n  139: 'su',\n  17: 'tr',\n  47: 'uz',\n  77: 'my',\n  140: 'gl',\n  18: 'hr',\n  48: 'kk',\n  78: 'km',\n  141: 'af',\n  19: 'zh-Hant',\n  49: 'az-Cyrl',\n  79: 'lo',\n  142: 'br',\n  20: 'ur',\n  50: 'az-Arab',\n  80: 'vi',\n  143: 'iu',\n  21: 'hi',\n  51: 'hy',\n  81: 'id',\n  144: 'gd',\n  22: 'th',\n  52: 'ka',\n  82: 'tl',\n  145: 'gv',\n  23: 'ko',\n  53: 'mo',\n  83: 'ms',\n  146: 'ga',\n  24: 'lt',\n  54: 'ky',\n  84: 'ms-Arab',\n  147: 'to',\n  25: 'pl',\n  55: 'tg',\n  85: 'am',\n  148: 'el-polyton',\n  26: 'hu',\n  56: 'tk',\n  86: 'ti',\n  149: 'kl',\n  27: 'es',\n  57: 'mn-CN',\n  87: 'om',\n  150: 'az',\n  28: 'lv',\n  58: 'mn',\n  88: 'so',\n  151: 'nn',\n  29: 'se',\n  59: 'ps',\n  89: 'sw'\n}, // ISO (deprecated)\n[], {\n  // windows                                        \n  0x0436: 'af',\n  0x4009: 'en-IN',\n  0x0487: 'rw',\n  0x0432: 'tn',\n  0x041C: 'sq',\n  0x1809: 'en-IE',\n  0x0441: 'sw',\n  0x045B: 'si',\n  0x0484: 'gsw',\n  0x2009: 'en-JM',\n  0x0457: 'kok',\n  0x041B: 'sk',\n  0x045E: 'am',\n  0x4409: 'en-MY',\n  0x0412: 'ko',\n  0x0424: 'sl',\n  0x1401: 'ar-DZ',\n  0x1409: 'en-NZ',\n  0x0440: 'ky',\n  0x2C0A: 'es-AR',\n  0x3C01: 'ar-BH',\n  0x3409: 'en-PH',\n  0x0454: 'lo',\n  0x400A: 'es-BO',\n  0x0C01: 'ar',\n  0x4809: 'en-SG',\n  0x0426: 'lv',\n  0x340A: 'es-CL',\n  0x0801: 'ar-IQ',\n  0x1C09: 'en-ZA',\n  0x0427: 'lt',\n  0x240A: 'es-CO',\n  0x2C01: 'ar-JO',\n  0x2C09: 'en-TT',\n  0x082E: 'dsb',\n  0x140A: 'es-CR',\n  0x3401: 'ar-KW',\n  0x0809: 'en-GB',\n  0x046E: 'lb',\n  0x1C0A: 'es-DO',\n  0x3001: 'ar-LB',\n  0x0409: 'en',\n  0x042F: 'mk',\n  0x300A: 'es-EC',\n  0x1001: 'ar-LY',\n  0x3009: 'en-ZW',\n  0x083E: 'ms-BN',\n  0x440A: 'es-SV',\n  0x1801: 'ary',\n  0x0425: 'et',\n  0x043E: 'ms',\n  0x100A: 'es-GT',\n  0x2001: 'ar-OM',\n  0x0438: 'fo',\n  0x044C: 'ml',\n  0x480A: 'es-HN',\n  0x4001: 'ar-QA',\n  0x0464: 'fil',\n  0x043A: 'mt',\n  0x080A: 'es-MX',\n  0x0401: 'ar-SA',\n  0x040B: 'fi',\n  0x0481: 'mi',\n  0x4C0A: 'es-NI',\n  0x2801: 'ar-SY',\n  0x080C: 'fr-BE',\n  0x047A: 'arn',\n  0x180A: 'es-PA',\n  0x1C01: 'aeb',\n  0x0C0C: 'fr-CA',\n  0x044E: 'mr',\n  0x3C0A: 'es-PY',\n  0x3801: 'ar-AE',\n  0x040C: 'fr',\n  0x047C: 'moh',\n  0x280A: 'es-PE',\n  0x2401: 'ar-YE',\n  0x140C: 'fr-LU',\n  0x0450: 'mn',\n  0x500A: 'es-PR',\n  0x042B: 'hy',\n  0x180C: 'fr-MC',\n  0x0850: 'mn-CN',\n  0x0C0A: 'es',\n  0x044D: 'as',\n  0x100C: 'fr-CH',\n  0x0461: 'ne',\n  0x040A: 'es',\n  0x082C: 'az-Cyrl',\n  0x0462: 'fy',\n  0x0414: 'nb',\n  0x540A: 'es-US',\n  0x042C: 'az',\n  0x0456: 'gl',\n  0x0814: 'nn',\n  0x380A: 'es-UY',\n  0x046D: 'ba',\n  0x0437: 'ka',\n  0x0482: 'oc',\n  0x200A: 'es-VE',\n  0x042D: 'eu',\n  0x0C07: 'de-AT',\n  0x0448: 'or',\n  0x081D: 'sv-FI',\n  0x0423: 'be',\n  0x0407: 'de',\n  0x0463: 'ps',\n  0x041D: 'sv',\n  0x0845: 'bn',\n  0x1407: 'de-LI',\n  0x0415: 'pl',\n  0x045A: 'syr',\n  0x0445: 'bn-IN',\n  0x1007: 'de-LU',\n  0x0416: 'pt',\n  0x0428: 'tg',\n  0x201A: 'bs-Cyrl',\n  0x0807: 'de-CH',\n  0x0816: 'pt-PT',\n  0x085F: 'tzm',\n  0x141A: 'bs',\n  0x0408: 'el',\n  0x0446: 'pa',\n  0x0449: 'ta',\n  0x047E: 'br',\n  0x046F: 'kl',\n  0x046B: 'qu-BO',\n  0x0444: 'tt',\n  0x0402: 'bg',\n  0x0447: 'gu',\n  0x086B: 'qu-EC',\n  0x044A: 'te',\n  0x0403: 'ca',\n  0x0468: 'ha',\n  0x0C6B: 'qu',\n  0x041E: 'th',\n  0x0C04: 'zh-HK',\n  0x040D: 'he',\n  0x0418: 'ro',\n  0x0451: 'bo',\n  0x1404: 'zh-MO',\n  0x0439: 'hi',\n  0x0417: 'rm',\n  0x041F: 'tr',\n  0x0804: 'zh',\n  0x040E: 'hu',\n  0x0419: 'ru',\n  0x0442: 'tk',\n  0x1004: 'zh-SG',\n  0x040F: 'is',\n  0x243B: 'smn',\n  0x0480: 'ug',\n  0x0404: 'zh-TW',\n  0x0470: 'ig',\n  0x103B: 'smj-NO',\n  0x0422: 'uk',\n  0x0483: 'co',\n  0x0421: 'id',\n  0x143B: 'smj',\n  0x042E: 'hsb',\n  0x041A: 'hr',\n  0x045D: 'iu',\n  0x0C3B: 'se-FI',\n  0x0420: 'ur',\n  0x101A: 'hr-BA',\n  0x085D: 'iu-Latn',\n  0x043B: 'se',\n  0x0843: 'uz-Cyrl',\n  0x0405: 'cs',\n  0x083C: 'ga',\n  0x083B: 'se-SE',\n  0x0443: 'uz',\n  0x0406: 'da',\n  0x0434: 'xh',\n  0x203B: 'sms',\n  0x042A: 'vi',\n  0x048C: 'prs',\n  0x0435: 'zu',\n  0x183B: 'sma-NO',\n  0x0452: 'cy',\n  0x0465: 'dv',\n  0x0410: 'it',\n  0x1C3B: 'sms',\n  0x0488: 'wo',\n  0x0813: 'nl-BE',\n  0x0810: 'it-CH',\n  0x044F: 'sa',\n  0x0485: 'sah',\n  0x0413: 'nl',\n  0x0411: 'ja',\n  0x1C1A: 'sr-Cyrl-BA',\n  0x0478: 'ii',\n  0x0C09: 'en-AU',\n  0x044B: 'kn',\n  0x0C1A: 'sr',\n  0x046A: 'yo',\n  0x2809: 'en-BZ',\n  0x043F: 'kk',\n  0x181A: 'sr-Latn-BA',\n  0x1009: 'en-CA',\n  0x0453: 'km',\n  0x081A: 'sr-Latn',\n  0x2409: 'en-029',\n  0x0486: 'quc',\n  0x046C: 'nso'\n}];\nvar NameRecord = new r.Struct({\n  platformID: r.uint16,\n  encodingID: r.uint16,\n  languageID: r.uint16,\n  nameID: r.uint16,\n  length: r.uint16,\n  string: new r.Pointer(r.uint16, new r.String('length', function (t) {\n    return getEncoding(t.platformID, t.encodingID, t.languageID);\n  }), {\n    type: 'parent',\n    relativeTo: 'parent.stringOffset',\n    allowNull: false\n  })\n});\nvar LangTagRecord = new r.Struct({\n  length: r.uint16,\n  tag: new r.Pointer(r.uint16, new r.String('length', 'utf16be'), {\n    type: 'parent',\n    relativeTo: 'stringOffset'\n  })\n});\nvar NameTable = new r.VersionedStruct(r.uint16, {\n  0: {\n    count: r.uint16,\n    stringOffset: r.uint16,\n    records: new r.Array(NameRecord, 'count')\n  },\n  1: {\n    count: r.uint16,\n    stringOffset: r.uint16,\n    records: new r.Array(NameRecord, 'count'),\n    langTagCount: r.uint16,\n    langTags: new r.Array(LangTagRecord, 'langTagCount')\n  }\n});\nvar NAMES = ['copyright', 'fontFamily', 'fontSubfamily', 'uniqueSubfamily', 'fullName', 'version', 'postscriptName', // Note: A font may have only one PostScript name and that name must be ASCII.\n'trademark', 'manufacturer', 'designer', 'description', 'vendorURL', 'designerURL', 'license', 'licenseURL', null, // reserved\n'preferredFamily', 'preferredSubfamily', 'compatibleFull', 'sampleText', 'postscriptCIDFontName', 'wwsFamilyName', 'wwsSubfamilyName'];\n\nNameTable.process = function (stream) {\n  var records = {};\n\n  for (var _iterator = this.records, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _getIterator(_iterator);;) {\n    var _ref;\n\n    if (_isArray) {\n      if (_i >= _iterator.length) break;\n      _ref = _iterator[_i++];\n    } else {\n      _i = _iterator.next();\n      if (_i.done) break;\n      _ref = _i.value;\n    }\n\n    var record = _ref; // find out what language this is for\n\n    var language = LANGUAGES[record.platformID][record.languageID];\n\n    if (language == null && this.langTags != null && record.languageID >= 0x8000) {\n      language = this.langTags[record.languageID - 0x8000].tag;\n    }\n\n    if (language == null) {\n      language = record.platformID + '-' + record.languageID;\n    } // if the nameID is >= 256, it is a font feature record (AAT)\n\n\n    var key = record.nameID >= 256 ? 'fontFeatures' : NAMES[record.nameID] || record.nameID;\n\n    if (records[key] == null) {\n      records[key] = {};\n    }\n\n    var obj = records[key];\n\n    if (record.nameID >= 256) {\n      obj = obj[record.nameID] || (obj[record.nameID] = {});\n    }\n\n    if (typeof record.string === 'string' || typeof obj[language] !== 'string') {\n      obj[language] = record.string;\n    }\n  }\n\n  this.records = records;\n};\n\nNameTable.preEncode = function () {\n  if (Array.isArray(this.records)) return;\n  this.version = 0;\n  var records = [];\n\n  for (var key in this.records) {\n    var val = this.records[key];\n    if (key === 'fontFeatures') continue;\n    records.push({\n      platformID: 3,\n      encodingID: 1,\n      languageID: 0x409,\n      nameID: NAMES.indexOf(key),\n      length: Buffer.byteLength(val.en, 'utf16le'),\n      string: val.en\n    });\n\n    if (key === 'postscriptName') {\n      records.push({\n        platformID: 1,\n        encodingID: 0,\n        languageID: 0,\n        nameID: NAMES.indexOf(key),\n        length: val.en.length,\n        string: val.en\n      });\n    }\n  }\n\n  this.records = records;\n  this.count = records.length;\n  this.stringOffset = NameTable.size(this, null, false);\n};\n\nvar OS2 = new r.VersionedStruct(r.uint16, {\n  header: {\n    xAvgCharWidth: r.int16,\n    // average weighted advance width of lower case letters and space\n    usWeightClass: r.uint16,\n    // visual weight of stroke in glyphs\n    usWidthClass: r.uint16,\n    // relative change from the normal aspect ratio (width to height ratio)\n    fsType: new r.Bitfield(r.uint16, [// Indicates font embedding licensing rights\n    null, 'noEmbedding', 'viewOnly', 'editable', null, null, null, null, 'noSubsetting', 'bitmapOnly']),\n    ySubscriptXSize: r.int16,\n    // recommended horizontal size in pixels for subscripts\n    ySubscriptYSize: r.int16,\n    // recommended vertical size in pixels for subscripts\n    ySubscriptXOffset: r.int16,\n    // recommended horizontal offset for subscripts\n    ySubscriptYOffset: r.int16,\n    // recommended vertical offset form the baseline for subscripts\n    ySuperscriptXSize: r.int16,\n    // recommended horizontal size in pixels for superscripts\n    ySuperscriptYSize: r.int16,\n    // recommended vertical size in pixels for superscripts\n    ySuperscriptXOffset: r.int16,\n    // recommended horizontal offset for superscripts\n    ySuperscriptYOffset: r.int16,\n    // recommended vertical offset from the baseline for superscripts\n    yStrikeoutSize: r.int16,\n    // width of the strikeout stroke\n    yStrikeoutPosition: r.int16,\n    // position of the strikeout stroke relative to the baseline\n    sFamilyClass: r.int16,\n    // classification of font-family design\n    panose: new r.Array(r.uint8, 10),\n    // describe the visual characteristics of a given typeface\n    ulCharRange: new r.Array(r.uint32, 4),\n    vendorID: new r.String(4),\n    // four character identifier for the font vendor\n    fsSelection: new r.Bitfield(r.uint16, [// bit field containing information about the font\n    'italic', 'underscore', 'negative', 'outlined', 'strikeout', 'bold', 'regular', 'useTypoMetrics', 'wws', 'oblique']),\n    usFirstCharIndex: r.uint16,\n    // The minimum Unicode index in this font\n    usLastCharIndex: r.uint16 // The maximum Unicode index in this font\n\n  },\n  // The Apple version of this table ends here, but the Microsoft one continues on...\n  0: {},\n  1: {\n    typoAscender: r.int16,\n    typoDescender: r.int16,\n    typoLineGap: r.int16,\n    winAscent: r.uint16,\n    winDescent: r.uint16,\n    codePageRange: new r.Array(r.uint32, 2)\n  },\n  2: {\n    // these should be common with version 1 somehow\n    typoAscender: r.int16,\n    typoDescender: r.int16,\n    typoLineGap: r.int16,\n    winAscent: r.uint16,\n    winDescent: r.uint16,\n    codePageRange: new r.Array(r.uint32, 2),\n    xHeight: r.int16,\n    capHeight: r.int16,\n    defaultChar: r.uint16,\n    breakChar: r.uint16,\n    maxContent: r.uint16\n  },\n  5: {\n    typoAscender: r.int16,\n    typoDescender: r.int16,\n    typoLineGap: r.int16,\n    winAscent: r.uint16,\n    winDescent: r.uint16,\n    codePageRange: new r.Array(r.uint32, 2),\n    xHeight: r.int16,\n    capHeight: r.int16,\n    defaultChar: r.uint16,\n    breakChar: r.uint16,\n    maxContent: r.uint16,\n    usLowerOpticalPointSize: r.uint16,\n    usUpperOpticalPointSize: r.uint16\n  }\n});\nvar versions = OS2.versions;\nversions[3] = versions[4] = versions[2]; // PostScript information\n\nvar post = new r.VersionedStruct(r.fixed32, {\n  header: {\n    // these fields exist at the top of all versions\n    italicAngle: r.fixed32,\n    // Italic angle in counter-clockwise degrees from the vertical.\n    underlinePosition: r.int16,\n    // Suggested distance of the top of the underline from the baseline\n    underlineThickness: r.int16,\n    // Suggested values for the underline thickness\n    isFixedPitch: r.uint32,\n    // Whether the font is monospaced\n    minMemType42: r.uint32,\n    // Minimum memory usage when a TrueType font is downloaded as a Type 42 font\n    maxMemType42: r.uint32,\n    // Maximum memory usage when a TrueType font is downloaded as a Type 42 font\n    minMemType1: r.uint32,\n    // Minimum memory usage when a TrueType font is downloaded as a Type 1 font\n    maxMemType1: r.uint32 // Maximum memory usage when a TrueType font is downloaded as a Type 1 font\n\n  },\n  1: {},\n  // version 1 has no additional fields\n  2: {\n    numberOfGlyphs: r.uint16,\n    glyphNameIndex: new r.Array(r.uint16, 'numberOfGlyphs'),\n    names: new r.Array(new r.String(r.uint8))\n  },\n  2.5: {\n    numberOfGlyphs: r.uint16,\n    offsets: new r.Array(r.uint8, 'numberOfGlyphs')\n  },\n  3: {},\n  // version 3 has no additional fields\n  4: {\n    map: new r.Array(r.uint32, function (t) {\n      return t.parent.maxp.numGlyphs;\n    })\n  }\n}); // An array of predefined values accessible by instructions\n\nvar cvt = new r.Struct({\n  controlValues: new r.Array(r.int16)\n}); // A list of instructions that are executed once when a font is first used.\n// These instructions are known as the font program. The main use of this table\n// is for the definition of functions that are used in many different glyph programs.\n\nvar fpgm = new r.Struct({\n  instructions: new r.Array(r.uint8)\n});\nvar loca = new r.VersionedStruct('head.indexToLocFormat', {\n  0: {\n    offsets: new r.Array(r.uint16)\n  },\n  1: {\n    offsets: new r.Array(r.uint32)\n  }\n});\n\nloca.process = function () {\n  if (this.version === 0) {\n    for (var i = 0; i < this.offsets.length; i++) {\n      this.offsets[i] <<= 1;\n    }\n  }\n};\n\nloca.preEncode = function () {\n  if (this.version === 0) {\n    for (var i = 0; i < this.offsets.length; i++) {\n      this.offsets[i] >>>= 1;\n    }\n  }\n}; // Set of instructions executed whenever the point size or font transformation change\n\n\nvar prep = new r.Struct({\n  controlValueProgram: new r.Array(r.uint8)\n}); // only used for encoding\n\nvar glyf = new r.Array(new r.Buffer());\n\nvar CFFIndex = function () {\n  function CFFIndex(type) {\n    _classCallCheck(this, CFFIndex);\n\n    this.type = type;\n  }\n\n  CFFIndex.prototype.getCFFVersion = function getCFFVersion(ctx) {\n    while (ctx && !ctx.hdrSize) {\n      ctx = ctx.parent;\n    }\n\n    return ctx ? ctx.version : -1;\n  };\n\n  CFFIndex.prototype.decode = function decode(stream, parent) {\n    var version = this.getCFFVersion(parent);\n    var count = version >= 2 ? stream.readUInt32BE() : stream.readUInt16BE();\n\n    if (count === 0) {\n      return [];\n    }\n\n    var offSize = stream.readUInt8();\n    var offsetType = void 0;\n\n    if (offSize === 1) {\n      offsetType = r.uint8;\n    } else if (offSize === 2) {\n      offsetType = r.uint16;\n    } else if (offSize === 3) {\n      offsetType = r.uint24;\n    } else if (offSize === 4) {\n      offsetType = r.uint32;\n    } else {\n      throw new Error(\"Bad offset size in CFFIndex: \" + offSize + \" \" + stream.pos);\n    }\n\n    var ret = [];\n    var startPos = stream.pos + (count + 1) * offSize - 1;\n    var start = offsetType.decode(stream);\n\n    for (var i = 0; i < count; i++) {\n      var end = offsetType.decode(stream);\n\n      if (this.type != null) {\n        var pos = stream.pos;\n        stream.pos = startPos + start;\n        parent.length = end - start;\n        ret.push(this.type.decode(stream, parent));\n        stream.pos = pos;\n      } else {\n        ret.push({\n          offset: startPos + start,\n          length: end - start\n        });\n      }\n\n      start = end;\n    }\n\n    stream.pos = startPos + start;\n    return ret;\n  };\n\n  CFFIndex.prototype.size = function size(arr, parent) {\n    var size = 2;\n\n    if (arr.length === 0) {\n      return size;\n    }\n\n    var type = this.type || new r.Buffer(); // find maximum offset to detminine offset type\n\n    var offset = 1;\n\n    for (var i = 0; i < arr.length; i++) {\n      var item = arr[i];\n      offset += type.size(item, parent);\n    }\n\n    var offsetType = void 0;\n\n    if (offset <= 0xff) {\n      offsetType = r.uint8;\n    } else if (offset <= 0xffff) {\n      offsetType = r.uint16;\n    } else if (offset <= 0xffffff) {\n      offsetType = r.uint24;\n    } else if (offset <= 0xffffffff) {\n      offsetType = r.uint32;\n    } else {\n      throw new Error(\"Bad offset in CFFIndex\");\n    }\n\n    size += 1 + offsetType.size() * (arr.length + 1);\n    size += offset - 1;\n    return size;\n  };\n\n  CFFIndex.prototype.encode = function encode(stream, arr, parent) {\n    stream.writeUInt16BE(arr.length);\n\n    if (arr.length === 0) {\n      return;\n    }\n\n    var type = this.type || new r.Buffer(); // find maximum offset to detminine offset type\n\n    var sizes = [];\n    var offset = 1;\n\n    for (var _iterator = arr, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _getIterator(_iterator);;) {\n      var _ref;\n\n      if (_isArray) {\n        if (_i >= _iterator.length) break;\n        _ref = _iterator[_i++];\n      } else {\n        _i = _iterator.next();\n        if (_i.done) break;\n        _ref = _i.value;\n      }\n\n      var item = _ref;\n      var s = type.size(item, parent);\n      sizes.push(s);\n      offset += s;\n    }\n\n    var offsetType = void 0;\n\n    if (offset <= 0xff) {\n      offsetType = r.uint8;\n    } else if (offset <= 0xffff) {\n      offsetType = r.uint16;\n    } else if (offset <= 0xffffff) {\n      offsetType = r.uint24;\n    } else if (offset <= 0xffffffff) {\n      offsetType = r.uint32;\n    } else {\n      throw new Error(\"Bad offset in CFFIndex\");\n    } // write offset size\n\n\n    stream.writeUInt8(offsetType.size()); // write elements\n\n    offset = 1;\n    offsetType.encode(stream, offset);\n\n    for (var _iterator2 = sizes, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _getIterator(_iterator2);;) {\n      var _ref2;\n\n      if (_isArray2) {\n        if (_i2 >= _iterator2.length) break;\n        _ref2 = _iterator2[_i2++];\n      } else {\n        _i2 = _iterator2.next();\n        if (_i2.done) break;\n        _ref2 = _i2.value;\n      }\n\n      var size = _ref2;\n      offset += size;\n      offsetType.encode(stream, offset);\n    }\n\n    for (var _iterator3 = arr, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _getIterator(_iterator3);;) {\n      var _ref3;\n\n      if (_isArray3) {\n        if (_i3 >= _iterator3.length) break;\n        _ref3 = _iterator3[_i3++];\n      } else {\n        _i3 = _iterator3.next();\n        if (_i3.done) break;\n        _ref3 = _i3.value;\n      }\n\n      var _item = _ref3;\n      type.encode(stream, _item, parent);\n    }\n\n    return;\n  };\n\n  return CFFIndex;\n}();\n\nvar FLOAT_EOF = 0xf;\nvar FLOAT_LOOKUP = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '.', 'E', 'E-', null, '-'];\nvar FLOAT_ENCODE_LOOKUP = {\n  '.': 10,\n  'E': 11,\n  'E-': 12,\n  '-': 14\n};\n\nvar CFFOperand = function () {\n  function CFFOperand() {\n    _classCallCheck(this, CFFOperand);\n  }\n\n  CFFOperand.decode = function decode(stream, value) {\n    if (32 <= value && value <= 246) {\n      return value - 139;\n    }\n\n    if (247 <= value && value <= 250) {\n      return (value - 247) * 256 + stream.readUInt8() + 108;\n    }\n\n    if (251 <= value && value <= 254) {\n      return -(value - 251) * 256 - stream.readUInt8() - 108;\n    }\n\n    if (value === 28) {\n      return stream.readInt16BE();\n    }\n\n    if (value === 29) {\n      return stream.readInt32BE();\n    }\n\n    if (value === 30) {\n      var str = '';\n\n      while (true) {\n        var b = stream.readUInt8();\n        var n1 = b >> 4;\n\n        if (n1 === FLOAT_EOF) {\n          break;\n        }\n\n        str += FLOAT_LOOKUP[n1];\n        var n2 = b & 15;\n\n        if (n2 === FLOAT_EOF) {\n          break;\n        }\n\n        str += FLOAT_LOOKUP[n2];\n      }\n\n      return parseFloat(str);\n    }\n\n    return null;\n  };\n\n  CFFOperand.size = function size(value) {\n    // if the value needs to be forced to the largest size (32 bit)\n    // e.g. for unknown pointers, set to 32768\n    if (value.forceLarge) {\n      value = 32768;\n    }\n\n    if ((value | 0) !== value) {\n      // floating point\n      var str = '' + value;\n      return 1 + Math.ceil((str.length + 1) / 2);\n    } else if (-107 <= value && value <= 107) {\n      return 1;\n    } else if (108 <= value && value <= 1131 || -1131 <= value && value <= -108) {\n      return 2;\n    } else if (-32768 <= value && value <= 32767) {\n      return 3;\n    } else {\n      return 5;\n    }\n  };\n\n  CFFOperand.encode = function encode(stream, value) {\n    // if the value needs to be forced to the largest size (32 bit)\n    // e.g. for unknown pointers, save the old value and set to 32768\n    var val = Number(value);\n\n    if (value.forceLarge) {\n      stream.writeUInt8(29);\n      return stream.writeInt32BE(val);\n    } else if ((val | 0) !== val) {\n      // floating point\n      stream.writeUInt8(30);\n      var str = '' + val;\n\n      for (var i = 0; i < str.length; i += 2) {\n        var c1 = str[i];\n        var n1 = FLOAT_ENCODE_LOOKUP[c1] || +c1;\n\n        if (i === str.length - 1) {\n          var n2 = FLOAT_EOF;\n        } else {\n          var c2 = str[i + 1];\n          var n2 = FLOAT_ENCODE_LOOKUP[c2] || +c2;\n        }\n\n        stream.writeUInt8(n1 << 4 | n2 & 15);\n      }\n\n      if (n2 !== FLOAT_EOF) {\n        return stream.writeUInt8(FLOAT_EOF << 4);\n      }\n    } else if (-107 <= val && val <= 107) {\n      return stream.writeUInt8(val + 139);\n    } else if (108 <= val && val <= 1131) {\n      val -= 108;\n      stream.writeUInt8((val >> 8) + 247);\n      return stream.writeUInt8(val & 0xff);\n    } else if (-1131 <= val && val <= -108) {\n      val = -val - 108;\n      stream.writeUInt8((val >> 8) + 251);\n      return stream.writeUInt8(val & 0xff);\n    } else if (-32768 <= val && val <= 32767) {\n      stream.writeUInt8(28);\n      return stream.writeInt16BE(val);\n    } else {\n      stream.writeUInt8(29);\n      return stream.writeInt32BE(val);\n    }\n  };\n\n  return CFFOperand;\n}();\n\nvar CFFDict = function () {\n  function CFFDict() {\n    var ops = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\n    _classCallCheck(this, CFFDict);\n\n    this.ops = ops;\n    this.fields = {};\n\n    for (var _iterator = ops, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _getIterator(_iterator);;) {\n      var _ref;\n\n      if (_isArray) {\n        if (_i >= _iterator.length) break;\n        _ref = _iterator[_i++];\n      } else {\n        _i = _iterator.next();\n        if (_i.done) break;\n        _ref = _i.value;\n      }\n\n      var field = _ref;\n      var key = Array.isArray(field[0]) ? field[0][0] << 8 | field[0][1] : field[0];\n      this.fields[key] = field;\n    }\n  }\n\n  CFFDict.prototype.decodeOperands = function decodeOperands(type, stream, ret, operands) {\n    var _this = this;\n\n    if (Array.isArray(type)) {\n      return operands.map(function (op, i) {\n        return _this.decodeOperands(type[i], stream, ret, [op]);\n      });\n    } else if (type.decode != null) {\n      return type.decode(stream, ret, operands);\n    } else {\n      switch (type) {\n        case 'number':\n        case 'offset':\n        case 'sid':\n          return operands[0];\n\n        case 'boolean':\n          return !!operands[0];\n\n        default:\n          return operands;\n      }\n    }\n  };\n\n  CFFDict.prototype.encodeOperands = function encodeOperands(type, stream, ctx, operands) {\n    var _this2 = this;\n\n    if (Array.isArray(type)) {\n      return operands.map(function (op, i) {\n        return _this2.encodeOperands(type[i], stream, ctx, op)[0];\n      });\n    } else if (type.encode != null) {\n      return type.encode(stream, operands, ctx);\n    } else if (typeof operands === 'number') {\n      return [operands];\n    } else if (typeof operands === 'boolean') {\n      return [+operands];\n    } else if (Array.isArray(operands)) {\n      return operands;\n    } else {\n      return [operands];\n    }\n  };\n\n  CFFDict.prototype.decode = function decode(stream, parent) {\n    var end = stream.pos + parent.length;\n    var ret = {};\n    var operands = []; // define hidden properties\n\n    _Object$defineProperties(ret, {\n      parent: {\n        value: parent\n      },\n      _startOffset: {\n        value: stream.pos\n      }\n    }); // fill in defaults\n\n\n    for (var key in this.fields) {\n      var field = this.fields[key];\n      ret[field[1]] = field[3];\n    }\n\n    while (stream.pos < end) {\n      var b = stream.readUInt8();\n\n      if (b < 28) {\n        if (b === 12) {\n          b = b << 8 | stream.readUInt8();\n        }\n\n        var _field = this.fields[b];\n\n        if (!_field) {\n          throw new Error('Unknown operator ' + b);\n        }\n\n        var val = this.decodeOperands(_field[2], stream, ret, operands);\n\n        if (val != null) {\n          if (val instanceof restructure_src_utils.PropertyDescriptor) {\n            _Object$defineProperty(ret, _field[1], val);\n          } else {\n            ret[_field[1]] = val;\n          }\n        }\n\n        operands = [];\n      } else {\n        operands.push(CFFOperand.decode(stream, b));\n      }\n    }\n\n    return ret;\n  };\n\n  CFFDict.prototype.size = function size(dict, parent) {\n    var includePointers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    var ctx = {\n      parent: parent,\n      val: dict,\n      pointerSize: 0,\n      startOffset: parent.startOffset || 0\n    };\n    var len = 0;\n\n    for (var k in this.fields) {\n      var field = this.fields[k];\n      var val = dict[field[1]];\n\n      if (val == null || isEqual(val, field[3])) {\n        continue;\n      }\n\n      var operands = this.encodeOperands(field[2], null, ctx, val);\n\n      for (var _iterator2 = operands, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _getIterator(_iterator2);;) {\n        var _ref2;\n\n        if (_isArray2) {\n          if (_i2 >= _iterator2.length) break;\n          _ref2 = _iterator2[_i2++];\n        } else {\n          _i2 = _iterator2.next();\n          if (_i2.done) break;\n          _ref2 = _i2.value;\n        }\n\n        var op = _ref2;\n        len += CFFOperand.size(op);\n      }\n\n      var key = Array.isArray(field[0]) ? field[0] : [field[0]];\n      len += key.length;\n    }\n\n    if (includePointers) {\n      len += ctx.pointerSize;\n    }\n\n    return len;\n  };\n\n  CFFDict.prototype.encode = function encode(stream, dict, parent) {\n    var ctx = {\n      pointers: [],\n      startOffset: stream.pos,\n      parent: parent,\n      val: dict,\n      pointerSize: 0\n    };\n    ctx.pointerOffset = stream.pos + this.size(dict, ctx, false);\n\n    for (var _iterator3 = this.ops, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _getIterator(_iterator3);;) {\n      var _ref3;\n\n      if (_isArray3) {\n        if (_i3 >= _iterator3.length) break;\n        _ref3 = _iterator3[_i3++];\n      } else {\n        _i3 = _iterator3.next();\n        if (_i3.done) break;\n        _ref3 = _i3.value;\n      }\n\n      var field = _ref3;\n      var val = dict[field[1]];\n\n      if (val == null || isEqual(val, field[3])) {\n        continue;\n      }\n\n      var operands = this.encodeOperands(field[2], stream, ctx, val);\n\n      for (var _iterator4 = operands, _isArray4 = Array.isArray(_iterator4), _i4 = 0, _iterator4 = _isArray4 ? _iterator4 : _getIterator(_iterator4);;) {\n        var _ref4;\n\n        if (_isArray4) {\n          if (_i4 >= _iterator4.length) break;\n          _ref4 = _iterator4[_i4++];\n        } else {\n          _i4 = _iterator4.next();\n          if (_i4.done) break;\n          _ref4 = _i4.value;\n        }\n\n        var op = _ref4;\n        CFFOperand.encode(stream, op);\n      }\n\n      var key = Array.isArray(field[0]) ? field[0] : [field[0]];\n\n      for (var _iterator5 = key, _isArray5 = Array.isArray(_iterator5), _i5 = 0, _iterator5 = _isArray5 ? _iterator5 : _getIterator(_iterator5);;) {\n        var _ref5;\n\n        if (_isArray5) {\n          if (_i5 >= _iterator5.length) break;\n          _ref5 = _iterator5[_i5++];\n        } else {\n          _i5 = _iterator5.next();\n          if (_i5.done) break;\n          _ref5 = _i5.value;\n        }\n\n        var _op = _ref5;\n        stream.writeUInt8(_op);\n      }\n    }\n\n    var i = 0;\n\n    while (i < ctx.pointers.length) {\n      var ptr = ctx.pointers[i++];\n      ptr.type.encode(stream, ptr.val, ptr.parent);\n    }\n\n    return;\n  };\n\n  return CFFDict;\n}();\n\nvar CFFPointer = function (_r$Pointer) {\n  _inherits(CFFPointer, _r$Pointer);\n\n  function CFFPointer(type) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, CFFPointer);\n\n    if (options.type == null) {\n      options.type = 'global';\n    }\n\n    return _possibleConstructorReturn(this, _r$Pointer.call(this, null, type, options));\n  }\n\n  CFFPointer.prototype.decode = function decode(stream, parent, operands) {\n    this.offsetType = {\n      decode: function decode() {\n        return operands[0];\n      }\n    };\n    return _r$Pointer.prototype.decode.call(this, stream, parent, operands);\n  };\n\n  CFFPointer.prototype.encode = function encode(stream, value, ctx) {\n    if (!stream) {\n      // compute the size (so ctx.pointerSize is correct)\n      this.offsetType = {\n        size: function size() {\n          return 0;\n        }\n      };\n      this.size(value, ctx);\n      return [new Ptr(0)];\n    }\n\n    var ptr = null;\n    this.offsetType = {\n      encode: function encode(stream, val) {\n        return ptr = val;\n      }\n    };\n\n    _r$Pointer.prototype.encode.call(this, stream, value, ctx);\n\n    return [new Ptr(ptr)];\n  };\n\n  return CFFPointer;\n}(r.Pointer);\n\nvar Ptr = function () {\n  function Ptr(val) {\n    _classCallCheck(this, Ptr);\n\n    this.val = val;\n    this.forceLarge = true;\n  }\n\n  Ptr.prototype.valueOf = function valueOf() {\n    return this.val;\n  };\n\n  return Ptr;\n}();\n\nvar CFFBlendOp = function () {\n  function CFFBlendOp() {\n    _classCallCheck(this, CFFBlendOp);\n  }\n\n  CFFBlendOp.decode = function decode(stream, parent, operands) {\n    var numBlends = operands.pop(); // TODO: actually blend. For now just consume the deltas\n    // since we don't use any of the values anyway.\n\n    while (operands.length > numBlends) {\n      operands.pop();\n    }\n  };\n\n  return CFFBlendOp;\n}();\n\nvar CFFPrivateDict = new CFFDict([// key       name                    type                                          default\n[6, 'BlueValues', 'delta', null], [7, 'OtherBlues', 'delta', null], [8, 'FamilyBlues', 'delta', null], [9, 'FamilyOtherBlues', 'delta', null], [[12, 9], 'BlueScale', 'number', 0.039625], [[12, 10], 'BlueShift', 'number', 7], [[12, 11], 'BlueFuzz', 'number', 1], [10, 'StdHW', 'number', null], [11, 'StdVW', 'number', null], [[12, 12], 'StemSnapH', 'delta', null], [[12, 13], 'StemSnapV', 'delta', null], [[12, 14], 'ForceBold', 'boolean', false], [[12, 17], 'LanguageGroup', 'number', 0], [[12, 18], 'ExpansionFactor', 'number', 0.06], [[12, 19], 'initialRandomSeed', 'number', 0], [20, 'defaultWidthX', 'number', 0], [21, 'nominalWidthX', 'number', 0], [22, 'vsindex', 'number', 0], [23, 'blend', CFFBlendOp, null], [19, 'Subrs', new CFFPointer(new CFFIndex(), {\n  type: 'local'\n}), null]]); // Automatically generated from Appendix A of the CFF specification; do\n// not edit. Length should be 391.\n\nvar standardStrings = [\".notdef\", \"space\", \"exclam\", \"quotedbl\", \"numbersign\", \"dollar\", \"percent\", \"ampersand\", \"quoteright\", \"parenleft\", \"parenright\", \"asterisk\", \"plus\", \"comma\", \"hyphen\", \"period\", \"slash\", \"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\", \"colon\", \"semicolon\", \"less\", \"equal\", \"greater\", \"question\", \"at\", \"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\", \"J\", \"K\", \"L\", \"M\", \"N\", \"O\", \"P\", \"Q\", \"R\", \"S\", \"T\", \"U\", \"V\", \"W\", \"X\", \"Y\", \"Z\", \"bracketleft\", \"backslash\", \"bracketright\", \"asciicircum\", \"underscore\", \"quoteleft\", \"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\", \"braceleft\", \"bar\", \"braceright\", \"asciitilde\", \"exclamdown\", \"cent\", \"sterling\", \"fraction\", \"yen\", \"florin\", \"section\", \"currency\", \"quotesingle\", \"quotedblleft\", \"guillemotleft\", \"guilsinglleft\", \"guilsinglright\", \"fi\", \"fl\", \"endash\", \"dagger\", \"daggerdbl\", \"periodcentered\", \"paragraph\", \"bullet\", \"quotesinglbase\", \"quotedblbase\", \"quotedblright\", \"guillemotright\", \"ellipsis\", \"perthousand\", \"questiondown\", \"grave\", \"acute\", \"circumflex\", \"tilde\", \"macron\", \"breve\", \"dotaccent\", \"dieresis\", \"ring\", \"cedilla\", \"hungarumlaut\", \"ogonek\", \"caron\", \"emdash\", \"AE\", \"ordfeminine\", \"Lslash\", \"Oslash\", \"OE\", \"ordmasculine\", \"ae\", \"dotlessi\", \"lslash\", \"oslash\", \"oe\", \"germandbls\", \"onesuperior\", \"logicalnot\", \"mu\", \"trademark\", \"Eth\", \"onehalf\", \"plusminus\", \"Thorn\", \"onequarter\", \"divide\", \"brokenbar\", \"degree\", \"thorn\", \"threequarters\", \"twosuperior\", \"registered\", \"minus\", \"eth\", \"multiply\", \"threesuperior\", \"copyright\", \"Aacute\", \"Acircumflex\", \"Adieresis\", \"Agrave\", \"Aring\", \"Atilde\", \"Ccedilla\", \"Eacute\", \"Ecircumflex\", \"Edieresis\", \"Egrave\", \"Iacute\", \"Icircumflex\", \"Idieresis\", \"Igrave\", \"Ntilde\", \"Oacute\", \"Ocircumflex\", \"Odieresis\", \"Ograve\", \"Otilde\", \"Scaron\", \"Uacute\", \"Ucircumflex\", \"Udieresis\", \"Ugrave\", \"Yacute\", \"Ydieresis\", \"Zcaron\", \"aacute\", \"acircumflex\", \"adieresis\", \"agrave\", \"aring\", \"atilde\", \"ccedilla\", \"eacute\", \"ecircumflex\", \"edieresis\", \"egrave\", \"iacute\", \"icircumflex\", \"idieresis\", \"igrave\", \"ntilde\", \"oacute\", \"ocircumflex\", \"odieresis\", \"ograve\", \"otilde\", \"scaron\", \"uacute\", \"ucircumflex\", \"udieresis\", \"ugrave\", \"yacute\", \"ydieresis\", \"zcaron\", \"exclamsmall\", \"Hungarumlautsmall\", \"dollaroldstyle\", \"dollarsuperior\", \"ampersandsmall\", \"Acutesmall\", \"parenleftsuperior\", \"parenrightsuperior\", \"twodotenleader\", \"onedotenleader\", \"zerooldstyle\", \"oneoldstyle\", \"twooldstyle\", \"threeoldstyle\", \"fouroldstyle\", \"fiveoldstyle\", \"sixoldstyle\", \"sevenoldstyle\", \"eightoldstyle\", \"nineoldstyle\", \"commasuperior\", \"threequartersemdash\", \"periodsuperior\", \"questionsmall\", \"asuperior\", \"bsuperior\", \"centsuperior\", \"dsuperior\", \"esuperior\", \"isuperior\", \"lsuperior\", \"msuperior\", \"nsuperior\", \"osuperior\", \"rsuperior\", \"ssuperior\", \"tsuperior\", \"ff\", \"ffi\", \"ffl\", \"parenleftinferior\", \"parenrightinferior\", \"Circumflexsmall\", \"hyphensuperior\", \"Gravesmall\", \"Asmall\", \"Bsmall\", \"Csmall\", \"Dsmall\", \"Esmall\", \"Fsmall\", \"Gsmall\", \"Hsmall\", \"Ismall\", \"Jsmall\", \"Ksmall\", \"Lsmall\", \"Msmall\", \"Nsmall\", \"Osmall\", \"Psmall\", \"Qsmall\", \"Rsmall\", \"Ssmall\", \"Tsmall\", \"Usmall\", \"Vsmall\", \"Wsmall\", \"Xsmall\", \"Ysmall\", \"Zsmall\", \"colonmonetary\", \"onefitted\", \"rupiah\", \"Tildesmall\", \"exclamdownsmall\", \"centoldstyle\", \"Lslashsmall\", \"Scaronsmall\", \"Zcaronsmall\", \"Dieresissmall\", \"Brevesmall\", \"Caronsmall\", \"Dotaccentsmall\", \"Macronsmall\", \"figuredash\", \"hypheninferior\", \"Ogoneksmall\", \"Ringsmall\", \"Cedillasmall\", \"questiondownsmall\", \"oneeighth\", \"threeeighths\", \"fiveeighths\", \"seveneighths\", \"onethird\", \"twothirds\", \"zerosuperior\", \"foursuperior\", \"fivesuperior\", \"sixsuperior\", \"sevensuperior\", \"eightsuperior\", \"ninesuperior\", \"zeroinferior\", \"oneinferior\", \"twoinferior\", \"threeinferior\", \"fourinferior\", \"fiveinferior\", \"sixinferior\", \"seveninferior\", \"eightinferior\", \"nineinferior\", \"centinferior\", \"dollarinferior\", \"periodinferior\", \"commainferior\", \"Agravesmall\", \"Aacutesmall\", \"Acircumflexsmall\", \"Atildesmall\", \"Adieresissmall\", \"Aringsmall\", \"AEsmall\", \"Ccedillasmall\", \"Egravesmall\", \"Eacutesmall\", \"Ecircumflexsmall\", \"Edieresissmall\", \"Igravesmall\", \"Iacutesmall\", \"Icircumflexsmall\", \"Idieresissmall\", \"Ethsmall\", \"Ntildesmall\", \"Ogravesmall\", \"Oacutesmall\", \"Ocircumflexsmall\", \"Otildesmall\", \"Odieresissmall\", \"OEsmall\", \"Oslashsmall\", \"Ugravesmall\", \"Uacutesmall\", \"Ucircumflexsmall\", \"Udieresissmall\", \"Yacutesmall\", \"Thornsmall\", \"Ydieresissmall\", \"001.000\", \"001.001\", \"001.002\", \"001.003\", \"Black\", \"Bold\", \"Book\", \"Light\", \"Medium\", \"Regular\", \"Roman\", \"Semibold\"];\nvar StandardEncoding = ['', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', 'space', 'exclam', 'quotedbl', 'numbersign', 'dollar', 'percent', 'ampersand', 'quoteright', 'parenleft', 'parenright', 'asterisk', 'plus', 'comma', 'hyphen', 'period', 'slash', 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'colon', 'semicolon', 'less', 'equal', 'greater', 'question', 'at', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'bracketleft', 'backslash', 'bracketright', 'asciicircum', 'underscore', 'quoteleft', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'braceleft', 'bar', 'braceright', 'asciitilde', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', 'exclamdown', 'cent', 'sterling', 'fraction', 'yen', 'florin', 'section', 'currency', 'quotesingle', 'quotedblleft', 'guillemotleft', 'guilsinglleft', 'guilsinglright', 'fi', 'fl', '', 'endash', 'dagger', 'daggerdbl', 'periodcentered', '', 'paragraph', 'bullet', 'quotesinglbase', 'quotedblbase', 'quotedblright', 'guillemotright', 'ellipsis', 'perthousand', '', 'questiondown', '', 'grave', 'acute', 'circumflex', 'tilde', 'macron', 'breve', 'dotaccent', 'dieresis', '', 'ring', 'cedilla', '', 'hungarumlaut', 'ogonek', 'caron', 'emdash', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', 'AE', '', 'ordfeminine', '', '', '', '', 'Lslash', 'Oslash', 'OE', 'ordmasculine', '', '', '', '', '', 'ae', '', '', '', 'dotlessi', '', '', 'lslash', 'oslash', 'oe', 'germandbls'];\nvar ExpertEncoding = ['', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', 'space', 'exclamsmall', 'Hungarumlautsmall', '', 'dollaroldstyle', 'dollarsuperior', 'ampersandsmall', 'Acutesmall', 'parenleftsuperior', 'parenrightsuperior', 'twodotenleader', 'onedotenleader', 'comma', 'hyphen', 'period', 'fraction', 'zerooldstyle', 'oneoldstyle', 'twooldstyle', 'threeoldstyle', 'fouroldstyle', 'fiveoldstyle', 'sixoldstyle', 'sevenoldstyle', 'eightoldstyle', 'nineoldstyle', 'colon', 'semicolon', 'commasuperior', 'threequartersemdash', 'periodsuperior', 'questionsmall', '', 'asuperior', 'bsuperior', 'centsuperior', 'dsuperior', 'esuperior', '', '', 'isuperior', '', '', 'lsuperior', 'msuperior', 'nsuperior', 'osuperior', '', '', 'rsuperior', 'ssuperior', 'tsuperior', '', 'ff', 'fi', 'fl', 'ffi', 'ffl', 'parenleftinferior', '', 'parenrightinferior', 'Circumflexsmall', 'hyphensuperior', 'Gravesmall', 'Asmall', 'Bsmall', 'Csmall', 'Dsmall', 'Esmall', 'Fsmall', 'Gsmall', 'Hsmall', 'Ismall', 'Jsmall', 'Ksmall', 'Lsmall', 'Msmall', 'Nsmall', 'Osmall', 'Psmall', 'Qsmall', 'Rsmall', 'Ssmall', 'Tsmall', 'Usmall', 'Vsmall', 'Wsmall', 'Xsmall', 'Ysmall', 'Zsmall', 'colonmonetary', 'onefitted', 'rupiah', 'Tildesmall', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', 'exclamdownsmall', 'centoldstyle', 'Lslashsmall', '', '', 'Scaronsmall', 'Zcaronsmall', 'Dieresissmall', 'Brevesmall', 'Caronsmall', '', 'Dotaccentsmall', '', '', 'Macronsmall', '', '', 'figuredash', 'hypheninferior', '', '', 'Ogoneksmall', 'Ringsmall', 'Cedillasmall', '', '', '', 'onequarter', 'onehalf', 'threequarters', 'questiondownsmall', 'oneeighth', 'threeeighths', 'fiveeighths', 'seveneighths', 'onethird', 'twothirds', '', '', 'zerosuperior', 'onesuperior', 'twosuperior', 'threesuperior', 'foursuperior', 'fivesuperior', 'sixsuperior', 'sevensuperior', 'eightsuperior', 'ninesuperior', 'zeroinferior', 'oneinferior', 'twoinferior', 'threeinferior', 'fourinferior', 'fiveinferior', 'sixinferior', 'seveninferior', 'eightinferior', 'nineinferior', 'centinferior', 'dollarinferior', 'periodinferior', 'commainferior', 'Agravesmall', 'Aacutesmall', 'Acircumflexsmall', 'Atildesmall', 'Adieresissmall', 'Aringsmall', 'AEsmall', 'Ccedillasmall', 'Egravesmall', 'Eacutesmall', 'Ecircumflexsmall', 'Edieresissmall', 'Igravesmall', 'Iacutesmall', 'Icircumflexsmall', 'Idieresissmall', 'Ethsmall', 'Ntildesmall', 'Ogravesmall', 'Oacutesmall', 'Ocircumflexsmall', 'Otildesmall', 'Odieresissmall', 'OEsmall', 'Oslashsmall', 'Ugravesmall', 'Uacutesmall', 'Ucircumflexsmall', 'Udieresissmall', 'Yacutesmall', 'Thornsmall', 'Ydieresissmall'];\nvar ISOAdobeCharset = ['.notdef', 'space', 'exclam', 'quotedbl', 'numbersign', 'dollar', 'percent', 'ampersand', 'quoteright', 'parenleft', 'parenright', 'asterisk', 'plus', 'comma', 'hyphen', 'period', 'slash', 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'colon', 'semicolon', 'less', 'equal', 'greater', 'question', 'at', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'bracketleft', 'backslash', 'bracketright', 'asciicircum', 'underscore', 'quoteleft', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'braceleft', 'bar', 'braceright', 'asciitilde', 'exclamdown', 'cent', 'sterling', 'fraction', 'yen', 'florin', 'section', 'currency', 'quotesingle', 'quotedblleft', 'guillemotleft', 'guilsinglleft', 'guilsinglright', 'fi', 'fl', 'endash', 'dagger', 'daggerdbl', 'periodcentered', 'paragraph', 'bullet', 'quotesinglbase', 'quotedblbase', 'quotedblright', 'guillemotright', 'ellipsis', 'perthousand', 'questiondown', 'grave', 'acute', 'circumflex', 'tilde', 'macron', 'breve', 'dotaccent', 'dieresis', 'ring', 'cedilla', 'hungarumlaut', 'ogonek', 'caron', 'emdash', 'AE', 'ordfeminine', 'Lslash', 'Oslash', 'OE', 'ordmasculine', 'ae', 'dotlessi', 'lslash', 'oslash', 'oe', 'germandbls', 'onesuperior', 'logicalnot', 'mu', 'trademark', 'Eth', 'onehalf', 'plusminus', 'Thorn', 'onequarter', 'divide', 'brokenbar', 'degree', 'thorn', 'threequarters', 'twosuperior', 'registered', 'minus', 'eth', 'multiply', 'threesuperior', 'copyright', 'Aacute', 'Acircumflex', 'Adieresis', 'Agrave', 'Aring', 'Atilde', 'Ccedilla', 'Eacute', 'Ecircumflex', 'Edieresis', 'Egrave', 'Iacute', 'Icircumflex', 'Idieresis', 'Igrave', 'Ntilde', 'Oacute', 'Ocircumflex', 'Odieresis', 'Ograve', 'Otilde', 'Scaron', 'Uacute', 'Ucircumflex', 'Udieresis', 'Ugrave', 'Yacute', 'Ydieresis', 'Zcaron', 'aacute', 'acircumflex', 'adieresis', 'agrave', 'aring', 'atilde', 'ccedilla', 'eacute', 'ecircumflex', 'edieresis', 'egrave', 'iacute', 'icircumflex', 'idieresis', 'igrave', 'ntilde', 'oacute', 'ocircumflex', 'odieresis', 'ograve', 'otilde', 'scaron', 'uacute', 'ucircumflex', 'udieresis', 'ugrave', 'yacute', 'ydieresis', 'zcaron'];\nvar ExpertCharset = ['.notdef', 'space', 'exclamsmall', 'Hungarumlautsmall', 'dollaroldstyle', 'dollarsuperior', 'ampersandsmall', 'Acutesmall', 'parenleftsuperior', 'parenrightsuperior', 'twodotenleader', 'onedotenleader', 'comma', 'hyphen', 'period', 'fraction', 'zerooldstyle', 'oneoldstyle', 'twooldstyle', 'threeoldstyle', 'fouroldstyle', 'fiveoldstyle', 'sixoldstyle', 'sevenoldstyle', 'eightoldstyle', 'nineoldstyle', 'colon', 'semicolon', 'commasuperior', 'threequartersemdash', 'periodsuperior', 'questionsmall', 'asuperior', 'bsuperior', 'centsuperior', 'dsuperior', 'esuperior', 'isuperior', 'lsuperior', 'msuperior', 'nsuperior', 'osuperior', 'rsuperior', 'ssuperior', 'tsuperior', 'ff', 'fi', 'fl', 'ffi', 'ffl', 'parenleftinferior', 'parenrightinferior', 'Circumflexsmall', 'hyphensuperior', 'Gravesmall', 'Asmall', 'Bsmall', 'Csmall', 'Dsmall', 'Esmall', 'Fsmall', 'Gsmall', 'Hsmall', 'Ismall', 'Jsmall', 'Ksmall', 'Lsmall', 'Msmall', 'Nsmall', 'Osmall', 'Psmall', 'Qsmall', 'Rsmall', 'Ssmall', 'Tsmall', 'Usmall', 'Vsmall', 'Wsmall', 'Xsmall', 'Ysmall', 'Zsmall', 'colonmonetary', 'onefitted', 'rupiah', 'Tildesmall', 'exclamdownsmall', 'centoldstyle', 'Lslashsmall', 'Scaronsmall', 'Zcaronsmall', 'Dieresissmall', 'Brevesmall', 'Caronsmall', 'Dotaccentsmall', 'Macronsmall', 'figuredash', 'hypheninferior', 'Ogoneksmall', 'Ringsmall', 'Cedillasmall', 'onequarter', 'onehalf', 'threequarters', 'questiondownsmall', 'oneeighth', 'threeeighths', 'fiveeighths', 'seveneighths', 'onethird', 'twothirds', 'zerosuperior', 'onesuperior', 'twosuperior', 'threesuperior', 'foursuperior', 'fivesuperior', 'sixsuperior', 'sevensuperior', 'eightsuperior', 'ninesuperior', 'zeroinferior', 'oneinferior', 'twoinferior', 'threeinferior', 'fourinferior', 'fiveinferior', 'sixinferior', 'seveninferior', 'eightinferior', 'nineinferior', 'centinferior', 'dollarinferior', 'periodinferior', 'commainferior', 'Agravesmall', 'Aacutesmall', 'Acircumflexsmall', 'Atildesmall', 'Adieresissmall', 'Aringsmall', 'AEsmall', 'Ccedillasmall', 'Egravesmall', 'Eacutesmall', 'Ecircumflexsmall', 'Edieresissmall', 'Igravesmall', 'Iacutesmall', 'Icircumflexsmall', 'Idieresissmall', 'Ethsmall', 'Ntildesmall', 'Ogravesmall', 'Oacutesmall', 'Ocircumflexsmall', 'Otildesmall', 'Odieresissmall', 'OEsmall', 'Oslashsmall', 'Ugravesmall', 'Uacutesmall', 'Ucircumflexsmall', 'Udieresissmall', 'Yacutesmall', 'Thornsmall', 'Ydieresissmall'];\nvar ExpertSubsetCharset = ['.notdef', 'space', 'dollaroldstyle', 'dollarsuperior', 'parenleftsuperior', 'parenrightsuperior', 'twodotenleader', 'onedotenleader', 'comma', 'hyphen', 'period', 'fraction', 'zerooldstyle', 'oneoldstyle', 'twooldstyle', 'threeoldstyle', 'fouroldstyle', 'fiveoldstyle', 'sixoldstyle', 'sevenoldstyle', 'eightoldstyle', 'nineoldstyle', 'colon', 'semicolon', 'commasuperior', 'threequartersemdash', 'periodsuperior', 'asuperior', 'bsuperior', 'centsuperior', 'dsuperior', 'esuperior', 'isuperior', 'lsuperior', 'msuperior', 'nsuperior', 'osuperior', 'rsuperior', 'ssuperior', 'tsuperior', 'ff', 'fi', 'fl', 'ffi', 'ffl', 'parenleftinferior', 'parenrightinferior', 'hyphensuperior', 'colonmonetary', 'onefitted', 'rupiah', 'centoldstyle', 'figuredash', 'hypheninferior', 'onequarter', 'onehalf', 'threequarters', 'oneeighth', 'threeeighths', 'fiveeighths', 'seveneighths', 'onethird', 'twothirds', 'zerosuperior', 'onesuperior', 'twosuperior', 'threesuperior', 'foursuperior', 'fivesuperior', 'sixsuperior', 'sevensuperior', 'eightsuperior', 'ninesuperior', 'zeroinferior', 'oneinferior', 'twoinferior', 'threeinferior', 'fourinferior', 'fiveinferior', 'sixinferior', 'seveninferior', 'eightinferior', 'nineinferior', 'centinferior', 'dollarinferior', 'periodinferior', 'commainferior']; //########################\n// Scripts and Languages #\n//########################\n\nvar LangSysTable = new r.Struct({\n  reserved: new r.Reserved(r.uint16),\n  reqFeatureIndex: r.uint16,\n  featureCount: r.uint16,\n  featureIndexes: new r.Array(r.uint16, 'featureCount')\n});\nvar LangSysRecord = new r.Struct({\n  tag: new r.String(4),\n  langSys: new r.Pointer(r.uint16, LangSysTable, {\n    type: 'parent'\n  })\n});\nvar Script = new r.Struct({\n  defaultLangSys: new r.Pointer(r.uint16, LangSysTable),\n  count: r.uint16,\n  langSysRecords: new r.Array(LangSysRecord, 'count')\n});\nvar ScriptRecord = new r.Struct({\n  tag: new r.String(4),\n  script: new r.Pointer(r.uint16, Script, {\n    type: 'parent'\n  })\n});\nvar ScriptList = new r.Array(ScriptRecord, r.uint16); //#######################\n// Features and Lookups #\n//#######################\n\nvar Feature = new r.Struct({\n  featureParams: r.uint16,\n  // pointer\n  lookupCount: r.uint16,\n  lookupListIndexes: new r.Array(r.uint16, 'lookupCount')\n});\nvar FeatureRecord = new r.Struct({\n  tag: new r.String(4),\n  feature: new r.Pointer(r.uint16, Feature, {\n    type: 'parent'\n  })\n});\nvar FeatureList = new r.Array(FeatureRecord, r.uint16);\nvar LookupFlags = new r.Struct({\n  markAttachmentType: r.uint8,\n  flags: new r.Bitfield(r.uint8, ['rightToLeft', 'ignoreBaseGlyphs', 'ignoreLigatures', 'ignoreMarks', 'useMarkFilteringSet'])\n});\n\nfunction LookupList(SubTable) {\n  var Lookup = new r.Struct({\n    lookupType: r.uint16,\n    flags: LookupFlags,\n    subTableCount: r.uint16,\n    subTables: new r.Array(new r.Pointer(r.uint16, SubTable), 'subTableCount'),\n    markFilteringSet: new r.Optional(r.uint16, function (t) {\n      return t.flags.flags.useMarkFilteringSet;\n    })\n  });\n  return new r.LazyArray(new r.Pointer(r.uint16, Lookup), r.uint16);\n} //#################\n// Coverage Table #\n//#################\n\n\nvar RangeRecord = new r.Struct({\n  start: r.uint16,\n  end: r.uint16,\n  startCoverageIndex: r.uint16\n});\nvar Coverage = new r.VersionedStruct(r.uint16, {\n  1: {\n    glyphCount: r.uint16,\n    glyphs: new r.Array(r.uint16, 'glyphCount')\n  },\n  2: {\n    rangeCount: r.uint16,\n    rangeRecords: new r.Array(RangeRecord, 'rangeCount')\n  }\n}); //#########################\n// Class Definition Table #\n//#########################\n\nvar ClassRangeRecord = new r.Struct({\n  start: r.uint16,\n  end: r.uint16,\n  class: r.uint16\n});\nvar ClassDef = new r.VersionedStruct(r.uint16, {\n  1: {\n    // Class array\n    startGlyph: r.uint16,\n    glyphCount: r.uint16,\n    classValueArray: new r.Array(r.uint16, 'glyphCount')\n  },\n  2: {\n    // Class ranges\n    classRangeCount: r.uint16,\n    classRangeRecord: new r.Array(ClassRangeRecord, 'classRangeCount')\n  }\n}); //###############\n// Device Table #\n//###############\n\nvar Device = new r.Struct({\n  a: r.uint16,\n  // startSize for hinting Device, outerIndex for VariationIndex\n  b: r.uint16,\n  // endSize for Device, innerIndex for VariationIndex\n  deltaFormat: r.uint16\n}); //#############################################\n// Contextual Substitution/Positioning Tables #\n//#############################################\n\nvar LookupRecord = new r.Struct({\n  sequenceIndex: r.uint16,\n  lookupListIndex: r.uint16\n});\nvar Rule = new r.Struct({\n  glyphCount: r.uint16,\n  lookupCount: r.uint16,\n  input: new r.Array(r.uint16, function (t) {\n    return t.glyphCount - 1;\n  }),\n  lookupRecords: new r.Array(LookupRecord, 'lookupCount')\n});\nvar RuleSet = new r.Array(new r.Pointer(r.uint16, Rule), r.uint16);\nvar ClassRule = new r.Struct({\n  glyphCount: r.uint16,\n  lookupCount: r.uint16,\n  classes: new r.Array(r.uint16, function (t) {\n    return t.glyphCount - 1;\n  }),\n  lookupRecords: new r.Array(LookupRecord, 'lookupCount')\n});\nvar ClassSet = new r.Array(new r.Pointer(r.uint16, ClassRule), r.uint16);\nvar Context = new r.VersionedStruct(r.uint16, {\n  1: {\n    // Simple context\n    coverage: new r.Pointer(r.uint16, Coverage),\n    ruleSetCount: r.uint16,\n    ruleSets: new r.Array(new r.Pointer(r.uint16, RuleSet), 'ruleSetCount')\n  },\n  2: {\n    // Class-based context\n    coverage: new r.Pointer(r.uint16, Coverage),\n    classDef: new r.Pointer(r.uint16, ClassDef),\n    classSetCnt: r.uint16,\n    classSet: new r.Array(new r.Pointer(r.uint16, ClassSet), 'classSetCnt')\n  },\n  3: {\n    glyphCount: r.uint16,\n    lookupCount: r.uint16,\n    coverages: new r.Array(new r.Pointer(r.uint16, Coverage), 'glyphCount'),\n    lookupRecords: new r.Array(LookupRecord, 'lookupCount')\n  }\n}); //######################################################\n// Chaining Contextual Substitution/Positioning Tables #\n//######################################################\n\nvar ChainRule = new r.Struct({\n  backtrackGlyphCount: r.uint16,\n  backtrack: new r.Array(r.uint16, 'backtrackGlyphCount'),\n  inputGlyphCount: r.uint16,\n  input: new r.Array(r.uint16, function (t) {\n    return t.inputGlyphCount - 1;\n  }),\n  lookaheadGlyphCount: r.uint16,\n  lookahead: new r.Array(r.uint16, 'lookaheadGlyphCount'),\n  lookupCount: r.uint16,\n  lookupRecords: new r.Array(LookupRecord, 'lookupCount')\n});\nvar ChainRuleSet = new r.Array(new r.Pointer(r.uint16, ChainRule), r.uint16);\nvar ChainingContext = new r.VersionedStruct(r.uint16, {\n  1: {\n    // Simple context glyph substitution\n    coverage: new r.Pointer(r.uint16, Coverage),\n    chainCount: r.uint16,\n    chainRuleSets: new r.Array(new r.Pointer(r.uint16, ChainRuleSet), 'chainCount')\n  },\n  2: {\n    // Class-based chaining context\n    coverage: new r.Pointer(r.uint16, Coverage),\n    backtrackClassDef: new r.Pointer(r.uint16, ClassDef),\n    inputClassDef: new r.Pointer(r.uint16, ClassDef),\n    lookaheadClassDef: new r.Pointer(r.uint16, ClassDef),\n    chainCount: r.uint16,\n    chainClassSet: new r.Array(new r.Pointer(r.uint16, ChainRuleSet), 'chainCount')\n  },\n  3: {\n    // Coverage-based chaining context\n    backtrackGlyphCount: r.uint16,\n    backtrackCoverage: new r.Array(new r.Pointer(r.uint16, Coverage), 'backtrackGlyphCount'),\n    inputGlyphCount: r.uint16,\n    inputCoverage: new r.Array(new r.Pointer(r.uint16, Coverage), 'inputGlyphCount'),\n    lookaheadGlyphCount: r.uint16,\n    lookaheadCoverage: new r.Array(new r.Pointer(r.uint16, Coverage), 'lookaheadGlyphCount'),\n    lookupCount: r.uint16,\n    lookupRecords: new r.Array(LookupRecord, 'lookupCount')\n  }\n});\n\nvar _;\n/*******************\n * Variation Store *\n *******************/\n\n\nvar F2DOT14 = new r.Fixed(16, 'BE', 14);\nvar RegionAxisCoordinates = new r.Struct({\n  startCoord: F2DOT14,\n  peakCoord: F2DOT14,\n  endCoord: F2DOT14\n});\nvar VariationRegionList = new r.Struct({\n  axisCount: r.uint16,\n  regionCount: r.uint16,\n  variationRegions: new r.Array(new r.Array(RegionAxisCoordinates, 'axisCount'), 'regionCount')\n});\nvar DeltaSet = new r.Struct({\n  shortDeltas: new r.Array(r.int16, function (t) {\n    return t.parent.shortDeltaCount;\n  }),\n  regionDeltas: new r.Array(r.int8, function (t) {\n    return t.parent.regionIndexCount - t.parent.shortDeltaCount;\n  }),\n  deltas: function deltas(t) {\n    return t.shortDeltas.concat(t.regionDeltas);\n  }\n});\nvar ItemVariationData = new r.Struct({\n  itemCount: r.uint16,\n  shortDeltaCount: r.uint16,\n  regionIndexCount: r.uint16,\n  regionIndexes: new r.Array(r.uint16, 'regionIndexCount'),\n  deltaSets: new r.Array(DeltaSet, 'itemCount')\n});\nvar ItemVariationStore = new r.Struct({\n  format: r.uint16,\n  variationRegionList: new r.Pointer(r.uint32, VariationRegionList),\n  variationDataCount: r.uint16,\n  itemVariationData: new r.Array(new r.Pointer(r.uint32, ItemVariationData), 'variationDataCount')\n});\n/**********************\n * Feature Variations *\n **********************/\n\nvar ConditionTable = new r.VersionedStruct(r.uint16, {\n  1: (_ = {\n    axisIndex: r.uint16\n  }, _['axisIndex'] = r.uint16, _.filterRangeMinValue = F2DOT14, _.filterRangeMaxValue = F2DOT14, _)\n});\nvar ConditionSet = new r.Struct({\n  conditionCount: r.uint16,\n  conditionTable: new r.Array(new r.Pointer(r.uint32, ConditionTable), 'conditionCount')\n});\nvar FeatureTableSubstitutionRecord = new r.Struct({\n  featureIndex: r.uint16,\n  alternateFeatureTable: new r.Pointer(r.uint32, Feature, {\n    type: 'parent'\n  })\n});\nvar FeatureTableSubstitution = new r.Struct({\n  version: r.fixed32,\n  substitutionCount: r.uint16,\n  substitutions: new r.Array(FeatureTableSubstitutionRecord, 'substitutionCount')\n});\nvar FeatureVariationRecord = new r.Struct({\n  conditionSet: new r.Pointer(r.uint32, ConditionSet, {\n    type: 'parent'\n  }),\n  featureTableSubstitution: new r.Pointer(r.uint32, FeatureTableSubstitution, {\n    type: 'parent'\n  })\n});\nvar FeatureVariations = new r.Struct({\n  majorVersion: r.uint16,\n  minorVersion: r.uint16,\n  featureVariationRecordCount: r.uint32,\n  featureVariationRecords: new r.Array(FeatureVariationRecord, 'featureVariationRecordCount')\n}); // Checks if an operand is an index of a predefined value,\n// otherwise delegates to the provided type.\n\nvar PredefinedOp = function () {\n  function PredefinedOp(predefinedOps, type) {\n    _classCallCheck(this, PredefinedOp);\n\n    this.predefinedOps = predefinedOps;\n    this.type = type;\n  }\n\n  PredefinedOp.prototype.decode = function decode(stream, parent, operands) {\n    if (this.predefinedOps[operands[0]]) {\n      return this.predefinedOps[operands[0]];\n    }\n\n    return this.type.decode(stream, parent, operands);\n  };\n\n  PredefinedOp.prototype.size = function size(value, ctx) {\n    return this.type.size(value, ctx);\n  };\n\n  PredefinedOp.prototype.encode = function encode(stream, value, ctx) {\n    var index = this.predefinedOps.indexOf(value);\n\n    if (index !== -1) {\n      return index;\n    }\n\n    return this.type.encode(stream, value, ctx);\n  };\n\n  return PredefinedOp;\n}();\n\nvar CFFEncodingVersion = function (_r$Number) {\n  _inherits(CFFEncodingVersion, _r$Number);\n\n  function CFFEncodingVersion() {\n    _classCallCheck(this, CFFEncodingVersion);\n\n    return _possibleConstructorReturn(this, _r$Number.call(this, 'UInt8'));\n  }\n\n  CFFEncodingVersion.prototype.decode = function decode(stream) {\n    return r.uint8.decode(stream) & 0x7f;\n  };\n\n  return CFFEncodingVersion;\n}(r.Number);\n\nvar Range1 = new r.Struct({\n  first: r.uint16,\n  nLeft: r.uint8\n});\nvar Range2 = new r.Struct({\n  first: r.uint16,\n  nLeft: r.uint16\n});\nvar CFFCustomEncoding = new r.VersionedStruct(new CFFEncodingVersion(), {\n  0: {\n    nCodes: r.uint8,\n    codes: new r.Array(r.uint8, 'nCodes')\n  },\n  1: {\n    nRanges: r.uint8,\n    ranges: new r.Array(Range1, 'nRanges') // TODO: supplement?\n\n  }\n});\nvar CFFEncoding = new PredefinedOp([StandardEncoding, ExpertEncoding], new CFFPointer(CFFCustomEncoding, {\n  lazy: true\n})); // Decodes an array of ranges until the total\n// length is equal to the provided length.\n\nvar RangeArray = function (_r$Array) {\n  _inherits(RangeArray, _r$Array);\n\n  function RangeArray() {\n    _classCallCheck(this, RangeArray);\n\n    return _possibleConstructorReturn(this, _r$Array.apply(this, arguments));\n  }\n\n  RangeArray.prototype.decode = function decode(stream, parent) {\n    var length = restructure_src_utils.resolveLength(this.length, stream, parent);\n    var count = 0;\n    var res = [];\n\n    while (count < length) {\n      var range = this.type.decode(stream, parent);\n      range.offset = count;\n      count += range.nLeft + 1;\n      res.push(range);\n    }\n\n    return res;\n  };\n\n  return RangeArray;\n}(r.Array);\n\nvar CFFCustomCharset = new r.VersionedStruct(r.uint8, {\n  0: {\n    glyphs: new r.Array(r.uint16, function (t) {\n      return t.parent.CharStrings.length - 1;\n    })\n  },\n  1: {\n    ranges: new RangeArray(Range1, function (t) {\n      return t.parent.CharStrings.length - 1;\n    })\n  },\n  2: {\n    ranges: new RangeArray(Range2, function (t) {\n      return t.parent.CharStrings.length - 1;\n    })\n  }\n});\nvar CFFCharset = new PredefinedOp([ISOAdobeCharset, ExpertCharset, ExpertSubsetCharset], new CFFPointer(CFFCustomCharset, {\n  lazy: true\n}));\nvar FDRange3 = new r.Struct({\n  first: r.uint16,\n  fd: r.uint8\n});\nvar FDRange4 = new r.Struct({\n  first: r.uint32,\n  fd: r.uint16\n});\nvar FDSelect = new r.VersionedStruct(r.uint8, {\n  0: {\n    fds: new r.Array(r.uint8, function (t) {\n      return t.parent.CharStrings.length;\n    })\n  },\n  3: {\n    nRanges: r.uint16,\n    ranges: new r.Array(FDRange3, 'nRanges'),\n    sentinel: r.uint16\n  },\n  4: {\n    nRanges: r.uint32,\n    ranges: new r.Array(FDRange4, 'nRanges'),\n    sentinel: r.uint32\n  }\n});\nvar ptr = new CFFPointer(CFFPrivateDict);\n\nvar CFFPrivateOp = function () {\n  function CFFPrivateOp() {\n    _classCallCheck(this, CFFPrivateOp);\n  }\n\n  CFFPrivateOp.prototype.decode = function decode(stream, parent, operands) {\n    parent.length = operands[0];\n    return ptr.decode(stream, parent, [operands[1]]);\n  };\n\n  CFFPrivateOp.prototype.size = function size(dict, ctx) {\n    return [CFFPrivateDict.size(dict, ctx, false), ptr.size(dict, ctx)[0]];\n  };\n\n  CFFPrivateOp.prototype.encode = function encode(stream, dict, ctx) {\n    return [CFFPrivateDict.size(dict, ctx, false), ptr.encode(stream, dict, ctx)[0]];\n  };\n\n  return CFFPrivateOp;\n}();\n\nvar FontDict = new CFFDict([// key       name                   type(s)                                 default\n[18, 'Private', new CFFPrivateOp(), null], [[12, 38], 'FontName', 'sid', null], [[12, 7], 'FontMatrix', 'array', [0.001, 0, 0, 0.001, 0, 0]], [[12, 5], 'PaintType', 'number', 0]]);\nvar CFFTopDict = new CFFDict([// key       name                   type(s)                                 default\n[[12, 30], 'ROS', ['sid', 'sid', 'number'], null], [0, 'version', 'sid', null], [1, 'Notice', 'sid', null], [[12, 0], 'Copyright', 'sid', null], [2, 'FullName', 'sid', null], [3, 'FamilyName', 'sid', null], [4, 'Weight', 'sid', null], [[12, 1], 'isFixedPitch', 'boolean', false], [[12, 2], 'ItalicAngle', 'number', 0], [[12, 3], 'UnderlinePosition', 'number', -100], [[12, 4], 'UnderlineThickness', 'number', 50], [[12, 5], 'PaintType', 'number', 0], [[12, 6], 'CharstringType', 'number', 2], [[12, 7], 'FontMatrix', 'array', [0.001, 0, 0, 0.001, 0, 0]], [13, 'UniqueID', 'number', null], [5, 'FontBBox', 'array', [0, 0, 0, 0]], [[12, 8], 'StrokeWidth', 'number', 0], [14, 'XUID', 'array', null], [15, 'charset', CFFCharset, ISOAdobeCharset], [16, 'Encoding', CFFEncoding, StandardEncoding], [17, 'CharStrings', new CFFPointer(new CFFIndex()), null], [18, 'Private', new CFFPrivateOp(), null], [[12, 20], 'SyntheticBase', 'number', null], [[12, 21], 'PostScript', 'sid', null], [[12, 22], 'BaseFontName', 'sid', null], [[12, 23], 'BaseFontBlend', 'delta', null], // CID font specific\n[[12, 31], 'CIDFontVersion', 'number', 0], [[12, 32], 'CIDFontRevision', 'number', 0], [[12, 33], 'CIDFontType', 'number', 0], [[12, 34], 'CIDCount', 'number', 8720], [[12, 35], 'UIDBase', 'number', null], [[12, 37], 'FDSelect', new CFFPointer(FDSelect), null], [[12, 36], 'FDArray', new CFFPointer(new CFFIndex(FontDict)), null], [[12, 38], 'FontName', 'sid', null]]);\nvar VariationStore = new r.Struct({\n  length: r.uint16,\n  itemVariationStore: ItemVariationStore\n});\nvar CFF2TopDict = new CFFDict([[[12, 7], 'FontMatrix', 'array', [0.001, 0, 0, 0.001, 0, 0]], [17, 'CharStrings', new CFFPointer(new CFFIndex()), null], [[12, 37], 'FDSelect', new CFFPointer(FDSelect), null], [[12, 36], 'FDArray', new CFFPointer(new CFFIndex(FontDict)), null], [24, 'vstore', new CFFPointer(VariationStore), null], [25, 'maxstack', 'number', 193]]);\nvar CFFTop = new r.VersionedStruct(r.fixed16, {\n  1: {\n    hdrSize: r.uint8,\n    offSize: r.uint8,\n    nameIndex: new CFFIndex(new r.String('length')),\n    topDictIndex: new CFFIndex(CFFTopDict),\n    stringIndex: new CFFIndex(new r.String('length')),\n    globalSubrIndex: new CFFIndex()\n  },\n  2: {\n    hdrSize: r.uint8,\n    length: r.uint16,\n    topDict: CFF2TopDict,\n    globalSubrIndex: new CFFIndex()\n  }\n});\n\nvar CFFFont = function () {\n  function CFFFont(stream) {\n    _classCallCheck(this, CFFFont);\n\n    this.stream = stream;\n    this.decode();\n  }\n\n  CFFFont.decode = function decode(stream) {\n    return new CFFFont(stream);\n  };\n\n  CFFFont.prototype.decode = function decode() {\n    var start = this.stream.pos;\n    var top = CFFTop.decode(this.stream);\n\n    for (var key in top) {\n      var val = top[key];\n      this[key] = val;\n    }\n\n    if (this.version < 2) {\n      if (this.topDictIndex.length !== 1) {\n        throw new Error(\"Only a single font is allowed in CFF\");\n      }\n\n      this.topDict = this.topDictIndex[0];\n    }\n\n    this.isCIDFont = this.topDict.ROS != null;\n    return this;\n  };\n\n  CFFFont.prototype.string = function string(sid) {\n    if (this.version >= 2) {\n      return null;\n    }\n\n    if (sid < standardStrings.length) {\n      return standardStrings[sid];\n    }\n\n    return this.stringIndex[sid - standardStrings.length];\n  };\n\n  CFFFont.prototype.getCharString = function getCharString(glyph) {\n    this.stream.pos = this.topDict.CharStrings[glyph].offset;\n    return this.stream.readBuffer(this.topDict.CharStrings[glyph].length);\n  };\n\n  CFFFont.prototype.getGlyphName = function getGlyphName(gid) {\n    // CFF2 glyph names are in the post table.\n    if (this.version >= 2) {\n      return null;\n    } // CID-keyed fonts don't have glyph names\n\n\n    if (this.isCIDFont) {\n      return null;\n    }\n\n    var charset = this.topDict.charset;\n\n    if (Array.isArray(charset)) {\n      return charset[gid];\n    }\n\n    if (gid === 0) {\n      return '.notdef';\n    }\n\n    gid -= 1;\n\n    switch (charset.version) {\n      case 0:\n        return this.string(charset.glyphs[gid]);\n\n      case 1:\n      case 2:\n        for (var i = 0; i < charset.ranges.length; i++) {\n          var range = charset.ranges[i];\n\n          if (range.offset <= gid && gid <= range.offset + range.nLeft) {\n            return this.string(range.first + (gid - range.offset));\n          }\n        }\n\n        break;\n    }\n\n    return null;\n  };\n\n  CFFFont.prototype.fdForGlyph = function fdForGlyph(gid) {\n    if (!this.topDict.FDSelect) {\n      return null;\n    }\n\n    switch (this.topDict.FDSelect.version) {\n      case 0:\n        return this.topDict.FDSelect.fds[gid];\n\n      case 3:\n      case 4:\n        var ranges = this.topDict.FDSelect.ranges;\n        var low = 0;\n        var high = ranges.length - 1;\n\n        while (low <= high) {\n          var mid = low + high >> 1;\n\n          if (gid < ranges[mid].first) {\n            high = mid - 1;\n          } else if (mid < high && gid >= ranges[mid + 1].first) {\n            low = mid + 1;\n          } else {\n            return ranges[mid].fd;\n          }\n        }\n\n      default:\n        throw new Error('Unknown FDSelect version: ' + this.topDict.FDSelect.version);\n    }\n  };\n\n  CFFFont.prototype.privateDictForGlyph = function privateDictForGlyph(gid) {\n    if (this.topDict.FDSelect) {\n      var fd = this.fdForGlyph(gid);\n\n      if (this.topDict.FDArray[fd]) {\n        return this.topDict.FDArray[fd].Private;\n      }\n\n      return null;\n    }\n\n    if (this.version < 2) {\n      return this.topDict.Private;\n    }\n\n    return this.topDict.FDArray[0].Private;\n  };\n\n  _createClass(CFFFont, [{\n    key: 'postscriptName',\n    get: function get() {\n      if (this.version < 2) {\n        return this.nameIndex[0];\n      }\n\n      return null;\n    }\n  }, {\n    key: 'fullName',\n    get: function get() {\n      return this.string(this.topDict.FullName);\n    }\n  }, {\n    key: 'familyName',\n    get: function get() {\n      return this.string(this.topDict.FamilyName);\n    }\n  }]);\n\n  return CFFFont;\n}();\n\nvar VerticalOrigin = new r.Struct({\n  glyphIndex: r.uint16,\n  vertOriginY: r.int16\n});\nvar VORG = new r.Struct({\n  majorVersion: r.uint16,\n  minorVersion: r.uint16,\n  defaultVertOriginY: r.int16,\n  numVertOriginYMetrics: r.uint16,\n  metrics: new r.Array(VerticalOrigin, 'numVertOriginYMetrics')\n});\nvar BigMetrics = new r.Struct({\n  height: r.uint8,\n  width: r.uint8,\n  horiBearingX: r.int8,\n  horiBearingY: r.int8,\n  horiAdvance: r.uint8,\n  vertBearingX: r.int8,\n  vertBearingY: r.int8,\n  vertAdvance: r.uint8\n});\nvar SmallMetrics = new r.Struct({\n  height: r.uint8,\n  width: r.uint8,\n  bearingX: r.int8,\n  bearingY: r.int8,\n  advance: r.uint8\n});\nvar EBDTComponent = new r.Struct({\n  glyph: r.uint16,\n  xOffset: r.int8,\n  yOffset: r.int8\n});\n\nvar ByteAligned = function ByteAligned() {\n  _classCallCheck(this, ByteAligned);\n};\n\nvar BitAligned = function BitAligned() {\n  _classCallCheck(this, BitAligned);\n};\n\nvar glyph = new r.VersionedStruct('version', {\n  1: {\n    metrics: SmallMetrics,\n    data: ByteAligned\n  },\n  2: {\n    metrics: SmallMetrics,\n    data: BitAligned\n  },\n  // format 3 is deprecated\n  // format 4 is not supported by Microsoft\n  5: {\n    data: BitAligned\n  },\n  6: {\n    metrics: BigMetrics,\n    data: ByteAligned\n  },\n  7: {\n    metrics: BigMetrics,\n    data: BitAligned\n  },\n  8: {\n    metrics: SmallMetrics,\n    pad: new r.Reserved(r.uint8),\n    numComponents: r.uint16,\n    components: new r.Array(EBDTComponent, 'numComponents')\n  },\n  9: {\n    metrics: BigMetrics,\n    pad: new r.Reserved(r.uint8),\n    numComponents: r.uint16,\n    components: new r.Array(EBDTComponent, 'numComponents')\n  },\n  17: {\n    metrics: SmallMetrics,\n    dataLen: r.uint32,\n    data: new r.Buffer('dataLen')\n  },\n  18: {\n    metrics: BigMetrics,\n    dataLen: r.uint32,\n    data: new r.Buffer('dataLen')\n  },\n  19: {\n    dataLen: r.uint32,\n    data: new r.Buffer('dataLen')\n  }\n});\nvar SBitLineMetrics = new r.Struct({\n  ascender: r.int8,\n  descender: r.int8,\n  widthMax: r.uint8,\n  caretSlopeNumerator: r.int8,\n  caretSlopeDenominator: r.int8,\n  caretOffset: r.int8,\n  minOriginSB: r.int8,\n  minAdvanceSB: r.int8,\n  maxBeforeBL: r.int8,\n  minAfterBL: r.int8,\n  pad: new r.Reserved(r.int8, 2)\n});\nvar CodeOffsetPair = new r.Struct({\n  glyphCode: r.uint16,\n  offset: r.uint16\n});\nvar IndexSubtable = new r.VersionedStruct(r.uint16, {\n  header: {\n    imageFormat: r.uint16,\n    imageDataOffset: r.uint32\n  },\n  1: {\n    offsetArray: new r.Array(r.uint32, function (t) {\n      return t.parent.lastGlyphIndex - t.parent.firstGlyphIndex + 1;\n    })\n  },\n  2: {\n    imageSize: r.uint32,\n    bigMetrics: BigMetrics\n  },\n  3: {\n    offsetArray: new r.Array(r.uint16, function (t) {\n      return t.parent.lastGlyphIndex - t.parent.firstGlyphIndex + 1;\n    })\n  },\n  4: {\n    numGlyphs: r.uint32,\n    glyphArray: new r.Array(CodeOffsetPair, function (t) {\n      return t.numGlyphs + 1;\n    })\n  },\n  5: {\n    imageSize: r.uint32,\n    bigMetrics: BigMetrics,\n    numGlyphs: r.uint32,\n    glyphCodeArray: new r.Array(r.uint16, 'numGlyphs')\n  }\n});\nvar IndexSubtableArray = new r.Struct({\n  firstGlyphIndex: r.uint16,\n  lastGlyphIndex: r.uint16,\n  subtable: new r.Pointer(r.uint32, IndexSubtable)\n});\nvar BitmapSizeTable = new r.Struct({\n  indexSubTableArray: new r.Pointer(r.uint32, new r.Array(IndexSubtableArray, 1), {\n    type: 'parent'\n  }),\n  indexTablesSize: r.uint32,\n  numberOfIndexSubTables: r.uint32,\n  colorRef: r.uint32,\n  hori: SBitLineMetrics,\n  vert: SBitLineMetrics,\n  startGlyphIndex: r.uint16,\n  endGlyphIndex: r.uint16,\n  ppemX: r.uint8,\n  ppemY: r.uint8,\n  bitDepth: r.uint8,\n  flags: new r.Bitfield(r.uint8, ['horizontal', 'vertical'])\n});\nvar EBLC = new r.Struct({\n  version: r.uint32,\n  // 0x00020000\n  numSizes: r.uint32,\n  sizes: new r.Array(BitmapSizeTable, 'numSizes')\n});\nvar ImageTable = new r.Struct({\n  ppem: r.uint16,\n  resolution: r.uint16,\n  imageOffsets: new r.Array(new r.Pointer(r.uint32, 'void'), function (t) {\n    return t.parent.parent.maxp.numGlyphs + 1;\n  })\n}); // This is the Apple sbix table, used by the \"Apple Color Emoji\" font.\n// It includes several image tables with images for each bitmap glyph\n// of several different sizes.\n\nvar sbix = new r.Struct({\n  version: r.uint16,\n  flags: new r.Bitfield(r.uint16, ['renderOutlines']),\n  numImgTables: r.uint32,\n  imageTables: new r.Array(new r.Pointer(r.uint32, ImageTable), 'numImgTables')\n});\nvar LayerRecord = new r.Struct({\n  gid: r.uint16,\n  // Glyph ID of layer glyph (must be in z-order from bottom to top).\n  paletteIndex: r.uint16 // Index value to use in the appropriate palette. This value must\n\n}); // be less than numPaletteEntries in the CPAL table, except for\n// the special case noted below. Each palette entry is 16 bits.\n// A palette index of 0xFFFF is a special case indicating that\n// the text foreground color should be used.\n\nvar BaseGlyphRecord = new r.Struct({\n  gid: r.uint16,\n  // Glyph ID of reference glyph. This glyph is for reference only\n  // and is not rendered for color.\n  firstLayerIndex: r.uint16,\n  // Index (from beginning of the Layer Records) to the layer record.\n  // There will be numLayers consecutive entries for this base glyph.\n  numLayers: r.uint16\n});\nvar COLR = new r.Struct({\n  version: r.uint16,\n  numBaseGlyphRecords: r.uint16,\n  baseGlyphRecord: new r.Pointer(r.uint32, new r.Array(BaseGlyphRecord, 'numBaseGlyphRecords')),\n  layerRecords: new r.Pointer(r.uint32, new r.Array(LayerRecord, 'numLayerRecords'), {\n    lazy: true\n  }),\n  numLayerRecords: r.uint16\n});\nvar ColorRecord = new r.Struct({\n  blue: r.uint8,\n  green: r.uint8,\n  red: r.uint8,\n  alpha: r.uint8\n});\nvar CPAL = new r.VersionedStruct(r.uint16, {\n  header: {\n    numPaletteEntries: r.uint16,\n    numPalettes: r.uint16,\n    numColorRecords: r.uint16,\n    colorRecords: new r.Pointer(r.uint32, new r.Array(ColorRecord, 'numColorRecords')),\n    colorRecordIndices: new r.Array(r.uint16, 'numPalettes')\n  },\n  0: {},\n  1: {\n    offsetPaletteTypeArray: new r.Pointer(r.uint32, new r.Array(r.uint32, 'numPalettes')),\n    offsetPaletteLabelArray: new r.Pointer(r.uint32, new r.Array(r.uint16, 'numPalettes')),\n    offsetPaletteEntryLabelArray: new r.Pointer(r.uint32, new r.Array(r.uint16, 'numPaletteEntries'))\n  }\n});\nvar BaseCoord = new r.VersionedStruct(r.uint16, {\n  1: {\n    // Design units only\n    coordinate: r.int16 // X or Y value, in design units\n\n  },\n  2: {\n    // Design units plus contour point\n    coordinate: r.int16,\n    // X or Y value, in design units\n    referenceGlyph: r.uint16,\n    // GlyphID of control glyph\n    baseCoordPoint: r.uint16 // Index of contour point on the referenceGlyph\n\n  },\n  3: {\n    // Design units plus Device table\n    coordinate: r.int16,\n    // X or Y value, in design units\n    deviceTable: new r.Pointer(r.uint16, Device) // Device table for X or Y value\n\n  }\n});\nvar BaseValues = new r.Struct({\n  defaultIndex: r.uint16,\n  // Index of default baseline for this script-same index in the BaseTagList\n  baseCoordCount: r.uint16,\n  baseCoords: new r.Array(new r.Pointer(r.uint16, BaseCoord), 'baseCoordCount')\n});\nvar FeatMinMaxRecord = new r.Struct({\n  tag: new r.String(4),\n  // 4-byte feature identification tag-must match FeatureTag in FeatureList\n  minCoord: new r.Pointer(r.uint16, BaseCoord, {\n    type: 'parent'\n  }),\n  // May be NULL\n  maxCoord: new r.Pointer(r.uint16, BaseCoord, {\n    type: 'parent'\n  }) // May be NULL\n\n});\nvar MinMax = new r.Struct({\n  minCoord: new r.Pointer(r.uint16, BaseCoord),\n  // May be NULL\n  maxCoord: new r.Pointer(r.uint16, BaseCoord),\n  // May be NULL\n  featMinMaxCount: r.uint16,\n  // May be 0\n  featMinMaxRecords: new r.Array(FeatMinMaxRecord, 'featMinMaxCount') // In alphabetical order\n\n});\nvar BaseLangSysRecord = new r.Struct({\n  tag: new r.String(4),\n  // 4-byte language system identification tag\n  minMax: new r.Pointer(r.uint16, MinMax, {\n    type: 'parent'\n  })\n});\nvar BaseScript = new r.Struct({\n  baseValues: new r.Pointer(r.uint16, BaseValues),\n  // May be NULL\n  defaultMinMax: new r.Pointer(r.uint16, MinMax),\n  // May be NULL\n  baseLangSysCount: r.uint16,\n  // May be 0\n  baseLangSysRecords: new r.Array(BaseLangSysRecord, 'baseLangSysCount') // in alphabetical order by BaseLangSysTag\n\n});\nvar BaseScriptRecord = new r.Struct({\n  tag: new r.String(4),\n  // 4-byte script identification tag\n  script: new r.Pointer(r.uint16, BaseScript, {\n    type: 'parent'\n  })\n});\nvar BaseScriptList = new r.Array(BaseScriptRecord, r.uint16); // Array of 4-byte baseline identification tags-must be in alphabetical order\n\nvar BaseTagList = new r.Array(new r.String(4), r.uint16);\nvar Axis = new r.Struct({\n  baseTagList: new r.Pointer(r.uint16, BaseTagList),\n  // May be NULL\n  baseScriptList: new r.Pointer(r.uint16, BaseScriptList)\n});\nvar BASE = new r.VersionedStruct(r.uint32, {\n  header: {\n    horizAxis: new r.Pointer(r.uint16, Axis),\n    // May be NULL\n    vertAxis: new r.Pointer(r.uint16, Axis) // May be NULL\n\n  },\n  0x00010000: {},\n  0x00010001: {\n    itemVariationStore: new r.Pointer(r.uint32, ItemVariationStore)\n  }\n});\nvar AttachPoint = new r.Array(r.uint16, r.uint16);\nvar AttachList = new r.Struct({\n  coverage: new r.Pointer(r.uint16, Coverage),\n  glyphCount: r.uint16,\n  attachPoints: new r.Array(new r.Pointer(r.uint16, AttachPoint), 'glyphCount')\n});\nvar CaretValue = new r.VersionedStruct(r.uint16, {\n  1: {\n    // Design units only\n    coordinate: r.int16\n  },\n  2: {\n    // Contour point\n    caretValuePoint: r.uint16\n  },\n  3: {\n    // Design units plus Device table\n    coordinate: r.int16,\n    deviceTable: new r.Pointer(r.uint16, Device)\n  }\n});\nvar LigGlyph = new r.Array(new r.Pointer(r.uint16, CaretValue), r.uint16);\nvar LigCaretList = new r.Struct({\n  coverage: new r.Pointer(r.uint16, Coverage),\n  ligGlyphCount: r.uint16,\n  ligGlyphs: new r.Array(new r.Pointer(r.uint16, LigGlyph), 'ligGlyphCount')\n});\nvar MarkGlyphSetsDef = new r.Struct({\n  markSetTableFormat: r.uint16,\n  markSetCount: r.uint16,\n  coverage: new r.Array(new r.Pointer(r.uint32, Coverage), 'markSetCount')\n});\nvar GDEF = new r.VersionedStruct(r.uint32, {\n  header: {\n    glyphClassDef: new r.Pointer(r.uint16, ClassDef),\n    attachList: new r.Pointer(r.uint16, AttachList),\n    ligCaretList: new r.Pointer(r.uint16, LigCaretList),\n    markAttachClassDef: new r.Pointer(r.uint16, ClassDef)\n  },\n  0x00010000: {},\n  0x00010002: {\n    markGlyphSetsDef: new r.Pointer(r.uint16, MarkGlyphSetsDef)\n  },\n  0x00010003: {\n    markGlyphSetsDef: new r.Pointer(r.uint16, MarkGlyphSetsDef),\n    itemVariationStore: new r.Pointer(r.uint32, ItemVariationStore)\n  }\n});\nvar ValueFormat = new r.Bitfield(r.uint16, ['xPlacement', 'yPlacement', 'xAdvance', 'yAdvance', 'xPlaDevice', 'yPlaDevice', 'xAdvDevice', 'yAdvDevice']);\nvar types = {\n  xPlacement: r.int16,\n  yPlacement: r.int16,\n  xAdvance: r.int16,\n  yAdvance: r.int16,\n  xPlaDevice: new r.Pointer(r.uint16, Device, {\n    type: 'global',\n    relativeTo: 'rel'\n  }),\n  yPlaDevice: new r.Pointer(r.uint16, Device, {\n    type: 'global',\n    relativeTo: 'rel'\n  }),\n  xAdvDevice: new r.Pointer(r.uint16, Device, {\n    type: 'global',\n    relativeTo: 'rel'\n  }),\n  yAdvDevice: new r.Pointer(r.uint16, Device, {\n    type: 'global',\n    relativeTo: 'rel'\n  })\n};\n\nvar ValueRecord = function () {\n  function ValueRecord() {\n    var key = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'valueFormat';\n\n    _classCallCheck(this, ValueRecord);\n\n    this.key = key;\n  }\n\n  ValueRecord.prototype.buildStruct = function buildStruct(parent) {\n    var struct = parent;\n\n    while (!struct[this.key] && struct.parent) {\n      struct = struct.parent;\n    }\n\n    if (!struct[this.key]) return;\n    var fields = {};\n\n    fields.rel = function () {\n      return struct._startOffset;\n    };\n\n    var format = struct[this.key];\n\n    for (var key in format) {\n      if (format[key]) {\n        fields[key] = types[key];\n      }\n    }\n\n    return new r.Struct(fields);\n  };\n\n  ValueRecord.prototype.size = function size(val, ctx) {\n    return this.buildStruct(ctx).size(val, ctx);\n  };\n\n  ValueRecord.prototype.decode = function decode(stream, parent) {\n    var res = this.buildStruct(parent).decode(stream, parent);\n    delete res.rel;\n    return res;\n  };\n\n  return ValueRecord;\n}();\n\nvar PairValueRecord = new r.Struct({\n  secondGlyph: r.uint16,\n  value1: new ValueRecord('valueFormat1'),\n  value2: new ValueRecord('valueFormat2')\n});\nvar PairSet = new r.Array(PairValueRecord, r.uint16);\nvar Class2Record = new r.Struct({\n  value1: new ValueRecord('valueFormat1'),\n  value2: new ValueRecord('valueFormat2')\n});\nvar Anchor = new r.VersionedStruct(r.uint16, {\n  1: {\n    // Design units only\n    xCoordinate: r.int16,\n    yCoordinate: r.int16\n  },\n  2: {\n    // Design units plus contour point\n    xCoordinate: r.int16,\n    yCoordinate: r.int16,\n    anchorPoint: r.uint16\n  },\n  3: {\n    // Design units plus Device tables\n    xCoordinate: r.int16,\n    yCoordinate: r.int16,\n    xDeviceTable: new r.Pointer(r.uint16, Device),\n    yDeviceTable: new r.Pointer(r.uint16, Device)\n  }\n});\nvar EntryExitRecord = new r.Struct({\n  entryAnchor: new r.Pointer(r.uint16, Anchor, {\n    type: 'parent'\n  }),\n  exitAnchor: new r.Pointer(r.uint16, Anchor, {\n    type: 'parent'\n  })\n});\nvar MarkRecord = new r.Struct({\n  class: r.uint16,\n  markAnchor: new r.Pointer(r.uint16, Anchor, {\n    type: 'parent'\n  })\n});\nvar MarkArray = new r.Array(MarkRecord, r.uint16);\nvar BaseRecord = new r.Array(new r.Pointer(r.uint16, Anchor), function (t) {\n  return t.parent.classCount;\n});\nvar BaseArray = new r.Array(BaseRecord, r.uint16);\nvar ComponentRecord = new r.Array(new r.Pointer(r.uint16, Anchor), function (t) {\n  return t.parent.parent.classCount;\n});\nvar LigatureAttach = new r.Array(ComponentRecord, r.uint16);\nvar LigatureArray = new r.Array(new r.Pointer(r.uint16, LigatureAttach), r.uint16);\nvar GPOSLookup = new r.VersionedStruct('lookupType', {\n  1: new r.VersionedStruct(r.uint16, {\n    // Single Adjustment\n    1: {\n      // Single positioning value\n      coverage: new r.Pointer(r.uint16, Coverage),\n      valueFormat: ValueFormat,\n      value: new ValueRecord()\n    },\n    2: {\n      coverage: new r.Pointer(r.uint16, Coverage),\n      valueFormat: ValueFormat,\n      valueCount: r.uint16,\n      values: new r.LazyArray(new ValueRecord(), 'valueCount')\n    }\n  }),\n  2: new r.VersionedStruct(r.uint16, {\n    // Pair Adjustment Positioning\n    1: {\n      // Adjustments for glyph pairs\n      coverage: new r.Pointer(r.uint16, Coverage),\n      valueFormat1: ValueFormat,\n      valueFormat2: ValueFormat,\n      pairSetCount: r.uint16,\n      pairSets: new r.LazyArray(new r.Pointer(r.uint16, PairSet), 'pairSetCount')\n    },\n    2: {\n      // Class pair adjustment\n      coverage: new r.Pointer(r.uint16, Coverage),\n      valueFormat1: ValueFormat,\n      valueFormat2: ValueFormat,\n      classDef1: new r.Pointer(r.uint16, ClassDef),\n      classDef2: new r.Pointer(r.uint16, ClassDef),\n      class1Count: r.uint16,\n      class2Count: r.uint16,\n      classRecords: new r.LazyArray(new r.LazyArray(Class2Record, 'class2Count'), 'class1Count')\n    }\n  }),\n  3: {\n    // Cursive Attachment Positioning\n    format: r.uint16,\n    coverage: new r.Pointer(r.uint16, Coverage),\n    entryExitCount: r.uint16,\n    entryExitRecords: new r.Array(EntryExitRecord, 'entryExitCount')\n  },\n  4: {\n    // MarkToBase Attachment Positioning\n    format: r.uint16,\n    markCoverage: new r.Pointer(r.uint16, Coverage),\n    baseCoverage: new r.Pointer(r.uint16, Coverage),\n    classCount: r.uint16,\n    markArray: new r.Pointer(r.uint16, MarkArray),\n    baseArray: new r.Pointer(r.uint16, BaseArray)\n  },\n  5: {\n    // MarkToLigature Attachment Positioning\n    format: r.uint16,\n    markCoverage: new r.Pointer(r.uint16, Coverage),\n    ligatureCoverage: new r.Pointer(r.uint16, Coverage),\n    classCount: r.uint16,\n    markArray: new r.Pointer(r.uint16, MarkArray),\n    ligatureArray: new r.Pointer(r.uint16, LigatureArray)\n  },\n  6: {\n    // MarkToMark Attachment Positioning\n    format: r.uint16,\n    mark1Coverage: new r.Pointer(r.uint16, Coverage),\n    mark2Coverage: new r.Pointer(r.uint16, Coverage),\n    classCount: r.uint16,\n    mark1Array: new r.Pointer(r.uint16, MarkArray),\n    mark2Array: new r.Pointer(r.uint16, BaseArray)\n  },\n  7: Context,\n  // Contextual positioning\n  8: ChainingContext,\n  // Chaining contextual positioning\n  9: {\n    // Extension Positioning\n    posFormat: r.uint16,\n    lookupType: r.uint16,\n    // cannot also be 9\n    extension: new r.Pointer(r.uint32, GPOSLookup)\n  }\n}); // Fix circular reference\n\nGPOSLookup.versions[9].extension.type = GPOSLookup;\nvar GPOS = new r.VersionedStruct(r.uint32, {\n  header: {\n    scriptList: new r.Pointer(r.uint16, ScriptList),\n    featureList: new r.Pointer(r.uint16, FeatureList),\n    lookupList: new r.Pointer(r.uint16, new LookupList(GPOSLookup))\n  },\n  0x00010000: {},\n  0x00010001: {\n    featureVariations: new r.Pointer(r.uint32, FeatureVariations)\n  }\n});\nvar Sequence = new r.Array(r.uint16, r.uint16);\nvar AlternateSet = Sequence;\nvar Ligature = new r.Struct({\n  glyph: r.uint16,\n  compCount: r.uint16,\n  components: new r.Array(r.uint16, function (t) {\n    return t.compCount - 1;\n  })\n});\nvar LigatureSet = new r.Array(new r.Pointer(r.uint16, Ligature), r.uint16);\nvar GSUBLookup = new r.VersionedStruct('lookupType', {\n  1: new r.VersionedStruct(r.uint16, {\n    // Single Substitution\n    1: {\n      coverage: new r.Pointer(r.uint16, Coverage),\n      deltaGlyphID: r.int16\n    },\n    2: {\n      coverage: new r.Pointer(r.uint16, Coverage),\n      glyphCount: r.uint16,\n      substitute: new r.LazyArray(r.uint16, 'glyphCount')\n    }\n  }),\n  2: {\n    // Multiple Substitution\n    substFormat: r.uint16,\n    coverage: new r.Pointer(r.uint16, Coverage),\n    count: r.uint16,\n    sequences: new r.LazyArray(new r.Pointer(r.uint16, Sequence), 'count')\n  },\n  3: {\n    // Alternate Substitution\n    substFormat: r.uint16,\n    coverage: new r.Pointer(r.uint16, Coverage),\n    count: r.uint16,\n    alternateSet: new r.LazyArray(new r.Pointer(r.uint16, AlternateSet), 'count')\n  },\n  4: {\n    // Ligature Substitution\n    substFormat: r.uint16,\n    coverage: new r.Pointer(r.uint16, Coverage),\n    count: r.uint16,\n    ligatureSets: new r.LazyArray(new r.Pointer(r.uint16, LigatureSet), 'count')\n  },\n  5: Context,\n  // Contextual Substitution\n  6: ChainingContext,\n  // Chaining Contextual Substitution\n  7: {\n    // Extension Substitution\n    substFormat: r.uint16,\n    lookupType: r.uint16,\n    // cannot also be 7\n    extension: new r.Pointer(r.uint32, GSUBLookup)\n  },\n  8: {\n    // Reverse Chaining Contextual Single Substitution\n    substFormat: r.uint16,\n    coverage: new r.Pointer(r.uint16, Coverage),\n    backtrackCoverage: new r.Array(new r.Pointer(r.uint16, Coverage), 'backtrackGlyphCount'),\n    lookaheadGlyphCount: r.uint16,\n    lookaheadCoverage: new r.Array(new r.Pointer(r.uint16, Coverage), 'lookaheadGlyphCount'),\n    glyphCount: r.uint16,\n    substitutes: new r.Array(r.uint16, 'glyphCount')\n  }\n}); // Fix circular reference\n\nGSUBLookup.versions[7].extension.type = GSUBLookup;\nvar GSUB = new r.VersionedStruct(r.uint32, {\n  header: {\n    scriptList: new r.Pointer(r.uint16, ScriptList),\n    featureList: new r.Pointer(r.uint16, FeatureList),\n    lookupList: new r.Pointer(r.uint16, new LookupList(GSUBLookup))\n  },\n  0x00010000: {},\n  0x00010001: {\n    featureVariations: new r.Pointer(r.uint32, FeatureVariations)\n  }\n});\nvar JstfGSUBModList = new r.Array(r.uint16, r.uint16);\nvar JstfPriority = new r.Struct({\n  shrinkageEnableGSUB: new r.Pointer(r.uint16, JstfGSUBModList),\n  shrinkageDisableGSUB: new r.Pointer(r.uint16, JstfGSUBModList),\n  shrinkageEnableGPOS: new r.Pointer(r.uint16, JstfGSUBModList),\n  shrinkageDisableGPOS: new r.Pointer(r.uint16, JstfGSUBModList),\n  shrinkageJstfMax: new r.Pointer(r.uint16, new LookupList(GPOSLookup)),\n  extensionEnableGSUB: new r.Pointer(r.uint16, JstfGSUBModList),\n  extensionDisableGSUB: new r.Pointer(r.uint16, JstfGSUBModList),\n  extensionEnableGPOS: new r.Pointer(r.uint16, JstfGSUBModList),\n  extensionDisableGPOS: new r.Pointer(r.uint16, JstfGSUBModList),\n  extensionJstfMax: new r.Pointer(r.uint16, new LookupList(GPOSLookup))\n});\nvar JstfLangSys = new r.Array(new r.Pointer(r.uint16, JstfPriority), r.uint16);\nvar JstfLangSysRecord = new r.Struct({\n  tag: new r.String(4),\n  jstfLangSys: new r.Pointer(r.uint16, JstfLangSys)\n});\nvar JstfScript = new r.Struct({\n  extenderGlyphs: new r.Pointer(r.uint16, new r.Array(r.uint16, r.uint16)),\n  // array of glyphs to extend line length\n  defaultLangSys: new r.Pointer(r.uint16, JstfLangSys),\n  langSysCount: r.uint16,\n  langSysRecords: new r.Array(JstfLangSysRecord, 'langSysCount')\n});\nvar JstfScriptRecord = new r.Struct({\n  tag: new r.String(4),\n  script: new r.Pointer(r.uint16, JstfScript, {\n    type: 'parent'\n  })\n});\nvar JSTF = new r.Struct({\n  version: r.uint32,\n  // should be 0x00010000\n  scriptCount: r.uint16,\n  scriptList: new r.Array(JstfScriptRecord, 'scriptCount')\n}); // TODO: add this to restructure\n\nvar VariableSizeNumber = function () {\n  function VariableSizeNumber(size) {\n    _classCallCheck(this, VariableSizeNumber);\n\n    this._size = size;\n  }\n\n  VariableSizeNumber.prototype.decode = function decode(stream, parent) {\n    switch (this.size(0, parent)) {\n      case 1:\n        return stream.readUInt8();\n\n      case 2:\n        return stream.readUInt16BE();\n\n      case 3:\n        return stream.readUInt24BE();\n\n      case 4:\n        return stream.readUInt32BE();\n    }\n  };\n\n  VariableSizeNumber.prototype.size = function size(val, parent) {\n    return restructure_src_utils.resolveLength(this._size, null, parent);\n  };\n\n  return VariableSizeNumber;\n}();\n\nvar MapDataEntry = new r.Struct({\n  entry: new VariableSizeNumber(function (t) {\n    return ((t.parent.entryFormat & 0x0030) >> 4) + 1;\n  }),\n  outerIndex: function outerIndex(t) {\n    return t.entry >> (t.parent.entryFormat & 0x000F) + 1;\n  },\n  innerIndex: function innerIndex(t) {\n    return t.entry & (1 << (t.parent.entryFormat & 0x000F) + 1) - 1;\n  }\n});\nvar DeltaSetIndexMap = new r.Struct({\n  entryFormat: r.uint16,\n  mapCount: r.uint16,\n  mapData: new r.Array(MapDataEntry, 'mapCount')\n});\nvar HVAR = new r.Struct({\n  majorVersion: r.uint16,\n  minorVersion: r.uint16,\n  itemVariationStore: new r.Pointer(r.uint32, ItemVariationStore),\n  advanceWidthMapping: new r.Pointer(r.uint32, DeltaSetIndexMap),\n  LSBMapping: new r.Pointer(r.uint32, DeltaSetIndexMap),\n  RSBMapping: new r.Pointer(r.uint32, DeltaSetIndexMap)\n});\nvar Signature = new r.Struct({\n  format: r.uint32,\n  length: r.uint32,\n  offset: r.uint32\n});\nvar SignatureBlock = new r.Struct({\n  reserved: new r.Reserved(r.uint16, 2),\n  cbSignature: r.uint32,\n  // Length (in bytes) of the PKCS#7 packet in pbSignature\n  signature: new r.Buffer('cbSignature')\n});\nvar DSIG = new r.Struct({\n  ulVersion: r.uint32,\n  // Version number of the DSIG table (0x00000001)\n  usNumSigs: r.uint16,\n  // Number of signatures in the table\n  usFlag: r.uint16,\n  // Permission flags\n  signatures: new r.Array(Signature, 'usNumSigs'),\n  signatureBlocks: new r.Array(SignatureBlock, 'usNumSigs')\n});\nvar GaspRange = new r.Struct({\n  rangeMaxPPEM: r.uint16,\n  // Upper limit of range, in ppem\n  rangeGaspBehavior: new r.Bitfield(r.uint16, [// Flags describing desired rasterizer behavior\n  'grayscale', 'gridfit', 'symmetricSmoothing', 'symmetricGridfit' // only in version 1, for ClearType\n  ])\n});\nvar gasp = new r.Struct({\n  version: r.uint16,\n  // set to 0\n  numRanges: r.uint16,\n  gaspRanges: new r.Array(GaspRange, 'numRanges') // Sorted by ppem\n\n});\nvar DeviceRecord = new r.Struct({\n  pixelSize: r.uint8,\n  maximumWidth: r.uint8,\n  widths: new r.Array(r.uint8, function (t) {\n    return t.parent.parent.maxp.numGlyphs;\n  })\n}); // The Horizontal Device Metrics table stores integer advance widths scaled to particular pixel sizes\n\nvar hdmx = new r.Struct({\n  version: r.uint16,\n  numRecords: r.int16,\n  sizeDeviceRecord: r.int32,\n  records: new r.Array(DeviceRecord, 'numRecords')\n});\nvar KernPair = new r.Struct({\n  left: r.uint16,\n  right: r.uint16,\n  value: r.int16\n});\nvar ClassTable = new r.Struct({\n  firstGlyph: r.uint16,\n  nGlyphs: r.uint16,\n  offsets: new r.Array(r.uint16, 'nGlyphs'),\n  max: function max(t) {\n    return t.offsets.length && Math.max.apply(Math, t.offsets);\n  }\n});\nvar Kern2Array = new r.Struct({\n  off: function off(t) {\n    return t._startOffset - t.parent.parent._startOffset;\n  },\n  len: function len(t) {\n    return ((t.parent.leftTable.max - t.off) / t.parent.rowWidth + 1) * (t.parent.rowWidth / 2);\n  },\n  values: new r.LazyArray(r.int16, 'len')\n});\nvar KernSubtable = new r.VersionedStruct('format', {\n  0: {\n    nPairs: r.uint16,\n    searchRange: r.uint16,\n    entrySelector: r.uint16,\n    rangeShift: r.uint16,\n    pairs: new r.Array(KernPair, 'nPairs')\n  },\n  2: {\n    rowWidth: r.uint16,\n    leftTable: new r.Pointer(r.uint16, ClassTable, {\n      type: 'parent'\n    }),\n    rightTable: new r.Pointer(r.uint16, ClassTable, {\n      type: 'parent'\n    }),\n    array: new r.Pointer(r.uint16, Kern2Array, {\n      type: 'parent'\n    })\n  },\n  3: {\n    glyphCount: r.uint16,\n    kernValueCount: r.uint8,\n    leftClassCount: r.uint8,\n    rightClassCount: r.uint8,\n    flags: r.uint8,\n    kernValue: new r.Array(r.int16, 'kernValueCount'),\n    leftClass: new r.Array(r.uint8, 'glyphCount'),\n    rightClass: new r.Array(r.uint8, 'glyphCount'),\n    kernIndex: new r.Array(r.uint8, function (t) {\n      return t.leftClassCount * t.rightClassCount;\n    })\n  }\n});\nvar KernTable = new r.VersionedStruct('version', {\n  0: {\n    // Microsoft uses this format\n    subVersion: r.uint16,\n    // Microsoft has an extra sub-table version number\n    length: r.uint16,\n    // Length of the subtable, in bytes\n    format: r.uint8,\n    // Format of subtable\n    coverage: new r.Bitfield(r.uint8, ['horizontal', // 1 if table has horizontal data, 0 if vertical\n    'minimum', // If set to 1, the table has minimum values. If set to 0, the table has kerning values.\n    'crossStream', // If set to 1, kerning is perpendicular to the flow of the text\n    'override' // If set to 1 the value in this table replaces the accumulated value\n    ]),\n    subtable: KernSubtable,\n    padding: new r.Reserved(r.uint8, function (t) {\n      return t.length - t._currentOffset;\n    })\n  },\n  1: {\n    // Apple uses this format\n    length: r.uint32,\n    coverage: new r.Bitfield(r.uint8, [null, null, null, null, null, 'variation', // Set if table has variation kerning values\n    'crossStream', // Set if table has cross-stream kerning values\n    'vertical' // Set if table has vertical kerning values\n    ]),\n    format: r.uint8,\n    tupleIndex: r.uint16,\n    subtable: KernSubtable,\n    padding: new r.Reserved(r.uint8, function (t) {\n      return t.length - t._currentOffset;\n    })\n  }\n});\nvar kern = new r.VersionedStruct(r.uint16, {\n  0: {\n    // Microsoft Version\n    nTables: r.uint16,\n    tables: new r.Array(KernTable, 'nTables')\n  },\n  1: {\n    // Apple Version\n    reserved: new r.Reserved(r.uint16),\n    // the other half of the version number\n    nTables: r.uint32,\n    tables: new r.Array(KernTable, 'nTables')\n  }\n}); // Linear Threshold table\n// Records the ppem for each glyph at which the scaling becomes linear again,\n// despite instructions effecting the advance width\n\nvar LTSH = new r.Struct({\n  version: r.uint16,\n  numGlyphs: r.uint16,\n  yPels: new r.Array(r.uint8, 'numGlyphs')\n}); // PCL 5 Table\n// NOTE: The PCLT table is strongly discouraged for OpenType fonts with TrueType outlines\n\nvar PCLT = new r.Struct({\n  version: r.uint16,\n  fontNumber: r.uint32,\n  pitch: r.uint16,\n  xHeight: r.uint16,\n  style: r.uint16,\n  typeFamily: r.uint16,\n  capHeight: r.uint16,\n  symbolSet: r.uint16,\n  typeface: new r.String(16),\n  characterComplement: new r.String(8),\n  fileName: new r.String(6),\n  strokeWeight: new r.String(1),\n  widthType: new r.String(1),\n  serifStyle: r.uint8,\n  reserved: new r.Reserved(r.uint8)\n}); // VDMX tables contain ascender/descender overrides for certain (usually small)\n// sizes. This is needed in order to match font metrics on Windows.\n\nvar Ratio = new r.Struct({\n  bCharSet: r.uint8,\n  // Character set\n  xRatio: r.uint8,\n  // Value to use for x-Ratio\n  yStartRatio: r.uint8,\n  // Starting y-Ratio value\n  yEndRatio: r.uint8 // Ending y-Ratio value\n\n});\nvar vTable = new r.Struct({\n  yPelHeight: r.uint16,\n  // yPelHeight to which values apply\n  yMax: r.int16,\n  // Maximum value (in pels) for this yPelHeight\n  yMin: r.int16 // Minimum value (in pels) for this yPelHeight\n\n});\nvar VdmxGroup = new r.Struct({\n  recs: r.uint16,\n  // Number of height records in this group\n  startsz: r.uint8,\n  // Starting yPelHeight\n  endsz: r.uint8,\n  // Ending yPelHeight\n  entries: new r.Array(vTable, 'recs') // The VDMX records\n\n});\nvar VDMX = new r.Struct({\n  version: r.uint16,\n  // Version number (0 or 1)\n  numRecs: r.uint16,\n  // Number of VDMX groups present\n  numRatios: r.uint16,\n  // Number of aspect ratio groupings\n  ratioRanges: new r.Array(Ratio, 'numRatios'),\n  // Ratio ranges\n  offsets: new r.Array(r.uint16, 'numRatios'),\n  // Offset to the VDMX group for this ratio range\n  groups: new r.Array(VdmxGroup, 'numRecs') // The actual VDMX groupings\n\n}); // Vertical Header Table\n\nvar vhea = new r.Struct({\n  version: r.uint16,\n  // Version number of the Vertical Header Table\n  ascent: r.int16,\n  // The vertical typographic ascender for this font\n  descent: r.int16,\n  // The vertical typographic descender for this font\n  lineGap: r.int16,\n  // The vertical typographic line gap for this font\n  advanceHeightMax: r.int16,\n  // The maximum advance height measurement found in the font\n  minTopSideBearing: r.int16,\n  // The minimum top side bearing measurement found in the font\n  minBottomSideBearing: r.int16,\n  // The minimum bottom side bearing measurement found in the font\n  yMaxExtent: r.int16,\n  caretSlopeRise: r.int16,\n  // Caret slope (rise/run)\n  caretSlopeRun: r.int16,\n  caretOffset: r.int16,\n  // Set value equal to 0 for nonslanted fonts\n  reserved: new r.Reserved(r.int16, 4),\n  metricDataFormat: r.int16,\n  // Set to 0\n  numberOfMetrics: r.uint16 // Number of advance heights in the Vertical Metrics table\n\n});\nvar VmtxEntry = new r.Struct({\n  advance: r.uint16,\n  // The advance height of the glyph\n  bearing: r.int16 // The top sidebearing of the glyph\n\n}); // Vertical Metrics Table\n\nvar vmtx = new r.Struct({\n  metrics: new r.LazyArray(VmtxEntry, function (t) {\n    return t.parent.vhea.numberOfMetrics;\n  }),\n  bearings: new r.LazyArray(r.int16, function (t) {\n    return t.parent.maxp.numGlyphs - t.parent.vhea.numberOfMetrics;\n  })\n});\nvar shortFrac = new r.Fixed(16, 'BE', 14);\nvar Correspondence = new r.Struct({\n  fromCoord: shortFrac,\n  toCoord: shortFrac\n});\nvar Segment = new r.Struct({\n  pairCount: r.uint16,\n  correspondence: new r.Array(Correspondence, 'pairCount')\n});\nvar avar = new r.Struct({\n  version: r.fixed32,\n  axisCount: r.uint32,\n  segment: new r.Array(Segment, 'axisCount')\n});\n\nvar UnboundedArrayAccessor = function () {\n  function UnboundedArrayAccessor(type, stream, parent) {\n    _classCallCheck(this, UnboundedArrayAccessor);\n\n    this.type = type;\n    this.stream = stream;\n    this.parent = parent;\n    this.base = this.stream.pos;\n    this._items = [];\n  }\n\n  UnboundedArrayAccessor.prototype.getItem = function getItem(index) {\n    if (this._items[index] == null) {\n      var pos = this.stream.pos;\n      this.stream.pos = this.base + this.type.size(null, this.parent) * index;\n      this._items[index] = this.type.decode(this.stream, this.parent);\n      this.stream.pos = pos;\n    }\n\n    return this._items[index];\n  };\n\n  UnboundedArrayAccessor.prototype.inspect = function inspect() {\n    return '[UnboundedArray ' + this.type.constructor.name + ']';\n  };\n\n  return UnboundedArrayAccessor;\n}();\n\nvar UnboundedArray = function (_r$Array) {\n  _inherits(UnboundedArray, _r$Array);\n\n  function UnboundedArray(type) {\n    _classCallCheck(this, UnboundedArray);\n\n    return _possibleConstructorReturn(this, _r$Array.call(this, type, 0));\n  }\n\n  UnboundedArray.prototype.decode = function decode(stream, parent) {\n    return new UnboundedArrayAccessor(this.type, stream, parent);\n  };\n\n  return UnboundedArray;\n}(r.Array);\n\nvar LookupTable = function LookupTable() {\n  var ValueType = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : r.uint16; // Helper class that makes internal structures invisible to pointers\n\n  var Shadow = function () {\n    function Shadow(type) {\n      _classCallCheck(this, Shadow);\n\n      this.type = type;\n    }\n\n    Shadow.prototype.decode = function decode(stream, ctx) {\n      ctx = ctx.parent.parent;\n      return this.type.decode(stream, ctx);\n    };\n\n    Shadow.prototype.size = function size(val, ctx) {\n      ctx = ctx.parent.parent;\n      return this.type.size(val, ctx);\n    };\n\n    Shadow.prototype.encode = function encode(stream, val, ctx) {\n      ctx = ctx.parent.parent;\n      return this.type.encode(stream, val, ctx);\n    };\n\n    return Shadow;\n  }();\n\n  ValueType = new Shadow(ValueType);\n  var BinarySearchHeader = new r.Struct({\n    unitSize: r.uint16,\n    nUnits: r.uint16,\n    searchRange: r.uint16,\n    entrySelector: r.uint16,\n    rangeShift: r.uint16\n  });\n  var LookupSegmentSingle = new r.Struct({\n    lastGlyph: r.uint16,\n    firstGlyph: r.uint16,\n    value: ValueType\n  });\n  var LookupSegmentArray = new r.Struct({\n    lastGlyph: r.uint16,\n    firstGlyph: r.uint16,\n    values: new r.Pointer(r.uint16, new r.Array(ValueType, function (t) {\n      return t.lastGlyph - t.firstGlyph + 1;\n    }), {\n      type: 'parent'\n    })\n  });\n  var LookupSingle = new r.Struct({\n    glyph: r.uint16,\n    value: ValueType\n  });\n  return new r.VersionedStruct(r.uint16, {\n    0: {\n      values: new UnboundedArray(ValueType) // length == number of glyphs maybe?\n\n    },\n    2: {\n      binarySearchHeader: BinarySearchHeader,\n      segments: new r.Array(LookupSegmentSingle, function (t) {\n        return t.binarySearchHeader.nUnits;\n      })\n    },\n    4: {\n      binarySearchHeader: BinarySearchHeader,\n      segments: new r.Array(LookupSegmentArray, function (t) {\n        return t.binarySearchHeader.nUnits;\n      })\n    },\n    6: {\n      binarySearchHeader: BinarySearchHeader,\n      segments: new r.Array(LookupSingle, function (t) {\n        return t.binarySearchHeader.nUnits;\n      })\n    },\n    8: {\n      firstGlyph: r.uint16,\n      count: r.uint16,\n      values: new r.Array(ValueType, 'count')\n    }\n  });\n};\n\nfunction StateTable() {\n  var entryData = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var lookupType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : r.uint16;\n\n  var entry = _Object$assign({\n    newState: r.uint16,\n    flags: r.uint16\n  }, entryData);\n\n  var Entry = new r.Struct(entry);\n  var StateArray = new UnboundedArray(new r.Array(r.uint16, function (t) {\n    return t.nClasses;\n  }));\n  var StateHeader = new r.Struct({\n    nClasses: r.uint32,\n    classTable: new r.Pointer(r.uint32, new LookupTable(lookupType)),\n    stateArray: new r.Pointer(r.uint32, StateArray),\n    entryTable: new r.Pointer(r.uint32, new UnboundedArray(Entry))\n  });\n  return StateHeader;\n} // This is the old version of the StateTable structure\n\n\nfunction StateTable1() {\n  var entryData = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var lookupType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : r.uint16;\n  var ClassLookupTable = new r.Struct({\n    version: function version() {\n      return 8;\n    },\n    // simulate LookupTable\n    firstGlyph: r.uint16,\n    values: new r.Array(r.uint8, r.uint16)\n  });\n\n  var entry = _Object$assign({\n    newStateOffset: r.uint16,\n    // convert offset to stateArray index\n    newState: function newState(t) {\n      return (t.newStateOffset - (t.parent.stateArray.base - t.parent._startOffset)) / t.parent.nClasses;\n    },\n    flags: r.uint16\n  }, entryData);\n\n  var Entry = new r.Struct(entry);\n  var StateArray = new UnboundedArray(new r.Array(r.uint8, function (t) {\n    return t.nClasses;\n  }));\n  var StateHeader1 = new r.Struct({\n    nClasses: r.uint16,\n    classTable: new r.Pointer(r.uint16, ClassLookupTable),\n    stateArray: new r.Pointer(r.uint16, StateArray),\n    entryTable: new r.Pointer(r.uint16, new UnboundedArray(Entry))\n  });\n  return StateHeader1;\n}\n\nvar BslnSubtable = new r.VersionedStruct('format', {\n  0: {\n    // Distance-based, no mapping\n    deltas: new r.Array(r.int16, 32)\n  },\n  1: {\n    // Distance-based, with mapping\n    deltas: new r.Array(r.int16, 32),\n    mappingData: new LookupTable(r.uint16)\n  },\n  2: {\n    // Control point-based, no mapping\n    standardGlyph: r.uint16,\n    controlPoints: new r.Array(r.uint16, 32)\n  },\n  3: {\n    // Control point-based, with mapping\n    standardGlyph: r.uint16,\n    controlPoints: new r.Array(r.uint16, 32),\n    mappingData: new LookupTable(r.uint16)\n  }\n});\nvar bsln = new r.Struct({\n  version: r.fixed32,\n  format: r.uint16,\n  defaultBaseline: r.uint16,\n  subtable: BslnSubtable\n});\nvar Setting = new r.Struct({\n  setting: r.uint16,\n  nameIndex: r.int16,\n  name: function name(t) {\n    return t.parent.parent.parent.name.records.fontFeatures[t.nameIndex];\n  }\n});\nvar FeatureName = new r.Struct({\n  feature: r.uint16,\n  nSettings: r.uint16,\n  settingTable: new r.Pointer(r.uint32, new r.Array(Setting, 'nSettings'), {\n    type: 'parent'\n  }),\n  featureFlags: new r.Bitfield(r.uint8, [null, null, null, null, null, null, 'hasDefault', 'exclusive']),\n  defaultSetting: r.uint8,\n  nameIndex: r.int16,\n  name: function name(t) {\n    return t.parent.parent.name.records.fontFeatures[t.nameIndex];\n  }\n});\nvar feat = new r.Struct({\n  version: r.fixed32,\n  featureNameCount: r.uint16,\n  reserved1: new r.Reserved(r.uint16),\n  reserved2: new r.Reserved(r.uint32),\n  featureNames: new r.Array(FeatureName, 'featureNameCount')\n});\nvar Axis$1 = new r.Struct({\n  axisTag: new r.String(4),\n  minValue: r.fixed32,\n  defaultValue: r.fixed32,\n  maxValue: r.fixed32,\n  flags: r.uint16,\n  nameID: r.uint16,\n  name: function name(t) {\n    return t.parent.parent.name.records.fontFeatures[t.nameID];\n  }\n});\nvar Instance = new r.Struct({\n  nameID: r.uint16,\n  name: function name(t) {\n    return t.parent.parent.name.records.fontFeatures[t.nameID];\n  },\n  flags: r.uint16,\n  coord: new r.Array(r.fixed32, function (t) {\n    return t.parent.axisCount;\n  }),\n  postscriptNameID: new r.Optional(r.uint16, function (t) {\n    return t.parent.instanceSize - t._currentOffset > 0;\n  })\n});\nvar fvar = new r.Struct({\n  version: r.fixed32,\n  offsetToData: r.uint16,\n  countSizePairs: r.uint16,\n  axisCount: r.uint16,\n  axisSize: r.uint16,\n  instanceCount: r.uint16,\n  instanceSize: r.uint16,\n  axis: new r.Array(Axis$1, 'axisCount'),\n  instance: new r.Array(Instance, 'instanceCount')\n});\nvar shortFrac$1 = new r.Fixed(16, 'BE', 14);\n\nvar Offset = function () {\n  function Offset() {\n    _classCallCheck(this, Offset);\n  }\n\n  Offset.decode = function decode(stream, parent) {\n    // In short format, offsets are multiplied by 2.\n    // This doesn't seem to be documented by Apple, but it\n    // is implemented this way in Freetype.\n    return parent.flags ? stream.readUInt32BE() : stream.readUInt16BE() * 2;\n  };\n\n  return Offset;\n}();\n\nvar gvar = new r.Struct({\n  version: r.uint16,\n  reserved: new r.Reserved(r.uint16),\n  axisCount: r.uint16,\n  globalCoordCount: r.uint16,\n  globalCoords: new r.Pointer(r.uint32, new r.Array(new r.Array(shortFrac$1, 'axisCount'), 'globalCoordCount')),\n  glyphCount: r.uint16,\n  flags: r.uint16,\n  offsetToData: r.uint32,\n  offsets: new r.Array(new r.Pointer(Offset, 'void', {\n    relativeTo: 'offsetToData',\n    allowNull: false\n  }), function (t) {\n    return t.glyphCount + 1;\n  })\n});\nvar ClassTable$1 = new r.Struct({\n  length: r.uint16,\n  coverage: r.uint16,\n  subFeatureFlags: r.uint32,\n  stateTable: new StateTable1()\n});\nvar WidthDeltaRecord = new r.Struct({\n  justClass: r.uint32,\n  beforeGrowLimit: r.fixed32,\n  beforeShrinkLimit: r.fixed32,\n  afterGrowLimit: r.fixed32,\n  afterShrinkLimit: r.fixed32,\n  growFlags: r.uint16,\n  shrinkFlags: r.uint16\n});\nvar WidthDeltaCluster = new r.Array(WidthDeltaRecord, r.uint32);\nvar ActionData = new r.VersionedStruct('actionType', {\n  0: {\n    // Decomposition action\n    lowerLimit: r.fixed32,\n    upperLimit: r.fixed32,\n    order: r.uint16,\n    glyphs: new r.Array(r.uint16, r.uint16)\n  },\n  1: {\n    // Unconditional add glyph action\n    addGlyph: r.uint16\n  },\n  2: {\n    // Conditional add glyph action\n    substThreshold: r.fixed32,\n    addGlyph: r.uint16,\n    substGlyph: r.uint16\n  },\n  3: {},\n  // Stretch glyph action (no data, not supported by CoreText)\n  4: {\n    // Ductile glyph action (not supported by CoreText)\n    variationAxis: r.uint32,\n    minimumLimit: r.fixed32,\n    noStretchValue: r.fixed32,\n    maximumLimit: r.fixed32\n  },\n  5: {\n    // Repeated add glyph action\n    flags: r.uint16,\n    glyph: r.uint16\n  }\n});\nvar Action = new r.Struct({\n  actionClass: r.uint16,\n  actionType: r.uint16,\n  actionLength: r.uint32,\n  actionData: ActionData,\n  padding: new r.Reserved(r.uint8, function (t) {\n    return t.actionLength - t._currentOffset;\n  })\n});\nvar PostcompensationAction = new r.Array(Action, r.uint32);\nvar PostCompensationTable = new r.Struct({\n  lookupTable: new LookupTable(new r.Pointer(r.uint16, PostcompensationAction))\n});\nvar JustificationTable = new r.Struct({\n  classTable: new r.Pointer(r.uint16, ClassTable$1, {\n    type: 'parent'\n  }),\n  wdcOffset: r.uint16,\n  postCompensationTable: new r.Pointer(r.uint16, PostCompensationTable, {\n    type: 'parent'\n  }),\n  widthDeltaClusters: new LookupTable(new r.Pointer(r.uint16, WidthDeltaCluster, {\n    type: 'parent',\n    relativeTo: 'wdcOffset'\n  }))\n});\nvar just = new r.Struct({\n  version: r.uint32,\n  format: r.uint16,\n  horizontal: new r.Pointer(r.uint16, JustificationTable),\n  vertical: new r.Pointer(r.uint16, JustificationTable)\n});\nvar LigatureData = {\n  action: r.uint16\n};\nvar ContextualData = {\n  markIndex: r.uint16,\n  currentIndex: r.uint16\n};\nvar InsertionData = {\n  currentInsertIndex: r.uint16,\n  markedInsertIndex: r.uint16\n};\nvar SubstitutionTable = new r.Struct({\n  items: new UnboundedArray(new r.Pointer(r.uint32, new LookupTable()))\n});\nvar SubtableData = new r.VersionedStruct('type', {\n  0: {\n    // Indic Rearrangement Subtable\n    stateTable: new StateTable()\n  },\n  1: {\n    // Contextual Glyph Substitution Subtable\n    stateTable: new StateTable(ContextualData),\n    substitutionTable: new r.Pointer(r.uint32, SubstitutionTable)\n  },\n  2: {\n    // Ligature subtable\n    stateTable: new StateTable(LigatureData),\n    ligatureActions: new r.Pointer(r.uint32, new UnboundedArray(r.uint32)),\n    components: new r.Pointer(r.uint32, new UnboundedArray(r.uint16)),\n    ligatureList: new r.Pointer(r.uint32, new UnboundedArray(r.uint16))\n  },\n  4: {\n    // Non-contextual Glyph Substitution Subtable\n    lookupTable: new LookupTable()\n  },\n  5: {\n    // Glyph Insertion Subtable\n    stateTable: new StateTable(InsertionData),\n    insertionActions: new r.Pointer(r.uint32, new UnboundedArray(r.uint16))\n  }\n});\nvar Subtable = new r.Struct({\n  length: r.uint32,\n  coverage: r.uint24,\n  type: r.uint8,\n  subFeatureFlags: r.uint32,\n  table: SubtableData,\n  padding: new r.Reserved(r.uint8, function (t) {\n    return t.length - t._currentOffset;\n  })\n});\nvar FeatureEntry = new r.Struct({\n  featureType: r.uint16,\n  featureSetting: r.uint16,\n  enableFlags: r.uint32,\n  disableFlags: r.uint32\n});\nvar MorxChain = new r.Struct({\n  defaultFlags: r.uint32,\n  chainLength: r.uint32,\n  nFeatureEntries: r.uint32,\n  nSubtables: r.uint32,\n  features: new r.Array(FeatureEntry, 'nFeatureEntries'),\n  subtables: new r.Array(Subtable, 'nSubtables')\n});\nvar morx = new r.Struct({\n  version: r.uint16,\n  unused: new r.Reserved(r.uint16),\n  nChains: r.uint32,\n  chains: new r.Array(MorxChain, 'nChains')\n});\nvar OpticalBounds = new r.Struct({\n  left: r.int16,\n  top: r.int16,\n  right: r.int16,\n  bottom: r.int16\n});\nvar opbd = new r.Struct({\n  version: r.fixed32,\n  format: r.uint16,\n  lookupTable: new LookupTable(OpticalBounds)\n});\nvar tables = {}; // Required Tables\n\ntables.cmap = cmap;\ntables.head = head;\ntables.hhea = hhea;\ntables.hmtx = hmtx;\ntables.maxp = maxp;\ntables.name = NameTable;\ntables['OS/2'] = OS2;\ntables.post = post; // TrueType Outlines\n\ntables.fpgm = fpgm;\ntables.loca = loca;\ntables.prep = prep;\ntables['cvt '] = cvt;\ntables.glyf = glyf; // PostScript Outlines\n\ntables['CFF '] = CFFFont;\ntables['CFF2'] = CFFFont;\ntables.VORG = VORG; // Bitmap Glyphs\n\ntables.EBLC = EBLC;\ntables.CBLC = tables.EBLC;\ntables.sbix = sbix;\ntables.COLR = COLR;\ntables.CPAL = CPAL; // Advanced OpenType Tables\n\ntables.BASE = BASE;\ntables.GDEF = GDEF;\ntables.GPOS = GPOS;\ntables.GSUB = GSUB;\ntables.JSTF = JSTF; // OpenType variations tables\n\ntables.HVAR = HVAR; // Other OpenType Tables\n\ntables.DSIG = DSIG;\ntables.gasp = gasp;\ntables.hdmx = hdmx;\ntables.kern = kern;\ntables.LTSH = LTSH;\ntables.PCLT = PCLT;\ntables.VDMX = VDMX;\ntables.vhea = vhea;\ntables.vmtx = vmtx; // Apple Advanced Typography Tables\n\ntables.avar = avar;\ntables.bsln = bsln;\ntables.feat = feat;\ntables.fvar = fvar;\ntables.gvar = gvar;\ntables.just = just;\ntables.morx = morx;\ntables.opbd = opbd;\nvar TableEntry = new r.Struct({\n  tag: new r.String(4),\n  checkSum: r.uint32,\n  offset: new r.Pointer(r.uint32, 'void', {\n    type: 'global'\n  }),\n  length: r.uint32\n});\nvar Directory = new r.Struct({\n  tag: new r.String(4),\n  numTables: r.uint16,\n  searchRange: r.uint16,\n  entrySelector: r.uint16,\n  rangeShift: r.uint16,\n  tables: new r.Array(TableEntry, 'numTables')\n});\n\nDirectory.process = function () {\n  var tables = {};\n\n  for (var _iterator = this.tables, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _getIterator(_iterator);;) {\n    var _ref;\n\n    if (_isArray) {\n      if (_i >= _iterator.length) break;\n      _ref = _iterator[_i++];\n    } else {\n      _i = _iterator.next();\n      if (_i.done) break;\n      _ref = _i.value;\n    }\n\n    var table = _ref;\n    tables[table.tag] = table;\n  }\n\n  this.tables = tables;\n};\n\nDirectory.preEncode = function (stream) {\n  var tables$$ = [];\n\n  for (var tag in this.tables) {\n    var table = this.tables[tag];\n\n    if (table) {\n      tables$$.push({\n        tag: tag,\n        checkSum: 0,\n        offset: new r.VoidPointer(tables[tag], table),\n        length: tables[tag].size(table)\n      });\n    }\n  }\n\n  this.tag = 'true';\n  this.numTables = tables$$.length;\n  this.tables = tables$$;\n  var maxExponentFor2 = Math.floor(Math.log(this.numTables) / Math.LN2);\n  var maxPowerOf2 = Math.pow(2, maxExponentFor2);\n  this.searchRange = maxPowerOf2 * 16;\n  this.entrySelector = Math.log(maxPowerOf2) / Math.LN2;\n  this.rangeShift = this.numTables * 16 - this.searchRange;\n};\n\nfunction binarySearch(arr, cmp) {\n  var min = 0;\n  var max = arr.length - 1;\n\n  while (min <= max) {\n    var mid = min + max >> 1;\n    var res = cmp(arr[mid]);\n\n    if (res < 0) {\n      max = mid - 1;\n    } else if (res > 0) {\n      min = mid + 1;\n    } else {\n      return mid;\n    }\n  }\n\n  return -1;\n}\n\nfunction range(index, end) {\n  var range = [];\n\n  while (index < end) {\n    range.push(index++);\n  }\n\n  return range;\n}\n\nvar _class$1;\n\nfunction _applyDecoratedDescriptor$1(target, property, decorators, descriptor, context) {\n  var desc = {};\n  Object['ke' + 'ys'](descriptor).forEach(function (key) {\n    desc[key] = descriptor[key];\n  });\n  desc.enumerable = !!desc.enumerable;\n  desc.configurable = !!desc.configurable;\n\n  if ('value' in desc || desc.initializer) {\n    desc.writable = true;\n  }\n\n  desc = decorators.slice().reverse().reduce(function (desc, decorator) {\n    return decorator(target, property, desc) || desc;\n  }, desc);\n\n  if (context && desc.initializer !== void 0) {\n    desc.value = desc.initializer ? desc.initializer.call(context) : void 0;\n    desc.initializer = undefined;\n  }\n\n  if (desc.initializer === void 0) {\n    Object['define' + 'Property'](target, property, desc);\n    desc = null;\n  }\n\n  return desc;\n} // iconv-lite is an optional dependency.\n\n\ntry {\n  var iconv = require('iconv-lite');\n} catch (err) {}\n\nvar CmapProcessor = (_class$1 = function () {\n  function CmapProcessor(cmapTable) {\n    _classCallCheck(this, CmapProcessor); // Attempt to find a Unicode cmap first\n\n\n    this.encoding = null;\n    this.cmap = this.findSubtable(cmapTable, [// 32-bit subtables\n    [3, 10], [0, 6], [0, 4], // 16-bit subtables\n    [3, 1], [0, 3], [0, 2], [0, 1], [0, 0]]); // If not unicode cmap was found, and iconv-lite is installed,\n    // take the first table with a supported encoding.\n\n    if (!this.cmap && iconv) {\n      for (var _iterator = cmapTable.tables, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _getIterator(_iterator);;) {\n        var _ref;\n\n        if (_isArray) {\n          if (_i >= _iterator.length) break;\n          _ref = _iterator[_i++];\n        } else {\n          _i = _iterator.next();\n          if (_i.done) break;\n          _ref = _i.value;\n        }\n\n        var cmap = _ref;\n        var encoding = getEncoding(cmap.platformID, cmap.encodingID, cmap.table.language - 1);\n\n        if (iconv.encodingExists(encoding)) {\n          this.cmap = cmap.table;\n          this.encoding = encoding;\n        }\n      }\n    }\n\n    if (!this.cmap) {\n      throw new Error(\"Could not find a supported cmap table\");\n    }\n\n    this.uvs = this.findSubtable(cmapTable, [[0, 5]]);\n\n    if (this.uvs && this.uvs.version !== 14) {\n      this.uvs = null;\n    }\n  }\n\n  CmapProcessor.prototype.findSubtable = function findSubtable(cmapTable, pairs) {\n    for (var _iterator2 = pairs, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _getIterator(_iterator2);;) {\n      var _ref2;\n\n      if (_isArray2) {\n        if (_i2 >= _iterator2.length) break;\n        _ref2 = _iterator2[_i2++];\n      } else {\n        _i2 = _iterator2.next();\n        if (_i2.done) break;\n        _ref2 = _i2.value;\n      }\n\n      var _ref3 = _ref2,\n          platformID = _ref3[0],\n          encodingID = _ref3[1];\n\n      for (var _iterator3 = cmapTable.tables, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _getIterator(_iterator3);;) {\n        var _ref4;\n\n        if (_isArray3) {\n          if (_i3 >= _iterator3.length) break;\n          _ref4 = _iterator3[_i3++];\n        } else {\n          _i3 = _iterator3.next();\n          if (_i3.done) break;\n          _ref4 = _i3.value;\n        }\n\n        var cmap = _ref4;\n\n        if (cmap.platformID === platformID && cmap.encodingID === encodingID) {\n          return cmap.table;\n        }\n      }\n    }\n\n    return null;\n  };\n\n  CmapProcessor.prototype.lookup = function lookup(codepoint, variationSelector) {\n    // If there is no Unicode cmap in this font, we need to re-encode\n    // the codepoint in the encoding that the cmap supports.\n    if (this.encoding) {\n      var buf = iconv.encode(_String$fromCodePoint(codepoint), this.encoding);\n      codepoint = 0;\n\n      for (var i = 0; i < buf.length; i++) {\n        codepoint = codepoint << 8 | buf[i];\n      } // Otherwise, try to get a Unicode variation selector for this codepoint if one is provided.\n\n    } else if (variationSelector) {\n      var gid = this.getVariationSelector(codepoint, variationSelector);\n\n      if (gid) {\n        return gid;\n      }\n    }\n\n    var cmap = this.cmap;\n\n    switch (cmap.version) {\n      case 0:\n        return cmap.codeMap.get(codepoint) || 0;\n\n      case 4:\n        {\n          var min = 0;\n          var max = cmap.segCount - 1;\n\n          while (min <= max) {\n            var mid = min + max >> 1;\n\n            if (codepoint < cmap.startCode.get(mid)) {\n              max = mid - 1;\n            } else if (codepoint > cmap.endCode.get(mid)) {\n              min = mid + 1;\n            } else {\n              var rangeOffset = cmap.idRangeOffset.get(mid);\n\n              var _gid = void 0;\n\n              if (rangeOffset === 0) {\n                _gid = codepoint + cmap.idDelta.get(mid);\n              } else {\n                var index = rangeOffset / 2 + (codepoint - cmap.startCode.get(mid)) - (cmap.segCount - mid);\n                _gid = cmap.glyphIndexArray.get(index) || 0;\n\n                if (_gid !== 0) {\n                  _gid += cmap.idDelta.get(mid);\n                }\n              }\n\n              return _gid & 0xffff;\n            }\n          }\n\n          return 0;\n        }\n\n      case 8:\n        throw new Error('TODO: cmap format 8');\n\n      case 6:\n      case 10:\n        return cmap.glyphIndices.get(codepoint - cmap.firstCode) || 0;\n\n      case 12:\n      case 13:\n        {\n          var _min = 0;\n\n          var _max = cmap.nGroups - 1;\n\n          while (_min <= _max) {\n            var _mid = _min + _max >> 1;\n\n            var group = cmap.groups.get(_mid);\n\n            if (codepoint < group.startCharCode) {\n              _max = _mid - 1;\n            } else if (codepoint > group.endCharCode) {\n              _min = _mid + 1;\n            } else {\n              if (cmap.version === 12) {\n                return group.glyphID + (codepoint - group.startCharCode);\n              } else {\n                return group.glyphID;\n              }\n            }\n          }\n\n          return 0;\n        }\n\n      case 14:\n        throw new Error('TODO: cmap format 14');\n\n      default:\n        throw new Error('Unknown cmap format ' + cmap.version);\n    }\n  };\n\n  CmapProcessor.prototype.getVariationSelector = function getVariationSelector(codepoint, variationSelector) {\n    if (!this.uvs) {\n      return 0;\n    }\n\n    var selectors = this.uvs.varSelectors.toArray();\n    var i = binarySearch(selectors, function (x) {\n      return variationSelector - x.varSelector;\n    });\n    var sel = selectors[i];\n\n    if (i !== -1 && sel.defaultUVS) {\n      i = binarySearch(sel.defaultUVS, function (x) {\n        return codepoint < x.startUnicodeValue ? -1 : codepoint > x.startUnicodeValue + x.additionalCount ? +1 : 0;\n      });\n    }\n\n    if (i !== -1 && sel.nonDefaultUVS) {\n      i = binarySearch(sel.nonDefaultUVS, function (x) {\n        return codepoint - x.unicodeValue;\n      });\n\n      if (i !== -1) {\n        return sel.nonDefaultUVS[i].glyphID;\n      }\n    }\n\n    return 0;\n  };\n\n  CmapProcessor.prototype.getCharacterSet = function getCharacterSet() {\n    var cmap = this.cmap;\n\n    switch (cmap.version) {\n      case 0:\n        return range(0, cmap.codeMap.length);\n\n      case 4:\n        {\n          var res = [];\n          var endCodes = cmap.endCode.toArray();\n\n          for (var i = 0; i < endCodes.length; i++) {\n            var tail = endCodes[i] + 1;\n            var start = cmap.startCode.get(i);\n            res.push.apply(res, range(start, tail));\n          }\n\n          return res;\n        }\n\n      case 8:\n        throw new Error('TODO: cmap format 8');\n\n      case 6:\n      case 10:\n        return range(cmap.firstCode, cmap.firstCode + cmap.glyphIndices.length);\n\n      case 12:\n      case 13:\n        {\n          var _res = [];\n\n          for (var _iterator4 = cmap.groups.toArray(), _isArray4 = Array.isArray(_iterator4), _i4 = 0, _iterator4 = _isArray4 ? _iterator4 : _getIterator(_iterator4);;) {\n            var _ref5;\n\n            if (_isArray4) {\n              if (_i4 >= _iterator4.length) break;\n              _ref5 = _iterator4[_i4++];\n            } else {\n              _i4 = _iterator4.next();\n              if (_i4.done) break;\n              _ref5 = _i4.value;\n            }\n\n            var group = _ref5;\n\n            _res.push.apply(_res, range(group.startCharCode, group.endCharCode + 1));\n          }\n\n          return _res;\n        }\n\n      case 14:\n        throw new Error('TODO: cmap format 14');\n\n      default:\n        throw new Error('Unknown cmap format ' + cmap.version);\n    }\n  };\n\n  CmapProcessor.prototype.codePointsForGlyph = function codePointsForGlyph(gid) {\n    var cmap = this.cmap;\n\n    switch (cmap.version) {\n      case 0:\n        {\n          var res = [];\n\n          for (var i = 0; i < 256; i++) {\n            if (cmap.codeMap.get(i) === gid) {\n              res.push(i);\n            }\n          }\n\n          return res;\n        }\n\n      case 4:\n        {\n          var _res2 = [];\n\n          for (var _i5 = 0; _i5 < cmap.segCount; _i5++) {\n            var end = cmap.endCode.get(_i5);\n            var start = cmap.startCode.get(_i5);\n            var rangeOffset = cmap.idRangeOffset.get(_i5);\n            var delta = cmap.idDelta.get(_i5);\n\n            for (var c = start; c <= end; c++) {\n              var g = 0;\n\n              if (rangeOffset === 0) {\n                g = c + delta;\n              } else {\n                var index = rangeOffset / 2 + (c - start) - (cmap.segCount - _i5);\n                g = cmap.glyphIndexArray.get(index) || 0;\n\n                if (g !== 0) {\n                  g += delta;\n                }\n              }\n\n              if (g === gid) {\n                _res2.push(c);\n              }\n            }\n          }\n\n          return _res2;\n        }\n\n      case 12:\n        {\n          var _res3 = [];\n\n          for (var _iterator5 = cmap.groups.toArray(), _isArray5 = Array.isArray(_iterator5), _i6 = 0, _iterator5 = _isArray5 ? _iterator5 : _getIterator(_iterator5);;) {\n            var _ref6;\n\n            if (_isArray5) {\n              if (_i6 >= _iterator5.length) break;\n              _ref6 = _iterator5[_i6++];\n            } else {\n              _i6 = _iterator5.next();\n              if (_i6.done) break;\n              _ref6 = _i6.value;\n            }\n\n            var group = _ref6;\n\n            if (gid >= group.glyphID && gid <= group.glyphID + (group.endCharCode - group.startCharCode)) {\n              _res3.push(group.startCharCode + (gid - group.glyphID));\n            }\n          }\n\n          return _res3;\n        }\n\n      case 13:\n        {\n          var _res4 = [];\n\n          for (var _iterator6 = cmap.groups.toArray(), _isArray6 = Array.isArray(_iterator6), _i7 = 0, _iterator6 = _isArray6 ? _iterator6 : _getIterator(_iterator6);;) {\n            var _ref7;\n\n            if (_isArray6) {\n              if (_i7 >= _iterator6.length) break;\n              _ref7 = _iterator6[_i7++];\n            } else {\n              _i7 = _iterator6.next();\n              if (_i7.done) break;\n              _ref7 = _i7.value;\n            }\n\n            var _group = _ref7;\n\n            if (gid === _group.glyphID) {\n              _res4.push.apply(_res4, range(_group.startCharCode, _group.endCharCode + 1));\n            }\n          }\n\n          return _res4;\n        }\n\n      default:\n        throw new Error('Unknown cmap format ' + cmap.version);\n    }\n  };\n\n  return CmapProcessor;\n}(), (_applyDecoratedDescriptor$1(_class$1.prototype, 'getCharacterSet', [cache], _Object$getOwnPropertyDescriptor(_class$1.prototype, 'getCharacterSet'), _class$1.prototype), _applyDecoratedDescriptor$1(_class$1.prototype, 'codePointsForGlyph', [cache], _Object$getOwnPropertyDescriptor(_class$1.prototype, 'codePointsForGlyph'), _class$1.prototype)), _class$1);\n\nvar KernProcessor = function () {\n  function KernProcessor(font) {\n    _classCallCheck(this, KernProcessor);\n\n    this.kern = font.kern;\n  }\n\n  KernProcessor.prototype.process = function process(glyphs, positions) {\n    for (var glyphIndex = 0; glyphIndex < glyphs.length - 1; glyphIndex++) {\n      var left = glyphs[glyphIndex].id;\n      var right = glyphs[glyphIndex + 1].id;\n      positions[glyphIndex].xAdvance += this.getKerning(left, right);\n    }\n  };\n\n  KernProcessor.prototype.getKerning = function getKerning(left, right) {\n    var res = 0;\n\n    for (var _iterator = this.kern.tables, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _getIterator(_iterator);;) {\n      var _ref;\n\n      if (_isArray) {\n        if (_i >= _iterator.length) break;\n        _ref = _iterator[_i++];\n      } else {\n        _i = _iterator.next();\n        if (_i.done) break;\n        _ref = _i.value;\n      }\n\n      var table = _ref;\n\n      if (table.coverage.crossStream) {\n        continue;\n      }\n\n      switch (table.version) {\n        case 0:\n          if (!table.coverage.horizontal) {\n            continue;\n          }\n\n          break;\n\n        case 1:\n          if (table.coverage.vertical || table.coverage.variation) {\n            continue;\n          }\n\n          break;\n\n        default:\n          throw new Error('Unsupported kerning table version ' + table.version);\n      }\n\n      var val = 0;\n      var s = table.subtable;\n\n      switch (table.format) {\n        case 0:\n          var pairIdx = binarySearch(s.pairs, function (pair) {\n            return left - pair.left || right - pair.right;\n          });\n\n          if (pairIdx >= 0) {\n            val = s.pairs[pairIdx].value;\n          }\n\n          break;\n\n        case 2:\n          var leftOffset = 0,\n              rightOffset = 0;\n\n          if (left >= s.leftTable.firstGlyph && left < s.leftTable.firstGlyph + s.leftTable.nGlyphs) {\n            leftOffset = s.leftTable.offsets[left - s.leftTable.firstGlyph];\n          } else {\n            leftOffset = s.array.off;\n          }\n\n          if (right >= s.rightTable.firstGlyph && right < s.rightTable.firstGlyph + s.rightTable.nGlyphs) {\n            rightOffset = s.rightTable.offsets[right - s.rightTable.firstGlyph];\n          }\n\n          var index = (leftOffset + rightOffset - s.array.off) / 2;\n          val = s.array.values.get(index);\n          break;\n\n        case 3:\n          if (left >= s.glyphCount || right >= s.glyphCount) {\n            return 0;\n          }\n\n          val = s.kernValue[s.kernIndex[s.leftClass[left] * s.rightClassCount + s.rightClass[right]]];\n          break;\n\n        default:\n          throw new Error('Unsupported kerning sub-table format ' + table.format);\n      } // Microsoft supports the override flag, which resets the result\n      // Otherwise, the sum of the results from all subtables is returned\n\n\n      if (table.coverage.override) {\n        res = val;\n      } else {\n        res += val;\n      }\n    }\n\n    return res;\n  };\n\n  return KernProcessor;\n}();\n/**\n * This class is used when GPOS does not define 'mark' or 'mkmk' features\n * for positioning marks relative to base glyphs. It uses the unicode\n * combining class property to position marks.\n *\n * Based on code from Harfbuzz, thanks!\n * https://github.com/behdad/harfbuzz/blob/master/src/hb-ot-shape-fallback.cc\n */\n\n\nvar UnicodeLayoutEngine = function () {\n  function UnicodeLayoutEngine(font) {\n    _classCallCheck(this, UnicodeLayoutEngine);\n\n    this.font = font;\n  }\n\n  UnicodeLayoutEngine.prototype.positionGlyphs = function positionGlyphs(glyphs, positions) {\n    // find each base + mark cluster, and position the marks relative to the base\n    var clusterStart = 0;\n    var clusterEnd = 0;\n\n    for (var index = 0; index < glyphs.length; index++) {\n      var glyph = glyphs[index];\n\n      if (glyph.isMark) {\n        // TODO: handle ligatures\n        clusterEnd = index;\n      } else {\n        if (clusterStart !== clusterEnd) {\n          this.positionCluster(glyphs, positions, clusterStart, clusterEnd);\n        }\n\n        clusterStart = clusterEnd = index;\n      }\n    }\n\n    if (clusterStart !== clusterEnd) {\n      this.positionCluster(glyphs, positions, clusterStart, clusterEnd);\n    }\n\n    return positions;\n  };\n\n  UnicodeLayoutEngine.prototype.positionCluster = function positionCluster(glyphs, positions, clusterStart, clusterEnd) {\n    var base = glyphs[clusterStart];\n    var baseBox = base.cbox.copy(); // adjust bounding box for ligature glyphs\n\n    if (base.codePoints.length > 1) {\n      // LTR. TODO: RTL support.\n      baseBox.minX += (base.codePoints.length - 1) * baseBox.width / base.codePoints.length;\n    }\n\n    var xOffset = -positions[clusterStart].xAdvance;\n    var yOffset = 0;\n    var yGap = this.font.unitsPerEm / 16; // position each of the mark glyphs relative to the base glyph\n\n    for (var index = clusterStart + 1; index <= clusterEnd; index++) {\n      var mark = glyphs[index];\n      var markBox = mark.cbox;\n      var position = positions[index];\n      var combiningClass = this.getCombiningClass(mark.codePoints[0]);\n\n      if (combiningClass !== 'Not_Reordered') {\n        position.xOffset = position.yOffset = 0; // x positioning\n\n        switch (combiningClass) {\n          case 'Double_Above':\n          case 'Double_Below':\n            // LTR. TODO: RTL support.\n            position.xOffset += baseBox.minX - markBox.width / 2 - markBox.minX;\n            break;\n\n          case 'Attached_Below_Left':\n          case 'Below_Left':\n          case 'Above_Left':\n            // left align\n            position.xOffset += baseBox.minX - markBox.minX;\n            break;\n\n          case 'Attached_Above_Right':\n          case 'Below_Right':\n          case 'Above_Right':\n            // right align\n            position.xOffset += baseBox.maxX - markBox.width - markBox.minX;\n            break;\n\n          default:\n            // Attached_Below, Attached_Above, Below, Above, other\n            // center align\n            position.xOffset += baseBox.minX + (baseBox.width - markBox.width) / 2 - markBox.minX;\n        } // y positioning\n\n\n        switch (combiningClass) {\n          case 'Double_Below':\n          case 'Below_Left':\n          case 'Below':\n          case 'Below_Right':\n          case 'Attached_Below_Left':\n          case 'Attached_Below':\n            // add a small gap between the glyphs if they are not attached\n            if (combiningClass === 'Attached_Below_Left' || combiningClass === 'Attached_Below') {\n              baseBox.minY += yGap;\n            }\n\n            position.yOffset = -baseBox.minY - markBox.maxY;\n            baseBox.minY += markBox.height;\n            break;\n\n          case 'Double_Above':\n          case 'Above_Left':\n          case 'Above':\n          case 'Above_Right':\n          case 'Attached_Above':\n          case 'Attached_Above_Right':\n            // add a small gap between the glyphs if they are not attached\n            if (combiningClass === 'Attached_Above' || combiningClass === 'Attached_Above_Right') {\n              baseBox.maxY += yGap;\n            }\n\n            position.yOffset = baseBox.maxY - markBox.minY;\n            baseBox.maxY += markBox.height;\n            break;\n        }\n\n        position.xAdvance = position.yAdvance = 0;\n        position.xOffset += xOffset;\n        position.yOffset += yOffset;\n      } else {\n        xOffset -= position.xAdvance;\n        yOffset -= position.yAdvance;\n      }\n    }\n\n    return;\n  };\n\n  UnicodeLayoutEngine.prototype.getCombiningClass = function getCombiningClass(codePoint) {\n    var combiningClass = unicode.getCombiningClass(codePoint); // Thai / Lao need some per-character work\n\n    if ((codePoint & ~0xff) === 0x0e00) {\n      if (combiningClass === 'Not_Reordered') {\n        switch (codePoint) {\n          case 0x0e31:\n          case 0x0e34:\n          case 0x0e35:\n          case 0x0e36:\n          case 0x0e37:\n          case 0x0e47:\n          case 0x0e4c:\n          case 0x0e3d:\n          case 0x0e4e:\n            return 'Above_Right';\n\n          case 0x0eb1:\n          case 0x0eb4:\n          case 0x0eb5:\n          case 0x0eb6:\n          case 0x0eb7:\n          case 0x0ebb:\n          case 0x0ecc:\n          case 0x0ecd:\n            return 'Above';\n\n          case 0x0ebc:\n            return 'Below';\n        }\n      } else if (codePoint === 0x0e3a) {\n        // virama\n        return 'Below_Right';\n      }\n    }\n\n    switch (combiningClass) {\n      // Hebrew\n      case 'CCC10': // sheva\n\n      case 'CCC11': // hataf segol\n\n      case 'CCC12': // hataf patah\n\n      case 'CCC13': // hataf qamats\n\n      case 'CCC14': // hiriq\n\n      case 'CCC15': // tsere\n\n      case 'CCC16': // segol\n\n      case 'CCC17': // patah\n\n      case 'CCC18': // qamats\n\n      case 'CCC20': // qubuts\n\n      case 'CCC22':\n        // meteg\n        return 'Below';\n\n      case 'CCC23':\n        // rafe\n        return 'Attached_Above';\n\n      case 'CCC24':\n        // shin dot\n        return 'Above_Right';\n\n      case 'CCC25': // sin dot\n\n      case 'CCC19':\n        // holam\n        return 'Above_Left';\n\n      case 'CCC26':\n        // point varika\n        return 'Above';\n\n      case 'CCC21':\n        // dagesh\n        break;\n      // Arabic and Syriac\n\n      case 'CCC27': // fathatan\n\n      case 'CCC28': // dammatan\n\n      case 'CCC30': // fatha\n\n      case 'CCC31': // damma\n\n      case 'CCC33': // shadda\n\n      case 'CCC34': // sukun\n\n      case 'CCC35': // superscript alef\n\n      case 'CCC36':\n        // superscript alaph\n        return 'Above';\n\n      case 'CCC29': // kasratan\n\n      case 'CCC32':\n        // kasra\n        return 'Below';\n      // Thai\n\n      case 'CCC103':\n        // sara u / sara uu\n        return 'Below_Right';\n\n      case 'CCC107':\n        // mai\n        return 'Above_Right';\n      // Lao\n\n      case 'CCC118':\n        // sign u / sign uu\n        return 'Below';\n\n      case 'CCC122':\n        // mai\n        return 'Above';\n      // Tibetan\n\n      case 'CCC129': // sign aa\n\n      case 'CCC132':\n        // sign u\n        return 'Below';\n\n      case 'CCC130':\n        // sign i\n        return 'Above';\n    }\n\n    return combiningClass;\n  };\n\n  return UnicodeLayoutEngine;\n}();\n/**\n * Represents a glyph bounding box\n */\n\n\nvar BBox = function () {\n  function BBox() {\n    var minX = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Infinity;\n    var minY = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Infinity;\n    var maxX = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -Infinity;\n    var maxY = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : -Infinity;\n\n    _classCallCheck(this, BBox);\n    /**\n     * The minimum X position in the bounding box\n     * @type {number}\n     */\n\n\n    this.minX = minX;\n    /**\n     * The minimum Y position in the bounding box\n     * @type {number}\n     */\n\n    this.minY = minY;\n    /**\n     * The maxmimum X position in the bounding box\n     * @type {number}\n     */\n\n    this.maxX = maxX;\n    /**\n     * The maxmimum Y position in the bounding box\n     * @type {number}\n     */\n\n    this.maxY = maxY;\n  }\n  /**\n   * The width of the bounding box\n   * @type {number}\n   */\n\n\n  BBox.prototype.addPoint = function addPoint(x, y) {\n    if (Math.abs(x) !== Infinity) {\n      if (x < this.minX) {\n        this.minX = x;\n      }\n\n      if (x > this.maxX) {\n        this.maxX = x;\n      }\n    }\n\n    if (Math.abs(y) !== Infinity) {\n      if (y < this.minY) {\n        this.minY = y;\n      }\n\n      if (y > this.maxY) {\n        this.maxY = y;\n      }\n    }\n  };\n\n  BBox.prototype.copy = function copy() {\n    return new BBox(this.minX, this.minY, this.maxX, this.maxY);\n  };\n\n  _createClass(BBox, [{\n    key: \"width\",\n    get: function get() {\n      return this.maxX - this.minX;\n    }\n    /**\n     * The height of the bounding box\n     * @type {number}\n     */\n\n  }, {\n    key: \"height\",\n    get: function get() {\n      return this.maxY - this.minY;\n    }\n  }]);\n\n  return BBox;\n}(); // This maps the Unicode Script property to an OpenType script tag\n// Data from http://www.microsoft.com/typography/otspec/scripttags.htm\n// and http://www.unicode.org/Public/UNIDATA/PropertyValueAliases.txt.\n\n\nvar UNICODE_SCRIPTS = {\n  Caucasian_Albanian: 'aghb',\n  Arabic: 'arab',\n  Imperial_Aramaic: 'armi',\n  Armenian: 'armn',\n  Avestan: 'avst',\n  Balinese: 'bali',\n  Bamum: 'bamu',\n  Bassa_Vah: 'bass',\n  Batak: 'batk',\n  Bengali: ['bng2', 'beng'],\n  Bopomofo: 'bopo',\n  Brahmi: 'brah',\n  Braille: 'brai',\n  Buginese: 'bugi',\n  Buhid: 'buhd',\n  Chakma: 'cakm',\n  Canadian_Aboriginal: 'cans',\n  Carian: 'cari',\n  Cham: 'cham',\n  Cherokee: 'cher',\n  Coptic: 'copt',\n  Cypriot: 'cprt',\n  Cyrillic: 'cyrl',\n  Devanagari: ['dev2', 'deva'],\n  Deseret: 'dsrt',\n  Duployan: 'dupl',\n  Egyptian_Hieroglyphs: 'egyp',\n  Elbasan: 'elba',\n  Ethiopic: 'ethi',\n  Georgian: 'geor',\n  Glagolitic: 'glag',\n  Gothic: 'goth',\n  Grantha: 'gran',\n  Greek: 'grek',\n  Gujarati: ['gjr2', 'gujr'],\n  Gurmukhi: ['gur2', 'guru'],\n  Hangul: 'hang',\n  Han: 'hani',\n  Hanunoo: 'hano',\n  Hebrew: 'hebr',\n  Hiragana: 'hira',\n  Pahawh_Hmong: 'hmng',\n  Katakana_Or_Hiragana: 'hrkt',\n  Old_Italic: 'ital',\n  Javanese: 'java',\n  Kayah_Li: 'kali',\n  Katakana: 'kana',\n  Kharoshthi: 'khar',\n  Khmer: 'khmr',\n  Khojki: 'khoj',\n  Kannada: ['knd2', 'knda'],\n  Kaithi: 'kthi',\n  Tai_Tham: 'lana',\n  Lao: 'lao ',\n  Latin: 'latn',\n  Lepcha: 'lepc',\n  Limbu: 'limb',\n  Linear_A: 'lina',\n  Linear_B: 'linb',\n  Lisu: 'lisu',\n  Lycian: 'lyci',\n  Lydian: 'lydi',\n  Mahajani: 'mahj',\n  Mandaic: 'mand',\n  Manichaean: 'mani',\n  Mende_Kikakui: 'mend',\n  Meroitic_Cursive: 'merc',\n  Meroitic_Hieroglyphs: 'mero',\n  Malayalam: ['mlm2', 'mlym'],\n  Modi: 'modi',\n  Mongolian: 'mong',\n  Mro: 'mroo',\n  Meetei_Mayek: 'mtei',\n  Myanmar: ['mym2', 'mymr'],\n  Old_North_Arabian: 'narb',\n  Nabataean: 'nbat',\n  Nko: 'nko ',\n  Ogham: 'ogam',\n  Ol_Chiki: 'olck',\n  Old_Turkic: 'orkh',\n  Oriya: ['ory2', 'orya'],\n  Osmanya: 'osma',\n  Palmyrene: 'palm',\n  Pau_Cin_Hau: 'pauc',\n  Old_Permic: 'perm',\n  Phags_Pa: 'phag',\n  Inscriptional_Pahlavi: 'phli',\n  Psalter_Pahlavi: 'phlp',\n  Phoenician: 'phnx',\n  Miao: 'plrd',\n  Inscriptional_Parthian: 'prti',\n  Rejang: 'rjng',\n  Runic: 'runr',\n  Samaritan: 'samr',\n  Old_South_Arabian: 'sarb',\n  Saurashtra: 'saur',\n  Shavian: 'shaw',\n  Sharada: 'shrd',\n  Siddham: 'sidd',\n  Khudawadi: 'sind',\n  Sinhala: 'sinh',\n  Sora_Sompeng: 'sora',\n  Sundanese: 'sund',\n  Syloti_Nagri: 'sylo',\n  Syriac: 'syrc',\n  Tagbanwa: 'tagb',\n  Takri: 'takr',\n  Tai_Le: 'tale',\n  New_Tai_Lue: 'talu',\n  Tamil: ['tml2', 'taml'],\n  Tai_Viet: 'tavt',\n  Telugu: ['tel2', 'telu'],\n  Tifinagh: 'tfng',\n  Tagalog: 'tglg',\n  Thaana: 'thaa',\n  Thai: 'thai',\n  Tibetan: 'tibt',\n  Tirhuta: 'tirh',\n  Ugaritic: 'ugar',\n  Vai: 'vai ',\n  Warang_Citi: 'wara',\n  Old_Persian: 'xpeo',\n  Cuneiform: 'xsux',\n  Yi: 'yi  ',\n  Inherited: 'zinh',\n  Common: 'zyyy',\n  Unknown: 'zzzz'\n};\nvar OPENTYPE_SCRIPTS = {};\n\nfor (var script in UNICODE_SCRIPTS) {\n  var tag = UNICODE_SCRIPTS[script];\n\n  if (Array.isArray(tag)) {\n    for (var _iterator = tag, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _getIterator(_iterator);;) {\n      var _ref;\n\n      if (_isArray) {\n        if (_i >= _iterator.length) break;\n        _ref = _iterator[_i++];\n      } else {\n        _i = _iterator.next();\n        if (_i.done) break;\n        _ref = _i.value;\n      }\n\n      var t = _ref;\n      OPENTYPE_SCRIPTS[t] = script;\n    }\n  } else {\n    OPENTYPE_SCRIPTS[tag] = script;\n  }\n}\n\nfunction fromOpenType(tag) {\n  return OPENTYPE_SCRIPTS[tag];\n}\n\nfunction forString(string) {\n  var len = string.length;\n  var idx = 0;\n\n  while (idx < len) {\n    var code = string.charCodeAt(idx++); // Check if this is a high surrogate\n\n    if (0xd800 <= code && code <= 0xdbff && idx < len) {\n      var next = string.charCodeAt(idx); // Check if this is a low surrogate\n\n      if (0xdc00 <= next && next <= 0xdfff) {\n        idx++;\n        code = ((code & 0x3FF) << 10) + (next & 0x3FF) + 0x10000;\n      }\n    }\n\n    var _script = unicode.getScript(code);\n\n    if (_script !== 'Common' && _script !== 'Inherited' && _script !== 'Unknown') {\n      return UNICODE_SCRIPTS[_script];\n    }\n  }\n\n  return UNICODE_SCRIPTS.Unknown;\n}\n\nfunction forCodePoints(codePoints) {\n  for (var i = 0; i < codePoints.length; i++) {\n    var codePoint = codePoints[i];\n\n    var _script2 = unicode.getScript(codePoint);\n\n    if (_script2 !== 'Common' && _script2 !== 'Inherited' && _script2 !== 'Unknown') {\n      return UNICODE_SCRIPTS[_script2];\n    }\n  }\n\n  return UNICODE_SCRIPTS.Unknown;\n} // The scripts in this map are written from right to left\n\n\nvar RTL = {\n  arab: true,\n  // Arabic\n  hebr: true,\n  // Hebrew\n  syrc: true,\n  // Syriac\n  thaa: true,\n  // Thaana\n  cprt: true,\n  // Cypriot Syllabary\n  khar: true,\n  // Kharosthi\n  phnx: true,\n  // Phoenician\n  'nko ': true,\n  // N'Ko\n  lydi: true,\n  // Lydian\n  avst: true,\n  // Avestan\n  armi: true,\n  // Imperial Aramaic\n  phli: true,\n  // Inscriptional Pahlavi\n  prti: true,\n  // Inscriptional Parthian\n  sarb: true,\n  // Old South Arabian\n  orkh: true,\n  // Old Turkic, Orkhon Runic\n  samr: true,\n  // Samaritan\n  mand: true,\n  // Mandaic, Mandaean\n  merc: true,\n  // Meroitic Cursive\n  mero: true,\n  // Meroitic Hieroglyphs\n  // Unicode 7.0 (not listed on http://www.microsoft.com/typography/otspec/scripttags.htm)\n  mani: true,\n  // Manichaean\n  mend: true,\n  // Mende Kikakui\n  nbat: true,\n  // Nabataean\n  narb: true,\n  // Old North Arabian\n  palm: true,\n  // Palmyrene\n  phlp: true // Psalter Pahlavi\n\n};\n\nfunction direction(script) {\n  if (RTL[script]) {\n    return 'rtl';\n  }\n\n  return 'ltr';\n}\n/**\n * Represents a run of Glyph and GlyphPosition objects.\n * Returned by the font layout method.\n */\n\n\nvar GlyphRun = function () {\n  function GlyphRun(glyphs, features, script, language, direction$$) {\n    _classCallCheck(this, GlyphRun);\n    /**\n     * An array of Glyph objects in the run\n     * @type {Glyph[]}\n     */\n\n\n    this.glyphs = glyphs;\n    /**\n     * An array of GlyphPosition objects for each glyph in the run\n     * @type {GlyphPosition[]}\n     */\n\n    this.positions = null;\n    /**\n     * The script that was requested for shaping. This was either passed in or detected automatically.\n     * @type {string}\n     */\n\n    this.script = script;\n    /**\n     * The language requested for shaping, as passed in. If `null`, the default language for the\n     * script was used.\n     * @type {string}\n     */\n\n    this.language = language || null;\n    /**\n     * The direction requested for shaping, as passed in (either ltr or rtl).\n     * If `null`, the default direction of the script is used.\n     * @type {string}\n     */\n\n    this.direction = direction$$ || direction(script);\n    /**\n     * The features requested during shaping. This is a combination of user\n     * specified features and features chosen by the shaper.\n     * @type {object}\n     */\n\n    this.features = {}; // Convert features to an object\n\n    if (Array.isArray(features)) {\n      for (var _iterator = features, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _getIterator(_iterator);;) {\n        var _ref;\n\n        if (_isArray) {\n          if (_i >= _iterator.length) break;\n          _ref = _iterator[_i++];\n        } else {\n          _i = _iterator.next();\n          if (_i.done) break;\n          _ref = _i.value;\n        }\n\n        var tag = _ref;\n        this.features[tag] = true;\n      }\n    } else if ((typeof features === 'undefined' ? 'undefined' : _typeof(features)) === 'object') {\n      this.features = features;\n    }\n  }\n  /**\n   * The total advance width of the run.\n   * @type {number}\n   */\n\n\n  _createClass(GlyphRun, [{\n    key: 'advanceWidth',\n    get: function get() {\n      var width = 0;\n\n      for (var _iterator2 = this.positions, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _getIterator(_iterator2);;) {\n        var _ref2;\n\n        if (_isArray2) {\n          if (_i2 >= _iterator2.length) break;\n          _ref2 = _iterator2[_i2++];\n        } else {\n          _i2 = _iterator2.next();\n          if (_i2.done) break;\n          _ref2 = _i2.value;\n        }\n\n        var position = _ref2;\n        width += position.xAdvance;\n      }\n\n      return width;\n    }\n    /**\n     * The total advance height of the run.\n     * @type {number}\n     */\n\n  }, {\n    key: 'advanceHeight',\n    get: function get() {\n      var height = 0;\n\n      for (var _iterator3 = this.positions, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _getIterator(_iterator3);;) {\n        var _ref3;\n\n        if (_isArray3) {\n          if (_i3 >= _iterator3.length) break;\n          _ref3 = _iterator3[_i3++];\n        } else {\n          _i3 = _iterator3.next();\n          if (_i3.done) break;\n          _ref3 = _i3.value;\n        }\n\n        var position = _ref3;\n        height += position.yAdvance;\n      }\n\n      return height;\n    }\n    /**\n     * The bounding box containing all glyphs in the run.\n     * @type {BBox}\n     */\n\n  }, {\n    key: 'bbox',\n    get: function get() {\n      var bbox = new BBox();\n      var x = 0;\n      var y = 0;\n\n      for (var index = 0; index < this.glyphs.length; index++) {\n        var glyph = this.glyphs[index];\n        var p = this.positions[index];\n        var b = glyph.bbox;\n        bbox.addPoint(b.minX + x + p.xOffset, b.minY + y + p.yOffset);\n        bbox.addPoint(b.maxX + x + p.xOffset, b.maxY + y + p.yOffset);\n        x += p.xAdvance;\n        y += p.yAdvance;\n      }\n\n      return bbox;\n    }\n  }]);\n\n  return GlyphRun;\n}();\n/**\n * Represents positioning information for a glyph in a GlyphRun.\n */\n\n\nvar GlyphPosition = function GlyphPosition() {\n  var xAdvance = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n  var yAdvance = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  var xOffset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  var yOffset = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n\n  _classCallCheck(this, GlyphPosition);\n  /**\n   * The amount to move the virtual pen in the X direction after rendering this glyph.\n   * @type {number}\n   */\n\n\n  this.xAdvance = xAdvance;\n  /**\n   * The amount to move the virtual pen in the Y direction after rendering this glyph.\n   * @type {number}\n   */\n\n  this.yAdvance = yAdvance;\n  /**\n   * The offset from the pen position in the X direction at which to render this glyph.\n   * @type {number}\n   */\n\n  this.xOffset = xOffset;\n  /**\n   * The offset from the pen position in the Y direction at which to render this glyph.\n   * @type {number}\n   */\n\n  this.yOffset = yOffset;\n}; // see https://developer.apple.com/fonts/TrueType-Reference-Manual/RM09/AppendixF.html\n// and /System/Library/Frameworks/CoreText.framework/Versions/A/Headers/SFNTLayoutTypes.h on a Mac\n\n\nvar features = {\n  allTypographicFeatures: {\n    code: 0,\n    exclusive: false,\n    allTypeFeatures: 0\n  },\n  ligatures: {\n    code: 1,\n    exclusive: false,\n    requiredLigatures: 0,\n    commonLigatures: 2,\n    rareLigatures: 4,\n    // logos: 6\n    rebusPictures: 8,\n    diphthongLigatures: 10,\n    squaredLigatures: 12,\n    abbrevSquaredLigatures: 14,\n    symbolLigatures: 16,\n    contextualLigatures: 18,\n    historicalLigatures: 20\n  },\n  cursiveConnection: {\n    code: 2,\n    exclusive: true,\n    unconnected: 0,\n    partiallyConnected: 1,\n    cursive: 2\n  },\n  letterCase: {\n    code: 3,\n    exclusive: true\n  },\n  // upperAndLowerCase: 0          # deprecated\n  // allCaps: 1                    # deprecated\n  // allLowerCase: 2               # deprecated\n  // smallCaps: 3                  # deprecated\n  // initialCaps: 4                # deprecated\n  // initialCapsAndSmallCaps: 5    # deprecated\n  verticalSubstitution: {\n    code: 4,\n    exclusive: false,\n    substituteVerticalForms: 0\n  },\n  linguisticRearrangement: {\n    code: 5,\n    exclusive: false,\n    linguisticRearrangement: 0\n  },\n  numberSpacing: {\n    code: 6,\n    exclusive: true,\n    monospacedNumbers: 0,\n    proportionalNumbers: 1,\n    thirdWidthNumbers: 2,\n    quarterWidthNumbers: 3\n  },\n  smartSwash: {\n    code: 8,\n    exclusive: false,\n    wordInitialSwashes: 0,\n    wordFinalSwashes: 2,\n    // lineInitialSwashes: 4\n    // lineFinalSwashes: 6\n    nonFinalSwashes: 8\n  },\n  diacritics: {\n    code: 9,\n    exclusive: true,\n    showDiacritics: 0,\n    hideDiacritics: 1,\n    decomposeDiacritics: 2\n  },\n  verticalPosition: {\n    code: 10,\n    exclusive: true,\n    normalPosition: 0,\n    superiors: 1,\n    inferiors: 2,\n    ordinals: 3,\n    scientificInferiors: 4\n  },\n  fractions: {\n    code: 11,\n    exclusive: true,\n    noFractions: 0,\n    verticalFractions: 1,\n    diagonalFractions: 2\n  },\n  overlappingCharacters: {\n    code: 13,\n    exclusive: false,\n    preventOverlap: 0\n  },\n  typographicExtras: {\n    code: 14,\n    exclusive: false,\n    // hyphensToEmDash: 0\n    // hyphenToEnDash: 2\n    slashedZero: 4\n  },\n  // formInterrobang: 6\n  // smartQuotes: 8\n  // periodsToEllipsis: 10\n  mathematicalExtras: {\n    code: 15,\n    exclusive: false,\n    // hyphenToMinus: 0\n    // asteristoMultiply: 2\n    // slashToDivide: 4\n    // inequalityLigatures: 6\n    // exponents: 8\n    mathematicalGreek: 10\n  },\n  ornamentSets: {\n    code: 16,\n    exclusive: true,\n    noOrnaments: 0,\n    dingbats: 1,\n    piCharacters: 2,\n    fleurons: 3,\n    decorativeBorders: 4,\n    internationalSymbols: 5,\n    mathSymbols: 6\n  },\n  characterAlternatives: {\n    code: 17,\n    exclusive: true,\n    noAlternates: 0\n  },\n  // user defined options\n  designComplexity: {\n    code: 18,\n    exclusive: true,\n    designLevel1: 0,\n    designLevel2: 1,\n    designLevel3: 2,\n    designLevel4: 3,\n    designLevel5: 4\n  },\n  styleOptions: {\n    code: 19,\n    exclusive: true,\n    noStyleOptions: 0,\n    displayText: 1,\n    engravedText: 2,\n    illuminatedCaps: 3,\n    titlingCaps: 4,\n    tallCaps: 5\n  },\n  characterShape: {\n    code: 20,\n    exclusive: true,\n    traditionalCharacters: 0,\n    simplifiedCharacters: 1,\n    JIS1978Characters: 2,\n    JIS1983Characters: 3,\n    JIS1990Characters: 4,\n    traditionalAltOne: 5,\n    traditionalAltTwo: 6,\n    traditionalAltThree: 7,\n    traditionalAltFour: 8,\n    traditionalAltFive: 9,\n    expertCharacters: 10,\n    JIS2004Characters: 11,\n    hojoCharacters: 12,\n    NLCCharacters: 13,\n    traditionalNamesCharacters: 14\n  },\n  numberCase: {\n    code: 21,\n    exclusive: true,\n    lowerCaseNumbers: 0,\n    upperCaseNumbers: 1\n  },\n  textSpacing: {\n    code: 22,\n    exclusive: true,\n    proportionalText: 0,\n    monospacedText: 1,\n    halfWidthText: 2,\n    thirdWidthText: 3,\n    quarterWidthText: 4,\n    altProportionalText: 5,\n    altHalfWidthText: 6\n  },\n  transliteration: {\n    code: 23,\n    exclusive: true,\n    noTransliteration: 0\n  },\n  // hanjaToHangul: 1\n  // hiraganaToKatakana: 2\n  // katakanaToHiragana: 3\n  // kanaToRomanization: 4\n  // romanizationToHiragana: 5\n  // romanizationToKatakana: 6\n  // hanjaToHangulAltOne: 7\n  // hanjaToHangulAltTwo: 8\n  // hanjaToHangulAltThree: 9\n  annotation: {\n    code: 24,\n    exclusive: true,\n    noAnnotation: 0,\n    boxAnnotation: 1,\n    roundedBoxAnnotation: 2,\n    circleAnnotation: 3,\n    invertedCircleAnnotation: 4,\n    parenthesisAnnotation: 5,\n    periodAnnotation: 6,\n    romanNumeralAnnotation: 7,\n    diamondAnnotation: 8,\n    invertedBoxAnnotation: 9,\n    invertedRoundedBoxAnnotation: 10\n  },\n  kanaSpacing: {\n    code: 25,\n    exclusive: true,\n    fullWidthKana: 0,\n    proportionalKana: 1\n  },\n  ideographicSpacing: {\n    code: 26,\n    exclusive: true,\n    fullWidthIdeographs: 0,\n    proportionalIdeographs: 1,\n    halfWidthIdeographs: 2\n  },\n  unicodeDecomposition: {\n    code: 27,\n    exclusive: false,\n    canonicalComposition: 0,\n    compatibilityComposition: 2,\n    transcodingComposition: 4\n  },\n  rubyKana: {\n    code: 28,\n    exclusive: false,\n    // noRubyKana: 0     # deprecated - use rubyKanaOff instead\n    // rubyKana: 1     # deprecated - use rubyKanaOn instead\n    rubyKana: 2\n  },\n  CJKSymbolAlternatives: {\n    code: 29,\n    exclusive: true,\n    noCJKSymbolAlternatives: 0,\n    CJKSymbolAltOne: 1,\n    CJKSymbolAltTwo: 2,\n    CJKSymbolAltThree: 3,\n    CJKSymbolAltFour: 4,\n    CJKSymbolAltFive: 5\n  },\n  ideographicAlternatives: {\n    code: 30,\n    exclusive: true,\n    noIdeographicAlternatives: 0,\n    ideographicAltOne: 1,\n    ideographicAltTwo: 2,\n    ideographicAltThree: 3,\n    ideographicAltFour: 4,\n    ideographicAltFive: 5\n  },\n  CJKVerticalRomanPlacement: {\n    code: 31,\n    exclusive: true,\n    CJKVerticalRomanCentered: 0,\n    CJKVerticalRomanHBaseline: 1\n  },\n  italicCJKRoman: {\n    code: 32,\n    exclusive: false,\n    // noCJKItalicRoman: 0     # deprecated - use CJKItalicRomanOff instead\n    // CJKItalicRoman: 1     # deprecated - use CJKItalicRomanOn instead\n    CJKItalicRoman: 2\n  },\n  caseSensitiveLayout: {\n    code: 33,\n    exclusive: false,\n    caseSensitiveLayout: 0,\n    caseSensitiveSpacing: 2\n  },\n  alternateKana: {\n    code: 34,\n    exclusive: false,\n    alternateHorizKana: 0,\n    alternateVertKana: 2\n  },\n  stylisticAlternatives: {\n    code: 35,\n    exclusive: false,\n    noStylisticAlternates: 0,\n    stylisticAltOne: 2,\n    stylisticAltTwo: 4,\n    stylisticAltThree: 6,\n    stylisticAltFour: 8,\n    stylisticAltFive: 10,\n    stylisticAltSix: 12,\n    stylisticAltSeven: 14,\n    stylisticAltEight: 16,\n    stylisticAltNine: 18,\n    stylisticAltTen: 20,\n    stylisticAltEleven: 22,\n    stylisticAltTwelve: 24,\n    stylisticAltThirteen: 26,\n    stylisticAltFourteen: 28,\n    stylisticAltFifteen: 30,\n    stylisticAltSixteen: 32,\n    stylisticAltSeventeen: 34,\n    stylisticAltEighteen: 36,\n    stylisticAltNineteen: 38,\n    stylisticAltTwenty: 40\n  },\n  contextualAlternates: {\n    code: 36,\n    exclusive: false,\n    contextualAlternates: 0,\n    swashAlternates: 2,\n    contextualSwashAlternates: 4\n  },\n  lowerCase: {\n    code: 37,\n    exclusive: true,\n    defaultLowerCase: 0,\n    lowerCaseSmallCaps: 1,\n    lowerCasePetiteCaps: 2\n  },\n  upperCase: {\n    code: 38,\n    exclusive: true,\n    defaultUpperCase: 0,\n    upperCaseSmallCaps: 1,\n    upperCasePetiteCaps: 2\n  },\n  languageTag: {\n    // indices into ltag table\n    code: 39,\n    exclusive: true\n  },\n  CJKRomanSpacing: {\n    code: 103,\n    exclusive: true,\n    halfWidthCJKRoman: 0,\n    proportionalCJKRoman: 1,\n    defaultCJKRoman: 2,\n    fullWidthCJKRoman: 3\n  }\n};\n\nvar feature = function feature(name, selector) {\n  return [features[name].code, features[name][selector]];\n};\n\nvar OTMapping = {\n  rlig: feature('ligatures', 'requiredLigatures'),\n  clig: feature('ligatures', 'contextualLigatures'),\n  dlig: feature('ligatures', 'rareLigatures'),\n  hlig: feature('ligatures', 'historicalLigatures'),\n  liga: feature('ligatures', 'commonLigatures'),\n  hist: feature('ligatures', 'historicalLigatures'),\n  // ??\n  smcp: feature('lowerCase', 'lowerCaseSmallCaps'),\n  pcap: feature('lowerCase', 'lowerCasePetiteCaps'),\n  frac: feature('fractions', 'diagonalFractions'),\n  dnom: feature('fractions', 'diagonalFractions'),\n  // ??\n  numr: feature('fractions', 'diagonalFractions'),\n  // ??\n  afrc: feature('fractions', 'verticalFractions'),\n  // aalt\n  // abvf, abvm, abvs, akhn, blwf, blwm, blws, cfar, cjct, cpsp, falt, isol, jalt, ljmo, mset?\n  // ltra, ltrm, nukt, pref, pres, pstf, psts, rand, rkrf, rphf, rtla, rtlm, size, tjmo, tnum?\n  // unic, vatu, vhal, vjmo, vpal, vrt2\n  // dist -> trak table?\n  // kern, vkrn -> kern table\n  // lfbd + opbd + rtbd -> opbd table?\n  // mark, mkmk -> acnt table?\n  // locl -> languageTag + ltag table\n  case: feature('caseSensitiveLayout', 'caseSensitiveLayout'),\n  // also caseSensitiveSpacing\n  ccmp: feature('unicodeDecomposition', 'canonicalComposition'),\n  // compatibilityComposition?\n  cpct: feature('CJKVerticalRomanPlacement', 'CJKVerticalRomanCentered'),\n  // guess..., probably not given below\n  valt: feature('CJKVerticalRomanPlacement', 'CJKVerticalRomanCentered'),\n  swsh: feature('contextualAlternates', 'swashAlternates'),\n  cswh: feature('contextualAlternates', 'contextualSwashAlternates'),\n  curs: feature('cursiveConnection', 'cursive'),\n  // ??\n  c2pc: feature('upperCase', 'upperCasePetiteCaps'),\n  c2sc: feature('upperCase', 'upperCaseSmallCaps'),\n  init: feature('smartSwash', 'wordInitialSwashes'),\n  // ??\n  fin2: feature('smartSwash', 'wordFinalSwashes'),\n  // ??\n  medi: feature('smartSwash', 'nonFinalSwashes'),\n  // ??\n  med2: feature('smartSwash', 'nonFinalSwashes'),\n  // ??\n  fin3: feature('smartSwash', 'wordFinalSwashes'),\n  // ??\n  fina: feature('smartSwash', 'wordFinalSwashes'),\n  // ??\n  pkna: feature('kanaSpacing', 'proportionalKana'),\n  half: feature('textSpacing', 'halfWidthText'),\n  // also HalfWidthCJKRoman, HalfWidthIdeographs?\n  halt: feature('textSpacing', 'altHalfWidthText'),\n  hkna: feature('alternateKana', 'alternateHorizKana'),\n  vkna: feature('alternateKana', 'alternateVertKana'),\n  // hngl: feature 'transliteration', 'hanjaToHangulSelector' # deprecated\n  ital: feature('italicCJKRoman', 'CJKItalicRoman'),\n  lnum: feature('numberCase', 'upperCaseNumbers'),\n  onum: feature('numberCase', 'lowerCaseNumbers'),\n  mgrk: feature('mathematicalExtras', 'mathematicalGreek'),\n  // nalt: not enough info. what type of annotation?\n  // ornm: ditto, which ornament style?\n  calt: feature('contextualAlternates', 'contextualAlternates'),\n  // or more?\n  vrt2: feature('verticalSubstitution', 'substituteVerticalForms'),\n  // oh... below?\n  vert: feature('verticalSubstitution', 'substituteVerticalForms'),\n  tnum: feature('numberSpacing', 'monospacedNumbers'),\n  pnum: feature('numberSpacing', 'proportionalNumbers'),\n  sups: feature('verticalPosition', 'superiors'),\n  subs: feature('verticalPosition', 'inferiors'),\n  ordn: feature('verticalPosition', 'ordinals'),\n  pwid: feature('textSpacing', 'proportionalText'),\n  hwid: feature('textSpacing', 'halfWidthText'),\n  qwid: feature('textSpacing', 'quarterWidthText'),\n  // also QuarterWidthNumbers?\n  twid: feature('textSpacing', 'thirdWidthText'),\n  // also ThirdWidthNumbers?\n  fwid: feature('textSpacing', 'proportionalText'),\n  //??\n  palt: feature('textSpacing', 'altProportionalText'),\n  trad: feature('characterShape', 'traditionalCharacters'),\n  smpl: feature('characterShape', 'simplifiedCharacters'),\n  jp78: feature('characterShape', 'JIS1978Characters'),\n  jp83: feature('characterShape', 'JIS1983Characters'),\n  jp90: feature('characterShape', 'JIS1990Characters'),\n  jp04: feature('characterShape', 'JIS2004Characters'),\n  expt: feature('characterShape', 'expertCharacters'),\n  hojo: feature('characterShape', 'hojoCharacters'),\n  nlck: feature('characterShape', 'NLCCharacters'),\n  tnam: feature('characterShape', 'traditionalNamesCharacters'),\n  ruby: feature('rubyKana', 'rubyKana'),\n  titl: feature('styleOptions', 'titlingCaps'),\n  zero: feature('typographicExtras', 'slashedZero'),\n  ss01: feature('stylisticAlternatives', 'stylisticAltOne'),\n  ss02: feature('stylisticAlternatives', 'stylisticAltTwo'),\n  ss03: feature('stylisticAlternatives', 'stylisticAltThree'),\n  ss04: feature('stylisticAlternatives', 'stylisticAltFour'),\n  ss05: feature('stylisticAlternatives', 'stylisticAltFive'),\n  ss06: feature('stylisticAlternatives', 'stylisticAltSix'),\n  ss07: feature('stylisticAlternatives', 'stylisticAltSeven'),\n  ss08: feature('stylisticAlternatives', 'stylisticAltEight'),\n  ss09: feature('stylisticAlternatives', 'stylisticAltNine'),\n  ss10: feature('stylisticAlternatives', 'stylisticAltTen'),\n  ss11: feature('stylisticAlternatives', 'stylisticAltEleven'),\n  ss12: feature('stylisticAlternatives', 'stylisticAltTwelve'),\n  ss13: feature('stylisticAlternatives', 'stylisticAltThirteen'),\n  ss14: feature('stylisticAlternatives', 'stylisticAltFourteen'),\n  ss15: feature('stylisticAlternatives', 'stylisticAltFifteen'),\n  ss16: feature('stylisticAlternatives', 'stylisticAltSixteen'),\n  ss17: feature('stylisticAlternatives', 'stylisticAltSeventeen'),\n  ss18: feature('stylisticAlternatives', 'stylisticAltEighteen'),\n  ss19: feature('stylisticAlternatives', 'stylisticAltNineteen'),\n  ss20: feature('stylisticAlternatives', 'stylisticAltTwenty')\n}; // salt: feature 'stylisticAlternatives', 'stylisticAltOne' # hmm, which one to choose\n// Add cv01-cv99 features\n\nfor (var i = 1; i <= 99; i++) {\n  OTMapping['cv' + ('00' + i).slice(-2)] = [features.characterAlternatives.code, i];\n} // create inverse mapping\n\n\nvar AATMapping = {};\n\nfor (var ot in OTMapping) {\n  var aat = OTMapping[ot];\n\n  if (AATMapping[aat[0]] == null) {\n    AATMapping[aat[0]] = {};\n  }\n\n  AATMapping[aat[0]][aat[1]] = ot;\n} // Maps an array of OpenType features to AAT features\n// in the form of {featureType:{featureSetting:true}}\n\n\nfunction mapOTToAAT(features) {\n  var res = {};\n\n  for (var k in features) {\n    var r = void 0;\n\n    if (r = OTMapping[k]) {\n      if (res[r[0]] == null) {\n        res[r[0]] = {};\n      }\n\n      res[r[0]][r[1]] = features[k];\n    }\n  }\n\n  return res;\n} // Maps strings in a [featureType, featureSetting]\n// to their equivalent number codes\n\n\nfunction mapFeatureStrings(f) {\n  var type = f[0],\n      setting = f[1];\n\n  if (isNaN(type)) {\n    var typeCode = features[type] && features[type].code;\n  } else {\n    var typeCode = type;\n  }\n\n  if (isNaN(setting)) {\n    var settingCode = features[type] && features[type][setting];\n  } else {\n    var settingCode = setting;\n  }\n\n  return [typeCode, settingCode];\n} // Maps AAT features to an array of OpenType features\n// Supports both arrays in the form of [[featureType, featureSetting]]\n// and objects in the form of {featureType:{featureSetting:true}}\n// featureTypes and featureSettings can be either strings or number codes\n\n\nfunction mapAATToOT(features) {\n  var res = {};\n\n  if (Array.isArray(features)) {\n    for (var k = 0; k < features.length; k++) {\n      var r = void 0;\n      var f = mapFeatureStrings(features[k]);\n\n      if (r = AATMapping[f[0]] && AATMapping[f[0]][f[1]]) {\n        res[r] = true;\n      }\n    }\n  } else if ((typeof features === 'undefined' ? 'undefined' : _typeof(features)) === 'object') {\n    for (var type in features) {\n      var _feature = features[type];\n\n      for (var setting in _feature) {\n        var _r = void 0;\n\n        var _f = mapFeatureStrings([type, setting]);\n\n        if (_feature[setting] && (_r = AATMapping[_f[0]] && AATMapping[_f[0]][_f[1]])) {\n          res[_r] = true;\n        }\n      }\n    }\n  }\n\n  return _Object$keys(res);\n}\n\nvar _class$3;\n\nfunction _applyDecoratedDescriptor$3(target, property, decorators, descriptor, context) {\n  var desc = {};\n  Object['ke' + 'ys'](descriptor).forEach(function (key) {\n    desc[key] = descriptor[key];\n  });\n  desc.enumerable = !!desc.enumerable;\n  desc.configurable = !!desc.configurable;\n\n  if ('value' in desc || desc.initializer) {\n    desc.writable = true;\n  }\n\n  desc = decorators.slice().reverse().reduce(function (desc, decorator) {\n    return decorator(target, property, desc) || desc;\n  }, desc);\n\n  if (context && desc.initializer !== void 0) {\n    desc.value = desc.initializer ? desc.initializer.call(context) : void 0;\n    desc.initializer = undefined;\n  }\n\n  if (desc.initializer === void 0) {\n    Object['define' + 'Property'](target, property, desc);\n    desc = null;\n  }\n\n  return desc;\n}\n\nvar AATLookupTable = (_class$3 = function () {\n  function AATLookupTable(table) {\n    _classCallCheck(this, AATLookupTable);\n\n    this.table = table;\n  }\n\n  AATLookupTable.prototype.lookup = function lookup(glyph) {\n    switch (this.table.version) {\n      case 0:\n        // simple array format\n        return this.table.values.getItem(glyph);\n\n      case 2: // segment format\n\n      case 4:\n        {\n          var min = 0;\n          var max = this.table.binarySearchHeader.nUnits - 1;\n\n          while (min <= max) {\n            var mid = min + max >> 1;\n            var seg = this.table.segments[mid]; // special end of search value\n\n            if (seg.firstGlyph === 0xffff) {\n              return null;\n            }\n\n            if (glyph < seg.firstGlyph) {\n              max = mid - 1;\n            } else if (glyph > seg.lastGlyph) {\n              min = mid + 1;\n            } else {\n              if (this.table.version === 2) {\n                return seg.value;\n              } else {\n                return seg.values[glyph - seg.firstGlyph];\n              }\n            }\n          }\n\n          return null;\n        }\n\n      case 6:\n        {\n          // lookup single\n          var _min = 0;\n\n          var _max = this.table.binarySearchHeader.nUnits - 1;\n\n          while (_min <= _max) {\n            var mid = _min + _max >> 1;\n            var seg = this.table.segments[mid]; // special end of search value\n\n            if (seg.glyph === 0xffff) {\n              return null;\n            }\n\n            if (glyph < seg.glyph) {\n              _max = mid - 1;\n            } else if (glyph > seg.glyph) {\n              _min = mid + 1;\n            } else {\n              return seg.value;\n            }\n          }\n\n          return null;\n        }\n\n      case 8:\n        // lookup trimmed\n        return this.table.values[glyph - this.table.firstGlyph];\n\n      default:\n        throw new Error('Unknown lookup table format: ' + this.table.version);\n    }\n  };\n\n  AATLookupTable.prototype.glyphsForValue = function glyphsForValue(classValue) {\n    var res = [];\n\n    switch (this.table.version) {\n      case 2: // segment format\n\n      case 4:\n        {\n          for (var _iterator = this.table.segments, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _getIterator(_iterator);;) {\n            var _ref;\n\n            if (_isArray) {\n              if (_i >= _iterator.length) break;\n              _ref = _iterator[_i++];\n            } else {\n              _i = _iterator.next();\n              if (_i.done) break;\n              _ref = _i.value;\n            }\n\n            var segment = _ref;\n\n            if (this.table.version === 2 && segment.value === classValue) {\n              res.push.apply(res, range(segment.firstGlyph, segment.lastGlyph + 1));\n            } else {\n              for (var index = 0; index < segment.values.length; index++) {\n                if (segment.values[index] === classValue) {\n                  res.push(segment.firstGlyph + index);\n                }\n              }\n            }\n          }\n\n          break;\n        }\n\n      case 6:\n        {\n          // lookup single\n          for (var _iterator2 = this.table.segments, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _getIterator(_iterator2);;) {\n            var _ref2;\n\n            if (_isArray2) {\n              if (_i2 >= _iterator2.length) break;\n              _ref2 = _iterator2[_i2++];\n            } else {\n              _i2 = _iterator2.next();\n              if (_i2.done) break;\n              _ref2 = _i2.value;\n            }\n\n            var _segment = _ref2;\n\n            if (_segment.value === classValue) {\n              res.push(_segment.glyph);\n            }\n          }\n\n          break;\n        }\n\n      case 8:\n        {\n          // lookup trimmed\n          for (var i = 0; i < this.table.values.length; i++) {\n            if (this.table.values[i] === classValue) {\n              res.push(this.table.firstGlyph + i);\n            }\n          }\n\n          break;\n        }\n\n      default:\n        throw new Error('Unknown lookup table format: ' + this.table.version);\n    }\n\n    return res;\n  };\n\n  return AATLookupTable;\n}(), _applyDecoratedDescriptor$3(_class$3.prototype, 'glyphsForValue', [cache], _Object$getOwnPropertyDescriptor(_class$3.prototype, 'glyphsForValue'), _class$3.prototype), _class$3);\nvar START_OF_TEXT_STATE = 0;\nvar END_OF_TEXT_CLASS = 0;\nvar OUT_OF_BOUNDS_CLASS = 1;\nvar DELETED_GLYPH_CLASS = 2;\nvar DONT_ADVANCE = 0x4000;\n\nvar AATStateMachine = function () {\n  function AATStateMachine(stateTable) {\n    _classCallCheck(this, AATStateMachine);\n\n    this.stateTable = stateTable;\n    this.lookupTable = new AATLookupTable(stateTable.classTable);\n  }\n\n  AATStateMachine.prototype.process = function process(glyphs, reverse, processEntry) {\n    var currentState = START_OF_TEXT_STATE; // START_OF_LINE_STATE is used for kashida glyph insertions sometimes I think?\n\n    var index = reverse ? glyphs.length - 1 : 0;\n    var dir = reverse ? -1 : 1;\n\n    while (dir === 1 && index <= glyphs.length || dir === -1 && index >= -1) {\n      var glyph = null;\n      var classCode = OUT_OF_BOUNDS_CLASS;\n      var shouldAdvance = true;\n\n      if (index === glyphs.length || index === -1) {\n        classCode = END_OF_TEXT_CLASS;\n      } else {\n        glyph = glyphs[index];\n\n        if (glyph.id === 0xffff) {\n          // deleted glyph\n          classCode = DELETED_GLYPH_CLASS;\n        } else {\n          classCode = this.lookupTable.lookup(glyph.id);\n\n          if (classCode == null) {\n            classCode = OUT_OF_BOUNDS_CLASS;\n          }\n        }\n      }\n\n      var row = this.stateTable.stateArray.getItem(currentState);\n      var entryIndex = row[classCode];\n      var entry = this.stateTable.entryTable.getItem(entryIndex);\n\n      if (classCode !== END_OF_TEXT_CLASS && classCode !== DELETED_GLYPH_CLASS) {\n        processEntry(glyph, entry, index);\n        shouldAdvance = !(entry.flags & DONT_ADVANCE);\n      }\n\n      currentState = entry.newState;\n\n      if (shouldAdvance) {\n        index += dir;\n      }\n    }\n\n    return glyphs;\n  };\n  /**\n   * Performs a depth-first traversal of the glyph strings\n   * represented by the state machine.\n   */\n\n\n  AATStateMachine.prototype.traverse = function traverse(opts) {\n    var state = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    var visited = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new _Set();\n\n    if (visited.has(state)) {\n      return;\n    }\n\n    visited.add(state);\n    var _stateTable = this.stateTable,\n        nClasses = _stateTable.nClasses,\n        stateArray = _stateTable.stateArray,\n        entryTable = _stateTable.entryTable;\n    var row = stateArray.getItem(state); // Skip predefined classes\n\n    for (var classCode = 4; classCode < nClasses; classCode++) {\n      var entryIndex = row[classCode];\n      var entry = entryTable.getItem(entryIndex); // Try all glyphs in the class\n\n      for (var _iterator = this.lookupTable.glyphsForValue(classCode), _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _getIterator(_iterator);;) {\n        var _ref;\n\n        if (_isArray) {\n          if (_i >= _iterator.length) break;\n          _ref = _iterator[_i++];\n        } else {\n          _i = _iterator.next();\n          if (_i.done) break;\n          _ref = _i.value;\n        }\n\n        var glyph = _ref;\n\n        if (opts.enter) {\n          opts.enter(glyph, entry);\n        }\n\n        if (entry.newState !== 0) {\n          this.traverse(opts, entry.newState, visited);\n        }\n\n        if (opts.exit) {\n          opts.exit(glyph, entry);\n        }\n      }\n    }\n  };\n\n  return AATStateMachine;\n}();\n\nvar _class$2;\n\nfunction _applyDecoratedDescriptor$2(target, property, decorators, descriptor, context) {\n  var desc = {};\n  Object['ke' + 'ys'](descriptor).forEach(function (key) {\n    desc[key] = descriptor[key];\n  });\n  desc.enumerable = !!desc.enumerable;\n  desc.configurable = !!desc.configurable;\n\n  if ('value' in desc || desc.initializer) {\n    desc.writable = true;\n  }\n\n  desc = decorators.slice().reverse().reduce(function (desc, decorator) {\n    return decorator(target, property, desc) || desc;\n  }, desc);\n\n  if (context && desc.initializer !== void 0) {\n    desc.value = desc.initializer ? desc.initializer.call(context) : void 0;\n    desc.initializer = undefined;\n  }\n\n  if (desc.initializer === void 0) {\n    Object['define' + 'Property'](target, property, desc);\n    desc = null;\n  }\n\n  return desc;\n} // indic replacement flags\n\n\nvar MARK_FIRST = 0x8000;\nvar MARK_LAST = 0x2000;\nvar VERB = 0x000F; // contextual substitution and glyph insertion flag\n\nvar SET_MARK = 0x8000; // ligature entry flags\n\nvar SET_COMPONENT = 0x8000;\nvar PERFORM_ACTION = 0x2000; // ligature action masks\n\nvar LAST_MASK = 0x80000000;\nvar STORE_MASK = 0x40000000;\nvar OFFSET_MASK = 0x3FFFFFFF;\nvar REVERSE_DIRECTION = 0x400000;\nvar CURRENT_INSERT_BEFORE = 0x0800;\nvar MARKED_INSERT_BEFORE = 0x0400;\nvar CURRENT_INSERT_COUNT = 0x03E0;\nvar MARKED_INSERT_COUNT = 0x001F;\nvar AATMorxProcessor = (_class$2 = function () {\n  function AATMorxProcessor(font) {\n    _classCallCheck(this, AATMorxProcessor);\n\n    this.processIndicRearragement = this.processIndicRearragement.bind(this);\n    this.processContextualSubstitution = this.processContextualSubstitution.bind(this);\n    this.processLigature = this.processLigature.bind(this);\n    this.processNoncontextualSubstitutions = this.processNoncontextualSubstitutions.bind(this);\n    this.processGlyphInsertion = this.processGlyphInsertion.bind(this);\n    this.font = font;\n    this.morx = font.morx;\n    this.inputCache = null;\n  } // Processes an array of glyphs and applies the specified features\n  // Features should be in the form of {featureType:{featureSetting:boolean}}\n\n\n  AATMorxProcessor.prototype.process = function process(glyphs) {\n    var features = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    for (var _iterator = this.morx.chains, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _getIterator(_iterator);;) {\n      var _ref;\n\n      if (_isArray) {\n        if (_i >= _iterator.length) break;\n        _ref = _iterator[_i++];\n      } else {\n        _i = _iterator.next();\n        if (_i.done) break;\n        _ref = _i.value;\n      }\n\n      var chain = _ref;\n      var flags = chain.defaultFlags; // enable/disable the requested features\n\n      for (var _iterator2 = chain.features, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _getIterator(_iterator2);;) {\n        var _ref2;\n\n        if (_isArray2) {\n          if (_i2 >= _iterator2.length) break;\n          _ref2 = _iterator2[_i2++];\n        } else {\n          _i2 = _iterator2.next();\n          if (_i2.done) break;\n          _ref2 = _i2.value;\n        }\n\n        var feature = _ref2;\n        var f = void 0;\n\n        if (f = features[feature.featureType]) {\n          if (f[feature.featureSetting]) {\n            flags &= feature.disableFlags;\n            flags |= feature.enableFlags;\n          } else if (f[feature.featureSetting] === false) {\n            flags |= ~feature.disableFlags;\n            flags &= ~feature.enableFlags;\n          }\n        }\n      }\n\n      for (var _iterator3 = chain.subtables, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _getIterator(_iterator3);;) {\n        var _ref3;\n\n        if (_isArray3) {\n          if (_i3 >= _iterator3.length) break;\n          _ref3 = _iterator3[_i3++];\n        } else {\n          _i3 = _iterator3.next();\n          if (_i3.done) break;\n          _ref3 = _i3.value;\n        }\n\n        var subtable = _ref3;\n\n        if (subtable.subFeatureFlags & flags) {\n          this.processSubtable(subtable, glyphs);\n        }\n      }\n    } // remove deleted glyphs\n\n\n    var index = glyphs.length - 1;\n\n    while (index >= 0) {\n      if (glyphs[index].id === 0xffff) {\n        glyphs.splice(index, 1);\n      }\n\n      index--;\n    }\n\n    return glyphs;\n  };\n\n  AATMorxProcessor.prototype.processSubtable = function processSubtable(subtable, glyphs) {\n    this.subtable = subtable;\n    this.glyphs = glyphs;\n\n    if (this.subtable.type === 4) {\n      this.processNoncontextualSubstitutions(this.subtable, this.glyphs);\n      return;\n    }\n\n    this.ligatureStack = [];\n    this.markedGlyph = null;\n    this.firstGlyph = null;\n    this.lastGlyph = null;\n    this.markedIndex = null;\n    var stateMachine = this.getStateMachine(subtable);\n    var process = this.getProcessor();\n    var reverse = !!(this.subtable.coverage & REVERSE_DIRECTION);\n    return stateMachine.process(this.glyphs, reverse, process);\n  };\n\n  AATMorxProcessor.prototype.getStateMachine = function getStateMachine(subtable) {\n    return new AATStateMachine(subtable.table.stateTable);\n  };\n\n  AATMorxProcessor.prototype.getProcessor = function getProcessor() {\n    switch (this.subtable.type) {\n      case 0:\n        return this.processIndicRearragement;\n\n      case 1:\n        return this.processContextualSubstitution;\n\n      case 2:\n        return this.processLigature;\n\n      case 4:\n        return this.processNoncontextualSubstitutions;\n\n      case 5:\n        return this.processGlyphInsertion;\n\n      default:\n        throw new Error('Invalid morx subtable type: ' + this.subtable.type);\n    }\n  };\n\n  AATMorxProcessor.prototype.processIndicRearragement = function processIndicRearragement(glyph, entry, index) {\n    if (entry.flags & MARK_FIRST) {\n      this.firstGlyph = index;\n    }\n\n    if (entry.flags & MARK_LAST) {\n      this.lastGlyph = index;\n    }\n\n    reorderGlyphs(this.glyphs, entry.flags & VERB, this.firstGlyph, this.lastGlyph);\n  };\n\n  AATMorxProcessor.prototype.processContextualSubstitution = function processContextualSubstitution(glyph, entry, index) {\n    var subsitutions = this.subtable.table.substitutionTable.items;\n\n    if (entry.markIndex !== 0xffff) {\n      var lookup = subsitutions.getItem(entry.markIndex);\n      var lookupTable = new AATLookupTable(lookup);\n      glyph = this.glyphs[this.markedGlyph];\n      var gid = lookupTable.lookup(glyph.id);\n\n      if (gid) {\n        this.glyphs[this.markedGlyph] = this.font.getGlyph(gid, glyph.codePoints);\n      }\n    }\n\n    if (entry.currentIndex !== 0xffff) {\n      var _lookup = subsitutions.getItem(entry.currentIndex);\n\n      var _lookupTable = new AATLookupTable(_lookup);\n\n      glyph = this.glyphs[index];\n\n      var gid = _lookupTable.lookup(glyph.id);\n\n      if (gid) {\n        this.glyphs[index] = this.font.getGlyph(gid, glyph.codePoints);\n      }\n    }\n\n    if (entry.flags & SET_MARK) {\n      this.markedGlyph = index;\n    }\n  };\n\n  AATMorxProcessor.prototype.processLigature = function processLigature(glyph, entry, index) {\n    if (entry.flags & SET_COMPONENT) {\n      this.ligatureStack.push(index);\n    }\n\n    if (entry.flags & PERFORM_ACTION) {\n      var _ligatureStack;\n\n      var actions = this.subtable.table.ligatureActions;\n      var components = this.subtable.table.components;\n      var ligatureList = this.subtable.table.ligatureList;\n      var actionIndex = entry.action;\n      var last = false;\n      var ligatureIndex = 0;\n      var codePoints = [];\n      var ligatureGlyphs = [];\n\n      while (!last) {\n        var _codePoints;\n\n        var componentGlyph = this.ligatureStack.pop();\n\n        (_codePoints = codePoints).unshift.apply(_codePoints, this.glyphs[componentGlyph].codePoints);\n\n        var action = actions.getItem(actionIndex++);\n        last = !!(action & LAST_MASK);\n        var store = !!(action & STORE_MASK);\n        var offset = (action & OFFSET_MASK) << 2 >> 2; // sign extend 30 to 32 bits\n\n        offset += this.glyphs[componentGlyph].id;\n        var component = components.getItem(offset);\n        ligatureIndex += component;\n\n        if (last || store) {\n          var ligatureEntry = ligatureList.getItem(ligatureIndex);\n          this.glyphs[componentGlyph] = this.font.getGlyph(ligatureEntry, codePoints);\n          ligatureGlyphs.push(componentGlyph);\n          ligatureIndex = 0;\n          codePoints = [];\n        } else {\n          this.glyphs[componentGlyph] = this.font.getGlyph(0xffff);\n        }\n      } // Put ligature glyph indexes back on the stack\n\n\n      (_ligatureStack = this.ligatureStack).push.apply(_ligatureStack, ligatureGlyphs);\n    }\n  };\n\n  AATMorxProcessor.prototype.processNoncontextualSubstitutions = function processNoncontextualSubstitutions(subtable, glyphs, index) {\n    var lookupTable = new AATLookupTable(subtable.table.lookupTable);\n\n    for (index = 0; index < glyphs.length; index++) {\n      var glyph = glyphs[index];\n\n      if (glyph.id !== 0xffff) {\n        var gid = lookupTable.lookup(glyph.id);\n\n        if (gid) {\n          // 0 means do nothing\n          glyphs[index] = this.font.getGlyph(gid, glyph.codePoints);\n        }\n      }\n    }\n  };\n\n  AATMorxProcessor.prototype._insertGlyphs = function _insertGlyphs(glyphIndex, insertionActionIndex, count, isBefore) {\n    var _glyphs;\n\n    var insertions = [];\n\n    while (count--) {\n      var gid = this.subtable.table.insertionActions.getItem(insertionActionIndex++);\n      insertions.push(this.font.getGlyph(gid));\n    }\n\n    if (!isBefore) {\n      glyphIndex++;\n    }\n\n    (_glyphs = this.glyphs).splice.apply(_glyphs, [glyphIndex, 0].concat(insertions));\n  };\n\n  AATMorxProcessor.prototype.processGlyphInsertion = function processGlyphInsertion(glyph, entry, index) {\n    if (entry.flags & SET_MARK) {\n      this.markedIndex = index;\n    }\n\n    if (entry.markedInsertIndex !== 0xffff) {\n      var count = (entry.flags & MARKED_INSERT_COUNT) >>> 5;\n      var isBefore = !!(entry.flags & MARKED_INSERT_BEFORE);\n\n      this._insertGlyphs(this.markedIndex, entry.markedInsertIndex, count, isBefore);\n    }\n\n    if (entry.currentInsertIndex !== 0xffff) {\n      var _count = (entry.flags & CURRENT_INSERT_COUNT) >>> 5;\n\n      var _isBefore = !!(entry.flags & CURRENT_INSERT_BEFORE);\n\n      this._insertGlyphs(index, entry.currentInsertIndex, _count, _isBefore);\n    }\n  };\n\n  AATMorxProcessor.prototype.getSupportedFeatures = function getSupportedFeatures() {\n    var features = [];\n\n    for (var _iterator4 = this.morx.chains, _isArray4 = Array.isArray(_iterator4), _i4 = 0, _iterator4 = _isArray4 ? _iterator4 : _getIterator(_iterator4);;) {\n      var _ref4;\n\n      if (_isArray4) {\n        if (_i4 >= _iterator4.length) break;\n        _ref4 = _iterator4[_i4++];\n      } else {\n        _i4 = _iterator4.next();\n        if (_i4.done) break;\n        _ref4 = _i4.value;\n      }\n\n      var chain = _ref4;\n\n      for (var _iterator5 = chain.features, _isArray5 = Array.isArray(_iterator5), _i5 = 0, _iterator5 = _isArray5 ? _iterator5 : _getIterator(_iterator5);;) {\n        var _ref5;\n\n        if (_isArray5) {\n          if (_i5 >= _iterator5.length) break;\n          _ref5 = _iterator5[_i5++];\n        } else {\n          _i5 = _iterator5.next();\n          if (_i5.done) break;\n          _ref5 = _i5.value;\n        }\n\n        var feature = _ref5;\n        features.push([feature.featureType, feature.featureSetting]);\n      }\n    }\n\n    return features;\n  };\n\n  AATMorxProcessor.prototype.generateInputs = function generateInputs(gid) {\n    if (!this.inputCache) {\n      this.generateInputCache();\n    }\n\n    return this.inputCache[gid] || [];\n  };\n\n  AATMorxProcessor.prototype.generateInputCache = function generateInputCache() {\n    this.inputCache = {};\n\n    for (var _iterator6 = this.morx.chains, _isArray6 = Array.isArray(_iterator6), _i6 = 0, _iterator6 = _isArray6 ? _iterator6 : _getIterator(_iterator6);;) {\n      var _ref6;\n\n      if (_isArray6) {\n        if (_i6 >= _iterator6.length) break;\n        _ref6 = _iterator6[_i6++];\n      } else {\n        _i6 = _iterator6.next();\n        if (_i6.done) break;\n        _ref6 = _i6.value;\n      }\n\n      var chain = _ref6;\n      var flags = chain.defaultFlags;\n\n      for (var _iterator7 = chain.subtables, _isArray7 = Array.isArray(_iterator7), _i7 = 0, _iterator7 = _isArray7 ? _iterator7 : _getIterator(_iterator7);;) {\n        var _ref7;\n\n        if (_isArray7) {\n          if (_i7 >= _iterator7.length) break;\n          _ref7 = _iterator7[_i7++];\n        } else {\n          _i7 = _iterator7.next();\n          if (_i7.done) break;\n          _ref7 = _i7.value;\n        }\n\n        var subtable = _ref7;\n\n        if (subtable.subFeatureFlags & flags) {\n          this.generateInputsForSubtable(subtable);\n        }\n      }\n    }\n  };\n\n  AATMorxProcessor.prototype.generateInputsForSubtable = function generateInputsForSubtable(subtable) {\n    var _this = this; // Currently, only supporting ligature subtables.\n\n\n    if (subtable.type !== 2) {\n      return;\n    }\n\n    var reverse = !!(subtable.coverage & REVERSE_DIRECTION);\n\n    if (reverse) {\n      throw new Error('Reverse subtable, not supported.');\n    }\n\n    this.subtable = subtable;\n    this.ligatureStack = [];\n    var stateMachine = this.getStateMachine(subtable);\n    var process = this.getProcessor();\n    var input = [];\n    var stack = [];\n    this.glyphs = [];\n    stateMachine.traverse({\n      enter: function enter(glyph, entry) {\n        var glyphs = _this.glyphs;\n        stack.push({\n          glyphs: glyphs.slice(),\n          ligatureStack: _this.ligatureStack.slice()\n        }); // Add glyph to input and glyphs to process.\n\n        var g = _this.font.getGlyph(glyph);\n\n        input.push(g);\n        glyphs.push(input[input.length - 1]); // Process ligature substitution\n\n        process(glyphs[glyphs.length - 1], entry, glyphs.length - 1); // Add input to result if only one matching (non-deleted) glyph remains.\n\n        var count = 0;\n        var found = 0;\n\n        for (var i = 0; i < glyphs.length && count <= 1; i++) {\n          if (glyphs[i].id !== 0xffff) {\n            count++;\n            found = glyphs[i].id;\n          }\n        }\n\n        if (count === 1) {\n          var result = input.map(function (g) {\n            return g.id;\n          });\n          var _cache = _this.inputCache[found];\n\n          if (_cache) {\n            _cache.push(result);\n          } else {\n            _this.inputCache[found] = [result];\n          }\n        }\n      },\n      exit: function exit() {\n        var _stack$pop = stack.pop();\n\n        _this.glyphs = _stack$pop.glyphs;\n        _this.ligatureStack = _stack$pop.ligatureStack;\n        input.pop();\n      }\n    });\n  };\n\n  return AATMorxProcessor;\n}(), _applyDecoratedDescriptor$2(_class$2.prototype, 'getStateMachine', [cache], _Object$getOwnPropertyDescriptor(_class$2.prototype, 'getStateMachine'), _class$2.prototype), _class$2);\n\nfunction swap(glyphs, rangeA, rangeB) {\n  var reverseA = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  var reverseB = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n  var end = glyphs.splice(rangeB[0] - (rangeB[1] - 1), rangeB[1]);\n\n  if (reverseB) {\n    end.reverse();\n  }\n\n  var start = glyphs.splice.apply(glyphs, [rangeA[0], rangeA[1]].concat(end));\n\n  if (reverseA) {\n    start.reverse();\n  }\n\n  glyphs.splice.apply(glyphs, [rangeB[0] - (rangeA[1] - 1), 0].concat(start));\n  return glyphs;\n}\n\nfunction reorderGlyphs(glyphs, verb, firstGlyph, lastGlyph) {\n  var length = lastGlyph - firstGlyph + 1;\n\n  switch (verb) {\n    case 0:\n      // no change\n      return glyphs;\n\n    case 1:\n      // Ax => xA\n      return swap(glyphs, [firstGlyph, 1], [lastGlyph, 0]);\n\n    case 2:\n      // xD => Dx\n      return swap(glyphs, [firstGlyph, 0], [lastGlyph, 1]);\n\n    case 3:\n      // AxD => DxA\n      return swap(glyphs, [firstGlyph, 1], [lastGlyph, 1]);\n\n    case 4:\n      // ABx => xAB\n      return swap(glyphs, [firstGlyph, 2], [lastGlyph, 0]);\n\n    case 5:\n      // ABx => xBA\n      return swap(glyphs, [firstGlyph, 2], [lastGlyph, 0], true, false);\n\n    case 6:\n      // xCD => CDx\n      return swap(glyphs, [firstGlyph, 0], [lastGlyph, 2]);\n\n    case 7:\n      // xCD => DCx\n      return swap(glyphs, [firstGlyph, 0], [lastGlyph, 2], false, true);\n\n    case 8:\n      // AxCD => CDxA\n      return swap(glyphs, [firstGlyph, 1], [lastGlyph, 2]);\n\n    case 9:\n      // AxCD => DCxA\n      return swap(glyphs, [firstGlyph, 1], [lastGlyph, 2], false, true);\n\n    case 10:\n      // ABxD => DxAB\n      return swap(glyphs, [firstGlyph, 2], [lastGlyph, 1]);\n\n    case 11:\n      // ABxD => DxBA\n      return swap(glyphs, [firstGlyph, 2], [lastGlyph, 1], true, false);\n\n    case 12:\n      // ABxCD => CDxAB\n      return swap(glyphs, [firstGlyph, 2], [lastGlyph, 2]);\n\n    case 13:\n      // ABxCD => CDxBA\n      return swap(glyphs, [firstGlyph, 2], [lastGlyph, 2], true, false);\n\n    case 14:\n      // ABxCD => DCxAB\n      return swap(glyphs, [firstGlyph, 2], [lastGlyph, 2], false, true);\n\n    case 15:\n      // ABxCD => DCxBA\n      return swap(glyphs, [firstGlyph, 2], [lastGlyph, 2], true, true);\n\n    default:\n      throw new Error('Unknown verb: ' + verb);\n  }\n}\n\nvar AATLayoutEngine = function () {\n  function AATLayoutEngine(font) {\n    _classCallCheck(this, AATLayoutEngine);\n\n    this.font = font;\n    this.morxProcessor = new AATMorxProcessor(font);\n    this.fallbackPosition = false;\n  }\n\n  AATLayoutEngine.prototype.substitute = function substitute(glyphRun) {\n    // AAT expects the glyphs to be in visual order prior to morx processing,\n    // so reverse the glyphs if the script is right-to-left.\n    if (glyphRun.direction === 'rtl') {\n      glyphRun.glyphs.reverse();\n    }\n\n    this.morxProcessor.process(glyphRun.glyphs, mapOTToAAT(glyphRun.features));\n  };\n\n  AATLayoutEngine.prototype.getAvailableFeatures = function getAvailableFeatures(script, language) {\n    return mapAATToOT(this.morxProcessor.getSupportedFeatures());\n  };\n\n  AATLayoutEngine.prototype.stringsForGlyph = function stringsForGlyph(gid) {\n    var glyphStrings = this.morxProcessor.generateInputs(gid);\n    var result = new _Set();\n\n    for (var _iterator = glyphStrings, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _getIterator(_iterator);;) {\n      var _ref;\n\n      if (_isArray) {\n        if (_i >= _iterator.length) break;\n        _ref = _iterator[_i++];\n      } else {\n        _i = _iterator.next();\n        if (_i.done) break;\n        _ref = _i.value;\n      }\n\n      var glyphs = _ref;\n\n      this._addStrings(glyphs, 0, result, '');\n    }\n\n    return result;\n  };\n\n  AATLayoutEngine.prototype._addStrings = function _addStrings(glyphs, index, strings, string) {\n    var codePoints = this.font._cmapProcessor.codePointsForGlyph(glyphs[index]);\n\n    for (var _iterator2 = codePoints, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _getIterator(_iterator2);;) {\n      var _ref2;\n\n      if (_isArray2) {\n        if (_i2 >= _iterator2.length) break;\n        _ref2 = _iterator2[_i2++];\n      } else {\n        _i2 = _iterator2.next();\n        if (_i2.done) break;\n        _ref2 = _i2.value;\n      }\n\n      var codePoint = _ref2;\n\n      var s = string + _String$fromCodePoint(codePoint);\n\n      if (index < glyphs.length - 1) {\n        this._addStrings(glyphs, index + 1, strings, s);\n      } else {\n        strings.add(s);\n      }\n    }\n  };\n\n  return AATLayoutEngine;\n}();\n/**\n * ShapingPlans are used by the OpenType shapers to store which\n * features should by applied, and in what order to apply them.\n * The features are applied in groups called stages. A feature\n * can be applied globally to all glyphs, or locally to only\n * specific glyphs.\n *\n * @private\n */\n\n\nvar ShapingPlan = function () {\n  function ShapingPlan(font, script, direction) {\n    _classCallCheck(this, ShapingPlan);\n\n    this.font = font;\n    this.script = script;\n    this.direction = direction;\n    this.stages = [];\n    this.globalFeatures = {};\n    this.allFeatures = {};\n  }\n  /**\n   * Adds the given features to the last stage.\n   * Ignores features that have already been applied.\n   */\n\n\n  ShapingPlan.prototype._addFeatures = function _addFeatures(features, global) {\n    var stageIndex = this.stages.length - 1;\n    var stage = this.stages[stageIndex];\n\n    for (var _iterator = features, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _getIterator(_iterator);;) {\n      var _ref;\n\n      if (_isArray) {\n        if (_i >= _iterator.length) break;\n        _ref = _iterator[_i++];\n      } else {\n        _i = _iterator.next();\n        if (_i.done) break;\n        _ref = _i.value;\n      }\n\n      var feature = _ref;\n\n      if (this.allFeatures[feature] == null) {\n        stage.push(feature);\n        this.allFeatures[feature] = stageIndex;\n\n        if (global) {\n          this.globalFeatures[feature] = true;\n        }\n      }\n    }\n  };\n  /**\n   * Add features to the last stage\n   */\n\n\n  ShapingPlan.prototype.add = function add(arg) {\n    var global = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n    if (this.stages.length === 0) {\n      this.stages.push([]);\n    }\n\n    if (typeof arg === 'string') {\n      arg = [arg];\n    }\n\n    if (Array.isArray(arg)) {\n      this._addFeatures(arg, global);\n    } else if ((typeof arg === 'undefined' ? 'undefined' : _typeof(arg)) === 'object') {\n      this._addFeatures(arg.global || [], true);\n\n      this._addFeatures(arg.local || [], false);\n    } else {\n      throw new Error(\"Unsupported argument to ShapingPlan#add\");\n    }\n  };\n  /**\n   * Add a new stage\n   */\n\n\n  ShapingPlan.prototype.addStage = function addStage(arg, global) {\n    if (typeof arg === 'function') {\n      this.stages.push(arg, []);\n    } else {\n      this.stages.push([]);\n      this.add(arg, global);\n    }\n  };\n\n  ShapingPlan.prototype.setFeatureOverrides = function setFeatureOverrides(features) {\n    if (Array.isArray(features)) {\n      this.add(features);\n    } else if ((typeof features === 'undefined' ? 'undefined' : _typeof(features)) === 'object') {\n      for (var tag in features) {\n        if (features[tag]) {\n          this.add(tag);\n        } else if (this.allFeatures[tag] != null) {\n          var stage = this.stages[this.allFeatures[tag]];\n          stage.splice(stage.indexOf(tag), 1);\n          delete this.allFeatures[tag];\n          delete this.globalFeatures[tag];\n        }\n      }\n    }\n  };\n  /**\n   * Assigns the global features to the given glyphs\n   */\n\n\n  ShapingPlan.prototype.assignGlobalFeatures = function assignGlobalFeatures(glyphs) {\n    for (var _iterator2 = glyphs, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _getIterator(_iterator2);;) {\n      var _ref2;\n\n      if (_isArray2) {\n        if (_i2 >= _iterator2.length) break;\n        _ref2 = _iterator2[_i2++];\n      } else {\n        _i2 = _iterator2.next();\n        if (_i2.done) break;\n        _ref2 = _i2.value;\n      }\n\n      var glyph = _ref2;\n\n      for (var feature in this.globalFeatures) {\n        glyph.features[feature] = true;\n      }\n    }\n  };\n  /**\n   * Executes the planned stages using the given OTProcessor\n   */\n\n\n  ShapingPlan.prototype.process = function process(processor, glyphs, positions) {\n    for (var _iterator3 = this.stages, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _getIterator(_iterator3);;) {\n      var _ref3;\n\n      if (_isArray3) {\n        if (_i3 >= _iterator3.length) break;\n        _ref3 = _iterator3[_i3++];\n      } else {\n        _i3 = _iterator3.next();\n        if (_i3.done) break;\n        _ref3 = _i3.value;\n      }\n\n      var stage = _ref3;\n\n      if (typeof stage === 'function') {\n        if (!positions) {\n          stage(this.font, glyphs, this);\n        }\n      } else if (stage.length > 0) {\n        processor.applyFeatures(stage, glyphs, positions);\n      }\n    }\n  };\n\n  return ShapingPlan;\n}();\n\nvar _class$4;\n\nvar _temp;\n\nvar VARIATION_FEATURES = ['rvrn'];\nvar COMMON_FEATURES = ['ccmp', 'locl', 'rlig', 'mark', 'mkmk'];\nvar FRACTIONAL_FEATURES = ['frac', 'numr', 'dnom'];\nvar HORIZONTAL_FEATURES = ['calt', 'clig', 'liga', 'rclt', 'curs', 'kern'];\nvar DIRECTIONAL_FEATURES = {\n  ltr: ['ltra', 'ltrm'],\n  rtl: ['rtla', 'rtlm']\n};\nvar DefaultShaper = (_temp = _class$4 = function () {\n  function DefaultShaper() {\n    _classCallCheck(this, DefaultShaper);\n  }\n\n  DefaultShaper.plan = function plan(_plan, glyphs, features) {\n    // Plan the features we want to apply\n    this.planPreprocessing(_plan);\n    this.planFeatures(_plan);\n    this.planPostprocessing(_plan, features); // Assign the global features to all the glyphs\n\n    _plan.assignGlobalFeatures(glyphs); // Assign local features to glyphs\n\n\n    this.assignFeatures(_plan, glyphs);\n  };\n\n  DefaultShaper.planPreprocessing = function planPreprocessing(plan) {\n    plan.add({\n      global: [].concat(VARIATION_FEATURES, DIRECTIONAL_FEATURES[plan.direction]),\n      local: FRACTIONAL_FEATURES\n    });\n  };\n\n  DefaultShaper.planFeatures = function planFeatures(plan) {// Do nothing by default. Let subclasses override this.\n  };\n\n  DefaultShaper.planPostprocessing = function planPostprocessing(plan, userFeatures) {\n    plan.add([].concat(COMMON_FEATURES, HORIZONTAL_FEATURES));\n    plan.setFeatureOverrides(userFeatures);\n  };\n\n  DefaultShaper.assignFeatures = function assignFeatures(plan, glyphs) {\n    // Enable contextual fractions\n    for (var i = 0; i < glyphs.length; i++) {\n      var glyph = glyphs[i];\n\n      if (glyph.codePoints[0] === 0x2044) {\n        // fraction slash\n        var start = i;\n        var end = i + 1; // Apply numerator\n\n        while (start > 0 && unicode.isDigit(glyphs[start - 1].codePoints[0])) {\n          glyphs[start - 1].features.numr = true;\n          glyphs[start - 1].features.frac = true;\n          start--;\n        } // Apply denominator\n\n\n        while (end < glyphs.length && unicode.isDigit(glyphs[end].codePoints[0])) {\n          glyphs[end].features.dnom = true;\n          glyphs[end].features.frac = true;\n          end++;\n        } // Apply fraction slash\n\n\n        glyph.features.frac = true;\n        i = end - 1;\n      }\n    }\n  };\n\n  return DefaultShaper;\n}(), _class$4.zeroMarkWidths = 'AFTER_GPOS', _temp);\nvar trie = new UnicodeTrie(require('fs').readFileSync(__dirname + '/data.trie'));\nvar FEATURES = ['isol', 'fina', 'fin2', 'fin3', 'medi', 'med2', 'init'];\nvar ShapingClasses = {\n  Non_Joining: 0,\n  Left_Joining: 1,\n  Right_Joining: 2,\n  Dual_Joining: 3,\n  Join_Causing: 3,\n  ALAPH: 4,\n  'DALATH RISH': 5,\n  Transparent: 6\n};\nvar ISOL = 'isol';\nvar FINA = 'fina';\nvar FIN2 = 'fin2';\nvar FIN3 = 'fin3';\nvar MEDI = 'medi';\nvar MED2 = 'med2';\nvar INIT = 'init';\nvar NONE = null; // Each entry is [prevAction, curAction, nextState]\n\nvar STATE_TABLE = [//   Non_Joining,        Left_Joining,       Right_Joining,     Dual_Joining,           ALAPH,            DALATH RISH\n// State 0: prev was U,  not willing to join.\n[[NONE, NONE, 0], [NONE, ISOL, 2], [NONE, ISOL, 1], [NONE, ISOL, 2], [NONE, ISOL, 1], [NONE, ISOL, 6]], // State 1: prev was R or ISOL/ALAPH,  not willing to join.\n[[NONE, NONE, 0], [NONE, ISOL, 2], [NONE, ISOL, 1], [NONE, ISOL, 2], [NONE, FIN2, 5], [NONE, ISOL, 6]], // State 2: prev was D/L in ISOL form,  willing to join.\n[[NONE, NONE, 0], [NONE, ISOL, 2], [INIT, FINA, 1], [INIT, FINA, 3], [INIT, FINA, 4], [INIT, FINA, 6]], // State 3: prev was D in FINA form,  willing to join.\n[[NONE, NONE, 0], [NONE, ISOL, 2], [MEDI, FINA, 1], [MEDI, FINA, 3], [MEDI, FINA, 4], [MEDI, FINA, 6]], // State 4: prev was FINA ALAPH,  not willing to join.\n[[NONE, NONE, 0], [NONE, ISOL, 2], [MED2, ISOL, 1], [MED2, ISOL, 2], [MED2, FIN2, 5], [MED2, ISOL, 6]], // State 5: prev was FIN2/FIN3 ALAPH,  not willing to join.\n[[NONE, NONE, 0], [NONE, ISOL, 2], [ISOL, ISOL, 1], [ISOL, ISOL, 2], [ISOL, FIN2, 5], [ISOL, ISOL, 6]], // State 6: prev was DALATH/RISH,  not willing to join.\n[[NONE, NONE, 0], [NONE, ISOL, 2], [NONE, ISOL, 1], [NONE, ISOL, 2], [NONE, FIN3, 5], [NONE, ISOL, 6]]];\n/**\n * This is a shaper for Arabic, and other cursive scripts.\n * It uses data from ArabicShaping.txt in the Unicode database,\n * compiled to a UnicodeTrie by generate-data.coffee.\n *\n * The shaping state machine was ported from Harfbuzz.\n * https://github.com/behdad/harfbuzz/blob/master/src/hb-ot-shape-complex-arabic.cc\n */\n\nvar ArabicShaper = function (_DefaultShaper) {\n  _inherits(ArabicShaper, _DefaultShaper);\n\n  function ArabicShaper() {\n    _classCallCheck(this, ArabicShaper);\n\n    return _possibleConstructorReturn(this, _DefaultShaper.apply(this, arguments));\n  }\n\n  ArabicShaper.planFeatures = function planFeatures(plan) {\n    plan.add(['ccmp', 'locl']);\n\n    for (var i = 0; i < FEATURES.length; i++) {\n      var feature = FEATURES[i];\n      plan.addStage(feature, false);\n    }\n\n    plan.addStage('mset');\n  };\n\n  ArabicShaper.assignFeatures = function assignFeatures(plan, glyphs) {\n    _DefaultShaper.assignFeatures.call(this, plan, glyphs);\n\n    var prev = -1;\n    var state = 0;\n    var actions = []; // Apply the state machine to map glyphs to features\n\n    for (var i = 0; i < glyphs.length; i++) {\n      var curAction = void 0,\n          prevAction = void 0;\n      var glyph = glyphs[i];\n      var type = getShapingClass(glyph.codePoints[0]);\n\n      if (type === ShapingClasses.Transparent) {\n        actions[i] = NONE;\n        continue;\n      }\n\n      var _STATE_TABLE$state$ty = STATE_TABLE[state][type];\n      prevAction = _STATE_TABLE$state$ty[0];\n      curAction = _STATE_TABLE$state$ty[1];\n      state = _STATE_TABLE$state$ty[2];\n\n      if (prevAction !== NONE && prev !== -1) {\n        actions[prev] = prevAction;\n      }\n\n      actions[i] = curAction;\n      prev = i;\n    } // Apply the chosen features to their respective glyphs\n\n\n    for (var index = 0; index < glyphs.length; index++) {\n      var feature = void 0;\n      var glyph = glyphs[index];\n\n      if (feature = actions[index]) {\n        glyph.features[feature] = true;\n      }\n    }\n  };\n\n  return ArabicShaper;\n}(DefaultShaper);\n\nfunction getShapingClass(codePoint) {\n  var res = trie.get(codePoint);\n\n  if (res) {\n    return res - 1;\n  }\n\n  var category = unicode.getCategory(codePoint);\n\n  if (category === 'Mn' || category === 'Me' || category === 'Cf') {\n    return ShapingClasses.Transparent;\n  }\n\n  return ShapingClasses.Non_Joining;\n}\n\nvar GlyphIterator = function () {\n  function GlyphIterator(glyphs, options) {\n    _classCallCheck(this, GlyphIterator);\n\n    this.glyphs = glyphs;\n    this.reset(options);\n  }\n\n  GlyphIterator.prototype.reset = function reset() {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    this.options = options;\n    this.flags = options.flags || {};\n    this.markAttachmentType = options.markAttachmentType || 0;\n    this.index = index;\n  };\n\n  GlyphIterator.prototype.shouldIgnore = function shouldIgnore(glyph) {\n    return this.flags.ignoreMarks && glyph.isMark || this.flags.ignoreBaseGlyphs && glyph.isBase || this.flags.ignoreLigatures && glyph.isLigature || this.markAttachmentType && glyph.isMark && glyph.markAttachmentType !== this.markAttachmentType;\n  };\n\n  GlyphIterator.prototype.move = function move(dir) {\n    this.index += dir;\n\n    while (0 <= this.index && this.index < this.glyphs.length && this.shouldIgnore(this.glyphs[this.index])) {\n      this.index += dir;\n    }\n\n    if (0 > this.index || this.index >= this.glyphs.length) {\n      return null;\n    }\n\n    return this.glyphs[this.index];\n  };\n\n  GlyphIterator.prototype.next = function next() {\n    return this.move(+1);\n  };\n\n  GlyphIterator.prototype.prev = function prev() {\n    return this.move(-1);\n  };\n\n  GlyphIterator.prototype.peek = function peek() {\n    var count = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n    var idx = this.index;\n    var res = this.increment(count);\n    this.index = idx;\n    return res;\n  };\n\n  GlyphIterator.prototype.peekIndex = function peekIndex() {\n    var count = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n    var idx = this.index;\n    this.increment(count);\n    var res = this.index;\n    this.index = idx;\n    return res;\n  };\n\n  GlyphIterator.prototype.increment = function increment() {\n    var count = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n    var dir = count < 0 ? -1 : 1;\n    count = Math.abs(count);\n\n    while (count--) {\n      this.move(dir);\n    }\n\n    return this.glyphs[this.index];\n  };\n\n  _createClass(GlyphIterator, [{\n    key: \"cur\",\n    get: function get() {\n      return this.glyphs[this.index] || null;\n    }\n  }]);\n\n  return GlyphIterator;\n}();\n\nvar DEFAULT_SCRIPTS = ['DFLT', 'dflt', 'latn'];\n\nvar OTProcessor = function () {\n  function OTProcessor(font, table) {\n    _classCallCheck(this, OTProcessor);\n\n    this.font = font;\n    this.table = table;\n    this.script = null;\n    this.scriptTag = null;\n    this.language = null;\n    this.languageTag = null;\n    this.features = {};\n    this.lookups = {}; // Setup variation substitutions\n\n    this.variationsIndex = font._variationProcessor ? this.findVariationsIndex(font._variationProcessor.normalizedCoords) : -1; // initialize to default script + language\n\n    this.selectScript(); // current context (set by applyFeatures)\n\n    this.glyphs = [];\n    this.positions = []; // only used by GPOS\n\n    this.ligatureID = 1;\n    this.currentFeature = null;\n  }\n\n  OTProcessor.prototype.findScript = function findScript(script) {\n    if (this.table.scriptList == null) {\n      return null;\n    }\n\n    if (!Array.isArray(script)) {\n      script = [script];\n    }\n\n    for (var _iterator = script, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _getIterator(_iterator);;) {\n      var _ref;\n\n      if (_isArray) {\n        if (_i >= _iterator.length) break;\n        _ref = _iterator[_i++];\n      } else {\n        _i = _iterator.next();\n        if (_i.done) break;\n        _ref = _i.value;\n      }\n\n      var s = _ref;\n\n      for (var _iterator2 = this.table.scriptList, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _getIterator(_iterator2);;) {\n        var _ref2;\n\n        if (_isArray2) {\n          if (_i2 >= _iterator2.length) break;\n          _ref2 = _iterator2[_i2++];\n        } else {\n          _i2 = _iterator2.next();\n          if (_i2.done) break;\n          _ref2 = _i2.value;\n        }\n\n        var entry = _ref2;\n\n        if (entry.tag === s) {\n          return entry;\n        }\n      }\n    }\n\n    return null;\n  };\n\n  OTProcessor.prototype.selectScript = function selectScript(script, language, direction$$) {\n    var changed = false;\n    var entry = void 0;\n\n    if (!this.script || script !== this.scriptTag) {\n      entry = this.findScript(script);\n\n      if (!entry) {\n        entry = this.findScript(DEFAULT_SCRIPTS);\n      }\n\n      if (!entry) {\n        return this.scriptTag;\n      }\n\n      this.scriptTag = entry.tag;\n      this.script = entry.script;\n      this.language = null;\n      this.languageTag = null;\n      changed = true;\n    }\n\n    if (!direction$$ || direction$$ !== this.direction) {\n      this.direction = direction$$ || direction(script);\n    }\n\n    if (language && language.length < 4) {\n      language += ' '.repeat(4 - language.length);\n    }\n\n    if (!language || language !== this.languageTag) {\n      this.language = null;\n\n      for (var _iterator3 = this.script.langSysRecords, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _getIterator(_iterator3);;) {\n        var _ref3;\n\n        if (_isArray3) {\n          if (_i3 >= _iterator3.length) break;\n          _ref3 = _iterator3[_i3++];\n        } else {\n          _i3 = _iterator3.next();\n          if (_i3.done) break;\n          _ref3 = _i3.value;\n        }\n\n        var lang = _ref3;\n\n        if (lang.tag === language) {\n          this.language = lang.langSys;\n          this.languageTag = lang.tag;\n          break;\n        }\n      }\n\n      if (!this.language) {\n        this.language = this.script.defaultLangSys;\n        this.languageTag = null;\n      }\n\n      changed = true;\n    } // Build a feature lookup table\n\n\n    if (changed) {\n      this.features = {};\n\n      if (this.language) {\n        for (var _iterator4 = this.language.featureIndexes, _isArray4 = Array.isArray(_iterator4), _i4 = 0, _iterator4 = _isArray4 ? _iterator4 : _getIterator(_iterator4);;) {\n          var _ref4;\n\n          if (_isArray4) {\n            if (_i4 >= _iterator4.length) break;\n            _ref4 = _iterator4[_i4++];\n          } else {\n            _i4 = _iterator4.next();\n            if (_i4.done) break;\n            _ref4 = _i4.value;\n          }\n\n          var featureIndex = _ref4;\n          var record = this.table.featureList[featureIndex];\n          var substituteFeature = this.substituteFeatureForVariations(featureIndex);\n          this.features[record.tag] = substituteFeature || record.feature;\n        }\n      }\n    }\n\n    return this.scriptTag;\n  };\n\n  OTProcessor.prototype.lookupsForFeatures = function lookupsForFeatures() {\n    var userFeatures = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    var exclude = arguments[1];\n    var lookups = [];\n\n    for (var _iterator5 = userFeatures, _isArray5 = Array.isArray(_iterator5), _i5 = 0, _iterator5 = _isArray5 ? _iterator5 : _getIterator(_iterator5);;) {\n      var _ref5;\n\n      if (_isArray5) {\n        if (_i5 >= _iterator5.length) break;\n        _ref5 = _iterator5[_i5++];\n      } else {\n        _i5 = _iterator5.next();\n        if (_i5.done) break;\n        _ref5 = _i5.value;\n      }\n\n      var tag = _ref5;\n      var feature = this.features[tag];\n\n      if (!feature) {\n        continue;\n      }\n\n      for (var _iterator6 = feature.lookupListIndexes, _isArray6 = Array.isArray(_iterator6), _i6 = 0, _iterator6 = _isArray6 ? _iterator6 : _getIterator(_iterator6);;) {\n        var _ref6;\n\n        if (_isArray6) {\n          if (_i6 >= _iterator6.length) break;\n          _ref6 = _iterator6[_i6++];\n        } else {\n          _i6 = _iterator6.next();\n          if (_i6.done) break;\n          _ref6 = _i6.value;\n        }\n\n        var lookupIndex = _ref6;\n\n        if (exclude && exclude.indexOf(lookupIndex) !== -1) {\n          continue;\n        }\n\n        lookups.push({\n          feature: tag,\n          index: lookupIndex,\n          lookup: this.table.lookupList.get(lookupIndex)\n        });\n      }\n    }\n\n    lookups.sort(function (a, b) {\n      return a.index - b.index;\n    });\n    return lookups;\n  };\n\n  OTProcessor.prototype.substituteFeatureForVariations = function substituteFeatureForVariations(featureIndex) {\n    if (this.variationsIndex === -1) {\n      return null;\n    }\n\n    var record = this.table.featureVariations.featureVariationRecords[this.variationsIndex];\n    var substitutions = record.featureTableSubstitution.substitutions;\n\n    for (var _iterator7 = substitutions, _isArray7 = Array.isArray(_iterator7), _i7 = 0, _iterator7 = _isArray7 ? _iterator7 : _getIterator(_iterator7);;) {\n      var _ref7;\n\n      if (_isArray7) {\n        if (_i7 >= _iterator7.length) break;\n        _ref7 = _iterator7[_i7++];\n      } else {\n        _i7 = _iterator7.next();\n        if (_i7.done) break;\n        _ref7 = _i7.value;\n      }\n\n      var substitution = _ref7;\n\n      if (substitution.featureIndex === featureIndex) {\n        return substitution.alternateFeatureTable;\n      }\n    }\n\n    return null;\n  };\n\n  OTProcessor.prototype.findVariationsIndex = function findVariationsIndex(coords) {\n    var variations = this.table.featureVariations;\n\n    if (!variations) {\n      return -1;\n    }\n\n    var records = variations.featureVariationRecords;\n\n    for (var i = 0; i < records.length; i++) {\n      var conditions = records[i].conditionSet.conditionTable;\n\n      if (this.variationConditionsMatch(conditions, coords)) {\n        return i;\n      }\n    }\n\n    return -1;\n  };\n\n  OTProcessor.prototype.variationConditionsMatch = function variationConditionsMatch(conditions, coords) {\n    return conditions.every(function (condition) {\n      var coord = condition.axisIndex < coords.length ? coords[condition.axisIndex] : 0;\n      return condition.filterRangeMinValue <= coord && coord <= condition.filterRangeMaxValue;\n    });\n  };\n\n  OTProcessor.prototype.applyFeatures = function applyFeatures(userFeatures, glyphs, advances) {\n    var lookups = this.lookupsForFeatures(userFeatures);\n    this.applyLookups(lookups, glyphs, advances);\n  };\n\n  OTProcessor.prototype.applyLookups = function applyLookups(lookups, glyphs, positions) {\n    this.glyphs = glyphs;\n    this.positions = positions;\n    this.glyphIterator = new GlyphIterator(glyphs);\n\n    for (var _iterator8 = lookups, _isArray8 = Array.isArray(_iterator8), _i8 = 0, _iterator8 = _isArray8 ? _iterator8 : _getIterator(_iterator8);;) {\n      var _ref8;\n\n      if (_isArray8) {\n        if (_i8 >= _iterator8.length) break;\n        _ref8 = _iterator8[_i8++];\n      } else {\n        _i8 = _iterator8.next();\n        if (_i8.done) break;\n        _ref8 = _i8.value;\n      }\n\n      var _ref9 = _ref8,\n          feature = _ref9.feature,\n          lookup = _ref9.lookup;\n      this.currentFeature = feature;\n      this.glyphIterator.reset(lookup.flags);\n\n      while (this.glyphIterator.index < glyphs.length) {\n        if (!(feature in this.glyphIterator.cur.features)) {\n          this.glyphIterator.next();\n          continue;\n        }\n\n        for (var _iterator9 = lookup.subTables, _isArray9 = Array.isArray(_iterator9), _i9 = 0, _iterator9 = _isArray9 ? _iterator9 : _getIterator(_iterator9);;) {\n          var _ref10;\n\n          if (_isArray9) {\n            if (_i9 >= _iterator9.length) break;\n            _ref10 = _iterator9[_i9++];\n          } else {\n            _i9 = _iterator9.next();\n            if (_i9.done) break;\n            _ref10 = _i9.value;\n          }\n\n          var table = _ref10;\n          var res = this.applyLookup(lookup.lookupType, table);\n\n          if (res) {\n            break;\n          }\n        }\n\n        this.glyphIterator.next();\n      }\n    }\n  };\n\n  OTProcessor.prototype.applyLookup = function applyLookup(lookup, table) {\n    throw new Error(\"applyLookup must be implemented by subclasses\");\n  };\n\n  OTProcessor.prototype.applyLookupList = function applyLookupList(lookupRecords) {\n    var options = this.glyphIterator.options;\n    var glyphIndex = this.glyphIterator.index;\n\n    for (var _iterator10 = lookupRecords, _isArray10 = Array.isArray(_iterator10), _i10 = 0, _iterator10 = _isArray10 ? _iterator10 : _getIterator(_iterator10);;) {\n      var _ref11;\n\n      if (_isArray10) {\n        if (_i10 >= _iterator10.length) break;\n        _ref11 = _iterator10[_i10++];\n      } else {\n        _i10 = _iterator10.next();\n        if (_i10.done) break;\n        _ref11 = _i10.value;\n      }\n\n      var lookupRecord = _ref11; // Reset flags and find glyph index for this lookup record\n\n      this.glyphIterator.reset(options, glyphIndex);\n      this.glyphIterator.increment(lookupRecord.sequenceIndex); // Get the lookup and setup flags for subtables\n\n      var lookup = this.table.lookupList.get(lookupRecord.lookupListIndex);\n      this.glyphIterator.reset(lookup.flags, this.glyphIterator.index); // Apply lookup subtables until one matches\n\n      for (var _iterator11 = lookup.subTables, _isArray11 = Array.isArray(_iterator11), _i11 = 0, _iterator11 = _isArray11 ? _iterator11 : _getIterator(_iterator11);;) {\n        var _ref12;\n\n        if (_isArray11) {\n          if (_i11 >= _iterator11.length) break;\n          _ref12 = _iterator11[_i11++];\n        } else {\n          _i11 = _iterator11.next();\n          if (_i11.done) break;\n          _ref12 = _i11.value;\n        }\n\n        var table = _ref12;\n\n        if (this.applyLookup(lookup.lookupType, table)) {\n          break;\n        }\n      }\n    }\n\n    this.glyphIterator.reset(options, glyphIndex);\n    return true;\n  };\n\n  OTProcessor.prototype.coverageIndex = function coverageIndex(coverage, glyph) {\n    if (glyph == null) {\n      glyph = this.glyphIterator.cur.id;\n    }\n\n    switch (coverage.version) {\n      case 1:\n        return coverage.glyphs.indexOf(glyph);\n\n      case 2:\n        for (var _iterator12 = coverage.rangeRecords, _isArray12 = Array.isArray(_iterator12), _i12 = 0, _iterator12 = _isArray12 ? _iterator12 : _getIterator(_iterator12);;) {\n          var _ref13;\n\n          if (_isArray12) {\n            if (_i12 >= _iterator12.length) break;\n            _ref13 = _iterator12[_i12++];\n          } else {\n            _i12 = _iterator12.next();\n            if (_i12.done) break;\n            _ref13 = _i12.value;\n          }\n\n          var range = _ref13;\n\n          if (range.start <= glyph && glyph <= range.end) {\n            return range.startCoverageIndex + glyph - range.start;\n          }\n        }\n\n        break;\n    }\n\n    return -1;\n  };\n\n  OTProcessor.prototype.match = function match(sequenceIndex, sequence, fn, matched) {\n    var pos = this.glyphIterator.index;\n    var glyph = this.glyphIterator.increment(sequenceIndex);\n    var idx = 0;\n\n    while (idx < sequence.length && glyph && fn(sequence[idx], glyph)) {\n      if (matched) {\n        matched.push(this.glyphIterator.index);\n      }\n\n      idx++;\n      glyph = this.glyphIterator.next();\n    }\n\n    this.glyphIterator.index = pos;\n\n    if (idx < sequence.length) {\n      return false;\n    }\n\n    return matched || true;\n  };\n\n  OTProcessor.prototype.sequenceMatches = function sequenceMatches(sequenceIndex, sequence) {\n    return this.match(sequenceIndex, sequence, function (component, glyph) {\n      return component === glyph.id;\n    });\n  };\n\n  OTProcessor.prototype.sequenceMatchIndices = function sequenceMatchIndices(sequenceIndex, sequence) {\n    var _this = this;\n\n    return this.match(sequenceIndex, sequence, function (component, glyph) {\n      // If the current feature doesn't apply to this glyph,\n      if (!(_this.currentFeature in glyph.features)) {\n        return false;\n      }\n\n      return component === glyph.id;\n    }, []);\n  };\n\n  OTProcessor.prototype.coverageSequenceMatches = function coverageSequenceMatches(sequenceIndex, sequence) {\n    var _this2 = this;\n\n    return this.match(sequenceIndex, sequence, function (coverage, glyph) {\n      return _this2.coverageIndex(coverage, glyph.id) >= 0;\n    });\n  };\n\n  OTProcessor.prototype.getClassID = function getClassID(glyph, classDef) {\n    switch (classDef.version) {\n      case 1:\n        // Class array\n        var i = glyph - classDef.startGlyph;\n\n        if (i >= 0 && i < classDef.classValueArray.length) {\n          return classDef.classValueArray[i];\n        }\n\n        break;\n\n      case 2:\n        for (var _iterator13 = classDef.classRangeRecord, _isArray13 = Array.isArray(_iterator13), _i13 = 0, _iterator13 = _isArray13 ? _iterator13 : _getIterator(_iterator13);;) {\n          var _ref14;\n\n          if (_isArray13) {\n            if (_i13 >= _iterator13.length) break;\n            _ref14 = _iterator13[_i13++];\n          } else {\n            _i13 = _iterator13.next();\n            if (_i13.done) break;\n            _ref14 = _i13.value;\n          }\n\n          var range = _ref14;\n\n          if (range.start <= glyph && glyph <= range.end) {\n            return range.class;\n          }\n        }\n\n        break;\n    }\n\n    return 0;\n  };\n\n  OTProcessor.prototype.classSequenceMatches = function classSequenceMatches(sequenceIndex, sequence, classDef) {\n    var _this3 = this;\n\n    return this.match(sequenceIndex, sequence, function (classID, glyph) {\n      return classID === _this3.getClassID(glyph.id, classDef);\n    });\n  };\n\n  OTProcessor.prototype.applyContext = function applyContext(table) {\n    switch (table.version) {\n      case 1:\n        var index = this.coverageIndex(table.coverage);\n\n        if (index === -1) {\n          return false;\n        }\n\n        var set = table.ruleSets[index];\n\n        for (var _iterator14 = set, _isArray14 = Array.isArray(_iterator14), _i14 = 0, _iterator14 = _isArray14 ? _iterator14 : _getIterator(_iterator14);;) {\n          var _ref15;\n\n          if (_isArray14) {\n            if (_i14 >= _iterator14.length) break;\n            _ref15 = _iterator14[_i14++];\n          } else {\n            _i14 = _iterator14.next();\n            if (_i14.done) break;\n            _ref15 = _i14.value;\n          }\n\n          var rule = _ref15;\n\n          if (this.sequenceMatches(1, rule.input)) {\n            return this.applyLookupList(rule.lookupRecords);\n          }\n        }\n\n        break;\n\n      case 2:\n        if (this.coverageIndex(table.coverage) === -1) {\n          return false;\n        }\n\n        index = this.getClassID(this.glyphIterator.cur.id, table.classDef);\n\n        if (index === -1) {\n          return false;\n        }\n\n        set = table.classSet[index];\n\n        for (var _iterator15 = set, _isArray15 = Array.isArray(_iterator15), _i15 = 0, _iterator15 = _isArray15 ? _iterator15 : _getIterator(_iterator15);;) {\n          var _ref16;\n\n          if (_isArray15) {\n            if (_i15 >= _iterator15.length) break;\n            _ref16 = _iterator15[_i15++];\n          } else {\n            _i15 = _iterator15.next();\n            if (_i15.done) break;\n            _ref16 = _i15.value;\n          }\n\n          var _rule = _ref16;\n\n          if (this.classSequenceMatches(1, _rule.classes, table.classDef)) {\n            return this.applyLookupList(_rule.lookupRecords);\n          }\n        }\n\n        break;\n\n      case 3:\n        if (this.coverageSequenceMatches(0, table.coverages)) {\n          return this.applyLookupList(table.lookupRecords);\n        }\n\n        break;\n    }\n\n    return false;\n  };\n\n  OTProcessor.prototype.applyChainingContext = function applyChainingContext(table) {\n    switch (table.version) {\n      case 1:\n        var index = this.coverageIndex(table.coverage);\n\n        if (index === -1) {\n          return false;\n        }\n\n        var set = table.chainRuleSets[index];\n\n        for (var _iterator16 = set, _isArray16 = Array.isArray(_iterator16), _i16 = 0, _iterator16 = _isArray16 ? _iterator16 : _getIterator(_iterator16);;) {\n          var _ref17;\n\n          if (_isArray16) {\n            if (_i16 >= _iterator16.length) break;\n            _ref17 = _iterator16[_i16++];\n          } else {\n            _i16 = _iterator16.next();\n            if (_i16.done) break;\n            _ref17 = _i16.value;\n          }\n\n          var rule = _ref17;\n\n          if (this.sequenceMatches(-rule.backtrack.length, rule.backtrack) && this.sequenceMatches(1, rule.input) && this.sequenceMatches(1 + rule.input.length, rule.lookahead)) {\n            return this.applyLookupList(rule.lookupRecords);\n          }\n        }\n\n        break;\n\n      case 2:\n        if (this.coverageIndex(table.coverage) === -1) {\n          return false;\n        }\n\n        index = this.getClassID(this.glyphIterator.cur.id, table.inputClassDef);\n        var rules = table.chainClassSet[index];\n\n        if (!rules) {\n          return false;\n        }\n\n        for (var _iterator17 = rules, _isArray17 = Array.isArray(_iterator17), _i17 = 0, _iterator17 = _isArray17 ? _iterator17 : _getIterator(_iterator17);;) {\n          var _ref18;\n\n          if (_isArray17) {\n            if (_i17 >= _iterator17.length) break;\n            _ref18 = _iterator17[_i17++];\n          } else {\n            _i17 = _iterator17.next();\n            if (_i17.done) break;\n            _ref18 = _i17.value;\n          }\n\n          var _rule2 = _ref18;\n\n          if (this.classSequenceMatches(-_rule2.backtrack.length, _rule2.backtrack, table.backtrackClassDef) && this.classSequenceMatches(1, _rule2.input, table.inputClassDef) && this.classSequenceMatches(1 + _rule2.input.length, _rule2.lookahead, table.lookaheadClassDef)) {\n            return this.applyLookupList(_rule2.lookupRecords);\n          }\n        }\n\n        break;\n\n      case 3:\n        if (this.coverageSequenceMatches(-table.backtrackGlyphCount, table.backtrackCoverage) && this.coverageSequenceMatches(0, table.inputCoverage) && this.coverageSequenceMatches(table.inputGlyphCount, table.lookaheadCoverage)) {\n          return this.applyLookupList(table.lookupRecords);\n        }\n\n        break;\n    }\n\n    return false;\n  };\n\n  return OTProcessor;\n}();\n\nvar GlyphInfo = function () {\n  function GlyphInfo(font, id) {\n    var codePoints = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n    var features = arguments[3];\n\n    _classCallCheck(this, GlyphInfo);\n\n    this._font = font;\n    this.codePoints = codePoints;\n    this.id = id;\n    this.features = {};\n\n    if (Array.isArray(features)) {\n      for (var i = 0; i < features.length; i++) {\n        var feature = features[i];\n        this.features[feature] = true;\n      }\n    } else if ((typeof features === 'undefined' ? 'undefined' : _typeof(features)) === 'object') {\n      _Object$assign(this.features, features);\n    }\n\n    this.ligatureID = null;\n    this.ligatureComponent = null;\n    this.isLigated = false;\n    this.cursiveAttachment = null;\n    this.markAttachment = null;\n    this.shaperInfo = null;\n    this.substituted = false;\n    this.isMultiplied = false;\n  }\n\n  GlyphInfo.prototype.copy = function copy() {\n    return new GlyphInfo(this._font, this.id, this.codePoints, this.features);\n  };\n\n  _createClass(GlyphInfo, [{\n    key: 'id',\n    get: function get() {\n      return this._id;\n    },\n    set: function set(id) {\n      this._id = id;\n      this.substituted = true;\n      var GDEF = this._font.GDEF;\n\n      if (GDEF && GDEF.glyphClassDef) {\n        // TODO: clean this up\n        var classID = OTProcessor.prototype.getClassID(id, GDEF.glyphClassDef);\n        this.isBase = classID === 1;\n        this.isLigature = classID === 2;\n        this.isMark = classID === 3;\n        this.markAttachmentType = GDEF.markAttachClassDef ? OTProcessor.prototype.getClassID(id, GDEF.markAttachClassDef) : 0;\n      } else {\n        this.isMark = this.codePoints.length > 0 && this.codePoints.every(unicode.isMark);\n        this.isBase = !this.isMark;\n        this.isLigature = this.codePoints.length > 1;\n        this.markAttachmentType = 0;\n      }\n    }\n  }]);\n\n  return GlyphInfo;\n}();\n\nvar _class$5;\n\nvar _temp$1;\n/**\n * This is a shaper for the Hangul script, used by the Korean language.\n * It does the following:\n *   - decompose if unsupported by the font:\n *     <LV>   -> <L,V>\n *     <LVT>  -> <L,V,T>\n *     <LV,T> -> <L,V,T>\n *\n *   - compose if supported by the font:\n *     <L,V>   -> <LV>\n *     <L,V,T> -> <LVT>\n *     <LV,T>  -> <LVT>\n *\n *   - reorder tone marks (S is any valid syllable):\n *     <S, M> -> <M, S>\n *\n *   - apply ljmo, vjmo, and tjmo OpenType features to decomposed Jamo sequences.\n *\n * This logic is based on the following documents:\n *   - http://www.microsoft.com/typography/OpenTypeDev/hangul/intro.htm\n *   - http://ktug.org/~nomos/harfbuzz-hangul/hangulshaper.pdf\n */\n\n\nvar HangulShaper = (_temp$1 = _class$5 = function (_DefaultShaper) {\n  _inherits(HangulShaper, _DefaultShaper);\n\n  function HangulShaper() {\n    _classCallCheck(this, HangulShaper);\n\n    return _possibleConstructorReturn(this, _DefaultShaper.apply(this, arguments));\n  }\n\n  HangulShaper.planFeatures = function planFeatures(plan) {\n    plan.add(['ljmo', 'vjmo', 'tjmo'], false);\n  };\n\n  HangulShaper.assignFeatures = function assignFeatures(plan, glyphs) {\n    var state = 0;\n    var i = 0;\n\n    while (i < glyphs.length) {\n      var action = void 0;\n      var glyph = glyphs[i];\n      var code = glyph.codePoints[0];\n      var type = getType(code);\n      var _STATE_TABLE$state$ty = STATE_TABLE$1[state][type];\n      action = _STATE_TABLE$state$ty[0];\n      state = _STATE_TABLE$state$ty[1];\n\n      switch (action) {\n        case DECOMPOSE:\n          // Decompose the composed syllable if it is not supported by the font.\n          if (!plan.font.hasGlyphForCodePoint(code)) {\n            i = decompose(glyphs, i, plan.font);\n          }\n\n          break;\n\n        case COMPOSE:\n          // Found a decomposed syllable. Try to compose if supported by the font.\n          i = compose(glyphs, i, plan.font);\n          break;\n\n        case TONE_MARK:\n          // Got a valid syllable, followed by a tone mark. Move the tone mark to the beginning of the syllable.\n          reorderToneMark(glyphs, i, plan.font);\n          break;\n\n        case INVALID:\n          // Tone mark has no valid syllable to attach to, so insert a dotted circle\n          i = insertDottedCircle(glyphs, i, plan.font);\n          break;\n      }\n\n      i++;\n    }\n  };\n\n  return HangulShaper;\n}(DefaultShaper), _class$5.zeroMarkWidths = 'NONE', _temp$1);\nvar HANGUL_BASE = 0xac00;\nvar HANGUL_END = 0xd7a4;\nvar HANGUL_COUNT = HANGUL_END - HANGUL_BASE + 1;\nvar L_BASE = 0x1100; // lead\n\nvar V_BASE = 0x1161; // vowel\n\nvar T_BASE = 0x11a7; // trail\n\nvar L_COUNT = 19;\nvar V_COUNT = 21;\nvar T_COUNT = 28;\nvar L_END = L_BASE + L_COUNT - 1;\nvar V_END = V_BASE + V_COUNT - 1;\nvar T_END = T_BASE + T_COUNT - 1;\nvar DOTTED_CIRCLE = 0x25cc;\n\nvar isL = function isL(code) {\n  return 0x1100 <= code && code <= 0x115f || 0xa960 <= code && code <= 0xa97c;\n};\n\nvar isV = function isV(code) {\n  return 0x1160 <= code && code <= 0x11a7 || 0xd7b0 <= code && code <= 0xd7c6;\n};\n\nvar isT = function isT(code) {\n  return 0x11a8 <= code && code <= 0x11ff || 0xd7cb <= code && code <= 0xd7fb;\n};\n\nvar isTone = function isTone(code) {\n  return 0x302e <= code && code <= 0x302f;\n};\n\nvar isLVT = function isLVT(code) {\n  return HANGUL_BASE <= code && code <= HANGUL_END;\n};\n\nvar isLV = function isLV(code) {\n  return code - HANGUL_BASE < HANGUL_COUNT && (code - HANGUL_BASE) % T_COUNT === 0;\n};\n\nvar isCombiningL = function isCombiningL(code) {\n  return L_BASE <= code && code <= L_END;\n};\n\nvar isCombiningV = function isCombiningV(code) {\n  return V_BASE <= code && code <= V_END;\n};\n\nvar isCombiningT = function isCombiningT(code) {\n  return T_BASE + 1 && 1 <= code && code <= T_END;\n}; // Character categories\n\n\nvar X = 0; // Other character\n\nvar L = 1; // Leading consonant\n\nvar V = 2; // Medial vowel\n\nvar T = 3; // Trailing consonant\n\nvar LV = 4; // Composed <LV> syllable\n\nvar LVT = 5; // Composed <LVT> syllable\n\nvar M = 6; // Tone mark\n// This function classifies a character using the above categories.\n\nfunction getType(code) {\n  if (isL(code)) {\n    return L;\n  }\n\n  if (isV(code)) {\n    return V;\n  }\n\n  if (isT(code)) {\n    return T;\n  }\n\n  if (isLV(code)) {\n    return LV;\n  }\n\n  if (isLVT(code)) {\n    return LVT;\n  }\n\n  if (isTone(code)) {\n    return M;\n  }\n\n  return X;\n} // State machine actions\n\n\nvar NO_ACTION = 0;\nvar DECOMPOSE = 1;\nvar COMPOSE = 2;\nvar TONE_MARK = 4;\nvar INVALID = 5; // Build a state machine that accepts valid syllables, and applies actions along the way.\n// The logic this is implementing is documented at the top of the file.\n\nvar STATE_TABLE$1 = [//       X                 L                 V                T                  LV                LVT               M\n// State 0: start state\n[[NO_ACTION, 0], [NO_ACTION, 1], [NO_ACTION, 0], [NO_ACTION, 0], [DECOMPOSE, 2], [DECOMPOSE, 3], [INVALID, 0]], // State 1: <L>\n[[NO_ACTION, 0], [NO_ACTION, 1], [COMPOSE, 2], [NO_ACTION, 0], [DECOMPOSE, 2], [DECOMPOSE, 3], [INVALID, 0]], // State 2: <L,V> or <LV>\n[[NO_ACTION, 0], [NO_ACTION, 1], [NO_ACTION, 0], [COMPOSE, 3], [DECOMPOSE, 2], [DECOMPOSE, 3], [TONE_MARK, 0]], // State 3: <L,V,T> or <LVT>\n[[NO_ACTION, 0], [NO_ACTION, 1], [NO_ACTION, 0], [NO_ACTION, 0], [DECOMPOSE, 2], [DECOMPOSE, 3], [TONE_MARK, 0]]];\n\nfunction getGlyph(font, code, features) {\n  return new GlyphInfo(font, font.glyphForCodePoint(code).id, [code], features);\n}\n\nfunction decompose(glyphs, i, font) {\n  var glyph = glyphs[i];\n  var code = glyph.codePoints[0];\n  var s = code - HANGUL_BASE;\n  var t = T_BASE + s % T_COUNT;\n  s = s / T_COUNT | 0;\n  var l = L_BASE + s / V_COUNT | 0;\n  var v = V_BASE + s % V_COUNT; // Don't decompose if all of the components are not available\n\n  if (!font.hasGlyphForCodePoint(l) || !font.hasGlyphForCodePoint(v) || t !== T_BASE && !font.hasGlyphForCodePoint(t)) {\n    return i;\n  } // Replace the current glyph with decomposed L, V, and T glyphs,\n  // and apply the proper OpenType features to each component.\n\n\n  var ljmo = getGlyph(font, l, glyph.features);\n  ljmo.features.ljmo = true;\n  var vjmo = getGlyph(font, v, glyph.features);\n  vjmo.features.vjmo = true;\n  var insert = [ljmo, vjmo];\n\n  if (t > T_BASE) {\n    var tjmo = getGlyph(font, t, glyph.features);\n    tjmo.features.tjmo = true;\n    insert.push(tjmo);\n  }\n\n  glyphs.splice.apply(glyphs, [i, 1].concat(insert));\n  return i + insert.length - 1;\n}\n\nfunction compose(glyphs, i, font) {\n  var glyph = glyphs[i];\n  var code = glyphs[i].codePoints[0];\n  var type = getType(code);\n  var prev = glyphs[i - 1].codePoints[0];\n  var prevType = getType(prev); // Figure out what type of syllable we're dealing with\n\n  var lv = void 0,\n      ljmo = void 0,\n      vjmo = void 0,\n      tjmo = void 0;\n\n  if (prevType === LV && type === T) {\n    // <LV,T>\n    lv = prev;\n    tjmo = glyph;\n  } else {\n    if (type === V) {\n      // <L,V>\n      ljmo = glyphs[i - 1];\n      vjmo = glyph;\n    } else {\n      // <L,V,T>\n      ljmo = glyphs[i - 2];\n      vjmo = glyphs[i - 1];\n      tjmo = glyph;\n    }\n\n    var l = ljmo.codePoints[0];\n    var v = vjmo.codePoints[0]; // Make sure L and V are combining characters\n\n    if (isCombiningL(l) && isCombiningV(v)) {\n      lv = HANGUL_BASE + ((l - L_BASE) * V_COUNT + (v - V_BASE)) * T_COUNT;\n    }\n  }\n\n  var t = tjmo && tjmo.codePoints[0] || T_BASE;\n\n  if (lv != null && (t === T_BASE || isCombiningT(t))) {\n    var s = lv + (t - T_BASE); // Replace with a composed glyph if supported by the font,\n    // otherwise apply the proper OpenType features to each component.\n\n    if (font.hasGlyphForCodePoint(s)) {\n      var del = prevType === V ? 3 : 2;\n      glyphs.splice(i - del + 1, del, getGlyph(font, s, glyph.features));\n      return i - del + 1;\n    }\n  } // Didn't compose (either a non-combining component or unsupported by font).\n\n\n  if (ljmo) {\n    ljmo.features.ljmo = true;\n  }\n\n  if (vjmo) {\n    vjmo.features.vjmo = true;\n  }\n\n  if (tjmo) {\n    tjmo.features.tjmo = true;\n  }\n\n  if (prevType === LV) {\n    // Sequence was originally <L,V>, which got combined earlier.\n    // Either the T was non-combining, or the LVT glyph wasn't supported.\n    // Decompose the glyph again and apply OT features.\n    decompose(glyphs, i - 1, font);\n    return i + 1;\n  }\n\n  return i;\n}\n\nfunction getLength(code) {\n  switch (getType(code)) {\n    case LV:\n    case LVT:\n      return 1;\n\n    case V:\n      return 2;\n\n    case T:\n      return 3;\n  }\n}\n\nfunction reorderToneMark(glyphs, i, font) {\n  var glyph = glyphs[i];\n  var code = glyphs[i].codePoints[0]; // Move tone mark to the beginning of the previous syllable, unless it is zero width\n\n  if (font.glyphForCodePoint(code).advanceWidth === 0) {\n    return;\n  }\n\n  var prev = glyphs[i - 1].codePoints[0];\n  var len = getLength(prev);\n  glyphs.splice(i, 1);\n  return glyphs.splice(i - len, 0, glyph);\n}\n\nfunction insertDottedCircle(glyphs, i, font) {\n  var glyph = glyphs[i];\n  var code = glyphs[i].codePoints[0];\n\n  if (font.hasGlyphForCodePoint(DOTTED_CIRCLE)) {\n    var dottedCircle = getGlyph(font, DOTTED_CIRCLE, glyph.features); // If the tone mark is zero width, insert the dotted circle before, otherwise after\n\n    var idx = font.glyphForCodePoint(code).advanceWidth === 0 ? i : i + 1;\n    glyphs.splice(idx, 0, dottedCircle);\n    i++;\n  }\n\n  return i;\n}\n\nvar stateTable = [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 2, 3, 4, 5, 6, 7, 8, 9, 0, 10, 11, 11, 12, 13, 14, 15, 16, 17], [0, 0, 0, 18, 19, 20, 21, 22, 23, 0, 24, 0, 0, 25, 26, 0, 0, 27, 0], [0, 0, 0, 28, 29, 30, 31, 32, 33, 0, 34, 0, 0, 35, 36, 0, 0, 37, 0], [0, 0, 0, 38, 5, 7, 7, 8, 9, 0, 10, 0, 0, 0, 13, 0, 0, 16, 0], [0, 39, 0, 0, 0, 40, 41, 0, 9, 0, 10, 0, 0, 0, 42, 0, 39, 0, 0], [0, 0, 0, 0, 43, 44, 44, 8, 9, 0, 0, 0, 0, 12, 43, 0, 0, 0, 0], [0, 0, 0, 0, 43, 44, 44, 8, 9, 0, 0, 0, 0, 0, 43, 0, 0, 0, 0], [0, 0, 0, 45, 46, 47, 48, 49, 9, 0, 10, 0, 0, 0, 42, 0, 0, 0, 0], [0, 0, 0, 0, 0, 50, 0, 0, 51, 0, 10, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 52, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 53, 54, 55, 56, 57, 58, 0, 59, 0, 0, 60, 61, 0, 0, 62, 0], [0, 0, 0, 4, 5, 7, 7, 8, 9, 0, 10, 0, 0, 0, 13, 0, 0, 16, 0], [0, 63, 64, 0, 0, 40, 41, 0, 9, 0, 10, 0, 0, 0, 42, 0, 63, 0, 0], [0, 2, 3, 4, 5, 6, 7, 8, 9, 0, 10, 11, 11, 12, 13, 0, 2, 16, 0], [0, 0, 0, 18, 65, 20, 21, 22, 23, 0, 24, 0, 0, 25, 26, 0, 0, 27, 0], [0, 0, 0, 0, 66, 67, 67, 8, 9, 0, 10, 0, 0, 0, 68, 0, 0, 0, 0], [0, 0, 0, 69, 0, 70, 70, 0, 71, 0, 72, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 73, 19, 74, 74, 22, 23, 0, 24, 0, 0, 0, 26, 0, 0, 27, 0], [0, 75, 0, 0, 0, 76, 77, 0, 23, 0, 24, 0, 0, 0, 78, 0, 75, 0, 0], [0, 0, 0, 0, 79, 80, 80, 22, 23, 0, 0, 0, 0, 25, 79, 0, 0, 0, 0], [0, 0, 0, 18, 19, 20, 74, 22, 23, 0, 24, 0, 0, 25, 26, 0, 0, 27, 0], [0, 0, 0, 81, 82, 83, 84, 85, 23, 0, 24, 0, 0, 0, 78, 0, 0, 0, 0], [0, 0, 0, 0, 0, 86, 0, 0, 87, 0, 24, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 88, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 18, 19, 74, 74, 22, 23, 0, 24, 0, 0, 0, 26, 0, 0, 27, 0], [0, 89, 90, 0, 0, 76, 77, 0, 23, 0, 24, 0, 0, 0, 78, 0, 89, 0, 0], [0, 0, 0, 0, 91, 92, 92, 22, 23, 0, 24, 0, 0, 0, 93, 0, 0, 0, 0], [0, 0, 0, 94, 29, 95, 31, 32, 33, 0, 34, 0, 0, 0, 36, 0, 0, 37, 0], [0, 96, 0, 0, 0, 97, 98, 0, 33, 0, 34, 0, 0, 0, 99, 0, 96, 0, 0], [0, 0, 0, 0, 100, 101, 101, 32, 33, 0, 0, 0, 0, 35, 100, 0, 0, 0, 0], [0, 0, 0, 0, 100, 101, 101, 32, 33, 0, 0, 0, 0, 0, 100, 0, 0, 0, 0], [0, 0, 0, 102, 103, 104, 105, 106, 33, 0, 34, 0, 0, 0, 99, 0, 0, 0, 0], [0, 0, 0, 0, 0, 107, 0, 0, 108, 0, 34, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 109, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 28, 29, 95, 31, 32, 33, 0, 34, 0, 0, 0, 36, 0, 0, 37, 0], [0, 110, 111, 0, 0, 97, 98, 0, 33, 0, 34, 0, 0, 0, 99, 0, 110, 0, 0], [0, 0, 0, 0, 112, 113, 113, 32, 33, 0, 34, 0, 0, 0, 114, 0, 0, 0, 0], [0, 0, 0, 0, 5, 7, 7, 8, 9, 0, 10, 0, 0, 0, 13, 0, 0, 16, 0], [0, 0, 0, 115, 116, 117, 118, 8, 9, 0, 10, 0, 0, 119, 120, 0, 0, 16, 0], [0, 0, 0, 0, 0, 121, 121, 0, 9, 0, 10, 0, 0, 0, 42, 0, 0, 0, 0], [0, 39, 0, 122, 0, 123, 123, 8, 9, 0, 10, 0, 0, 0, 42, 0, 39, 0, 0], [0, 124, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 124, 0, 0], [0, 39, 0, 0, 0, 121, 125, 0, 9, 0, 10, 0, 0, 0, 42, 0, 39, 0, 0], [0, 0, 0, 0, 0, 126, 126, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 46, 47, 48, 49, 9, 0, 10, 0, 0, 0, 42, 0, 0, 0, 0], [0, 0, 0, 0, 0, 47, 47, 49, 9, 0, 10, 0, 0, 0, 42, 0, 0, 0, 0], [0, 0, 0, 0, 0, 127, 127, 49, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 128, 127, 127, 49, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 129, 130, 131, 132, 133, 9, 0, 10, 0, 0, 0, 42, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 50, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 134, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 135, 54, 56, 56, 57, 58, 0, 59, 0, 0, 0, 61, 0, 0, 62, 0], [0, 136, 0, 0, 0, 137, 138, 0, 58, 0, 59, 0, 0, 0, 139, 0, 136, 0, 0], [0, 0, 0, 0, 140, 141, 141, 57, 58, 0, 0, 0, 0, 60, 140, 0, 0, 0, 0], [0, 0, 0, 0, 140, 141, 141, 57, 58, 0, 0, 0, 0, 0, 140, 0, 0, 0, 0], [0, 0, 0, 142, 143, 144, 145, 146, 58, 0, 59, 0, 0, 0, 139, 0, 0, 0, 0], [0, 0, 0, 0, 0, 147, 0, 0, 148, 0, 59, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 149, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 53, 54, 56, 56, 57, 58, 0, 59, 0, 0, 0, 61, 0, 0, 62, 0], [0, 150, 151, 0, 0, 137, 138, 0, 58, 0, 59, 0, 0, 0, 139, 0, 150, 0, 0], [0, 0, 0, 0, 152, 153, 153, 57, 58, 0, 59, 0, 0, 0, 154, 0, 0, 0, 0], [0, 0, 0, 155, 116, 156, 157, 8, 9, 0, 10, 0, 0, 158, 120, 0, 0, 16, 0], [0, 0, 0, 0, 0, 121, 121, 0, 9, 0, 10, 0, 0, 0, 0, 0, 0, 0, 0], [0, 75, 3, 4, 5, 159, 160, 8, 161, 0, 162, 0, 11, 12, 163, 0, 75, 16, 0], [0, 0, 0, 0, 0, 40, 164, 0, 9, 0, 10, 0, 0, 0, 42, 0, 0, 0, 0], [0, 0, 0, 0, 165, 44, 44, 8, 9, 0, 0, 0, 0, 0, 165, 0, 0, 0, 0], [0, 124, 64, 0, 0, 40, 164, 0, 9, 0, 10, 0, 0, 0, 42, 0, 124, 0, 0], [0, 0, 0, 0, 0, 70, 70, 0, 71, 0, 72, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 71, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 166, 0, 0, 167, 0, 72, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 168, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 19, 74, 74, 22, 23, 0, 24, 0, 0, 0, 26, 0, 0, 27, 0], [0, 0, 0, 0, 79, 80, 80, 22, 23, 0, 0, 0, 0, 0, 79, 0, 0, 0, 0], [0, 0, 0, 169, 170, 171, 172, 22, 23, 0, 24, 0, 0, 173, 174, 0, 0, 27, 0], [0, 0, 0, 0, 0, 175, 175, 0, 23, 0, 24, 0, 0, 0, 78, 0, 0, 0, 0], [0, 75, 0, 176, 0, 177, 177, 22, 23, 0, 24, 0, 0, 0, 78, 0, 75, 0, 0], [0, 178, 90, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 178, 0, 0], [0, 75, 0, 0, 0, 175, 179, 0, 23, 0, 24, 0, 0, 0, 78, 0, 75, 0, 0], [0, 0, 0, 0, 0, 180, 180, 22, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 82, 83, 84, 85, 23, 0, 24, 0, 0, 0, 78, 0, 0, 0, 0], [0, 0, 0, 0, 0, 83, 83, 85, 23, 0, 24, 0, 0, 0, 78, 0, 0, 0, 0], [0, 0, 0, 0, 0, 181, 181, 85, 23, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 182, 181, 181, 85, 23, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 183, 184, 185, 186, 187, 23, 0, 24, 0, 0, 0, 78, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 86, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 188, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 189, 170, 190, 191, 22, 23, 0, 24, 0, 0, 192, 174, 0, 0, 27, 0], [0, 0, 0, 0, 0, 175, 175, 0, 23, 0, 24, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 76, 193, 0, 23, 0, 24, 0, 0, 0, 78, 0, 0, 0, 0], [0, 0, 0, 0, 194, 80, 80, 22, 23, 0, 0, 0, 0, 0, 194, 0, 0, 0, 0], [0, 178, 90, 0, 0, 76, 193, 0, 23, 0, 24, 0, 0, 0, 78, 0, 178, 0, 0], [0, 0, 0, 0, 29, 95, 31, 32, 33, 0, 34, 0, 0, 0, 36, 0, 0, 37, 0], [0, 0, 0, 0, 100, 101, 101, 32, 33, 0, 0, 0, 0, 0, 100, 0, 0, 0, 0], [0, 0, 0, 195, 196, 197, 198, 32, 33, 0, 34, 0, 0, 199, 200, 0, 0, 37, 0], [0, 0, 0, 0, 0, 201, 201, 0, 33, 0, 34, 0, 0, 0, 99, 0, 0, 0, 0], [0, 96, 0, 202, 0, 203, 203, 32, 33, 0, 34, 0, 0, 0, 99, 0, 96, 0, 0], [0, 204, 111, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 204, 0, 0], [0, 96, 0, 0, 0, 201, 205, 0, 33, 0, 34, 0, 0, 0, 99, 0, 96, 0, 0], [0, 0, 0, 0, 0, 206, 206, 32, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 103, 104, 105, 106, 33, 0, 34, 0, 0, 0, 99, 0, 0, 0, 0], [0, 0, 0, 0, 0, 104, 104, 106, 33, 0, 34, 0, 0, 0, 99, 0, 0, 0, 0], [0, 0, 0, 0, 0, 207, 207, 106, 33, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 208, 207, 207, 106, 33, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 209, 210, 211, 212, 213, 33, 0, 34, 0, 0, 0, 99, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 34, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 107, 0, 0, 0, 0, 34, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 214, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 215, 196, 216, 217, 32, 33, 0, 34, 0, 0, 218, 200, 0, 0, 37, 0], [0, 0, 0, 0, 0, 201, 201, 0, 33, 0, 34, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 97, 219, 0, 33, 0, 34, 0, 0, 0, 99, 0, 0, 0, 0], [0, 0, 0, 0, 220, 101, 101, 32, 33, 0, 0, 0, 0, 0, 220, 0, 0, 0, 0], [0, 204, 111, 0, 0, 97, 219, 0, 33, 0, 34, 0, 0, 0, 99, 0, 204, 0, 0], [0, 0, 0, 221, 116, 222, 222, 8, 9, 0, 10, 0, 0, 0, 120, 0, 0, 16, 0], [0, 223, 0, 0, 0, 40, 224, 0, 9, 0, 10, 0, 0, 0, 42, 0, 223, 0, 0], [0, 0, 0, 0, 225, 44, 44, 8, 9, 0, 0, 0, 0, 119, 225, 0, 0, 0, 0], [0, 0, 0, 115, 116, 117, 222, 8, 9, 0, 10, 0, 0, 119, 120, 0, 0, 16, 0], [0, 0, 0, 115, 116, 222, 222, 8, 9, 0, 10, 0, 0, 0, 120, 0, 0, 16, 0], [0, 226, 64, 0, 0, 40, 224, 0, 9, 0, 10, 0, 0, 0, 42, 0, 226, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 39, 0, 0, 0, 121, 121, 0, 9, 0, 10, 0, 0, 0, 42, 0, 39, 0, 0], [0, 0, 0, 0, 0, 44, 44, 8, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 227, 0, 228, 229, 0, 9, 0, 10, 0, 0, 230, 0, 0, 0, 0, 0], [0, 39, 0, 122, 0, 121, 121, 0, 9, 0, 10, 0, 0, 0, 42, 0, 39, 0, 0], [0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 231, 231, 49, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 232, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 130, 131, 132, 133, 9, 0, 10, 0, 0, 0, 42, 0, 0, 0, 0], [0, 0, 0, 0, 0, 131, 131, 133, 9, 0, 10, 0, 0, 0, 42, 0, 0, 0, 0], [0, 0, 0, 0, 0, 233, 233, 133, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 234, 233, 233, 133, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 235, 236, 237, 238, 239, 9, 0, 10, 0, 0, 0, 42, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 54, 56, 56, 57, 58, 0, 59, 0, 0, 0, 61, 0, 0, 62, 0], [0, 0, 0, 240, 241, 242, 243, 57, 58, 0, 59, 0, 0, 244, 245, 0, 0, 62, 0], [0, 0, 0, 0, 0, 246, 246, 0, 58, 0, 59, 0, 0, 0, 139, 0, 0, 0, 0], [0, 136, 0, 247, 0, 248, 248, 57, 58, 0, 59, 0, 0, 0, 139, 0, 136, 0, 0], [0, 249, 151, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 249, 0, 0], [0, 136, 0, 0, 0, 246, 250, 0, 58, 0, 59, 0, 0, 0, 139, 0, 136, 0, 0], [0, 0, 0, 0, 0, 251, 251, 57, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 143, 144, 145, 146, 58, 0, 59, 0, 0, 0, 139, 0, 0, 0, 0], [0, 0, 0, 0, 0, 144, 144, 146, 58, 0, 59, 0, 0, 0, 139, 0, 0, 0, 0], [0, 0, 0, 0, 0, 252, 252, 146, 58, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 253, 252, 252, 146, 58, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 254, 255, 256, 257, 258, 58, 0, 59, 0, 0, 0, 139, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 59, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 147, 0, 0, 0, 0, 59, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 259, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 260, 241, 261, 262, 57, 58, 0, 59, 0, 0, 263, 245, 0, 0, 62, 0], [0, 0, 0, 0, 0, 246, 246, 0, 58, 0, 59, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 137, 264, 0, 58, 0, 59, 0, 0, 0, 139, 0, 0, 0, 0], [0, 0, 0, 0, 265, 141, 141, 57, 58, 0, 0, 0, 0, 0, 265, 0, 0, 0, 0], [0, 249, 151, 0, 0, 137, 264, 0, 58, 0, 59, 0, 0, 0, 139, 0, 249, 0, 0], [0, 0, 0, 221, 116, 222, 222, 8, 9, 0, 10, 0, 0, 0, 120, 0, 0, 16, 0], [0, 0, 0, 0, 225, 44, 44, 8, 9, 0, 0, 0, 0, 158, 225, 0, 0, 0, 0], [0, 0, 0, 155, 116, 156, 222, 8, 9, 0, 10, 0, 0, 158, 120, 0, 0, 16, 0], [0, 0, 0, 155, 116, 222, 222, 8, 9, 0, 10, 0, 0, 0, 120, 0, 0, 16, 0], [0, 0, 0, 0, 43, 266, 266, 8, 161, 0, 24, 0, 0, 12, 267, 0, 0, 0, 0], [0, 75, 0, 176, 43, 268, 268, 269, 161, 0, 24, 0, 0, 0, 267, 0, 75, 0, 0], [0, 0, 0, 0, 0, 270, 0, 0, 271, 0, 162, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 272, 0, 0, 0, 0, 0, 0, 0, 0], [0, 273, 274, 0, 0, 40, 41, 0, 9, 0, 10, 0, 0, 0, 42, 0, 273, 0, 0], [0, 0, 0, 40, 0, 123, 123, 8, 9, 0, 10, 0, 0, 0, 42, 0, 0, 0, 0], [0, 0, 0, 0, 0, 121, 275, 0, 9, 0, 10, 0, 0, 0, 42, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 72, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 166, 0, 0, 0, 0, 72, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 276, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 277, 170, 278, 278, 22, 23, 0, 24, 0, 0, 0, 174, 0, 0, 27, 0], [0, 279, 0, 0, 0, 76, 280, 0, 23, 0, 24, 0, 0, 0, 78, 0, 279, 0, 0], [0, 0, 0, 0, 281, 80, 80, 22, 23, 0, 0, 0, 0, 173, 281, 0, 0, 0, 0], [0, 0, 0, 169, 170, 171, 278, 22, 23, 0, 24, 0, 0, 173, 174, 0, 0, 27, 0], [0, 0, 0, 169, 170, 278, 278, 22, 23, 0, 24, 0, 0, 0, 174, 0, 0, 27, 0], [0, 282, 90, 0, 0, 76, 280, 0, 23, 0, 24, 0, 0, 0, 78, 0, 282, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 23, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 75, 0, 0, 0, 175, 175, 0, 23, 0, 24, 0, 0, 0, 78, 0, 75, 0, 0], [0, 0, 0, 0, 0, 80, 80, 22, 23, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 283, 0, 284, 285, 0, 23, 0, 24, 0, 0, 286, 0, 0, 0, 0, 0], [0, 75, 0, 176, 0, 175, 175, 0, 23, 0, 24, 0, 0, 0, 78, 0, 75, 0, 0], [0, 0, 0, 0, 0, 0, 0, 22, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 287, 287, 85, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 288, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 184, 185, 186, 187, 23, 0, 24, 0, 0, 0, 78, 0, 0, 0, 0], [0, 0, 0, 0, 0, 185, 185, 187, 23, 0, 24, 0, 0, 0, 78, 0, 0, 0, 0], [0, 0, 0, 0, 0, 289, 289, 187, 23, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 290, 289, 289, 187, 23, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 291, 292, 293, 294, 295, 23, 0, 24, 0, 0, 0, 78, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 277, 170, 278, 278, 22, 23, 0, 24, 0, 0, 0, 174, 0, 0, 27, 0], [0, 0, 0, 0, 281, 80, 80, 22, 23, 0, 0, 0, 0, 192, 281, 0, 0, 0, 0], [0, 0, 0, 189, 170, 190, 278, 22, 23, 0, 24, 0, 0, 192, 174, 0, 0, 27, 0], [0, 0, 0, 189, 170, 278, 278, 22, 23, 0, 24, 0, 0, 0, 174, 0, 0, 27, 0], [0, 0, 0, 76, 0, 177, 177, 22, 23, 0, 24, 0, 0, 0, 78, 0, 0, 0, 0], [0, 0, 0, 0, 0, 175, 296, 0, 23, 0, 24, 0, 0, 0, 78, 0, 0, 0, 0], [0, 0, 0, 297, 196, 298, 298, 32, 33, 0, 34, 0, 0, 0, 200, 0, 0, 37, 0], [0, 299, 0, 0, 0, 97, 300, 0, 33, 0, 34, 0, 0, 0, 99, 0, 299, 0, 0], [0, 0, 0, 0, 301, 101, 101, 32, 33, 0, 0, 0, 0, 199, 301, 0, 0, 0, 0], [0, 0, 0, 195, 196, 197, 298, 32, 33, 0, 34, 0, 0, 199, 200, 0, 0, 37, 0], [0, 0, 0, 195, 196, 298, 298, 32, 33, 0, 34, 0, 0, 0, 200, 0, 0, 37, 0], [0, 302, 111, 0, 0, 97, 300, 0, 33, 0, 34, 0, 0, 0, 99, 0, 302, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 33, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 96, 0, 0, 0, 201, 201, 0, 33, 0, 34, 0, 0, 0, 99, 0, 96, 0, 0], [0, 0, 0, 0, 0, 101, 101, 32, 33, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 303, 0, 304, 305, 0, 33, 0, 34, 0, 0, 306, 0, 0, 0, 0, 0], [0, 96, 0, 202, 0, 201, 201, 0, 33, 0, 34, 0, 0, 0, 99, 0, 96, 0, 0], [0, 0, 0, 0, 0, 0, 0, 32, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 307, 307, 106, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 308, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 210, 211, 212, 213, 33, 0, 34, 0, 0, 0, 99, 0, 0, 0, 0], [0, 0, 0, 0, 0, 211, 211, 213, 33, 0, 34, 0, 0, 0, 99, 0, 0, 0, 0], [0, 0, 0, 0, 0, 309, 309, 213, 33, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 310, 309, 309, 213, 33, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 311, 312, 313, 314, 315, 33, 0, 34, 0, 0, 0, 99, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 297, 196, 298, 298, 32, 33, 0, 34, 0, 0, 0, 200, 0, 0, 37, 0], [0, 0, 0, 0, 301, 101, 101, 32, 33, 0, 0, 0, 0, 218, 301, 0, 0, 0, 0], [0, 0, 0, 215, 196, 216, 298, 32, 33, 0, 34, 0, 0, 218, 200, 0, 0, 37, 0], [0, 0, 0, 215, 196, 298, 298, 32, 33, 0, 34, 0, 0, 0, 200, 0, 0, 37, 0], [0, 0, 0, 97, 0, 203, 203, 32, 33, 0, 34, 0, 0, 0, 99, 0, 0, 0, 0], [0, 0, 0, 0, 0, 201, 316, 0, 33, 0, 34, 0, 0, 0, 99, 0, 0, 0, 0], [0, 0, 0, 0, 116, 222, 222, 8, 9, 0, 10, 0, 0, 0, 120, 0, 0, 16, 0], [0, 0, 0, 0, 225, 44, 44, 8, 9, 0, 0, 0, 0, 0, 225, 0, 0, 0, 0], [0, 0, 0, 317, 318, 319, 320, 8, 9, 0, 10, 0, 0, 321, 322, 0, 0, 16, 0], [0, 223, 0, 323, 0, 123, 123, 8, 9, 0, 10, 0, 0, 0, 42, 0, 223, 0, 0], [0, 223, 0, 0, 0, 121, 324, 0, 9, 0, 10, 0, 0, 0, 42, 0, 223, 0, 0], [0, 0, 0, 325, 318, 326, 327, 8, 9, 0, 10, 0, 0, 328, 322, 0, 0, 16, 0], [0, 0, 0, 64, 0, 121, 121, 0, 9, 0, 10, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 230, 0, 0, 0, 0, 0], [0, 0, 0, 227, 0, 228, 121, 0, 9, 0, 10, 0, 0, 230, 0, 0, 0, 0, 0], [0, 0, 0, 227, 0, 121, 121, 0, 9, 0, 10, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 49, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 46, 0, 0], [0, 0, 0, 0, 0, 329, 329, 133, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 330, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 236, 237, 238, 239, 9, 0, 10, 0, 0, 0, 42, 0, 0, 0, 0], [0, 0, 0, 0, 0, 237, 237, 239, 9, 0, 10, 0, 0, 0, 42, 0, 0, 0, 0], [0, 0, 0, 0, 0, 331, 331, 239, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 332, 331, 331, 239, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 333, 40, 121, 334, 0, 9, 0, 10, 0, 0, 0, 42, 0, 0, 0, 0], [0, 0, 0, 335, 241, 336, 336, 57, 58, 0, 59, 0, 0, 0, 245, 0, 0, 62, 0], [0, 337, 0, 0, 0, 137, 338, 0, 58, 0, 59, 0, 0, 0, 139, 0, 337, 0, 0], [0, 0, 0, 0, 339, 141, 141, 57, 58, 0, 0, 0, 0, 244, 339, 0, 0, 0, 0], [0, 0, 0, 240, 241, 242, 336, 57, 58, 0, 59, 0, 0, 244, 245, 0, 0, 62, 0], [0, 0, 0, 240, 241, 336, 336, 57, 58, 0, 59, 0, 0, 0, 245, 0, 0, 62, 0], [0, 340, 151, 0, 0, 137, 338, 0, 58, 0, 59, 0, 0, 0, 139, 0, 340, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 58, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 136, 0, 0, 0, 246, 246, 0, 58, 0, 59, 0, 0, 0, 139, 0, 136, 0, 0], [0, 0, 0, 0, 0, 141, 141, 57, 58, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 341, 0, 342, 343, 0, 58, 0, 59, 0, 0, 344, 0, 0, 0, 0, 0], [0, 136, 0, 247, 0, 246, 246, 0, 58, 0, 59, 0, 0, 0, 139, 0, 136, 0, 0], [0, 0, 0, 0, 0, 0, 0, 57, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 345, 345, 146, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 346, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 255, 256, 257, 258, 58, 0, 59, 0, 0, 0, 139, 0, 0, 0, 0], [0, 0, 0, 0, 0, 256, 256, 258, 58, 0, 59, 0, 0, 0, 139, 0, 0, 0, 0], [0, 0, 0, 0, 0, 347, 347, 258, 58, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 348, 347, 347, 258, 58, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 349, 350, 351, 352, 353, 58, 0, 59, 0, 0, 0, 139, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 335, 241, 336, 336, 57, 58, 0, 59, 0, 0, 0, 245, 0, 0, 62, 0], [0, 0, 0, 0, 339, 141, 141, 57, 58, 0, 0, 0, 0, 263, 339, 0, 0, 0, 0], [0, 0, 0, 260, 241, 261, 336, 57, 58, 0, 59, 0, 0, 263, 245, 0, 0, 62, 0], [0, 0, 0, 260, 241, 336, 336, 57, 58, 0, 59, 0, 0, 0, 245, 0, 0, 62, 0], [0, 0, 0, 137, 0, 248, 248, 57, 58, 0, 59, 0, 0, 0, 139, 0, 0, 0, 0], [0, 0, 0, 0, 0, 246, 354, 0, 58, 0, 59, 0, 0, 0, 139, 0, 0, 0, 0], [0, 0, 0, 0, 0, 126, 126, 8, 23, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 355, 90, 0, 0, 121, 125, 0, 9, 0, 10, 0, 0, 0, 42, 0, 355, 0, 0], [0, 0, 0, 0, 0, 356, 356, 269, 23, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 357, 358, 359, 360, 361, 161, 0, 162, 0, 0, 0, 362, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 162, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 270, 0, 0, 0, 0, 162, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 363, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 364, 116, 365, 366, 8, 161, 0, 162, 0, 0, 367, 120, 0, 0, 16, 0], [0, 0, 0, 0, 0, 368, 368, 0, 161, 0, 162, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 40, 0, 121, 121, 0, 9, 0, 10, 0, 0, 0, 42, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 170, 278, 278, 22, 23, 0, 24, 0, 0, 0, 174, 0, 0, 27, 0], [0, 0, 0, 0, 281, 80, 80, 22, 23, 0, 0, 0, 0, 0, 281, 0, 0, 0, 0], [0, 0, 0, 369, 370, 371, 372, 22, 23, 0, 24, 0, 0, 373, 374, 0, 0, 27, 0], [0, 279, 0, 375, 0, 177, 177, 22, 23, 0, 24, 0, 0, 0, 78, 0, 279, 0, 0], [0, 279, 0, 0, 0, 175, 376, 0, 23, 0, 24, 0, 0, 0, 78, 0, 279, 0, 0], [0, 0, 0, 377, 370, 378, 379, 22, 23, 0, 24, 0, 0, 380, 374, 0, 0, 27, 0], [0, 0, 0, 90, 0, 175, 175, 0, 23, 0, 24, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 23, 0, 0, 0, 0, 286, 0, 0, 0, 0, 0], [0, 0, 0, 283, 0, 284, 175, 0, 23, 0, 24, 0, 0, 286, 0, 0, 0, 0, 0], [0, 0, 0, 283, 0, 175, 175, 0, 23, 0, 24, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 85, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 82, 0, 0], [0, 0, 0, 0, 0, 381, 381, 187, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 382, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 292, 293, 294, 295, 23, 0, 24, 0, 0, 0, 78, 0, 0, 0, 0], [0, 0, 0, 0, 0, 293, 293, 295, 23, 0, 24, 0, 0, 0, 78, 0, 0, 0, 0], [0, 0, 0, 0, 0, 383, 383, 295, 23, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 384, 383, 383, 295, 23, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 385, 76, 175, 386, 0, 23, 0, 24, 0, 0, 0, 78, 0, 0, 0, 0], [0, 0, 0, 76, 0, 175, 175, 0, 23, 0, 24, 0, 0, 0, 78, 0, 0, 0, 0], [0, 0, 0, 0, 196, 298, 298, 32, 33, 0, 34, 0, 0, 0, 200, 0, 0, 37, 0], [0, 0, 0, 0, 301, 101, 101, 32, 33, 0, 0, 0, 0, 0, 301, 0, 0, 0, 0], [0, 0, 0, 387, 388, 389, 390, 32, 33, 0, 34, 0, 0, 391, 392, 0, 0, 37, 0], [0, 299, 0, 393, 0, 203, 203, 32, 33, 0, 34, 0, 0, 0, 99, 0, 299, 0, 0], [0, 299, 0, 0, 0, 201, 394, 0, 33, 0, 34, 0, 0, 0, 99, 0, 299, 0, 0], [0, 0, 0, 395, 388, 396, 397, 32, 33, 0, 34, 0, 0, 398, 392, 0, 0, 37, 0], [0, 0, 0, 111, 0, 201, 201, 0, 33, 0, 34, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 33, 0, 0, 0, 0, 306, 0, 0, 0, 0, 0], [0, 0, 0, 303, 0, 304, 201, 0, 33, 0, 34, 0, 0, 306, 0, 0, 0, 0, 0], [0, 0, 0, 303, 0, 201, 201, 0, 33, 0, 34, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 106, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 103, 0, 0], [0, 0, 0, 0, 0, 399, 399, 213, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 400, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 312, 313, 314, 315, 33, 0, 34, 0, 0, 0, 99, 0, 0, 0, 0], [0, 0, 0, 0, 0, 313, 313, 315, 33, 0, 34, 0, 0, 0, 99, 0, 0, 0, 0], [0, 0, 0, 0, 0, 401, 401, 315, 33, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 402, 401, 401, 315, 33, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 403, 97, 201, 404, 0, 33, 0, 34, 0, 0, 0, 99, 0, 0, 0, 0], [0, 0, 0, 97, 0, 201, 201, 0, 33, 0, 34, 0, 0, 0, 99, 0, 0, 0, 0], [0, 0, 0, 405, 318, 406, 406, 8, 9, 0, 10, 0, 0, 0, 322, 0, 0, 16, 0], [0, 407, 0, 0, 0, 40, 408, 0, 9, 0, 10, 0, 0, 0, 42, 0, 407, 0, 0], [0, 0, 0, 0, 409, 44, 44, 8, 9, 0, 0, 0, 0, 321, 409, 0, 0, 0, 0], [0, 0, 0, 317, 318, 319, 406, 8, 9, 0, 10, 0, 0, 321, 322, 0, 0, 16, 0], [0, 0, 0, 317, 318, 406, 406, 8, 9, 0, 10, 0, 0, 0, 322, 0, 0, 16, 0], [0, 410, 64, 0, 0, 40, 408, 0, 9, 0, 10, 0, 0, 0, 42, 0, 410, 0, 0], [0, 223, 0, 0, 0, 121, 121, 0, 9, 0, 10, 0, 0, 0, 42, 0, 223, 0, 0], [0, 223, 0, 323, 0, 121, 121, 0, 9, 0, 10, 0, 0, 0, 42, 0, 223, 0, 0], [0, 0, 0, 405, 318, 406, 406, 8, 9, 0, 10, 0, 0, 0, 322, 0, 0, 16, 0], [0, 0, 0, 0, 409, 44, 44, 8, 9, 0, 0, 0, 0, 328, 409, 0, 0, 0, 0], [0, 0, 0, 325, 318, 326, 406, 8, 9, 0, 10, 0, 0, 328, 322, 0, 0, 16, 0], [0, 0, 0, 325, 318, 406, 406, 8, 9, 0, 10, 0, 0, 0, 322, 0, 0, 16, 0], [0, 0, 0, 0, 0, 0, 0, 133, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 130, 0, 0], [0, 0, 0, 0, 0, 411, 411, 239, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 412, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 40, 121, 334, 0, 9, 0, 10, 0, 0, 0, 42, 0, 0, 0, 0], [0, 0, 0, 0, 413, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 241, 336, 336, 57, 58, 0, 59, 0, 0, 0, 245, 0, 0, 62, 0], [0, 0, 0, 0, 339, 141, 141, 57, 58, 0, 0, 0, 0, 0, 339, 0, 0, 0, 0], [0, 0, 0, 414, 415, 416, 417, 57, 58, 0, 59, 0, 0, 418, 419, 0, 0, 62, 0], [0, 337, 0, 420, 0, 248, 248, 57, 58, 0, 59, 0, 0, 0, 139, 0, 337, 0, 0], [0, 337, 0, 0, 0, 246, 421, 0, 58, 0, 59, 0, 0, 0, 139, 0, 337, 0, 0], [0, 0, 0, 422, 415, 423, 424, 57, 58, 0, 59, 0, 0, 425, 419, 0, 0, 62, 0], [0, 0, 0, 151, 0, 246, 246, 0, 58, 0, 59, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 58, 0, 0, 0, 0, 344, 0, 0, 0, 0, 0], [0, 0, 0, 341, 0, 342, 246, 0, 58, 0, 59, 0, 0, 344, 0, 0, 0, 0, 0], [0, 0, 0, 341, 0, 246, 246, 0, 58, 0, 59, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 146, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 143, 0, 0], [0, 0, 0, 0, 0, 426, 426, 258, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 427, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 350, 351, 352, 353, 58, 0, 59, 0, 0, 0, 139, 0, 0, 0, 0], [0, 0, 0, 0, 0, 351, 351, 353, 58, 0, 59, 0, 0, 0, 139, 0, 0, 0, 0], [0, 0, 0, 0, 0, 428, 428, 353, 58, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 429, 428, 428, 353, 58, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 430, 137, 246, 431, 0, 58, 0, 59, 0, 0, 0, 139, 0, 0, 0, 0], [0, 0, 0, 137, 0, 246, 246, 0, 58, 0, 59, 0, 0, 0, 139, 0, 0, 0, 0], [0, 0, 0, 432, 116, 433, 434, 8, 161, 0, 162, 0, 0, 435, 120, 0, 0, 16, 0], [0, 0, 0, 0, 0, 180, 180, 269, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 358, 359, 360, 361, 161, 0, 162, 0, 0, 0, 362, 0, 0, 0, 0], [0, 0, 0, 0, 0, 359, 359, 361, 161, 0, 162, 0, 0, 0, 362, 0, 0, 0, 0], [0, 0, 0, 0, 0, 436, 436, 361, 161, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 437, 436, 436, 361, 161, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 438, 439, 440, 441, 442, 161, 0, 162, 0, 0, 0, 362, 0, 0, 0, 0], [0, 443, 274, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 443, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 444, 116, 445, 445, 8, 161, 0, 162, 0, 0, 0, 120, 0, 0, 16, 0], [0, 0, 0, 0, 225, 44, 44, 8, 161, 0, 0, 0, 0, 367, 225, 0, 0, 0, 0], [0, 0, 0, 364, 116, 365, 445, 8, 161, 0, 162, 0, 0, 367, 120, 0, 0, 16, 0], [0, 0, 0, 364, 116, 445, 445, 8, 161, 0, 162, 0, 0, 0, 120, 0, 0, 16, 0], [0, 0, 0, 0, 0, 0, 0, 0, 161, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 446, 370, 447, 447, 22, 23, 0, 24, 0, 0, 0, 374, 0, 0, 27, 0], [0, 448, 0, 0, 0, 76, 449, 0, 23, 0, 24, 0, 0, 0, 78, 0, 448, 0, 0], [0, 0, 0, 0, 450, 80, 80, 22, 23, 0, 0, 0, 0, 373, 450, 0, 0, 0, 0], [0, 0, 0, 369, 370, 371, 447, 22, 23, 0, 24, 0, 0, 373, 374, 0, 0, 27, 0], [0, 0, 0, 369, 370, 447, 447, 22, 23, 0, 24, 0, 0, 0, 374, 0, 0, 27, 0], [0, 451, 90, 0, 0, 76, 449, 0, 23, 0, 24, 0, 0, 0, 78, 0, 451, 0, 0], [0, 279, 0, 0, 0, 175, 175, 0, 23, 0, 24, 0, 0, 0, 78, 0, 279, 0, 0], [0, 279, 0, 375, 0, 175, 175, 0, 23, 0, 24, 0, 0, 0, 78, 0, 279, 0, 0], [0, 0, 0, 446, 370, 447, 447, 22, 23, 0, 24, 0, 0, 0, 374, 0, 0, 27, 0], [0, 0, 0, 0, 450, 80, 80, 22, 23, 0, 0, 0, 0, 380, 450, 0, 0, 0, 0], [0, 0, 0, 377, 370, 378, 447, 22, 23, 0, 24, 0, 0, 380, 374, 0, 0, 27, 0], [0, 0, 0, 377, 370, 447, 447, 22, 23, 0, 24, 0, 0, 0, 374, 0, 0, 27, 0], [0, 0, 0, 0, 0, 0, 0, 187, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 184, 0, 0], [0, 0, 0, 0, 0, 452, 452, 295, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 453, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 76, 175, 386, 0, 23, 0, 24, 0, 0, 0, 78, 0, 0, 0, 0], [0, 0, 0, 0, 454, 0, 0, 0, 23, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 455, 388, 456, 456, 32, 33, 0, 34, 0, 0, 0, 392, 0, 0, 37, 0], [0, 457, 0, 0, 0, 97, 458, 0, 33, 0, 34, 0, 0, 0, 99, 0, 457, 0, 0], [0, 0, 0, 0, 459, 101, 101, 32, 33, 0, 0, 0, 0, 391, 459, 0, 0, 0, 0], [0, 0, 0, 387, 388, 389, 456, 32, 33, 0, 34, 0, 0, 391, 392, 0, 0, 37, 0], [0, 0, 0, 387, 388, 456, 456, 32, 33, 0, 34, 0, 0, 0, 392, 0, 0, 37, 0], [0, 460, 111, 0, 0, 97, 458, 0, 33, 0, 34, 0, 0, 0, 99, 0, 460, 0, 0], [0, 299, 0, 0, 0, 201, 201, 0, 33, 0, 34, 0, 0, 0, 99, 0, 299, 0, 0], [0, 299, 0, 393, 0, 201, 201, 0, 33, 0, 34, 0, 0, 0, 99, 0, 299, 0, 0], [0, 0, 0, 455, 388, 456, 456, 32, 33, 0, 34, 0, 0, 0, 392, 0, 0, 37, 0], [0, 0, 0, 0, 459, 101, 101, 32, 33, 0, 0, 0, 0, 398, 459, 0, 0, 0, 0], [0, 0, 0, 395, 388, 396, 456, 32, 33, 0, 34, 0, 0, 398, 392, 0, 0, 37, 0], [0, 0, 0, 395, 388, 456, 456, 32, 33, 0, 34, 0, 0, 0, 392, 0, 0, 37, 0], [0, 0, 0, 0, 0, 0, 0, 213, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 210, 0, 0], [0, 0, 0, 0, 0, 461, 461, 315, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 462, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 97, 201, 404, 0, 33, 0, 34, 0, 0, 0, 99, 0, 0, 0, 0], [0, 0, 0, 0, 463, 0, 0, 0, 33, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 318, 406, 406, 8, 9, 0, 10, 0, 0, 0, 322, 0, 0, 16, 0], [0, 0, 0, 0, 409, 44, 44, 8, 9, 0, 0, 0, 0, 0, 409, 0, 0, 0, 0], [0, 0, 0, 464, 465, 466, 467, 8, 9, 0, 10, 0, 0, 468, 469, 0, 0, 16, 0], [0, 407, 0, 470, 0, 123, 123, 8, 9, 0, 10, 0, 0, 0, 42, 0, 407, 0, 0], [0, 407, 0, 0, 0, 121, 471, 0, 9, 0, 10, 0, 0, 0, 42, 0, 407, 0, 0], [0, 0, 0, 472, 465, 473, 474, 8, 9, 0, 10, 0, 0, 475, 469, 0, 0, 16, 0], [0, 0, 0, 0, 0, 0, 0, 239, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 236, 0, 0], [0, 0, 0, 0, 0, 0, 476, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 477, 415, 478, 478, 57, 58, 0, 59, 0, 0, 0, 419, 0, 0, 62, 0], [0, 479, 0, 0, 0, 137, 480, 0, 58, 0, 59, 0, 0, 0, 139, 0, 479, 0, 0], [0, 0, 0, 0, 481, 141, 141, 57, 58, 0, 0, 0, 0, 418, 481, 0, 0, 0, 0], [0, 0, 0, 414, 415, 416, 478, 57, 58, 0, 59, 0, 0, 418, 419, 0, 0, 62, 0], [0, 0, 0, 414, 415, 478, 478, 57, 58, 0, 59, 0, 0, 0, 419, 0, 0, 62, 0], [0, 482, 151, 0, 0, 137, 480, 0, 58, 0, 59, 0, 0, 0, 139, 0, 482, 0, 0], [0, 337, 0, 0, 0, 246, 246, 0, 58, 0, 59, 0, 0, 0, 139, 0, 337, 0, 0], [0, 337, 0, 420, 0, 246, 246, 0, 58, 0, 59, 0, 0, 0, 139, 0, 337, 0, 0], [0, 0, 0, 477, 415, 478, 478, 57, 58, 0, 59, 0, 0, 0, 419, 0, 0, 62, 0], [0, 0, 0, 0, 481, 141, 141, 57, 58, 0, 0, 0, 0, 425, 481, 0, 0, 0, 0], [0, 0, 0, 422, 415, 423, 478, 57, 58, 0, 59, 0, 0, 425, 419, 0, 0, 62, 0], [0, 0, 0, 422, 415, 478, 478, 57, 58, 0, 59, 0, 0, 0, 419, 0, 0, 62, 0], [0, 0, 0, 0, 0, 0, 0, 258, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 0, 0], [0, 0, 0, 0, 0, 483, 483, 353, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 484, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 137, 246, 431, 0, 58, 0, 59, 0, 0, 0, 139, 0, 0, 0, 0], [0, 0, 0, 0, 485, 0, 0, 0, 58, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 444, 116, 445, 445, 8, 161, 0, 162, 0, 0, 0, 120, 0, 0, 16, 0], [0, 0, 0, 0, 225, 44, 44, 8, 161, 0, 0, 0, 0, 435, 225, 0, 0, 0, 0], [0, 0, 0, 432, 116, 433, 445, 8, 161, 0, 162, 0, 0, 435, 120, 0, 0, 16, 0], [0, 0, 0, 432, 116, 445, 445, 8, 161, 0, 162, 0, 0, 0, 120, 0, 0, 16, 0], [0, 0, 0, 0, 0, 486, 486, 361, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 487, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 439, 440, 441, 442, 161, 0, 162, 0, 0, 0, 362, 0, 0, 0, 0], [0, 0, 0, 0, 0, 440, 440, 442, 161, 0, 162, 0, 0, 0, 362, 0, 0, 0, 0], [0, 0, 0, 0, 0, 488, 488, 442, 161, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 489, 488, 488, 442, 161, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 490, 491, 492, 493, 494, 161, 0, 162, 0, 0, 0, 362, 0, 0, 0, 0], [0, 0, 0, 495, 0, 496, 497, 0, 161, 0, 162, 0, 0, 498, 0, 0, 0, 0, 0], [0, 0, 0, 0, 116, 445, 445, 8, 161, 0, 162, 0, 0, 0, 120, 0, 0, 16, 0], [0, 0, 0, 0, 225, 44, 44, 8, 161, 0, 0, 0, 0, 0, 225, 0, 0, 0, 0], [0, 0, 0, 0, 370, 447, 447, 22, 23, 0, 24, 0, 0, 0, 374, 0, 0, 27, 0], [0, 0, 0, 0, 450, 80, 80, 22, 23, 0, 0, 0, 0, 0, 450, 0, 0, 0, 0], [0, 0, 0, 499, 500, 501, 502, 22, 23, 0, 24, 0, 0, 503, 504, 0, 0, 27, 0], [0, 448, 0, 505, 0, 177, 177, 22, 23, 0, 24, 0, 0, 0, 78, 0, 448, 0, 0], [0, 448, 0, 0, 0, 175, 506, 0, 23, 0, 24, 0, 0, 0, 78, 0, 448, 0, 0], [0, 0, 0, 507, 500, 508, 509, 22, 23, 0, 24, 0, 0, 510, 504, 0, 0, 27, 0], [0, 0, 0, 0, 0, 0, 0, 295, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 292, 0, 0], [0, 0, 0, 0, 0, 0, 511, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 388, 456, 456, 32, 33, 0, 34, 0, 0, 0, 392, 0, 0, 37, 0], [0, 0, 0, 0, 459, 101, 101, 32, 33, 0, 0, 0, 0, 0, 459, 0, 0, 0, 0], [0, 0, 0, 512, 513, 514, 515, 32, 33, 0, 34, 0, 0, 516, 517, 0, 0, 37, 0], [0, 457, 0, 518, 0, 203, 203, 32, 33, 0, 34, 0, 0, 0, 99, 0, 457, 0, 0], [0, 457, 0, 0, 0, 201, 519, 0, 33, 0, 34, 0, 0, 0, 99, 0, 457, 0, 0], [0, 0, 0, 520, 513, 521, 522, 32, 33, 0, 34, 0, 0, 523, 517, 0, 0, 37, 0], [0, 0, 0, 0, 0, 0, 0, 315, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 312, 0, 0], [0, 0, 0, 0, 0, 0, 524, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 525, 465, 526, 526, 8, 9, 0, 10, 0, 0, 0, 469, 0, 0, 16, 0], [0, 527, 0, 0, 0, 40, 528, 0, 9, 0, 10, 0, 0, 0, 42, 0, 527, 0, 0], [0, 0, 0, 0, 529, 44, 44, 8, 9, 0, 0, 0, 0, 468, 529, 0, 0, 0, 0], [0, 0, 0, 464, 465, 466, 526, 8, 9, 0, 10, 0, 0, 468, 469, 0, 0, 16, 0], [0, 0, 0, 464, 465, 526, 526, 8, 9, 0, 10, 0, 0, 0, 469, 0, 0, 16, 0], [0, 530, 64, 0, 0, 40, 528, 0, 9, 0, 10, 0, 0, 0, 42, 0, 530, 0, 0], [0, 407, 0, 0, 0, 121, 121, 0, 9, 0, 10, 0, 0, 0, 42, 0, 407, 0, 0], [0, 407, 0, 470, 0, 121, 121, 0, 9, 0, 10, 0, 0, 0, 42, 0, 407, 0, 0], [0, 0, 0, 525, 465, 526, 526, 8, 9, 0, 10, 0, 0, 0, 469, 0, 0, 16, 0], [0, 0, 0, 0, 529, 44, 44, 8, 9, 0, 0, 0, 0, 475, 529, 0, 0, 0, 0], [0, 0, 0, 472, 465, 473, 526, 8, 9, 0, 10, 0, 0, 475, 469, 0, 0, 16, 0], [0, 0, 0, 472, 465, 526, 526, 8, 9, 0, 10, 0, 0, 0, 469, 0, 0, 16, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 40, 0, 0], [0, 0, 0, 0, 415, 478, 478, 57, 58, 0, 59, 0, 0, 0, 419, 0, 0, 62, 0], [0, 0, 0, 0, 481, 141, 141, 57, 58, 0, 0, 0, 0, 0, 481, 0, 0, 0, 0], [0, 0, 0, 531, 532, 533, 534, 57, 58, 0, 59, 0, 0, 535, 536, 0, 0, 62, 0], [0, 479, 0, 537, 0, 248, 248, 57, 58, 0, 59, 0, 0, 0, 139, 0, 479, 0, 0], [0, 479, 0, 0, 0, 246, 538, 0, 58, 0, 59, 0, 0, 0, 139, 0, 479, 0, 0], [0, 0, 0, 539, 532, 540, 541, 57, 58, 0, 59, 0, 0, 542, 536, 0, 0, 62, 0], [0, 0, 0, 0, 0, 0, 0, 353, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 350, 0, 0], [0, 0, 0, 0, 0, 0, 543, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 361, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 358, 0, 0], [0, 0, 0, 0, 0, 544, 544, 442, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 545, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 491, 492, 493, 494, 161, 0, 162, 0, 0, 0, 362, 0, 0, 0, 0], [0, 0, 0, 0, 0, 492, 492, 494, 161, 0, 162, 0, 0, 0, 362, 0, 0, 0, 0], [0, 0, 0, 0, 0, 546, 546, 494, 161, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 547, 546, 546, 494, 161, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 548, 549, 368, 550, 0, 161, 0, 162, 0, 0, 0, 362, 0, 0, 0, 0], [0, 0, 0, 274, 0, 368, 368, 0, 161, 0, 162, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 161, 0, 0, 0, 0, 498, 0, 0, 0, 0, 0], [0, 0, 0, 495, 0, 496, 368, 0, 161, 0, 162, 0, 0, 498, 0, 0, 0, 0, 0], [0, 0, 0, 495, 0, 368, 368, 0, 161, 0, 162, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 551, 500, 552, 552, 22, 23, 0, 24, 0, 0, 0, 504, 0, 0, 27, 0], [0, 553, 0, 0, 0, 76, 554, 0, 23, 0, 24, 0, 0, 0, 78, 0, 553, 0, 0], [0, 0, 0, 0, 555, 80, 80, 22, 23, 0, 0, 0, 0, 503, 555, 0, 0, 0, 0], [0, 0, 0, 499, 500, 501, 552, 22, 23, 0, 24, 0, 0, 503, 504, 0, 0, 27, 0], [0, 0, 0, 499, 500, 552, 552, 22, 23, 0, 24, 0, 0, 0, 504, 0, 0, 27, 0], [0, 556, 90, 0, 0, 76, 554, 0, 23, 0, 24, 0, 0, 0, 78, 0, 556, 0, 0], [0, 448, 0, 0, 0, 175, 175, 0, 23, 0, 24, 0, 0, 0, 78, 0, 448, 0, 0], [0, 448, 0, 505, 0, 175, 175, 0, 23, 0, 24, 0, 0, 0, 78, 0, 448, 0, 0], [0, 0, 0, 551, 500, 552, 552, 22, 23, 0, 24, 0, 0, 0, 504, 0, 0, 27, 0], [0, 0, 0, 0, 555, 80, 80, 22, 23, 0, 0, 0, 0, 510, 555, 0, 0, 0, 0], [0, 0, 0, 507, 500, 508, 552, 22, 23, 0, 24, 0, 0, 510, 504, 0, 0, 27, 0], [0, 0, 0, 507, 500, 552, 552, 22, 23, 0, 24, 0, 0, 0, 504, 0, 0, 27, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 76, 0, 0], [0, 0, 0, 557, 513, 558, 558, 32, 33, 0, 34, 0, 0, 0, 517, 0, 0, 37, 0], [0, 559, 0, 0, 0, 97, 560, 0, 33, 0, 34, 0, 0, 0, 99, 0, 559, 0, 0], [0, 0, 0, 0, 561, 101, 101, 32, 33, 0, 0, 0, 0, 516, 561, 0, 0, 0, 0], [0, 0, 0, 512, 513, 514, 558, 32, 33, 0, 34, 0, 0, 516, 517, 0, 0, 37, 0], [0, 0, 0, 512, 513, 558, 558, 32, 33, 0, 34, 0, 0, 0, 517, 0, 0, 37, 0], [0, 562, 111, 0, 0, 97, 560, 0, 33, 0, 34, 0, 0, 0, 99, 0, 562, 0, 0], [0, 457, 0, 0, 0, 201, 201, 0, 33, 0, 34, 0, 0, 0, 99, 0, 457, 0, 0], [0, 457, 0, 518, 0, 201, 201, 0, 33, 0, 34, 0, 0, 0, 99, 0, 457, 0, 0], [0, 0, 0, 557, 513, 558, 558, 32, 33, 0, 34, 0, 0, 0, 517, 0, 0, 37, 0], [0, 0, 0, 0, 561, 101, 101, 32, 33, 0, 0, 0, 0, 523, 561, 0, 0, 0, 0], [0, 0, 0, 520, 513, 521, 558, 32, 33, 0, 34, 0, 0, 523, 517, 0, 0, 37, 0], [0, 0, 0, 520, 513, 558, 558, 32, 33, 0, 34, 0, 0, 0, 517, 0, 0, 37, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 97, 0, 0], [0, 0, 0, 0, 465, 526, 526, 8, 9, 0, 10, 0, 0, 0, 469, 0, 0, 16, 0], [0, 0, 0, 0, 529, 44, 44, 8, 9, 0, 0, 0, 0, 0, 529, 0, 0, 0, 0], [0, 0, 0, 563, 66, 564, 565, 8, 9, 0, 10, 0, 0, 566, 68, 0, 0, 16, 0], [0, 527, 0, 567, 0, 123, 123, 8, 9, 0, 10, 0, 0, 0, 42, 0, 527, 0, 0], [0, 527, 0, 0, 0, 121, 568, 0, 9, 0, 10, 0, 0, 0, 42, 0, 527, 0, 0], [0, 0, 0, 569, 66, 570, 571, 8, 9, 0, 10, 0, 0, 572, 68, 0, 0, 16, 0], [0, 0, 0, 573, 532, 574, 574, 57, 58, 0, 59, 0, 0, 0, 536, 0, 0, 62, 0], [0, 575, 0, 0, 0, 137, 576, 0, 58, 0, 59, 0, 0, 0, 139, 0, 575, 0, 0], [0, 0, 0, 0, 577, 141, 141, 57, 58, 0, 0, 0, 0, 535, 577, 0, 0, 0, 0], [0, 0, 0, 531, 532, 533, 574, 57, 58, 0, 59, 0, 0, 535, 536, 0, 0, 62, 0], [0, 0, 0, 531, 532, 574, 574, 57, 58, 0, 59, 0, 0, 0, 536, 0, 0, 62, 0], [0, 578, 151, 0, 0, 137, 576, 0, 58, 0, 59, 0, 0, 0, 139, 0, 578, 0, 0], [0, 479, 0, 0, 0, 246, 246, 0, 58, 0, 59, 0, 0, 0, 139, 0, 479, 0, 0], [0, 479, 0, 537, 0, 246, 246, 0, 58, 0, 59, 0, 0, 0, 139, 0, 479, 0, 0], [0, 0, 0, 573, 532, 574, 574, 57, 58, 0, 59, 0, 0, 0, 536, 0, 0, 62, 0], [0, 0, 0, 0, 577, 141, 141, 57, 58, 0, 0, 0, 0, 542, 577, 0, 0, 0, 0], [0, 0, 0, 539, 532, 540, 574, 57, 58, 0, 59, 0, 0, 542, 536, 0, 0, 62, 0], [0, 0, 0, 539, 532, 574, 574, 57, 58, 0, 59, 0, 0, 0, 536, 0, 0, 62, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 137, 0, 0], [0, 0, 0, 0, 0, 0, 0, 442, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 439, 0, 0], [0, 0, 0, 0, 0, 579, 579, 494, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 580, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 549, 368, 550, 0, 161, 0, 162, 0, 0, 0, 362, 0, 0, 0, 0], [0, 0, 0, 0, 0, 368, 368, 0, 161, 0, 162, 0, 0, 0, 362, 0, 0, 0, 0], [0, 0, 0, 0, 581, 0, 0, 0, 161, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 500, 552, 552, 22, 23, 0, 24, 0, 0, 0, 504, 0, 0, 27, 0], [0, 0, 0, 0, 555, 80, 80, 22, 23, 0, 0, 0, 0, 0, 555, 0, 0, 0, 0], [0, 0, 0, 582, 91, 583, 584, 22, 23, 0, 24, 0, 0, 585, 93, 0, 0, 27, 0], [0, 553, 0, 586, 0, 177, 177, 22, 23, 0, 24, 0, 0, 0, 78, 0, 553, 0, 0], [0, 553, 0, 0, 0, 175, 587, 0, 23, 0, 24, 0, 0, 0, 78, 0, 553, 0, 0], [0, 0, 0, 588, 91, 589, 590, 22, 23, 0, 24, 0, 0, 591, 93, 0, 0, 27, 0], [0, 0, 0, 0, 513, 558, 558, 32, 33, 0, 34, 0, 0, 0, 517, 0, 0, 37, 0], [0, 0, 0, 0, 561, 101, 101, 32, 33, 0, 0, 0, 0, 0, 561, 0, 0, 0, 0], [0, 0, 0, 592, 112, 593, 594, 32, 33, 0, 34, 0, 0, 595, 114, 0, 0, 37, 0], [0, 559, 0, 596, 0, 203, 203, 32, 33, 0, 34, 0, 0, 0, 99, 0, 559, 0, 0], [0, 559, 0, 0, 0, 201, 597, 0, 33, 0, 34, 0, 0, 0, 99, 0, 559, 0, 0], [0, 0, 0, 598, 112, 599, 600, 32, 33, 0, 34, 0, 0, 601, 114, 0, 0, 37, 0], [0, 0, 0, 602, 66, 67, 67, 8, 9, 0, 10, 0, 0, 0, 68, 0, 0, 16, 0], [0, 0, 0, 0, 165, 44, 44, 8, 9, 0, 0, 0, 0, 566, 165, 0, 0, 0, 0], [0, 0, 0, 563, 66, 564, 67, 8, 9, 0, 10, 0, 0, 566, 68, 0, 0, 16, 0], [0, 0, 0, 563, 66, 67, 67, 8, 9, 0, 10, 0, 0, 0, 68, 0, 0, 16, 0], [0, 527, 0, 0, 0, 121, 121, 0, 9, 0, 10, 0, 0, 0, 42, 0, 527, 0, 0], [0, 527, 0, 567, 0, 121, 121, 0, 9, 0, 10, 0, 0, 0, 42, 0, 527, 0, 0], [0, 0, 0, 602, 66, 67, 67, 8, 9, 0, 10, 0, 0, 0, 68, 0, 0, 16, 0], [0, 0, 0, 0, 165, 44, 44, 8, 9, 0, 0, 0, 0, 572, 165, 0, 0, 0, 0], [0, 0, 0, 569, 66, 570, 67, 8, 9, 0, 10, 0, 0, 572, 68, 0, 0, 16, 0], [0, 0, 0, 569, 66, 67, 67, 8, 9, 0, 10, 0, 0, 0, 68, 0, 0, 16, 0], [0, 0, 0, 0, 532, 574, 574, 57, 58, 0, 59, 0, 0, 0, 536, 0, 0, 62, 0], [0, 0, 0, 0, 577, 141, 141, 57, 58, 0, 0, 0, 0, 0, 577, 0, 0, 0, 0], [0, 0, 0, 603, 152, 604, 605, 57, 58, 0, 59, 0, 0, 606, 154, 0, 0, 62, 0], [0, 575, 0, 607, 0, 248, 248, 57, 58, 0, 59, 0, 0, 0, 139, 0, 575, 0, 0], [0, 575, 0, 0, 0, 246, 608, 0, 58, 0, 59, 0, 0, 0, 139, 0, 575, 0, 0], [0, 0, 0, 609, 152, 610, 611, 57, 58, 0, 59, 0, 0, 612, 154, 0, 0, 62, 0], [0, 0, 0, 0, 0, 0, 0, 494, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 491, 0, 0], [0, 0, 0, 0, 0, 0, 613, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 614, 91, 92, 92, 22, 23, 0, 24, 0, 0, 0, 93, 0, 0, 27, 0], [0, 0, 0, 0, 194, 80, 80, 22, 23, 0, 0, 0, 0, 585, 194, 0, 0, 0, 0], [0, 0, 0, 582, 91, 583, 92, 22, 23, 0, 24, 0, 0, 585, 93, 0, 0, 27, 0], [0, 0, 0, 582, 91, 92, 92, 22, 23, 0, 24, 0, 0, 0, 93, 0, 0, 27, 0], [0, 553, 0, 0, 0, 175, 175, 0, 23, 0, 24, 0, 0, 0, 78, 0, 553, 0, 0], [0, 553, 0, 586, 0, 175, 175, 0, 23, 0, 24, 0, 0, 0, 78, 0, 553, 0, 0], [0, 0, 0, 614, 91, 92, 92, 22, 23, 0, 24, 0, 0, 0, 93, 0, 0, 27, 0], [0, 0, 0, 0, 194, 80, 80, 22, 23, 0, 0, 0, 0, 591, 194, 0, 0, 0, 0], [0, 0, 0, 588, 91, 589, 92, 22, 23, 0, 24, 0, 0, 591, 93, 0, 0, 27, 0], [0, 0, 0, 588, 91, 92, 92, 22, 23, 0, 24, 0, 0, 0, 93, 0, 0, 27, 0], [0, 0, 0, 615, 112, 113, 113, 32, 33, 0, 34, 0, 0, 0, 114, 0, 0, 37, 0], [0, 0, 0, 0, 220, 101, 101, 32, 33, 0, 0, 0, 0, 595, 220, 0, 0, 0, 0], [0, 0, 0, 592, 112, 593, 113, 32, 33, 0, 34, 0, 0, 595, 114, 0, 0, 37, 0], [0, 0, 0, 592, 112, 113, 113, 32, 33, 0, 34, 0, 0, 0, 114, 0, 0, 37, 0], [0, 559, 0, 0, 0, 201, 201, 0, 33, 0, 34, 0, 0, 0, 99, 0, 559, 0, 0], [0, 559, 0, 596, 0, 201, 201, 0, 33, 0, 34, 0, 0, 0, 99, 0, 559, 0, 0], [0, 0, 0, 615, 112, 113, 113, 32, 33, 0, 34, 0, 0, 0, 114, 0, 0, 37, 0], [0, 0, 0, 0, 220, 101, 101, 32, 33, 0, 0, 0, 0, 601, 220, 0, 0, 0, 0], [0, 0, 0, 598, 112, 599, 113, 32, 33, 0, 34, 0, 0, 601, 114, 0, 0, 37, 0], [0, 0, 0, 598, 112, 113, 113, 32, 33, 0, 34, 0, 0, 0, 114, 0, 0, 37, 0], [0, 0, 0, 0, 66, 67, 67, 8, 9, 0, 10, 0, 0, 0, 68, 0, 0, 16, 0], [0, 0, 0, 616, 152, 153, 153, 57, 58, 0, 59, 0, 0, 0, 154, 0, 0, 62, 0], [0, 0, 0, 0, 265, 141, 141, 57, 58, 0, 0, 0, 0, 606, 265, 0, 0, 0, 0], [0, 0, 0, 603, 152, 604, 153, 57, 58, 0, 59, 0, 0, 606, 154, 0, 0, 62, 0], [0, 0, 0, 603, 152, 153, 153, 57, 58, 0, 59, 0, 0, 0, 154, 0, 0, 62, 0], [0, 575, 0, 0, 0, 246, 246, 0, 58, 0, 59, 0, 0, 0, 139, 0, 575, 0, 0], [0, 575, 0, 607, 0, 246, 246, 0, 58, 0, 59, 0, 0, 0, 139, 0, 575, 0, 0], [0, 0, 0, 616, 152, 153, 153, 57, 58, 0, 59, 0, 0, 0, 154, 0, 0, 62, 0], [0, 0, 0, 0, 265, 141, 141, 57, 58, 0, 0, 0, 0, 612, 265, 0, 0, 0, 0], [0, 0, 0, 609, 152, 610, 153, 57, 58, 0, 59, 0, 0, 612, 154, 0, 0, 62, 0], [0, 0, 0, 609, 152, 153, 153, 57, 58, 0, 59, 0, 0, 0, 154, 0, 0, 62, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 549, 0, 0], [0, 0, 0, 0, 91, 92, 92, 22, 23, 0, 24, 0, 0, 0, 93, 0, 0, 27, 0], [0, 0, 0, 0, 112, 113, 113, 32, 33, 0, 34, 0, 0, 0, 114, 0, 0, 37, 0], [0, 0, 0, 0, 152, 153, 153, 57, 58, 0, 59, 0, 0, 0, 154, 0, 0, 62, 0]];\nvar accepting = [false, true, true, true, true, true, false, false, true, true, true, true, true, true, true, true, true, true, true, true, false, true, true, true, true, true, true, true, true, true, false, true, true, true, true, true, true, true, true, true, true, true, false, true, false, true, true, false, false, true, true, true, true, true, true, false, false, true, true, true, true, true, true, true, true, true, true, false, true, true, false, true, true, true, false, true, true, true, false, true, false, true, true, false, false, true, true, true, true, true, true, true, false, true, true, false, true, true, true, false, true, false, true, true, false, false, true, true, true, true, true, true, true, false, true, true, true, false, true, true, true, false, true, false, true, true, false, false, false, true, true, false, false, true, true, true, true, true, true, false, true, false, true, true, false, false, true, true, true, true, true, true, true, false, true, true, false, true, true, true, true, true, true, true, true, true, true, true, true, true, true, false, true, true, true, false, true, false, true, true, false, false, false, true, true, false, false, true, true, true, false, true, true, true, true, true, true, false, true, true, true, false, true, false, true, true, false, false, false, true, true, false, false, true, true, true, false, true, true, true, true, true, false, true, true, true, true, true, false, true, true, false, false, false, false, true, true, false, false, true, true, true, false, true, true, true, false, true, false, true, true, false, false, false, true, true, false, false, true, true, true, false, true, true, true, true, false, true, false, true, true, true, true, true, true, true, true, true, false, true, true, true, true, true, false, true, true, false, false, false, false, true, true, false, false, true, true, true, false, true, true, true, true, true, false, true, true, false, false, false, false, true, true, false, false, true, true, true, true, false, true, true, true, true, true, true, false, true, true, false, false, false, false, true, false, true, false, true, true, true, true, true, false, true, true, false, false, false, false, true, true, false, false, true, true, true, false, true, true, false, false, true, false, true, true, false, true, true, false, true, true, false, true, true, true, true, true, true, false, true, true, false, false, false, false, true, false, true, true, false, true, true, true, true, true, true, false, true, true, false, false, false, false, true, false, true, false, true, true, true, true, false, false, false, true, true, false, true, true, true, true, true, true, false, true, true, false, false, false, false, true, false, true, false, true, true, false, false, true, true, false, false, true, true, true, false, true, false, true, true, true, true, false, false, false, true, false, true, true, true, true, false, false, false, true, true, false, true, true, true, true, true, true, false, true, true, false, true, false, true, true, true, true, false, false, false, false, false, false, false, true, true, false, false, true, true, false, true, true, true, true, false, true, true, true, true, true, true, false, true, true, false, true, true, false, true, true, true, true, true, true, false, true, true, false, true, false, true, true, true, true, true, true, false, true, true, true, true, true, true, false, true, true, false, false, false, false, false, true, true, false, true, false, true, true, true, true, true, false, true, true, true, true, true, false, true, true, true, true, true, false, true, true, true, false, true, true, true, true, false, false, false, true, false, true, true, true, true, true, false, true, true, true, false, true, true, true, true, true, false, true, true, true, true, false, true, true, true, true, true, false, true, true, false, true, true, true];\nvar tags = [[], [\"broken_cluster\"], [\"consonant_syllable\"], [\"vowel_syllable\"], [\"broken_cluster\"], [\"broken_cluster\"], [], [], [\"broken_cluster\"], [\"broken_cluster\"], [\"broken_cluster\"], [\"standalone_cluster\"], [\"broken_cluster\"], [\"broken_cluster\"], [\"broken_cluster\"], [\"consonant_syllable\"], [\"broken_cluster\"], [\"symbol_cluster\"], [\"consonant_syllable\"], [\"consonant_syllable\"], [], [\"consonant_syllable\"], [\"consonant_syllable\"], [\"consonant_syllable\"], [\"consonant_syllable\"], [\"consonant_syllable\"], [\"consonant_syllable\"], [\"consonant_syllable\"], [\"vowel_syllable\"], [\"vowel_syllable\"], [], [\"vowel_syllable\"], [\"vowel_syllable\"], [\"vowel_syllable\"], [\"vowel_syllable\"], [\"vowel_syllable\"], [\"vowel_syllable\"], [\"vowel_syllable\"], [\"broken_cluster\"], [\"broken_cluster\"], [\"broken_cluster\"], [\"broken_cluster\"], [], [\"broken_cluster\"], [], [\"broken_cluster\"], [\"broken_cluster\"], [], [], [\"broken_cluster\"], [\"broken_cluster\"], [\"broken_cluster\"], [\"broken_cluster\"], [\"standalone_cluster\"], [\"standalone_cluster\"], [], [], [\"standalone_cluster\"], [\"standalone_cluster\"], [\"standalone_cluster\"], [\"standalone_cluster\"], [\"standalone_cluster\"], [\"standalone_cluster\"], [\"broken_cluster\"], [\"broken_cluster\"], [\"consonant_syllable\", \"broken_cluster\"], [\"broken_cluster\"], [], [\"broken_cluster\"], [\"symbol_cluster\"], [], [\"symbol_cluster\"], [\"symbol_cluster\"], [\"consonant_syllable\"], [], [\"consonant_syllable\"], [\"consonant_syllable\"], [\"consonant_syllable\"], [], [\"consonant_syllable\"], [], [\"consonant_syllable\"], [\"consonant_syllable\"], [], [], [\"consonant_syllable\"], [\"consonant_syllable\"], [\"consonant_syllable\"], [\"consonant_syllable\"], [\"consonant_syllable\"], [\"consonant_syllable\"], [\"consonant_syllable\"], [], [\"consonant_syllable\"], [\"vowel_syllable\"], [], [\"vowel_syllable\"], [\"vowel_syllable\"], [\"vowel_syllable\"], [], [\"vowel_syllable\"], [], [\"vowel_syllable\"], [\"vowel_syllable\"], [], [], [\"vowel_syllable\"], [\"vowel_syllable\"], [\"vowel_syllable\"], [\"vowel_syllable\"], [\"vowel_syllable\"], [\"vowel_syllable\"], [\"vowel_syllable\"], [], [\"vowel_syllable\"], [\"broken_cluster\"], [\"broken_cluster\"], [], [\"broken_cluster\"], [\"broken_cluster\"], [\"broken_cluster\"], [], [\"broken_cluster\"], [], [\"broken_cluster\"], [\"broken_cluster\"], [], [], [], [\"broken_cluster\"], [\"broken_cluster\"], [], [], [\"broken_cluster\"], [\"broken_cluster\"], [\"standalone_cluster\"], [\"standalone_cluster\"], [\"standalone_cluster\"], [\"standalone_cluster\"], [], [\"standalone_cluster\"], [], [\"standalone_cluster\"], [\"standalone_cluster\"], [], [], [\"standalone_cluster\"], [\"standalone_cluster\"], [\"standalone_cluster\"], [\"standalone_cluster\"], [\"standalone_cluster\"], [\"standalone_cluster\"], [\"standalone_cluster\"], [], [\"standalone_cluster\"], [\"broken_cluster\"], [], [\"broken_cluster\"], [\"broken_cluster\"], [\"consonant_syllable\"], [\"consonant_syllable\"], [\"consonant_syllable\", \"broken_cluster\"], [\"consonant_syllable\", \"broken_cluster\"], [\"broken_cluster\"], [\"broken_cluster\"], [\"broken_cluster\"], [\"symbol_cluster\"], [\"symbol_cluster\"], [\"symbol_cluster\"], [\"consonant_syllable\"], [\"consonant_syllable\"], [], [\"consonant_syllable\"], [\"consonant_syllable\"], [\"consonant_syllable\"], [], [\"consonant_syllable\"], [], [\"consonant_syllable\"], [\"consonant_syllable\"], [], [], [], [\"consonant_syllable\"], [\"consonant_syllable\"], [], [], [\"consonant_syllable\"], [\"consonant_syllable\"], [\"consonant_syllable\"], [], [\"consonant_syllable\"], [\"consonant_syllable\"], [\"consonant_syllable\"], [\"consonant_syllable\"], [\"vowel_syllable\"], [\"vowel_syllable\"], [], [\"vowel_syllable\"], [\"vowel_syllable\"], [\"vowel_syllable\"], [], [\"vowel_syllable\"], [], [\"vowel_syllable\"], [\"vowel_syllable\"], [], [], [], [\"vowel_syllable\"], [\"vowel_syllable\"], [], [], [\"vowel_syllable\"], [\"vowel_syllable\"], [\"vowel_syllable\"], [], [\"vowel_syllable\"], [\"vowel_syllable\"], [\"vowel_syllable\"], [\"vowel_syllable\"], [\"broken_cluster\"], [], [\"broken_cluster\"], [\"broken_cluster\"], [\"broken_cluster\"], [\"broken_cluster\"], [\"broken_cluster\"], [], [\"broken_cluster\"], [\"broken_cluster\"], [], [], [], [], [\"broken_cluster\"], [\"broken_cluster\"], [], [], [\"broken_cluster\"], [\"standalone_cluster\"], [\"standalone_cluster\"], [], [\"standalone_cluster\"], [\"standalone_cluster\"], [\"standalone_cluster\"], [], [\"standalone_cluster\"], [], [\"standalone_cluster\"], [\"standalone_cluster\"], [], [], [], [\"standalone_cluster\"], [\"standalone_cluster\"], [], [], [\"standalone_cluster\"], [\"standalone_cluster\"], [\"standalone_cluster\"], [], [\"standalone_cluster\"], [\"standalone_cluster\"], [\"standalone_cluster\"], [\"standalone_cluster\"], [], [\"broken_cluster\"], [], [\"consonant_syllable\", \"broken_cluster\"], [\"consonant_syllable\", \"broken_cluster\"], [\"consonant_syllable\", \"broken_cluster\"], [\"consonant_syllable\", \"broken_cluster\"], [\"consonant_syllable\", \"broken_cluster\"], [\"consonant_syllable\", \"broken_cluster\"], [\"broken_cluster\"], [\"symbol_cluster\"], [\"consonant_syllable\"], [], [\"consonant_syllable\"], [\"consonant_syllable\"], [\"consonant_syllable\"], [\"consonant_syllable\"], [\"consonant_syllable\"], [], [\"consonant_syllable\"], [\"consonant_syllable\"], [], [], [], [], [\"consonant_syllable\"], [\"consonant_syllable\"], [], [], [\"consonant_syllable\"], [\"consonant_syllable\"], [\"vowel_syllable\"], [], [\"vowel_syllable\"], [\"vowel_syllable\"], [\"vowel_syllable\"], [\"vowel_syllable\"], [\"vowel_syllable\"], [], [\"vowel_syllable\"], [\"vowel_syllable\"], [], [], [], [], [\"vowel_syllable\"], [\"vowel_syllable\"], [], [], [\"vowel_syllable\"], [\"vowel_syllable\"], [\"broken_cluster\"], [\"broken_cluster\"], [], [\"broken_cluster\"], [\"broken_cluster\"], [\"broken_cluster\"], [\"broken_cluster\"], [\"broken_cluster\"], [\"broken_cluster\"], [], [\"broken_cluster\"], [\"broken_cluster\"], [], [], [], [], [\"broken_cluster\"], [], [\"standalone_cluster\"], [], [\"standalone_cluster\"], [\"standalone_cluster\"], [\"standalone_cluster\"], [\"standalone_cluster\"], [\"standalone_cluster\"], [], [\"standalone_cluster\"], [\"standalone_cluster\"], [], [], [], [], [\"standalone_cluster\"], [\"standalone_cluster\"], [], [], [\"standalone_cluster\"], [\"standalone_cluster\"], [\"consonant_syllable\", \"broken_cluster\"], [], [\"consonant_syllable\", \"broken_cluster\"], [\"consonant_syllable\", \"broken_cluster\"], [], [], [\"consonant_syllable\", \"broken_cluster\"], [], [\"consonant_syllable\", \"broken_cluster\"], [\"consonant_syllable\", \"broken_cluster\"], [], [\"consonant_syllable\", \"broken_cluster\"], [\"consonant_syllable\", \"broken_cluster\"], [], [\"consonant_syllable\"], [\"consonant_syllable\"], [], [\"consonant_syllable\"], [\"consonant_syllable\"], [\"consonant_syllable\"], [\"consonant_syllable\"], [\"consonant_syllable\"], [\"consonant_syllable\"], [], [\"consonant_syllable\"], [\"consonant_syllable\"], [], [], [], [], [\"consonant_syllable\"], [], [\"vowel_syllable\"], [\"vowel_syllable\"], [], [\"vowel_syllable\"], [\"vowel_syllable\"], [\"vowel_syllable\"], [\"vowel_syllable\"], [\"vowel_syllable\"], [\"vowel_syllable\"], [], [\"vowel_syllable\"], [\"vowel_syllable\"], [], [], [], [], [\"vowel_syllable\"], [], [\"broken_cluster\"], [], [\"broken_cluster\"], [\"broken_cluster\"], [\"broken_cluster\"], [\"broken_cluster\"], [], [], [], [\"standalone_cluster\"], [\"standalone_cluster\"], [], [\"standalone_cluster\"], [\"standalone_cluster\"], [\"standalone_cluster\"], [\"standalone_cluster\"], [\"standalone_cluster\"], [\"standalone_cluster\"], [], [\"standalone_cluster\"], [\"standalone_cluster\"], [], [], [], [], [\"standalone_cluster\"], [], [\"consonant_syllable\", \"broken_cluster\"], [], [\"consonant_syllable\", \"broken_cluster\"], [\"consonant_syllable\", \"broken_cluster\"], [], [], [\"consonant_syllable\", \"broken_cluster\"], [\"consonant_syllable\", \"broken_cluster\"], [], [], [\"consonant_syllable\", \"broken_cluster\"], [\"consonant_syllable\", \"broken_cluster\"], [\"consonant_syllable\", \"broken_cluster\"], [], [\"consonant_syllable\"], [], [\"consonant_syllable\"], [\"consonant_syllable\"], [\"consonant_syllable\"], [\"consonant_syllable\"], [], [], [], [\"vowel_syllable\"], [], [\"vowel_syllable\"], [\"vowel_syllable\"], [\"vowel_syllable\"], [\"vowel_syllable\"], [], [], [], [\"broken_cluster\"], [\"broken_cluster\"], [], [\"broken_cluster\"], [\"broken_cluster\"], [\"broken_cluster\"], [\"broken_cluster\"], [\"broken_cluster\"], [\"broken_cluster\"], [], [\"broken_cluster\"], [\"broken_cluster\"], [], [\"standalone_cluster\"], [], [\"standalone_cluster\"], [\"standalone_cluster\"], [\"standalone_cluster\"], [\"standalone_cluster\"], [], [], [], [], [], [], [], [\"consonant_syllable\", \"broken_cluster\"], [\"consonant_syllable\", \"broken_cluster\"], [], [], [\"consonant_syllable\", \"broken_cluster\"], [\"consonant_syllable\", \"broken_cluster\"], [], [\"consonant_syllable\", \"broken_cluster\"], [\"consonant_syllable\", \"broken_cluster\"], [\"consonant_syllable\"], [\"consonant_syllable\"], [], [\"consonant_syllable\"], [\"consonant_syllable\"], [\"consonant_syllable\"], [\"consonant_syllable\"], [\"consonant_syllable\"], [\"consonant_syllable\"], [], [\"consonant_syllable\"], [\"consonant_syllable\"], [], [\"vowel_syllable\"], [\"vowel_syllable\"], [], [\"vowel_syllable\"], [\"vowel_syllable\"], [\"vowel_syllable\"], [\"vowel_syllable\"], [\"vowel_syllable\"], [\"vowel_syllable\"], [], [\"vowel_syllable\"], [\"vowel_syllable\"], [], [\"broken_cluster\"], [], [\"broken_cluster\"], [\"broken_cluster\"], [\"broken_cluster\"], [\"broken_cluster\"], [\"standalone_cluster\"], [\"standalone_cluster\"], [], [\"standalone_cluster\"], [\"standalone_cluster\"], [\"standalone_cluster\"], [\"standalone_cluster\"], [\"standalone_cluster\"], [\"standalone_cluster\"], [], [\"standalone_cluster\"], [\"standalone_cluster\"], [], [], [], [], [], [\"consonant_syllable\", \"broken_cluster\"], [\"consonant_syllable\", \"broken_cluster\"], [], [\"consonant_syllable\"], [], [\"consonant_syllable\"], [\"consonant_syllable\"], [\"consonant_syllable\"], [\"consonant_syllable\"], [\"vowel_syllable\"], [], [\"vowel_syllable\"], [\"vowel_syllable\"], [\"vowel_syllable\"], [\"vowel_syllable\"], [\"broken_cluster\"], [], [\"broken_cluster\"], [\"broken_cluster\"], [\"broken_cluster\"], [\"broken_cluster\"], [\"broken_cluster\"], [], [\"broken_cluster\"], [\"broken_cluster\"], [\"standalone_cluster\"], [], [\"standalone_cluster\"], [\"standalone_cluster\"], [\"standalone_cluster\"], [\"standalone_cluster\"], [], [], [], [\"consonant_syllable\"], [], [\"consonant_syllable\"], [\"consonant_syllable\"], [\"consonant_syllable\"], [\"consonant_syllable\"], [\"consonant_syllable\"], [], [\"consonant_syllable\"], [\"consonant_syllable\"], [\"vowel_syllable\"], [], [\"vowel_syllable\"], [\"vowel_syllable\"], [\"vowel_syllable\"], [\"vowel_syllable\"], [\"vowel_syllable\"], [], [\"vowel_syllable\"], [\"vowel_syllable\"], [\"broken_cluster\"], [\"standalone_cluster\"], [], [\"standalone_cluster\"], [\"standalone_cluster\"], [\"standalone_cluster\"], [\"standalone_cluster\"], [\"standalone_cluster\"], [], [\"standalone_cluster\"], [\"standalone_cluster\"], [], [\"consonant_syllable\"], [\"vowel_syllable\"], [\"standalone_cluster\"]];\nvar indicMachine = {\n  stateTable: stateTable,\n  accepting: accepting,\n  tags: tags\n};\nvar categories = [\"O\", \"IND\", \"S\", \"GB\", \"B\", \"FM\", \"CGJ\", \"VMAbv\", \"VMPst\", \"VAbv\", \"VPst\", \"CMBlw\", \"VPre\", \"VBlw\", \"H\", \"VMBlw\", \"CMAbv\", \"MBlw\", \"CS\", \"R\", \"SUB\", \"MPst\", \"MPre\", \"FAbv\", \"FPst\", \"FBlw\", \"null\", \"SMAbv\", \"SMBlw\", \"VMPre\", \"ZWNJ\", \"ZWJ\", \"WJ\", \"M\", \"VS\", \"N\", \"HN\", \"MAbv\"];\nvar decompositions$1 = {\n  \"2507\": [2503, 2494],\n  \"2508\": [2503, 2519],\n  \"2888\": [2887, 2902],\n  \"2891\": [2887, 2878],\n  \"2892\": [2887, 2903],\n  \"3018\": [3014, 3006],\n  \"3019\": [3015, 3006],\n  \"3020\": [3014, 3031],\n  \"3144\": [3142, 3158],\n  \"3264\": [3263, 3285],\n  \"3271\": [3270, 3285],\n  \"3272\": [3270, 3286],\n  \"3274\": [3270, 3266],\n  \"3275\": [3270, 3266, 3285],\n  \"3402\": [3398, 3390],\n  \"3403\": [3399, 3390],\n  \"3404\": [3398, 3415],\n  \"3546\": [3545, 3530],\n  \"3548\": [3545, 3535],\n  \"3549\": [3545, 3535, 3530],\n  \"3550\": [3545, 3551],\n  \"3635\": [3661, 3634],\n  \"3763\": [3789, 3762],\n  \"3955\": [3953, 3954],\n  \"3957\": [3953, 3956],\n  \"3958\": [4018, 3968],\n  \"3959\": [4018, 3953, 3968],\n  \"3960\": [4019, 3968],\n  \"3961\": [4019, 3953, 3968],\n  \"3969\": [3953, 3968],\n  \"6971\": [6970, 6965],\n  \"6973\": [6972, 6965],\n  \"6976\": [6974, 6965],\n  \"6977\": [6975, 6965],\n  \"6979\": [6978, 6965],\n  \"69934\": [69937, 69927],\n  \"69935\": [69938, 69927],\n  \"70475\": [70471, 70462],\n  \"70476\": [70471, 70487],\n  \"70843\": [70841, 70842],\n  \"70844\": [70841, 70832],\n  \"70846\": [70841, 70845],\n  \"71098\": [71096, 71087],\n  \"71099\": [71097, 71087]\n};\nvar stateTable$1 = [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [2, 2, 3, 4, 4, 5, 0, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 0, 17, 18, 11, 19, 20, 21, 22, 0, 0, 0, 23, 0, 0, 2, 0, 0, 24, 0, 25], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 26, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 27, 28, 0, 0, 0, 0, 0, 27, 0, 0, 0], [0, 0, 0, 0, 0, 29, 0, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 0, 0, 41, 35, 42, 43, 44, 45, 0, 0, 0, 46, 0, 0, 0, 0, 39, 0, 0, 47], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 5, 0, 6, 7, 0, 0, 0, 0, 0, 0, 14, 0, 0, 0, 0, 0, 0, 0, 20, 21, 22, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 5, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20, 21, 22, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 5, 0, 6, 7, 8, 9, 0, 0, 12, 0, 14, 0, 0, 0, 0, 0, 0, 0, 20, 21, 22, 0, 0, 0, 23, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 5, 0, 6, 7, 0, 9, 0, 0, 0, 0, 14, 0, 0, 0, 0, 0, 0, 0, 20, 21, 22, 0, 0, 0, 23, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 5, 0, 6, 7, 8, 9, 10, 11, 12, 13, 14, 0, 16, 0, 0, 18, 11, 19, 20, 21, 22, 0, 0, 0, 23, 0, 0, 0, 0, 0, 0, 0, 25], [0, 0, 0, 0, 0, 5, 0, 6, 7, 8, 9, 0, 11, 12, 0, 14, 0, 0, 0, 0, 0, 0, 0, 20, 21, 22, 0, 0, 0, 23, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 5, 0, 6, 7, 0, 9, 0, 0, 12, 0, 14, 0, 0, 0, 0, 0, 0, 0, 20, 21, 22, 0, 0, 0, 23, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 18, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 5, 0, 0, 7, 0, 0, 0, 0, 0, 0, 14, 0, 0, 0, 0, 0, 0, 0, 20, 21, 22, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 5, 0, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 0, 0, 18, 11, 19, 20, 21, 22, 0, 0, 0, 23, 0, 0, 0, 0, 0, 0, 0, 25], [0, 0, 0, 0, 0, 5, 0, 6, 7, 8, 9, 0, 11, 12, 0, 14, 0, 0, 0, 0, 0, 11, 0, 20, 21, 22, 0, 0, 0, 23, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 4, 4, 5, 0, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 0, 0, 18, 11, 19, 20, 21, 22, 0, 0, 0, 23, 0, 0, 0, 0, 0, 0, 0, 25], [0, 0, 0, 0, 0, 5, 0, 6, 7, 8, 9, 48, 11, 12, 13, 14, 48, 16, 0, 0, 18, 11, 19, 20, 21, 22, 0, 0, 0, 23, 0, 0, 0, 0, 49, 0, 0, 25], [0, 0, 0, 0, 0, 5, 0, 6, 7, 8, 9, 0, 11, 12, 0, 14, 0, 16, 0, 0, 0, 11, 0, 20, 21, 22, 0, 0, 0, 23, 0, 0, 0, 0, 0, 0, 0, 25], [0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20, 21, 22, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 21, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 21, 22, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 5, 0, 6, 7, 0, 0, 0, 0, 0, 0, 14, 0, 0, 0, 0, 0, 0, 0, 20, 21, 22, 0, 0, 0, 23, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 50, 0, 51, 0], [0, 0, 0, 0, 0, 5, 0, 6, 7, 8, 9, 0, 11, 12, 0, 14, 0, 16, 0, 0, 0, 11, 0, 20, 21, 22, 0, 0, 0, 23, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 27, 28, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 28, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 29, 0, 30, 31, 0, 0, 0, 0, 0, 0, 38, 0, 0, 0, 0, 0, 0, 0, 43, 44, 45, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 29, 0, 0, 31, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 43, 44, 45, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 29, 0, 30, 31, 32, 33, 0, 0, 36, 0, 38, 0, 0, 0, 0, 0, 0, 0, 43, 44, 45, 0, 0, 0, 46, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 29, 0, 30, 31, 0, 33, 0, 0, 0, 0, 38, 0, 0, 0, 0, 0, 0, 0, 43, 44, 45, 0, 0, 0, 46, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 29, 0, 30, 31, 32, 33, 34, 35, 36, 37, 38, 0, 40, 0, 0, 41, 35, 42, 43, 44, 45, 0, 0, 0, 46, 0, 0, 0, 0, 0, 0, 0, 47], [0, 0, 0, 0, 0, 29, 0, 30, 31, 32, 33, 0, 35, 36, 0, 38, 0, 0, 0, 0, 0, 0, 0, 43, 44, 45, 0, 0, 0, 46, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 29, 0, 30, 31, 0, 33, 0, 0, 36, 0, 38, 0, 0, 0, 0, 0, 0, 0, 43, 44, 45, 0, 0, 0, 46, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 41, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 29, 0, 0, 31, 0, 0, 0, 0, 0, 0, 38, 0, 0, 0, 0, 0, 0, 0, 43, 44, 45, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 29, 0, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 0, 0, 41, 35, 42, 43, 44, 45, 0, 0, 0, 46, 0, 0, 0, 0, 0, 0, 0, 47], [0, 0, 0, 0, 0, 29, 0, 30, 31, 32, 33, 0, 35, 36, 0, 38, 0, 0, 0, 0, 0, 35, 0, 43, 44, 45, 0, 0, 0, 46, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 29, 0, 30, 31, 32, 33, 52, 35, 36, 37, 38, 52, 40, 0, 0, 41, 35, 42, 43, 44, 45, 0, 0, 0, 46, 0, 0, 0, 0, 53, 0, 0, 47], [0, 0, 0, 0, 0, 29, 0, 30, 31, 32, 33, 0, 35, 36, 0, 38, 0, 40, 0, 0, 0, 35, 0, 43, 44, 45, 0, 0, 0, 46, 0, 0, 0, 0, 0, 0, 0, 47], [0, 0, 0, 0, 0, 29, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 43, 44, 45, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 29, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 44, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 29, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 44, 45, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 29, 0, 30, 31, 0, 0, 0, 0, 0, 0, 38, 0, 0, 0, 0, 0, 0, 0, 43, 44, 45, 0, 0, 0, 46, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 29, 0, 30, 31, 32, 33, 0, 35, 36, 0, 38, 0, 40, 0, 0, 0, 35, 0, 43, 44, 45, 0, 0, 0, 46, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 5, 0, 6, 7, 8, 9, 48, 11, 12, 13, 14, 0, 16, 0, 0, 18, 11, 19, 20, 21, 22, 0, 0, 0, 23, 0, 0, 0, 0, 0, 0, 0, 25], [0, 0, 0, 0, 0, 5, 0, 6, 7, 8, 9, 48, 11, 12, 13, 14, 48, 16, 0, 0, 18, 11, 19, 20, 21, 22, 0, 0, 0, 23, 0, 0, 0, 0, 0, 0, 0, 25], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 51, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 54, 0, 0], [0, 0, 0, 0, 0, 29, 0, 30, 31, 32, 33, 52, 35, 36, 37, 38, 0, 40, 0, 0, 41, 35, 42, 43, 44, 45, 0, 0, 0, 46, 0, 0, 0, 0, 0, 0, 0, 47], [0, 0, 0, 0, 0, 29, 0, 30, 31, 32, 33, 52, 35, 36, 37, 38, 52, 40, 0, 0, 41, 35, 42, 43, 44, 45, 0, 0, 0, 46, 0, 0, 0, 0, 0, 0, 0, 47], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 50, 0, 51, 0]];\nvar accepting$1 = [false, true, true, true, true, true, true, true, true, true, true, true, true, false, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true];\nvar tags$1 = [[], [\"broken_cluster\"], [\"independent_cluster\"], [\"symbol_cluster\"], [\"standard_cluster\"], [\"broken_cluster\"], [\"broken_cluster\"], [\"broken_cluster\"], [\"broken_cluster\"], [\"broken_cluster\"], [\"broken_cluster\"], [\"broken_cluster\"], [\"broken_cluster\"], [], [\"broken_cluster\"], [\"broken_cluster\"], [\"broken_cluster\"], [\"broken_cluster\"], [\"broken_cluster\"], [\"broken_cluster\"], [\"broken_cluster\"], [\"broken_cluster\"], [\"broken_cluster\"], [\"broken_cluster\"], [\"numeral_cluster\"], [\"broken_cluster\"], [\"independent_cluster\"], [\"symbol_cluster\"], [\"symbol_cluster\"], [\"standard_cluster\"], [\"standard_cluster\"], [\"standard_cluster\"], [\"standard_cluster\"], [\"standard_cluster\"], [\"standard_cluster\"], [\"standard_cluster\"], [\"standard_cluster\"], [\"virama_terminated_cluster\"], [\"standard_cluster\"], [\"standard_cluster\"], [\"standard_cluster\"], [\"standard_cluster\"], [\"standard_cluster\"], [\"standard_cluster\"], [\"standard_cluster\"], [\"standard_cluster\"], [\"standard_cluster\"], [\"standard_cluster\"], [\"broken_cluster\"], [\"broken_cluster\"], [\"numeral_cluster\"], [\"number_joiner_terminated_cluster\"], [\"standard_cluster\"], [\"standard_cluster\"], [\"numeral_cluster\"]];\nvar useData = {\n  categories: categories,\n  decompositions: decompositions$1,\n  stateTable: stateTable$1,\n  accepting: accepting$1,\n  tags: tags$1\n}; // Cateories used in the OpenType spec:\n// https://www.microsoft.com/typography/otfntdev/devanot/shaping.aspx\n\nvar CATEGORIES = {\n  X: 1 << 0,\n  C: 1 << 1,\n  V: 1 << 2,\n  N: 1 << 3,\n  H: 1 << 4,\n  ZWNJ: 1 << 5,\n  ZWJ: 1 << 6,\n  M: 1 << 7,\n  SM: 1 << 8,\n  VD: 1 << 9,\n  A: 1 << 10,\n  Placeholder: 1 << 11,\n  Dotted_Circle: 1 << 12,\n  RS: 1 << 13,\n  // Register Shifter, used in Khmer OT spec.\n  Coeng: 1 << 14,\n  // Khmer-style Virama.\n  Repha: 1 << 15,\n  // Atomically-encoded logical or visual repha.\n  Ra: 1 << 16,\n  CM: 1 << 17,\n  // Consonant-Medial.\n  Symbol: 1 << 18 // Avagraha, etc that take marks (SM,A,VD).\n\n}; // Visual positions in a syllable from left to right.\n\nvar POSITIONS = {\n  Start: 1 << 0,\n  Ra_To_Become_Reph: 1 << 1,\n  Pre_M: 1 << 2,\n  Pre_C: 1 << 3,\n  Base_C: 1 << 4,\n  After_Main: 1 << 5,\n  Above_C: 1 << 6,\n  Before_Sub: 1 << 7,\n  Below_C: 1 << 8,\n  After_Sub: 1 << 9,\n  Before_Post: 1 << 10,\n  Post_C: 1 << 11,\n  After_Post: 1 << 12,\n  Final_C: 1 << 13,\n  SMVD: 1 << 14,\n  End: 1 << 15\n};\nvar CONSONANT_FLAGS = CATEGORIES.C | CATEGORIES.Ra | CATEGORIES.CM | CATEGORIES.V | CATEGORIES.Placeholder | CATEGORIES.Dotted_Circle;\nvar JOINER_FLAGS = CATEGORIES.ZWJ | CATEGORIES.ZWNJ;\nvar HALANT_OR_COENG_FLAGS = CATEGORIES.H | CATEGORIES.Coeng;\nvar INDIC_CONFIGS = {\n  Default: {\n    hasOldSpec: false,\n    virama: 0,\n    basePos: 'Last',\n    rephPos: POSITIONS.Before_Post,\n    rephMode: 'Implicit',\n    blwfMode: 'Pre_And_Post'\n  },\n  Devanagari: {\n    hasOldSpec: true,\n    virama: 0x094D,\n    basePos: 'Last',\n    rephPos: POSITIONS.Before_Post,\n    rephMode: 'Implicit',\n    blwfMode: 'Pre_And_Post'\n  },\n  Bengali: {\n    hasOldSpec: true,\n    virama: 0x09CD,\n    basePos: 'Last',\n    rephPos: POSITIONS.After_Sub,\n    rephMode: 'Implicit',\n    blwfMode: 'Pre_And_Post'\n  },\n  Gurmukhi: {\n    hasOldSpec: true,\n    virama: 0x0A4D,\n    basePos: 'Last',\n    rephPos: POSITIONS.Before_Sub,\n    rephMode: 'Implicit',\n    blwfMode: 'Pre_And_Post'\n  },\n  Gujarati: {\n    hasOldSpec: true,\n    virama: 0x0ACD,\n    basePos: 'Last',\n    rephPos: POSITIONS.Before_Post,\n    rephMode: 'Implicit',\n    blwfMode: 'Pre_And_Post'\n  },\n  Oriya: {\n    hasOldSpec: true,\n    virama: 0x0B4D,\n    basePos: 'Last',\n    rephPos: POSITIONS.After_Main,\n    rephMode: 'Implicit',\n    blwfMode: 'Pre_And_Post'\n  },\n  Tamil: {\n    hasOldSpec: true,\n    virama: 0x0BCD,\n    basePos: 'Last',\n    rephPos: POSITIONS.After_Post,\n    rephMode: 'Implicit',\n    blwfMode: 'Pre_And_Post'\n  },\n  Telugu: {\n    hasOldSpec: true,\n    virama: 0x0C4D,\n    basePos: 'Last',\n    rephPos: POSITIONS.After_Post,\n    rephMode: 'Explicit',\n    blwfMode: 'Post_Only'\n  },\n  Kannada: {\n    hasOldSpec: true,\n    virama: 0x0CCD,\n    basePos: 'Last',\n    rephPos: POSITIONS.After_Post,\n    rephMode: 'Implicit',\n    blwfMode: 'Post_Only'\n  },\n  Malayalam: {\n    hasOldSpec: true,\n    virama: 0x0D4D,\n    basePos: 'Last',\n    rephPos: POSITIONS.After_Main,\n    rephMode: 'Log_Repha',\n    blwfMode: 'Pre_And_Post'\n  },\n  // Handled by UniversalShaper\n  // Sinhala: {\n  //   hasOldSpec: false,\n  //   virama: 0x0DCA,\n  //   basePos: 'Last_Sinhala',\n  //   rephPos: POSITIONS.After_Main,\n  //   rephMode: 'Explicit',\n  //   blwfMode: 'Pre_And_Post'\n  // },\n  Khmer: {\n    hasOldSpec: false,\n    virama: 0x17D2,\n    basePos: 'First',\n    rephPos: POSITIONS.Ra_To_Become_Reph,\n    rephMode: 'Vis_Repha',\n    blwfMode: 'Pre_And_Post'\n  }\n}; // Additional decompositions that aren't in Unicode\n\nvar INDIC_DECOMPOSITIONS = {\n  // Khmer\n  0x17BE: [0x17C1, 0x17BE],\n  0x17BF: [0x17C1, 0x17BF],\n  0x17C0: [0x17C1, 0x17C0],\n  0x17C4: [0x17C1, 0x17C4],\n  0x17C5: [0x17C1, 0x17C5]\n};\n\nvar _class$6;\n\nvar _temp$2;\n\nvar decompositions = useData.decompositions;\nvar trie$1 = new UnicodeTrie(require('fs').readFileSync(__dirname + '/indic.trie'));\nvar stateMachine = new StateMachine(indicMachine);\n/**\n * The IndicShaper supports indic scripts e.g. Devanagari, Kannada, etc.\n * Based on code from Harfbuzz: https://github.com/behdad/harfbuzz/blob/master/src/hb-ot-shape-complex-indic.cc\n */\n\nvar IndicShaper = (_temp$2 = _class$6 = function (_DefaultShaper) {\n  _inherits(IndicShaper, _DefaultShaper);\n\n  function IndicShaper() {\n    _classCallCheck(this, IndicShaper);\n\n    return _possibleConstructorReturn(this, _DefaultShaper.apply(this, arguments));\n  }\n\n  IndicShaper.planFeatures = function planFeatures(plan) {\n    plan.addStage(setupSyllables);\n    plan.addStage(['locl', 'ccmp']);\n    plan.addStage(initialReordering);\n    plan.addStage('nukt');\n    plan.addStage('akhn');\n    plan.addStage('rphf', false);\n    plan.addStage('rkrf');\n    plan.addStage('pref', false);\n    plan.addStage('blwf', false);\n    plan.addStage('abvf', false);\n    plan.addStage('half', false);\n    plan.addStage('pstf', false);\n    plan.addStage('vatu');\n    plan.addStage('cjct');\n    plan.addStage('cfar', false);\n    plan.addStage(finalReordering);\n    plan.addStage({\n      local: ['init'],\n      global: ['pres', 'abvs', 'blws', 'psts', 'haln', 'dist', 'abvm', 'blwm', 'calt', 'clig']\n    }); // Setup the indic config for the selected script\n\n    plan.unicodeScript = fromOpenType(plan.script);\n    plan.indicConfig = INDIC_CONFIGS[plan.unicodeScript] || INDIC_CONFIGS.Default;\n    plan.isOldSpec = plan.indicConfig.hasOldSpec && plan.script[plan.script.length - 1] !== '2'; // TODO: turn off kern (Khmer) and liga features.\n  };\n\n  IndicShaper.assignFeatures = function assignFeatures(plan, glyphs) {\n    var _loop = function _loop(i) {\n      var codepoint = glyphs[i].codePoints[0];\n      var d = INDIC_DECOMPOSITIONS[codepoint] || decompositions[codepoint];\n\n      if (d) {\n        var decomposed = d.map(function (c) {\n          var g = plan.font.glyphForCodePoint(c);\n          return new GlyphInfo(plan.font, g.id, [c], glyphs[i].features);\n        });\n        glyphs.splice.apply(glyphs, [i, 1].concat(decomposed));\n      }\n    }; // Decompose split matras\n    // TODO: do this in a more general unicode normalizer\n\n\n    for (var i = glyphs.length - 1; i >= 0; i--) {\n      _loop(i);\n    }\n  };\n\n  return IndicShaper;\n}(DefaultShaper), _class$6.zeroMarkWidths = 'NONE', _temp$2);\n\nfunction indicCategory(glyph) {\n  return trie$1.get(glyph.codePoints[0]) >> 8;\n}\n\nfunction indicPosition(glyph) {\n  return 1 << (trie$1.get(glyph.codePoints[0]) & 0xff);\n}\n\nvar IndicInfo = function IndicInfo(category, position, syllableType, syllable) {\n  _classCallCheck(this, IndicInfo);\n\n  this.category = category;\n  this.position = position;\n  this.syllableType = syllableType;\n  this.syllable = syllable;\n};\n\nfunction setupSyllables(font, glyphs) {\n  var syllable = 0;\n  var last = 0;\n\n  for (var _iterator = stateMachine.match(glyphs.map(indicCategory)), _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _getIterator(_iterator);;) {\n    var _ref;\n\n    if (_isArray) {\n      if (_i >= _iterator.length) break;\n      _ref = _iterator[_i++];\n    } else {\n      _i = _iterator.next();\n      if (_i.done) break;\n      _ref = _i.value;\n    }\n\n    var _ref2 = _ref,\n        start = _ref2[0],\n        end = _ref2[1],\n        tags = _ref2[2];\n\n    if (start > last) {\n      ++syllable;\n\n      for (var _i2 = last; _i2 < start; _i2++) {\n        glyphs[_i2].shaperInfo = new IndicInfo(CATEGORIES.X, POSITIONS.End, 'non_indic_cluster', syllable);\n      }\n    }\n\n    ++syllable; // Create shaper info\n\n    for (var _i3 = start; _i3 <= end; _i3++) {\n      glyphs[_i3].shaperInfo = new IndicInfo(1 << indicCategory(glyphs[_i3]), indicPosition(glyphs[_i3]), tags[0], syllable);\n    }\n\n    last = end + 1;\n  }\n\n  if (last < glyphs.length) {\n    ++syllable;\n\n    for (var i = last; i < glyphs.length; i++) {\n      glyphs[i].shaperInfo = new IndicInfo(CATEGORIES.X, POSITIONS.End, 'non_indic_cluster', syllable);\n    }\n  }\n}\n\nfunction isConsonant(glyph) {\n  return glyph.shaperInfo.category & CONSONANT_FLAGS;\n}\n\nfunction isJoiner(glyph) {\n  return glyph.shaperInfo.category & JOINER_FLAGS;\n}\n\nfunction isHalantOrCoeng(glyph) {\n  return glyph.shaperInfo.category & HALANT_OR_COENG_FLAGS;\n}\n\nfunction wouldSubstitute(glyphs, feature) {\n  for (var _iterator2 = glyphs, _isArray2 = Array.isArray(_iterator2), _i4 = 0, _iterator2 = _isArray2 ? _iterator2 : _getIterator(_iterator2);;) {\n    var _glyph$features;\n\n    var _ref3;\n\n    if (_isArray2) {\n      if (_i4 >= _iterator2.length) break;\n      _ref3 = _iterator2[_i4++];\n    } else {\n      _i4 = _iterator2.next();\n      if (_i4.done) break;\n      _ref3 = _i4.value;\n    }\n\n    var glyph = _ref3;\n    glyph.features = (_glyph$features = {}, _glyph$features[feature] = true, _glyph$features);\n  }\n\n  var GSUB = glyphs[0]._font._layoutEngine.engine.GSUBProcessor;\n  GSUB.applyFeatures([feature], glyphs);\n  return glyphs.length === 1;\n}\n\nfunction consonantPosition(font, consonant, virama) {\n  var glyphs = [virama, consonant, virama];\n\n  if (wouldSubstitute(glyphs.slice(0, 2), 'blwf') || wouldSubstitute(glyphs.slice(1, 3), 'blwf')) {\n    return POSITIONS.Below_C;\n  } else if (wouldSubstitute(glyphs.slice(0, 2), 'pstf') || wouldSubstitute(glyphs.slice(1, 3), 'pstf')) {\n    return POSITIONS.Post_C;\n  } else if (wouldSubstitute(glyphs.slice(0, 2), 'pref') || wouldSubstitute(glyphs.slice(1, 3), 'pref')) {\n    return POSITIONS.Post_C;\n  }\n\n  return POSITIONS.Base_C;\n}\n\nfunction initialReordering(font, glyphs, plan) {\n  var indicConfig = plan.indicConfig;\n  var features = font._layoutEngine.engine.GSUBProcessor.features;\n  var dottedCircle = font.glyphForCodePoint(0x25cc).id;\n  var virama = font.glyphForCodePoint(indicConfig.virama).id;\n\n  if (virama) {\n    var info = new GlyphInfo(font, virama, [indicConfig.virama]);\n\n    for (var i = 0; i < glyphs.length; i++) {\n      if (glyphs[i].shaperInfo.position === POSITIONS.Base_C) {\n        glyphs[i].shaperInfo.position = consonantPosition(font, glyphs[i].copy(), info);\n      }\n    }\n  }\n\n  for (var start = 0, end = nextSyllable(glyphs, 0); start < glyphs.length; start = end, end = nextSyllable(glyphs, start)) {\n    var _glyphs$start$shaperI = glyphs[start].shaperInfo,\n        category = _glyphs$start$shaperI.category,\n        syllableType = _glyphs$start$shaperI.syllableType;\n\n    if (syllableType === 'symbol_cluster' || syllableType === 'non_indic_cluster') {\n      continue;\n    }\n\n    if (syllableType === 'broken_cluster' && dottedCircle) {\n      var g = new GlyphInfo(font, dottedCircle, [0x25cc]);\n      g.shaperInfo = new IndicInfo(1 << indicCategory(g), indicPosition(g), glyphs[start].shaperInfo.syllableType, glyphs[start].shaperInfo.syllable); // Insert after possible Repha.\n\n      var _i5 = start;\n\n      while (_i5 < end && glyphs[_i5].shaperInfo.category === CATEGORIES.Repha) {\n        _i5++;\n      }\n\n      glyphs.splice(_i5++, 0, g);\n      end++;\n    } // 1. Find base consonant:\n    //\n    // The shaping engine finds the base consonant of the syllable, using the\n    // following algorithm: starting from the end of the syllable, move backwards\n    // until a consonant is found that does not have a below-base or post-base\n    // form (post-base forms have to follow below-base forms), or that is not a\n    // pre-base reordering Ra, or arrive at the first consonant. The consonant\n    // stopped at will be the base.\n\n\n    var base = end;\n    var limit = start;\n    var hasReph = false; // If the syllable starts with Ra + Halant (in a script that has Reph)\n    // and has more than one consonant, Ra is excluded from candidates for\n    // base consonants.\n\n    if (indicConfig.rephPos !== POSITIONS.Ra_To_Become_Reph && features.rphf && start + 3 <= end && (indicConfig.rephMode === 'Implicit' && !isJoiner(glyphs[start + 2]) || indicConfig.rephMode === 'Explicit' && glyphs[start + 2].shaperInfo.category === CATEGORIES.ZWJ)) {\n      // See if it matches the 'rphf' feature.\n      var _g = [glyphs[start].copy(), glyphs[start + 1].copy(), glyphs[start + 2].copy()];\n\n      if (wouldSubstitute(_g.slice(0, 2), 'rphf') || indicConfig.rephMode === 'Explicit' && wouldSubstitute(_g, 'rphf')) {\n        limit += 2;\n\n        while (limit < end && isJoiner(glyphs[limit])) {\n          limit++;\n        }\n\n        base = start;\n        hasReph = true;\n      }\n    } else if (indicConfig.rephMode === 'Log_Repha' && glyphs[start].shaperInfo.category === CATEGORIES.Repha) {\n      limit++;\n\n      while (limit < end && isJoiner(glyphs[limit])) {\n        limit++;\n      }\n\n      base = start;\n      hasReph = true;\n    }\n\n    switch (indicConfig.basePos) {\n      case 'Last':\n        {\n          // starting from the end of the syllable, move backwards\n          var _i6 = end;\n          var seenBelow = false;\n\n          do {\n            var _info = glyphs[--_i6].shaperInfo; // until a consonant is found\n\n            if (isConsonant(glyphs[_i6])) {\n              // that does not have a below-base or post-base form\n              // (post-base forms have to follow below-base forms),\n              if (_info.position !== POSITIONS.Below_C && (_info.position !== POSITIONS.Post_C || seenBelow)) {\n                base = _i6;\n                break;\n              } // or that is not a pre-base reordering Ra,\n              //\n              // IMPLEMENTATION NOTES:\n              //\n              // Our pre-base reordering Ra's are marked POS_POST_C, so will be skipped\n              // by the logic above already.\n              //\n              // or arrive at the first consonant. The consonant stopped at will\n              // be the base.\n\n\n              if (_info.position === POSITIONS.Below_C) {\n                seenBelow = true;\n              }\n\n              base = _i6;\n            } else if (start < _i6 && _info.category === CATEGORIES.ZWJ && glyphs[_i6 - 1].shaperInfo.category === CATEGORIES.H) {\n              // A ZWJ after a Halant stops the base search, and requests an explicit\n              // half form.\n              // A ZWJ before a Halant, requests a subjoined form instead, and hence\n              // search continues.  This is particularly important for Bengali\n              // sequence Ra,H,Ya that should form Ya-Phalaa by subjoining Ya.\n              break;\n            }\n          } while (_i6 > limit);\n\n          break;\n        }\n\n      case 'First':\n        {\n          // The first consonant is always the base.\n          base = start; // Mark all subsequent consonants as below.\n\n          for (var _i7 = base + 1; _i7 < end; _i7++) {\n            if (isConsonant(glyphs[_i7])) {\n              glyphs[_i7].shaperInfo.position = POSITIONS.Below_C;\n            }\n          }\n        }\n    } // If the syllable starts with Ra + Halant (in a script that has Reph)\n    // and has more than one consonant, Ra is excluded from candidates for\n    // base consonants.\n    //\n    //  Only do this for unforced Reph. (ie. not for Ra,H,ZWJ)\n\n\n    if (hasReph && base === start && limit - base <= 2) {\n      hasReph = false;\n    } // 2. Decompose and reorder Matras:\n    //\n    // Each matra and any syllable modifier sign in the cluster are moved to the\n    // appropriate position relative to the consonant(s) in the cluster. The\n    // shaping engine decomposes two- or three-part matras into their constituent\n    // parts before any repositioning. Matra characters are classified by which\n    // consonant in a conjunct they have affinity for and are reordered to the\n    // following positions:\n    //\n    //   o Before first half form in the syllable\n    //   o After subjoined consonants\n    //   o After post-form consonant\n    //   o After main consonant (for above marks)\n    //\n    // IMPLEMENTATION NOTES:\n    //\n    // The normalize() routine has already decomposed matras for us, so we don't\n    // need to worry about that.\n    // 3.  Reorder marks to canonical order:\n    //\n    // Adjacent nukta and halant or nukta and vedic sign are always repositioned\n    // if necessary, so that the nukta is first.\n    //\n    // IMPLEMENTATION NOTES:\n    //\n    // We don't need to do this: the normalize() routine already did this for us.\n    // Reorder characters\n\n\n    for (var _i8 = start; _i8 < base; _i8++) {\n      var _info2 = glyphs[_i8].shaperInfo;\n      _info2.position = Math.min(POSITIONS.Pre_C, _info2.position);\n    }\n\n    if (base < end) {\n      glyphs[base].shaperInfo.position = POSITIONS.Base_C;\n    } // Mark final consonants.  A final consonant is one appearing after a matra,\n    // like in Khmer.\n\n\n    for (var _i9 = base + 1; _i9 < end; _i9++) {\n      if (glyphs[_i9].shaperInfo.category === CATEGORIES.M) {\n        for (var j = _i9 + 1; j < end; j++) {\n          if (isConsonant(glyphs[j])) {\n            glyphs[j].shaperInfo.position = POSITIONS.Final_C;\n            break;\n          }\n        }\n\n        break;\n      }\n    } // Handle beginning Ra\n\n\n    if (hasReph) {\n      glyphs[start].shaperInfo.position = POSITIONS.Ra_To_Become_Reph;\n    } // For old-style Indic script tags, move the first post-base Halant after\n    // last consonant.\n    //\n    // Reports suggest that in some scripts Uniscribe does this only if there\n    // is *not* a Halant after last consonant already (eg. Kannada), while it\n    // does it unconditionally in other scripts (eg. Malayalam).  We don't\n    // currently know about other scripts, so we single out Malayalam for now.\n    //\n    // Kannada test case:\n    // U+0C9A,U+0CCD,U+0C9A,U+0CCD\n    // With some versions of Lohit Kannada.\n    // https://bugs.freedesktop.org/show_bug.cgi?id=59118\n    //\n    // Malayalam test case:\n    // U+0D38,U+0D4D,U+0D31,U+0D4D,U+0D31,U+0D4D\n    // With lohit-ttf-20121122/Lohit-Malayalam.ttf\n\n\n    if (plan.isOldSpec) {\n      var disallowDoubleHalants = plan.unicodeScript !== 'Malayalam';\n\n      for (var _i10 = base + 1; _i10 < end; _i10++) {\n        if (glyphs[_i10].shaperInfo.category === CATEGORIES.H) {\n          var _j = void 0;\n\n          for (_j = end - 1; _j > _i10; _j--) {\n            if (isConsonant(glyphs[_j]) || disallowDoubleHalants && glyphs[_j].shaperInfo.category === CATEGORIES.H) {\n              break;\n            }\n          }\n\n          if (glyphs[_j].shaperInfo.category !== CATEGORIES.H && _j > _i10) {\n            // Move Halant to after last consonant.\n            var t = glyphs[_i10];\n            glyphs.splice.apply(glyphs, [_i10, 0].concat(glyphs.splice(_i10 + 1, _j - _i10)));\n            glyphs[_j] = t;\n          }\n\n          break;\n        }\n      }\n    } // Attach misc marks to previous char to move with them.\n\n\n    var lastPos = POSITIONS.Start;\n\n    for (var _i11 = start; _i11 < end; _i11++) {\n      var _info3 = glyphs[_i11].shaperInfo;\n\n      if (_info3.category & (JOINER_FLAGS | CATEGORIES.N | CATEGORIES.RS | CATEGORIES.CM | HALANT_OR_COENG_FLAGS & _info3.category)) {\n        _info3.position = lastPos;\n\n        if (_info3.category === CATEGORIES.H && _info3.position === POSITIONS.Pre_M) {\n          // Uniscribe doesn't move the Halant with Left Matra.\n          // TEST: U+092B,U+093F,U+094DE\n          // We follow.  This is important for the Sinhala\n          // U+0DDA split matra since it decomposes to U+0DD9,U+0DCA\n          // where U+0DD9 is a left matra and U+0DCA is the virama.\n          // We don't want to move the virama with the left matra.\n          // TEST: U+0D9A,U+0DDA\n          for (var _j2 = _i11; _j2 > start; _j2--) {\n            if (glyphs[_j2 - 1].shaperInfo.position !== POSITIONS.Pre_M) {\n              _info3.position = glyphs[_j2 - 1].shaperInfo.position;\n              break;\n            }\n          }\n        }\n      } else if (_info3.position !== POSITIONS.SMVD) {\n        lastPos = _info3.position;\n      }\n    } // For post-base consonants let them own anything before them\n    // since the last consonant or matra.\n\n\n    var last = base;\n\n    for (var _i12 = base + 1; _i12 < end; _i12++) {\n      if (isConsonant(glyphs[_i12])) {\n        for (var _j3 = last + 1; _j3 < _i12; _j3++) {\n          if (glyphs[_j3].shaperInfo.position < POSITIONS.SMVD) {\n            glyphs[_j3].shaperInfo.position = glyphs[_i12].shaperInfo.position;\n          }\n        }\n\n        last = _i12;\n      } else if (glyphs[_i12].shaperInfo.category === CATEGORIES.M) {\n        last = _i12;\n      }\n    }\n\n    var arr = glyphs.slice(start, end);\n    arr.sort(function (a, b) {\n      return a.shaperInfo.position - b.shaperInfo.position;\n    });\n    glyphs.splice.apply(glyphs, [start, arr.length].concat(arr)); // Find base again\n\n    for (var _i13 = start; _i13 < end; _i13++) {\n      if (glyphs[_i13].shaperInfo.position === POSITIONS.Base_C) {\n        base = _i13;\n        break;\n      }\n    } // Setup features now\n    // Reph\n\n\n    for (var _i14 = start; _i14 < end && glyphs[_i14].shaperInfo.position === POSITIONS.Ra_To_Become_Reph; _i14++) {\n      glyphs[_i14].features.rphf = true;\n    } // Pre-base\n\n\n    var blwf = !plan.isOldSpec && indicConfig.blwfMode === 'Pre_And_Post';\n\n    for (var _i15 = start; _i15 < base; _i15++) {\n      glyphs[_i15].features.half = true;\n\n      if (blwf) {\n        glyphs[_i15].features.blwf = true;\n      }\n    } // Post-base\n\n\n    for (var _i16 = base + 1; _i16 < end; _i16++) {\n      glyphs[_i16].features.abvf = true;\n      glyphs[_i16].features.pstf = true;\n      glyphs[_i16].features.blwf = true;\n    }\n\n    if (plan.isOldSpec && plan.unicodeScript === 'Devanagari') {\n      // Old-spec eye-lash Ra needs special handling.  From the\n      // spec:\n      //\n      // \"The feature 'below-base form' is applied to consonants\n      // having below-base forms and following the base consonant.\n      // The exception is vattu, which may appear below half forms\n      // as well as below the base glyph. The feature 'below-base\n      // form' will be applied to all such occurrences of Ra as well.\"\n      //\n      // Test case: U+0924,U+094D,U+0930,U+094d,U+0915\n      // with Sanskrit 2003 font.\n      //\n      // However, note that Ra,Halant,ZWJ is the correct way to\n      // request eyelash form of Ra, so we wouldbn't inhibit it\n      // in that sequence.\n      //\n      // Test case: U+0924,U+094D,U+0930,U+094d,U+200D,U+0915\n      for (var _i17 = start; _i17 + 1 < base; _i17++) {\n        if (glyphs[_i17].shaperInfo.category === CATEGORIES.Ra && glyphs[_i17 + 1].shaperInfo.category === CATEGORIES.H && (_i17 + 1 === base || glyphs[_i17 + 2].shaperInfo.category === CATEGORIES.ZWJ)) {\n          glyphs[_i17].features.blwf = true;\n          glyphs[_i17 + 1].features.blwf = true;\n        }\n      }\n    }\n\n    var prefLen = 2;\n\n    if (features.pref && base + prefLen < end) {\n      // Find a Halant,Ra sequence and mark it for pre-base reordering processing.\n      for (var _i18 = base + 1; _i18 + prefLen - 1 < end; _i18++) {\n        var _g2 = [glyphs[_i18].copy(), glyphs[_i18 + 1].copy()];\n\n        if (wouldSubstitute(_g2, 'pref')) {\n          for (var _j4 = 0; _j4 < prefLen; _j4++) {\n            glyphs[_i18++].features.pref = true;\n          } // Mark the subsequent stuff with 'cfar'.  Used in Khmer.\n          // Read the feature spec.\n          // This allows distinguishing the following cases with MS Khmer fonts:\n          // U+1784,U+17D2,U+179A,U+17D2,U+1782\n          // U+1784,U+17D2,U+1782,U+17D2,U+179A\n\n\n          if (features.cfar) {\n            for (; _i18 < end; _i18++) {\n              glyphs[_i18].features.cfar = true;\n            }\n          }\n\n          break;\n        }\n      }\n    } // Apply ZWJ/ZWNJ effects\n\n\n    for (var _i19 = start + 1; _i19 < end; _i19++) {\n      if (isJoiner(glyphs[_i19])) {\n        var nonJoiner = glyphs[_i19].shaperInfo.category === CATEGORIES.ZWNJ;\n        var _j5 = _i19;\n\n        do {\n          _j5--; // ZWJ/ZWNJ should disable CJCT.  They do that by simply\n          // being there, since we don't skip them for the CJCT\n          // feature (ie. F_MANUAL_ZWJ)\n          // A ZWNJ disables HALF.\n\n          if (nonJoiner) {\n            delete glyphs[_j5].features.half;\n          }\n        } while (_j5 > start && !isConsonant(glyphs[_j5]));\n      }\n    }\n  }\n}\n\nfunction finalReordering(font, glyphs, plan) {\n  var indicConfig = plan.indicConfig;\n  var features = font._layoutEngine.engine.GSUBProcessor.features;\n\n  for (var start = 0, end = nextSyllable(glyphs, 0); start < glyphs.length; start = end, end = nextSyllable(glyphs, start)) {\n    // 4. Final reordering:\n    //\n    // After the localized forms and basic shaping forms GSUB features have been\n    // applied (see below), the shaping engine performs some final glyph\n    // reordering before applying all the remaining font features to the entire\n    // cluster.\n    var tryPref = !!features.pref; // Find base again\n\n    var base = start;\n\n    for (; base < end; base++) {\n      if (glyphs[base].shaperInfo.position >= POSITIONS.Base_C) {\n        if (tryPref && base + 1 < end) {\n          for (var i = base + 1; i < end; i++) {\n            if (glyphs[i].features.pref) {\n              if (!(glyphs[i].substituted && glyphs[i].isLigated && !glyphs[i].isMultiplied)) {\n                // Ok, this was a 'pref' candidate but didn't form any.\n                // Base is around here...\n                base = i;\n\n                while (base < end && isHalantOrCoeng(glyphs[base])) {\n                  base++;\n                }\n\n                glyphs[base].shaperInfo.position = POSITIONS.BASE_C;\n                tryPref = false;\n              }\n\n              break;\n            }\n          }\n        } // For Malayalam, skip over unformed below- (but NOT post-) forms.\n\n\n        if (plan.unicodeScript === 'Malayalam') {\n          for (var _i20 = base + 1; _i20 < end; _i20++) {\n            while (_i20 < end && isJoiner(glyphs[_i20])) {\n              _i20++;\n            }\n\n            if (_i20 === end || !isHalantOrCoeng(glyphs[_i20])) {\n              break;\n            }\n\n            _i20++; // Skip halant.\n\n            while (_i20 < end && isJoiner(glyphs[_i20])) {\n              _i20++;\n            }\n\n            if (_i20 < end && isConsonant(glyphs[_i20]) && glyphs[_i20].shaperInfo.position === POSITIONS.Below_C) {\n              base = _i20;\n              glyphs[base].shaperInfo.position = POSITIONS.Base_C;\n            }\n          }\n        }\n\n        if (start < base && glyphs[base].shaperInfo.position > POSITIONS.Base_C) {\n          base--;\n        }\n\n        break;\n      }\n    }\n\n    if (base === end && start < base && glyphs[base - 1].shaperInfo.category === CATEGORIES.ZWJ) {\n      base--;\n    }\n\n    if (base < end) {\n      while (start < base && glyphs[base].shaperInfo.category & (CATEGORIES.N | HALANT_OR_COENG_FLAGS)) {\n        base--;\n      }\n    } // o Reorder matras:\n    //\n    // If a pre-base matra character had been reordered before applying basic\n    // features, the glyph can be moved closer to the main consonant based on\n    // whether half-forms had been formed. Actual position for the matra is\n    // defined as “after last standalone halant glyph, after initial matra\n    // position and before the main consonant”. If ZWJ or ZWNJ follow this\n    // halant, position is moved after it.\n    //\n\n\n    if (start + 1 < end && start < base) {\n      // Otherwise there can't be any pre-base matra characters.\n      // If we lost track of base, alas, position before last thingy.\n      var newPos = base === end ? base - 2 : base - 1; // Malayalam / Tamil do not have \"half\" forms or explicit virama forms.\n      // The glyphs formed by 'half' are Chillus or ligated explicit viramas.\n      // We want to position matra after them.\n\n      if (plan.unicodeScript !== 'Malayalam' && plan.unicodeScript !== 'Tamil') {\n        while (newPos > start && !(glyphs[newPos].shaperInfo.category & (CATEGORIES.M | HALANT_OR_COENG_FLAGS))) {\n          newPos--;\n        } // If we found no Halant we are done.\n        // Otherwise only proceed if the Halant does\n        // not belong to the Matra itself!\n\n\n        if (isHalantOrCoeng(glyphs[newPos]) && glyphs[newPos].shaperInfo.position !== POSITIONS.Pre_M) {\n          // If ZWJ or ZWNJ follow this halant, position is moved after it.\n          if (newPos + 1 < end && isJoiner(glyphs[newPos + 1])) {\n            newPos++;\n          }\n        } else {\n          newPos = start; // No move.\n        }\n      }\n\n      if (start < newPos && glyphs[newPos].shaperInfo.position !== POSITIONS.Pre_M) {\n        // Now go see if there's actually any matras...\n        for (var _i21 = newPos; _i21 > start; _i21--) {\n          if (glyphs[_i21 - 1].shaperInfo.position === POSITIONS.Pre_M) {\n            var oldPos = _i21 - 1;\n\n            if (oldPos < base && base <= newPos) {\n              // Shouldn't actually happen.\n              base--;\n            }\n\n            var tmp = glyphs[oldPos];\n            glyphs.splice.apply(glyphs, [oldPos, 0].concat(glyphs.splice(oldPos + 1, newPos - oldPos)));\n            glyphs[newPos] = tmp;\n            newPos--;\n          }\n        }\n      }\n    } // o Reorder reph:\n    //\n    // Reph’s original position is always at the beginning of the syllable,\n    // (i.e. it is not reordered at the character reordering stage). However,\n    // it will be reordered according to the basic-forms shaping results.\n    // Possible positions for reph, depending on the script, are; after main,\n    // before post-base consonant forms, and after post-base consonant forms.\n    // Two cases:\n    //\n    // - If repha is encoded as a sequence of characters (Ra,H or Ra,H,ZWJ), then\n    //   we should only move it if the sequence ligated to the repha form.\n    //\n    // - If repha is encoded separately and in the logical position, we should only\n    //   move it if it did NOT ligate.  If it ligated, it's probably the font trying\n    //   to make it work without the reordering.\n\n\n    if (start + 1 < end && glyphs[start].shaperInfo.position === POSITIONS.Ra_To_Become_Reph && glyphs[start].shaperInfo.category === CATEGORIES.Repha !== (glyphs[start].isLigated && !glyphs[start].isMultiplied)) {\n      var newRephPos = void 0;\n      var rephPos = indicConfig.rephPos;\n      var found = false; // 1. If reph should be positioned after post-base consonant forms,\n      //    proceed to step 5.\n\n      if (rephPos !== POSITIONS.After_Post) {\n        //  2. If the reph repositioning class is not after post-base: target\n        //     position is after the first explicit halant glyph between the\n        //     first post-reph consonant and last main consonant. If ZWJ or ZWNJ\n        //     are following this halant, position is moved after it. If such\n        //     position is found, this is the target position. Otherwise,\n        //     proceed to the next step.\n        //\n        //     Note: in old-implementation fonts, where classifications were\n        //     fixed in shaping engine, there was no case where reph position\n        //     will be found on this step.\n        newRephPos = start + 1;\n\n        while (newRephPos < base && !isHalantOrCoeng(glyphs[newRephPos])) {\n          newRephPos++;\n        }\n\n        if (newRephPos < base && isHalantOrCoeng(glyphs[newRephPos])) {\n          // ->If ZWJ or ZWNJ are following this halant, position is moved after it.\n          if (newRephPos + 1 < base && isJoiner(glyphs[newRephPos + 1])) {\n            newRephPos++;\n          }\n\n          found = true;\n        } // 3. If reph should be repositioned after the main consonant: find the\n        //    first consonant not ligated with main, or find the first\n        //    consonant that is not a potential pre-base reordering Ra.\n\n\n        if (!found && rephPos === POSITIONS.After_Main) {\n          newRephPos = base;\n\n          while (newRephPos + 1 < end && glyphs[newRephPos + 1].shaperInfo.position <= POSITIONS.After_Main) {\n            newRephPos++;\n          }\n\n          found = newRephPos < end;\n        } // 4. If reph should be positioned before post-base consonant, find\n        //    first post-base classified consonant not ligated with main. If no\n        //    consonant is found, the target position should be before the\n        //    first matra, syllable modifier sign or vedic sign.\n        //\n        // This is our take on what step 4 is trying to say (and failing, BADLY).\n\n\n        if (!found && rephPos === POSITIONS.After_Sub) {\n          newRephPos = base;\n\n          while (newRephPos + 1 < end && !(glyphs[newRephPos + 1].shaperInfo.position & (POSITIONS.Post_C | POSITIONS.After_Post | POSITIONS.SMVD))) {\n            newRephPos++;\n          }\n\n          found = newRephPos < end;\n        }\n      } //  5. If no consonant is found in steps 3 or 4, move reph to a position\n      //     immediately before the first post-base matra, syllable modifier\n      //     sign or vedic sign that has a reordering class after the intended\n      //     reph position. For example, if the reordering position for reph\n      //     is post-main, it will skip above-base matras that also have a\n      //     post-main position.\n\n\n      if (!found) {\n        // Copied from step 2.\n        newRephPos = start + 1;\n\n        while (newRephPos < base && !isHalantOrCoeng(glyphs[newRephPos])) {\n          newRephPos++;\n        }\n\n        if (newRephPos < base && isHalantOrCoeng(glyphs[newRephPos])) {\n          // ->If ZWJ or ZWNJ are following this halant, position is moved after it.\n          if (newRephPos + 1 < base && isJoiner(glyphs[newRephPos + 1])) {\n            newRephPos++;\n          }\n\n          found = true;\n        }\n      } // 6. Otherwise, reorder reph to the end of the syllable.\n\n\n      if (!found) {\n        newRephPos = end - 1;\n\n        while (newRephPos > start && glyphs[newRephPos].shaperInfo.position === POSITIONS.SMVD) {\n          newRephPos--;\n        } // If the Reph is to be ending up after a Matra,Halant sequence,\n        // position it before that Halant so it can interact with the Matra.\n        // However, if it's a plain Consonant,Halant we shouldn't do that.\n        // Uniscribe doesn't do this.\n        // TEST: U+0930,U+094D,U+0915,U+094B,U+094D\n\n\n        if (isHalantOrCoeng(glyphs[newRephPos])) {\n          for (var _i22 = base + 1; _i22 < newRephPos; _i22++) {\n            if (glyphs[_i22].shaperInfo.category === CATEGORIES.M) {\n              newRephPos--;\n            }\n          }\n        }\n      }\n\n      var reph = glyphs[start];\n      glyphs.splice.apply(glyphs, [start, 0].concat(glyphs.splice(start + 1, newRephPos - start)));\n      glyphs[newRephPos] = reph;\n\n      if (start < base && base <= newRephPos) {\n        base--;\n      }\n    } // o Reorder pre-base reordering consonants:\n    //\n    // If a pre-base reordering consonant is found, reorder it according to\n    // the following rules:\n\n\n    if (tryPref && base + 1 < end) {\n      for (var _i23 = base + 1; _i23 < end; _i23++) {\n        if (glyphs[_i23].features.pref) {\n          // 1. Only reorder a glyph produced by substitution during application\n          //    of the <pref> feature. (Note that a font may shape a Ra consonant with\n          //    the feature generally but block it in certain contexts.)\n          // Note: We just check that something got substituted.  We don't check that\n          // the <pref> feature actually did it...\n          //\n          // Reorder pref only if it ligated.\n          if (glyphs[_i23].isLigated && !glyphs[_i23].isMultiplied) {\n            // 2. Try to find a target position the same way as for pre-base matra.\n            //    If it is found, reorder pre-base consonant glyph.\n            //\n            // 3. If position is not found, reorder immediately before main\n            //    consonant.\n            var _newPos = base; // Malayalam / Tamil do not have \"half\" forms or explicit virama forms.\n            // The glyphs formed by 'half' are Chillus or ligated explicit viramas.\n            // We want to position matra after them.\n\n            if (plan.unicodeScript !== 'Malayalam' && plan.unicodeScript !== 'Tamil') {\n              while (_newPos > start && !(glyphs[_newPos - 1].shaperInfo.category & (CATEGORIES.M | HALANT_OR_COENG_FLAGS))) {\n                _newPos--;\n              } // In Khmer coeng model, a H,Ra can go *after* matras.  If it goes after a\n              // split matra, it should be reordered to *before* the left part of such matra.\n\n\n              if (_newPos > start && glyphs[_newPos - 1].shaperInfo.category === CATEGORIES.M) {\n                var _oldPos2 = _i23;\n\n                for (var j = base + 1; j < _oldPos2; j++) {\n                  if (glyphs[j].shaperInfo.category === CATEGORIES.M) {\n                    _newPos--;\n                    break;\n                  }\n                }\n              }\n            }\n\n            if (_newPos > start && isHalantOrCoeng(glyphs[_newPos - 1])) {\n              // -> If ZWJ or ZWNJ follow this halant, position is moved after it.\n              if (_newPos < end && isJoiner(glyphs[_newPos])) {\n                _newPos++;\n              }\n            }\n\n            var _oldPos = _i23;\n            var _tmp = glyphs[_oldPos];\n            glyphs.splice.apply(glyphs, [_newPos + 1, 0].concat(glyphs.splice(_newPos, _oldPos - _newPos)));\n            glyphs[_newPos] = _tmp;\n\n            if (_newPos <= base && base < _oldPos) {\n              base++;\n            }\n          }\n\n          break;\n        }\n      }\n    } // Apply 'init' to the Left Matra if it's a word start.\n\n\n    if (glyphs[start].shaperInfo.position === POSITIONS.Pre_M && (!start || !/Cf|Mn/.test(unicode.getCategory(glyphs[start - 1].codePoints[0])))) {\n      glyphs[start].features.init = true;\n    }\n  }\n}\n\nfunction nextSyllable(glyphs, start) {\n  if (start >= glyphs.length) return start;\n  var syllable = glyphs[start].shaperInfo.syllable;\n\n  while (++start < glyphs.length && glyphs[start].shaperInfo.syllable === syllable) {}\n\n  return start;\n}\n\nvar _class$7;\n\nvar _temp$3;\n\nvar categories$1 = useData.categories;\nvar decompositions$2 = useData.decompositions;\nvar trie$2 = new UnicodeTrie(require('fs').readFileSync(__dirname + '/use.trie'));\nvar stateMachine$1 = new StateMachine(useData);\n/**\n * This shaper is an implementation of the Universal Shaping Engine, which\n * uses Unicode data to shape a number of scripts without a dedicated shaping engine.\n * See https://www.microsoft.com/typography/OpenTypeDev/USE/intro.htm.\n */\n\nvar UniversalShaper = (_temp$3 = _class$7 = function (_DefaultShaper) {\n  _inherits(UniversalShaper, _DefaultShaper);\n\n  function UniversalShaper() {\n    _classCallCheck(this, UniversalShaper);\n\n    return _possibleConstructorReturn(this, _DefaultShaper.apply(this, arguments));\n  }\n\n  UniversalShaper.planFeatures = function planFeatures(plan) {\n    plan.addStage(setupSyllables$1); // Default glyph pre-processing group\n\n    plan.addStage(['locl', 'ccmp', 'nukt', 'akhn']); // Reordering group\n\n    plan.addStage(clearSubstitutionFlags);\n    plan.addStage(['rphf'], false);\n    plan.addStage(recordRphf);\n    plan.addStage(clearSubstitutionFlags);\n    plan.addStage(['pref']);\n    plan.addStage(recordPref); // Orthographic unit shaping group\n\n    plan.addStage(['rkrf', 'abvf', 'blwf', 'half', 'pstf', 'vatu', 'cjct']);\n    plan.addStage(reorder); // Topographical features\n    // Scripts that need this are handled by the Arabic shaper, not implemented here for now.\n    // plan.addStage(['isol', 'init', 'medi', 'fina', 'med2', 'fin2', 'fin3'], false);\n    // Standard topographic presentation and positional feature application\n\n    plan.addStage(['abvs', 'blws', 'pres', 'psts', 'dist', 'abvm', 'blwm']);\n  };\n\n  UniversalShaper.assignFeatures = function assignFeatures(plan, glyphs) {\n    var _loop = function _loop(i) {\n      var codepoint = glyphs[i].codePoints[0];\n\n      if (decompositions$2[codepoint]) {\n        var decomposed = decompositions$2[codepoint].map(function (c) {\n          var g = plan.font.glyphForCodePoint(c);\n          return new GlyphInfo(plan.font, g.id, [c], glyphs[i].features);\n        });\n        glyphs.splice.apply(glyphs, [i, 1].concat(decomposed));\n      }\n    }; // Decompose split vowels\n    // TODO: do this in a more general unicode normalizer\n\n\n    for (var i = glyphs.length - 1; i >= 0; i--) {\n      _loop(i);\n    }\n  };\n\n  return UniversalShaper;\n}(DefaultShaper), _class$7.zeroMarkWidths = 'BEFORE_GPOS', _temp$3);\n\nfunction useCategory(glyph) {\n  return trie$2.get(glyph.codePoints[0]);\n}\n\nvar USEInfo = function USEInfo(category, syllableType, syllable) {\n  _classCallCheck(this, USEInfo);\n\n  this.category = category;\n  this.syllableType = syllableType;\n  this.syllable = syllable;\n};\n\nfunction setupSyllables$1(font, glyphs) {\n  var syllable = 0;\n\n  for (var _iterator = stateMachine$1.match(glyphs.map(useCategory)), _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _getIterator(_iterator);;) {\n    var _ref;\n\n    if (_isArray) {\n      if (_i >= _iterator.length) break;\n      _ref = _iterator[_i++];\n    } else {\n      _i = _iterator.next();\n      if (_i.done) break;\n      _ref = _i.value;\n    }\n\n    var _ref2 = _ref,\n        start = _ref2[0],\n        end = _ref2[1],\n        tags = _ref2[2];\n    ++syllable; // Create shaper info\n\n    for (var i = start; i <= end; i++) {\n      glyphs[i].shaperInfo = new USEInfo(categories$1[useCategory(glyphs[i])], tags[0], syllable);\n    } // Assign rphf feature\n\n\n    var limit = glyphs[start].shaperInfo.category === 'R' ? 1 : Math.min(3, end - start);\n\n    for (var _i2 = start; _i2 < start + limit; _i2++) {\n      glyphs[_i2].features.rphf = true;\n    }\n  }\n}\n\nfunction clearSubstitutionFlags(font, glyphs) {\n  for (var _iterator2 = glyphs, _isArray2 = Array.isArray(_iterator2), _i3 = 0, _iterator2 = _isArray2 ? _iterator2 : _getIterator(_iterator2);;) {\n    var _ref3;\n\n    if (_isArray2) {\n      if (_i3 >= _iterator2.length) break;\n      _ref3 = _iterator2[_i3++];\n    } else {\n      _i3 = _iterator2.next();\n      if (_i3.done) break;\n      _ref3 = _i3.value;\n    }\n\n    var glyph = _ref3;\n    glyph.substituted = false;\n  }\n}\n\nfunction recordRphf(font, glyphs) {\n  for (var _iterator3 = glyphs, _isArray3 = Array.isArray(_iterator3), _i4 = 0, _iterator3 = _isArray3 ? _iterator3 : _getIterator(_iterator3);;) {\n    var _ref4;\n\n    if (_isArray3) {\n      if (_i4 >= _iterator3.length) break;\n      _ref4 = _iterator3[_i4++];\n    } else {\n      _i4 = _iterator3.next();\n      if (_i4.done) break;\n      _ref4 = _i4.value;\n    }\n\n    var glyph = _ref4;\n\n    if (glyph.substituted && glyph.features.rphf) {\n      // Mark a substituted repha.\n      glyph.shaperInfo.category = 'R';\n    }\n  }\n}\n\nfunction recordPref(font, glyphs) {\n  for (var _iterator4 = glyphs, _isArray4 = Array.isArray(_iterator4), _i5 = 0, _iterator4 = _isArray4 ? _iterator4 : _getIterator(_iterator4);;) {\n    var _ref5;\n\n    if (_isArray4) {\n      if (_i5 >= _iterator4.length) break;\n      _ref5 = _iterator4[_i5++];\n    } else {\n      _i5 = _iterator4.next();\n      if (_i5.done) break;\n      _ref5 = _i5.value;\n    }\n\n    var glyph = _ref5;\n\n    if (glyph.substituted) {\n      // Mark a substituted pref as VPre, as they behave the same way.\n      glyph.shaperInfo.category = 'VPre';\n    }\n  }\n}\n\nfunction reorder(font, glyphs) {\n  var dottedCircle = font.glyphForCodePoint(0x25cc).id;\n\n  for (var start = 0, end = nextSyllable$1(glyphs, 0); start < glyphs.length; start = end, end = nextSyllable$1(glyphs, start)) {\n    var i = void 0,\n        j = void 0;\n    var info = glyphs[start].shaperInfo;\n    var type = info.syllableType; // Only a few syllable types need reordering.\n\n    if (type !== 'virama_terminated_cluster' && type !== 'standard_cluster' && type !== 'broken_cluster') {\n      continue;\n    } // Insert a dotted circle glyph in broken clusters.\n\n\n    if (type === 'broken_cluster' && dottedCircle) {\n      var g = new GlyphInfo(font, dottedCircle, [0x25cc]);\n      g.shaperInfo = info; // Insert after possible Repha.\n\n      for (i = start; i < end && glyphs[i].shaperInfo.category === 'R'; i++) {}\n\n      glyphs.splice(++i, 0, g);\n      end++;\n    } // Move things forward.\n\n\n    if (info.category === 'R' && end - start > 1) {\n      // Got a repha. Reorder it to after first base, before first halant.\n      for (i = start + 1; i < end; i++) {\n        info = glyphs[i].shaperInfo;\n\n        if (isBase(info) || isHalant(glyphs[i])) {\n          // If we hit a halant, move before it; otherwise it's a base: move to it's\n          // place, and shift things in between backward.\n          if (isHalant(glyphs[i])) {\n            i--;\n          }\n\n          glyphs.splice.apply(glyphs, [start, 0].concat(glyphs.splice(start + 1, i - start), [glyphs[i]]));\n          break;\n        }\n      }\n    } // Move things back.\n\n\n    for (i = start, j = end; i < end; i++) {\n      info = glyphs[i].shaperInfo;\n\n      if (isBase(info) || isHalant(glyphs[i])) {\n        // If we hit a halant, move after it; otherwise it's a base: move to it's\n        // place, and shift things in between backward.\n        j = isHalant(glyphs[i]) ? i + 1 : i;\n      } else if ((info.category === 'VPre' || info.category === 'VMPre') && j < i) {\n        glyphs.splice.apply(glyphs, [j, 1, glyphs[i]].concat(glyphs.splice(j, i - j)));\n      }\n    }\n  }\n}\n\nfunction nextSyllable$1(glyphs, start) {\n  if (start >= glyphs.length) return start;\n  var syllable = glyphs[start].shaperInfo.syllable;\n\n  while (++start < glyphs.length && glyphs[start].shaperInfo.syllable === syllable) {}\n\n  return start;\n}\n\nfunction isHalant(glyph) {\n  return glyph.shaperInfo.category === 'H' && !glyph.isLigated;\n}\n\nfunction isBase(info) {\n  return info.category === 'B' || info.category === 'GB';\n}\n\nvar SHAPERS = {\n  arab: ArabicShaper,\n  // Arabic\n  mong: ArabicShaper,\n  // Mongolian\n  syrc: ArabicShaper,\n  // Syriac\n  'nko ': ArabicShaper,\n  // N'Ko\n  phag: ArabicShaper,\n  // Phags Pa\n  mand: ArabicShaper,\n  // Mandaic\n  mani: ArabicShaper,\n  // Manichaean\n  phlp: ArabicShaper,\n  // Psalter Pahlavi\n  hang: HangulShaper,\n  // Hangul\n  bng2: IndicShaper,\n  // Bengali\n  beng: IndicShaper,\n  // Bengali\n  dev2: IndicShaper,\n  // Devanagari\n  deva: IndicShaper,\n  // Devanagari\n  gjr2: IndicShaper,\n  // Gujarati\n  gujr: IndicShaper,\n  // Gujarati\n  guru: IndicShaper,\n  // Gurmukhi\n  gur2: IndicShaper,\n  // Gurmukhi\n  knda: IndicShaper,\n  // Kannada\n  knd2: IndicShaper,\n  // Kannada\n  mlm2: IndicShaper,\n  // Malayalam\n  mlym: IndicShaper,\n  // Malayalam\n  ory2: IndicShaper,\n  // Oriya\n  orya: IndicShaper,\n  // Oriya\n  taml: IndicShaper,\n  // Tamil\n  tml2: IndicShaper,\n  // Tamil\n  telu: IndicShaper,\n  // Telugu\n  tel2: IndicShaper,\n  // Telugu\n  khmr: IndicShaper,\n  // Khmer\n  bali: UniversalShaper,\n  // Balinese\n  batk: UniversalShaper,\n  // Batak\n  brah: UniversalShaper,\n  // Brahmi\n  bugi: UniversalShaper,\n  // Buginese\n  buhd: UniversalShaper,\n  // Buhid\n  cakm: UniversalShaper,\n  // Chakma\n  cham: UniversalShaper,\n  // Cham\n  dupl: UniversalShaper,\n  // Duployan\n  egyp: UniversalShaper,\n  // Egyptian Hieroglyphs\n  gran: UniversalShaper,\n  // Grantha\n  hano: UniversalShaper,\n  // Hanunoo\n  java: UniversalShaper,\n  // Javanese\n  kthi: UniversalShaper,\n  // Kaithi\n  kali: UniversalShaper,\n  // Kayah Li\n  khar: UniversalShaper,\n  // Kharoshthi\n  khoj: UniversalShaper,\n  // Khojki\n  sind: UniversalShaper,\n  // Khudawadi\n  lepc: UniversalShaper,\n  // Lepcha\n  limb: UniversalShaper,\n  // Limbu\n  mahj: UniversalShaper,\n  // Mahajani\n  // mand: UniversalShaper, // Mandaic\n  // mani: UniversalShaper, // Manichaean\n  mtei: UniversalShaper,\n  // Meitei Mayek\n  modi: UniversalShaper,\n  // Modi\n  // mong: UniversalShaper, // Mongolian\n  // 'nko ': UniversalShaper, // N’Ko\n  hmng: UniversalShaper,\n  // Pahawh Hmong\n  // phag: UniversalShaper, // Phags-pa\n  // phlp: UniversalShaper, // Psalter Pahlavi\n  rjng: UniversalShaper,\n  // Rejang\n  saur: UniversalShaper,\n  // Saurashtra\n  shrd: UniversalShaper,\n  // Sharada\n  sidd: UniversalShaper,\n  // Siddham\n  sinh: UniversalShaper,\n  // Sinhala\n  sund: UniversalShaper,\n  // Sundanese\n  sylo: UniversalShaper,\n  // Syloti Nagri\n  tglg: UniversalShaper,\n  // Tagalog\n  tagb: UniversalShaper,\n  // Tagbanwa\n  tale: UniversalShaper,\n  // Tai Le\n  lana: UniversalShaper,\n  // Tai Tham\n  tavt: UniversalShaper,\n  // Tai Viet\n  takr: UniversalShaper,\n  // Takri\n  tibt: UniversalShaper,\n  // Tibetan\n  tfng: UniversalShaper,\n  // Tifinagh\n  tirh: UniversalShaper,\n  // Tirhuta\n  latn: DefaultShaper,\n  // Latin\n  DFLT: DefaultShaper // Default\n\n};\n\nfunction choose(script) {\n  if (!Array.isArray(script)) {\n    script = [script];\n  }\n\n  for (var _iterator = script, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _getIterator(_iterator);;) {\n    var _ref;\n\n    if (_isArray) {\n      if (_i >= _iterator.length) break;\n      _ref = _iterator[_i++];\n    } else {\n      _i = _iterator.next();\n      if (_i.done) break;\n      _ref = _i.value;\n    }\n\n    var s = _ref;\n    var shaper = SHAPERS[s];\n\n    if (shaper) {\n      return shaper;\n    }\n  }\n\n  return DefaultShaper;\n}\n\nvar GSUBProcessor = function (_OTProcessor) {\n  _inherits(GSUBProcessor, _OTProcessor);\n\n  function GSUBProcessor() {\n    _classCallCheck(this, GSUBProcessor);\n\n    return _possibleConstructorReturn(this, _OTProcessor.apply(this, arguments));\n  }\n\n  GSUBProcessor.prototype.applyLookup = function applyLookup(lookupType, table) {\n    var _this2 = this;\n\n    switch (lookupType) {\n      case 1:\n        {\n          // Single Substitution\n          var index = this.coverageIndex(table.coverage);\n\n          if (index === -1) {\n            return false;\n          }\n\n          var glyph = this.glyphIterator.cur;\n\n          switch (table.version) {\n            case 1:\n              glyph.id = glyph.id + table.deltaGlyphID & 0xffff;\n              break;\n\n            case 2:\n              glyph.id = table.substitute.get(index);\n              break;\n          }\n\n          return true;\n        }\n\n      case 2:\n        {\n          // Multiple Substitution\n          var _index = this.coverageIndex(table.coverage);\n\n          if (_index !== -1) {\n            var _glyphs;\n\n            var sequence = table.sequences.get(_index);\n\n            if (sequence.length === 0) {\n              // If the sequence length is zero, delete the glyph.\n              // The OpenType spec disallows this, but seems like Harfbuzz and Uniscribe allow it.\n              this.glyphs.splice(this.glyphIterator.index, 1);\n              return true;\n            }\n\n            this.glyphIterator.cur.id = sequence[0];\n            this.glyphIterator.cur.ligatureComponent = 0;\n            var features = this.glyphIterator.cur.features;\n            var curGlyph = this.glyphIterator.cur;\n            var replacement = sequence.slice(1).map(function (gid, i) {\n              var glyph = new GlyphInfo(_this2.font, gid, undefined, features);\n              glyph.shaperInfo = curGlyph.shaperInfo;\n              glyph.isLigated = curGlyph.isLigated;\n              glyph.ligatureComponent = i + 1;\n              glyph.substituted = true;\n              glyph.isMultiplied = true;\n              return glyph;\n            });\n\n            (_glyphs = this.glyphs).splice.apply(_glyphs, [this.glyphIterator.index + 1, 0].concat(replacement));\n\n            return true;\n          }\n\n          return false;\n        }\n\n      case 3:\n        {\n          // Alternate Substitution\n          var _index2 = this.coverageIndex(table.coverage);\n\n          if (_index2 !== -1) {\n            var USER_INDEX = 0; // TODO\n\n            this.glyphIterator.cur.id = table.alternateSet.get(_index2)[USER_INDEX];\n            return true;\n          }\n\n          return false;\n        }\n\n      case 4:\n        {\n          // Ligature Substitution\n          var _index3 = this.coverageIndex(table.coverage);\n\n          if (_index3 === -1) {\n            return false;\n          }\n\n          for (var _iterator = table.ligatureSets.get(_index3), _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _getIterator(_iterator);;) {\n            var _ref;\n\n            if (_isArray) {\n              if (_i >= _iterator.length) break;\n              _ref = _iterator[_i++];\n            } else {\n              _i = _iterator.next();\n              if (_i.done) break;\n              _ref = _i.value;\n            }\n\n            var ligature = _ref;\n            var matched = this.sequenceMatchIndices(1, ligature.components);\n\n            if (!matched) {\n              continue;\n            }\n\n            var _curGlyph = this.glyphIterator.cur; // Concatenate all of the characters the new ligature will represent\n\n            var characters = _curGlyph.codePoints.slice();\n\n            for (var _iterator2 = matched, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _getIterator(_iterator2);;) {\n              var _ref2;\n\n              if (_isArray2) {\n                if (_i2 >= _iterator2.length) break;\n                _ref2 = _iterator2[_i2++];\n              } else {\n                _i2 = _iterator2.next();\n                if (_i2.done) break;\n                _ref2 = _i2.value;\n              }\n\n              var _index4 = _ref2;\n              characters.push.apply(characters, this.glyphs[_index4].codePoints);\n            } // Create the replacement ligature glyph\n\n\n            var ligatureGlyph = new GlyphInfo(this.font, ligature.glyph, characters, _curGlyph.features);\n            ligatureGlyph.shaperInfo = _curGlyph.shaperInfo;\n            ligatureGlyph.isLigated = true;\n            ligatureGlyph.substituted = true; // From Harfbuzz:\n            // - If it *is* a mark ligature, we don't allocate a new ligature id, and leave\n            //   the ligature to keep its old ligature id.  This will allow it to attach to\n            //   a base ligature in GPOS.  Eg. if the sequence is: LAM,LAM,SHADDA,FATHA,HEH,\n            //   and LAM,LAM,HEH for a ligature, they will leave SHADDA and FATHA with a\n            //   ligature id and component value of 2.  Then if SHADDA,FATHA form a ligature\n            //   later, we don't want them to lose their ligature id/component, otherwise\n            //   GPOS will fail to correctly position the mark ligature on top of the\n            //   LAM,LAM,HEH ligature. See https://bugzilla.gnome.org/show_bug.cgi?id=676343\n            //\n            // - If a ligature is formed of components that some of which are also ligatures\n            //   themselves, and those ligature components had marks attached to *their*\n            //   components, we have to attach the marks to the new ligature component\n            //   positions!  Now *that*'s tricky!  And these marks may be following the\n            //   last component of the whole sequence, so we should loop forward looking\n            //   for them and update them.\n            //\n            //   Eg. the sequence is LAM,LAM,SHADDA,FATHA,HEH, and the font first forms a\n            //   'calt' ligature of LAM,HEH, leaving the SHADDA and FATHA with a ligature\n            //   id and component == 1.  Now, during 'liga', the LAM and the LAM-HEH ligature\n            //   form a LAM-LAM-HEH ligature.  We need to reassign the SHADDA and FATHA to\n            //   the new ligature with a component value of 2.\n            //\n            //   This in fact happened to a font...  See https://bugzilla.gnome.org/show_bug.cgi?id=437633\n\n            var isMarkLigature = _curGlyph.isMark;\n\n            for (var i = 0; i < matched.length && isMarkLigature; i++) {\n              isMarkLigature = this.glyphs[matched[i]].isMark;\n            }\n\n            ligatureGlyph.ligatureID = isMarkLigature ? null : this.ligatureID++;\n            var lastLigID = _curGlyph.ligatureID;\n            var lastNumComps = _curGlyph.codePoints.length;\n            var curComps = lastNumComps;\n            var idx = this.glyphIterator.index + 1; // Set ligatureID and ligatureComponent on glyphs that were skipped in the matched sequence.\n            // This allows GPOS to attach marks to the correct ligature components.\n\n            for (var _iterator3 = matched, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _getIterator(_iterator3);;) {\n              var _ref3;\n\n              if (_isArray3) {\n                if (_i3 >= _iterator3.length) break;\n                _ref3 = _iterator3[_i3++];\n              } else {\n                _i3 = _iterator3.next();\n                if (_i3.done) break;\n                _ref3 = _i3.value;\n              }\n\n              var matchIndex = _ref3; // Don't assign new ligature components for mark ligatures (see above)\n\n              if (isMarkLigature) {\n                idx = matchIndex;\n              } else {\n                while (idx < matchIndex) {\n                  var ligatureComponent = curComps - lastNumComps + Math.min(this.glyphs[idx].ligatureComponent || 1, lastNumComps);\n                  this.glyphs[idx].ligatureID = ligatureGlyph.ligatureID;\n                  this.glyphs[idx].ligatureComponent = ligatureComponent;\n                  idx++;\n                }\n              }\n\n              lastLigID = this.glyphs[idx].ligatureID;\n              lastNumComps = this.glyphs[idx].codePoints.length;\n              curComps += lastNumComps;\n              idx++; // skip base glyph\n            } // Adjust ligature components for any marks following\n\n\n            if (lastLigID && !isMarkLigature) {\n              for (var _i4 = idx; _i4 < this.glyphs.length; _i4++) {\n                if (this.glyphs[_i4].ligatureID === lastLigID) {\n                  var ligatureComponent = curComps - lastNumComps + Math.min(this.glyphs[_i4].ligatureComponent || 1, lastNumComps);\n                  this.glyphs[_i4].ligatureComponent = ligatureComponent;\n                } else {\n                  break;\n                }\n              }\n            } // Delete the matched glyphs, and replace the current glyph with the ligature glyph\n\n\n            for (var _i5 = matched.length - 1; _i5 >= 0; _i5--) {\n              this.glyphs.splice(matched[_i5], 1);\n            }\n\n            this.glyphs[this.glyphIterator.index] = ligatureGlyph;\n            return true;\n          }\n\n          return false;\n        }\n\n      case 5:\n        // Contextual Substitution\n        return this.applyContext(table);\n\n      case 6:\n        // Chaining Contextual Substitution\n        return this.applyChainingContext(table);\n\n      case 7:\n        // Extension Substitution\n        return this.applyLookup(table.lookupType, table.extension);\n\n      default:\n        throw new Error('GSUB lookupType ' + lookupType + ' is not supported');\n    }\n  };\n\n  return GSUBProcessor;\n}(OTProcessor);\n\nvar GPOSProcessor = function (_OTProcessor) {\n  _inherits(GPOSProcessor, _OTProcessor);\n\n  function GPOSProcessor() {\n    _classCallCheck(this, GPOSProcessor);\n\n    return _possibleConstructorReturn(this, _OTProcessor.apply(this, arguments));\n  }\n\n  GPOSProcessor.prototype.applyPositionValue = function applyPositionValue(sequenceIndex, value) {\n    var position = this.positions[this.glyphIterator.peekIndex(sequenceIndex)];\n\n    if (value.xAdvance != null) {\n      position.xAdvance += value.xAdvance;\n    }\n\n    if (value.yAdvance != null) {\n      position.yAdvance += value.yAdvance;\n    }\n\n    if (value.xPlacement != null) {\n      position.xOffset += value.xPlacement;\n    }\n\n    if (value.yPlacement != null) {\n      position.yOffset += value.yPlacement;\n    } // Adjustments for font variations\n\n\n    var variationProcessor = this.font._variationProcessor;\n    var variationStore = this.font.GDEF && this.font.GDEF.itemVariationStore;\n\n    if (variationProcessor && variationStore) {\n      if (value.xPlaDevice) {\n        position.xOffset += variationProcessor.getDelta(variationStore, value.xPlaDevice.a, value.xPlaDevice.b);\n      }\n\n      if (value.yPlaDevice) {\n        position.yOffset += variationProcessor.getDelta(variationStore, value.yPlaDevice.a, value.yPlaDevice.b);\n      }\n\n      if (value.xAdvDevice) {\n        position.xAdvance += variationProcessor.getDelta(variationStore, value.xAdvDevice.a, value.xAdvDevice.b);\n      }\n\n      if (value.yAdvDevice) {\n        position.yAdvance += variationProcessor.getDelta(variationStore, value.yAdvDevice.a, value.yAdvDevice.b);\n      }\n    } // TODO: device tables\n\n  };\n\n  GPOSProcessor.prototype.applyLookup = function applyLookup(lookupType, table) {\n    switch (lookupType) {\n      case 1:\n        {\n          // Single positioning value\n          var index = this.coverageIndex(table.coverage);\n\n          if (index === -1) {\n            return false;\n          }\n\n          switch (table.version) {\n            case 1:\n              this.applyPositionValue(0, table.value);\n              break;\n\n            case 2:\n              this.applyPositionValue(0, table.values.get(index));\n              break;\n          }\n\n          return true;\n        }\n\n      case 2:\n        {\n          // Pair Adjustment Positioning\n          var nextGlyph = this.glyphIterator.peek();\n\n          if (!nextGlyph) {\n            return false;\n          }\n\n          var _index = this.coverageIndex(table.coverage);\n\n          if (_index === -1) {\n            return false;\n          }\n\n          switch (table.version) {\n            case 1:\n              // Adjustments for glyph pairs\n              var set = table.pairSets.get(_index);\n\n              for (var _iterator = set, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _getIterator(_iterator);;) {\n                var _ref;\n\n                if (_isArray) {\n                  if (_i >= _iterator.length) break;\n                  _ref = _iterator[_i++];\n                } else {\n                  _i = _iterator.next();\n                  if (_i.done) break;\n                  _ref = _i.value;\n                }\n\n                var _pair = _ref;\n\n                if (_pair.secondGlyph === nextGlyph.id) {\n                  this.applyPositionValue(0, _pair.value1);\n                  this.applyPositionValue(1, _pair.value2);\n                  return true;\n                }\n              }\n\n              return false;\n\n            case 2:\n              // Class pair adjustment\n              var class1 = this.getClassID(this.glyphIterator.cur.id, table.classDef1);\n              var class2 = this.getClassID(nextGlyph.id, table.classDef2);\n\n              if (class1 === -1 || class2 === -1) {\n                return false;\n              }\n\n              var pair = table.classRecords.get(class1).get(class2);\n              this.applyPositionValue(0, pair.value1);\n              this.applyPositionValue(1, pair.value2);\n              return true;\n          }\n        }\n\n      case 3:\n        {\n          // Cursive Attachment Positioning\n          var nextIndex = this.glyphIterator.peekIndex();\n          var _nextGlyph = this.glyphs[nextIndex];\n\n          if (!_nextGlyph) {\n            return false;\n          }\n\n          var curRecord = table.entryExitRecords[this.coverageIndex(table.coverage)];\n\n          if (!curRecord || !curRecord.exitAnchor) {\n            return false;\n          }\n\n          var nextRecord = table.entryExitRecords[this.coverageIndex(table.coverage, _nextGlyph.id)];\n\n          if (!nextRecord || !nextRecord.entryAnchor) {\n            return false;\n          }\n\n          var entry = this.getAnchor(nextRecord.entryAnchor);\n          var exit = this.getAnchor(curRecord.exitAnchor);\n          var cur = this.positions[this.glyphIterator.index];\n          var next = this.positions[nextIndex];\n\n          switch (this.direction) {\n            case 'ltr':\n              cur.xAdvance = exit.x + cur.xOffset;\n              var d = entry.x + next.xOffset;\n              next.xAdvance -= d;\n              next.xOffset -= d;\n              break;\n\n            case 'rtl':\n              d = exit.x + cur.xOffset;\n              cur.xAdvance -= d;\n              cur.xOffset -= d;\n              next.xAdvance = entry.x + next.xOffset;\n              break;\n          }\n\n          if (this.glyphIterator.flags.rightToLeft) {\n            this.glyphIterator.cur.cursiveAttachment = nextIndex;\n            cur.yOffset = entry.y - exit.y;\n          } else {\n            _nextGlyph.cursiveAttachment = this.glyphIterator.index;\n            cur.yOffset = exit.y - entry.y;\n          }\n\n          return true;\n        }\n\n      case 4:\n        {\n          // Mark to base positioning\n          var markIndex = this.coverageIndex(table.markCoverage);\n\n          if (markIndex === -1) {\n            return false;\n          } // search backward for a base glyph\n\n\n          var baseGlyphIndex = this.glyphIterator.index;\n\n          while (--baseGlyphIndex >= 0 && (this.glyphs[baseGlyphIndex].isMark || this.glyphs[baseGlyphIndex].ligatureComponent > 0)) {}\n\n          if (baseGlyphIndex < 0) {\n            return false;\n          }\n\n          var baseIndex = this.coverageIndex(table.baseCoverage, this.glyphs[baseGlyphIndex].id);\n\n          if (baseIndex === -1) {\n            return false;\n          }\n\n          var markRecord = table.markArray[markIndex];\n          var baseAnchor = table.baseArray[baseIndex][markRecord.class];\n          this.applyAnchor(markRecord, baseAnchor, baseGlyphIndex);\n          return true;\n        }\n\n      case 5:\n        {\n          // Mark to ligature positioning\n          var _markIndex = this.coverageIndex(table.markCoverage);\n\n          if (_markIndex === -1) {\n            return false;\n          } // search backward for a base glyph\n\n\n          var _baseGlyphIndex = this.glyphIterator.index;\n\n          while (--_baseGlyphIndex >= 0 && this.glyphs[_baseGlyphIndex].isMark) {}\n\n          if (_baseGlyphIndex < 0) {\n            return false;\n          }\n\n          var ligIndex = this.coverageIndex(table.ligatureCoverage, this.glyphs[_baseGlyphIndex].id);\n\n          if (ligIndex === -1) {\n            return false;\n          }\n\n          var ligAttach = table.ligatureArray[ligIndex];\n          var markGlyph = this.glyphIterator.cur;\n          var ligGlyph = this.glyphs[_baseGlyphIndex];\n          var compIndex = ligGlyph.ligatureID && ligGlyph.ligatureID === markGlyph.ligatureID && markGlyph.ligatureComponent > 0 ? Math.min(markGlyph.ligatureComponent, ligGlyph.codePoints.length) - 1 : ligGlyph.codePoints.length - 1;\n          var _markRecord = table.markArray[_markIndex];\n          var _baseAnchor = ligAttach[compIndex][_markRecord.class];\n          this.applyAnchor(_markRecord, _baseAnchor, _baseGlyphIndex);\n          return true;\n        }\n\n      case 6:\n        {\n          // Mark to mark positioning\n          var mark1Index = this.coverageIndex(table.mark1Coverage);\n\n          if (mark1Index === -1) {\n            return false;\n          } // get the previous mark to attach to\n\n\n          var prevIndex = this.glyphIterator.peekIndex(-1);\n          var prev = this.glyphs[prevIndex];\n\n          if (!prev || !prev.isMark) {\n            return false;\n          }\n\n          var _cur = this.glyphIterator.cur; // The following logic was borrowed from Harfbuzz\n\n          var good = false;\n\n          if (_cur.ligatureID === prev.ligatureID) {\n            if (!_cur.ligatureID) {\n              // Marks belonging to the same base\n              good = true;\n            } else if (_cur.ligatureComponent === prev.ligatureComponent) {\n              // Marks belonging to the same ligature component\n              good = true;\n            }\n          } else {\n            // If ligature ids don't match, it may be the case that one of the marks\n            // itself is a ligature, in which case match.\n            if (_cur.ligatureID && !_cur.ligatureComponent || prev.ligatureID && !prev.ligatureComponent) {\n              good = true;\n            }\n          }\n\n          if (!good) {\n            return false;\n          }\n\n          var mark2Index = this.coverageIndex(table.mark2Coverage, prev.id);\n\n          if (mark2Index === -1) {\n            return false;\n          }\n\n          var _markRecord2 = table.mark1Array[mark1Index];\n          var _baseAnchor2 = table.mark2Array[mark2Index][_markRecord2.class];\n          this.applyAnchor(_markRecord2, _baseAnchor2, prevIndex);\n          return true;\n        }\n\n      case 7:\n        // Contextual positioning\n        return this.applyContext(table);\n\n      case 8:\n        // Chaining contextual positioning\n        return this.applyChainingContext(table);\n\n      case 9:\n        // Extension positioning\n        return this.applyLookup(table.lookupType, table.extension);\n\n      default:\n        throw new Error('Unsupported GPOS table: ' + lookupType);\n    }\n  };\n\n  GPOSProcessor.prototype.applyAnchor = function applyAnchor(markRecord, baseAnchor, baseGlyphIndex) {\n    var baseCoords = this.getAnchor(baseAnchor);\n    var markCoords = this.getAnchor(markRecord.markAnchor);\n    var basePos = this.positions[baseGlyphIndex];\n    var markPos = this.positions[this.glyphIterator.index];\n    markPos.xOffset = baseCoords.x - markCoords.x;\n    markPos.yOffset = baseCoords.y - markCoords.y;\n    this.glyphIterator.cur.markAttachment = baseGlyphIndex;\n  };\n\n  GPOSProcessor.prototype.getAnchor = function getAnchor(anchor) {\n    // TODO: contour point, device tables\n    var x = anchor.xCoordinate;\n    var y = anchor.yCoordinate; // Adjustments for font variations\n\n    var variationProcessor = this.font._variationProcessor;\n    var variationStore = this.font.GDEF && this.font.GDEF.itemVariationStore;\n\n    if (variationProcessor && variationStore) {\n      if (anchor.xDeviceTable) {\n        x += variationProcessor.getDelta(variationStore, anchor.xDeviceTable.a, anchor.xDeviceTable.b);\n      }\n\n      if (anchor.yDeviceTable) {\n        y += variationProcessor.getDelta(variationStore, anchor.yDeviceTable.a, anchor.yDeviceTable.b);\n      }\n    }\n\n    return {\n      x: x,\n      y: y\n    };\n  };\n\n  GPOSProcessor.prototype.applyFeatures = function applyFeatures(userFeatures, glyphs, advances) {\n    _OTProcessor.prototype.applyFeatures.call(this, userFeatures, glyphs, advances);\n\n    for (var i = 0; i < this.glyphs.length; i++) {\n      this.fixCursiveAttachment(i);\n    }\n\n    this.fixMarkAttachment();\n  };\n\n  GPOSProcessor.prototype.fixCursiveAttachment = function fixCursiveAttachment(i) {\n    var glyph = this.glyphs[i];\n\n    if (glyph.cursiveAttachment != null) {\n      var j = glyph.cursiveAttachment;\n      glyph.cursiveAttachment = null;\n      this.fixCursiveAttachment(j);\n      this.positions[i].yOffset += this.positions[j].yOffset;\n    }\n  };\n\n  GPOSProcessor.prototype.fixMarkAttachment = function fixMarkAttachment() {\n    for (var i = 0; i < this.glyphs.length; i++) {\n      var glyph = this.glyphs[i];\n\n      if (glyph.markAttachment != null) {\n        var j = glyph.markAttachment;\n        this.positions[i].xOffset += this.positions[j].xOffset;\n        this.positions[i].yOffset += this.positions[j].yOffset;\n\n        if (this.direction === 'ltr') {\n          for (var k = j; k < i; k++) {\n            this.positions[i].xOffset -= this.positions[k].xAdvance;\n            this.positions[i].yOffset -= this.positions[k].yAdvance;\n          }\n        } else {\n          for (var _k = j + 1; _k < i + 1; _k++) {\n            this.positions[i].xOffset += this.positions[_k].xAdvance;\n            this.positions[i].yOffset += this.positions[_k].yAdvance;\n          }\n        }\n      }\n    }\n  };\n\n  return GPOSProcessor;\n}(OTProcessor);\n\nvar OTLayoutEngine = function () {\n  function OTLayoutEngine(font) {\n    _classCallCheck(this, OTLayoutEngine);\n\n    this.font = font;\n    this.glyphInfos = null;\n    this.plan = null;\n    this.GSUBProcessor = null;\n    this.GPOSProcessor = null;\n    this.fallbackPosition = true;\n\n    if (font.GSUB) {\n      this.GSUBProcessor = new GSUBProcessor(font, font.GSUB);\n    }\n\n    if (font.GPOS) {\n      this.GPOSProcessor = new GPOSProcessor(font, font.GPOS);\n    }\n  }\n\n  OTLayoutEngine.prototype.setup = function setup(glyphRun) {\n    var _this = this; // Map glyphs to GlyphInfo objects so data can be passed between\n    // GSUB and GPOS without mutating the real (shared) Glyph objects.\n\n\n    this.glyphInfos = glyphRun.glyphs.map(function (glyph) {\n      return new GlyphInfo(_this.font, glyph.id, [].concat(glyph.codePoints));\n    }); // Select a script based on what is available in GSUB/GPOS.\n\n    var script = null;\n\n    if (this.GPOSProcessor) {\n      script = this.GPOSProcessor.selectScript(glyphRun.script, glyphRun.language, glyphRun.direction);\n    }\n\n    if (this.GSUBProcessor) {\n      script = this.GSUBProcessor.selectScript(glyphRun.script, glyphRun.language, glyphRun.direction);\n    } // Choose a shaper based on the script, and setup a shaping plan.\n    // This determines which features to apply to which glyphs.\n\n\n    this.shaper = choose(script);\n    this.plan = new ShapingPlan(this.font, script, glyphRun.direction);\n    this.shaper.plan(this.plan, this.glyphInfos, glyphRun.features); // Assign chosen features to output glyph run\n\n    for (var key in this.plan.allFeatures) {\n      glyphRun.features[key] = true;\n    }\n  };\n\n  OTLayoutEngine.prototype.substitute = function substitute(glyphRun) {\n    var _this2 = this;\n\n    if (this.GSUBProcessor) {\n      this.plan.process(this.GSUBProcessor, this.glyphInfos); // Map glyph infos back to normal Glyph objects\n\n      glyphRun.glyphs = this.glyphInfos.map(function (glyphInfo) {\n        return _this2.font.getGlyph(glyphInfo.id, glyphInfo.codePoints);\n      });\n    }\n  };\n\n  OTLayoutEngine.prototype.position = function position(glyphRun) {\n    if (this.shaper.zeroMarkWidths === 'BEFORE_GPOS') {\n      this.zeroMarkAdvances(glyphRun.positions);\n    }\n\n    if (this.GPOSProcessor) {\n      this.plan.process(this.GPOSProcessor, this.glyphInfos, glyphRun.positions);\n    }\n\n    if (this.shaper.zeroMarkWidths === 'AFTER_GPOS') {\n      this.zeroMarkAdvances(glyphRun.positions);\n    } // Reverse the glyphs and positions if the script is right-to-left\n\n\n    if (glyphRun.direction === 'rtl') {\n      glyphRun.glyphs.reverse();\n      glyphRun.positions.reverse();\n    }\n\n    return this.GPOSProcessor && this.GPOSProcessor.features;\n  };\n\n  OTLayoutEngine.prototype.zeroMarkAdvances = function zeroMarkAdvances(positions) {\n    for (var i = 0; i < this.glyphInfos.length; i++) {\n      if (this.glyphInfos[i].isMark) {\n        positions[i].xAdvance = 0;\n        positions[i].yAdvance = 0;\n      }\n    }\n  };\n\n  OTLayoutEngine.prototype.cleanup = function cleanup() {\n    this.glyphInfos = null;\n    this.plan = null;\n    this.shaper = null;\n  };\n\n  OTLayoutEngine.prototype.getAvailableFeatures = function getAvailableFeatures(script, language) {\n    var features = [];\n\n    if (this.GSUBProcessor) {\n      this.GSUBProcessor.selectScript(script, language);\n      features.push.apply(features, _Object$keys(this.GSUBProcessor.features));\n    }\n\n    if (this.GPOSProcessor) {\n      this.GPOSProcessor.selectScript(script, language);\n      features.push.apply(features, _Object$keys(this.GPOSProcessor.features));\n    }\n\n    return features;\n  };\n\n  return OTLayoutEngine;\n}();\n\nvar LayoutEngine = function () {\n  function LayoutEngine(font) {\n    _classCallCheck(this, LayoutEngine);\n\n    this.font = font;\n    this.unicodeLayoutEngine = null;\n    this.kernProcessor = null; // Choose an advanced layout engine. We try the AAT morx table first since more\n    // scripts are currently supported because the shaping logic is built into the font.\n\n    if (this.font.morx) {\n      this.engine = new AATLayoutEngine(this.font);\n    } else if (this.font.GSUB || this.font.GPOS) {\n      this.engine = new OTLayoutEngine(this.font);\n    }\n  }\n\n  LayoutEngine.prototype.layout = function layout(string, features, script, language, direction) {\n    // Make the features parameter optional\n    if (typeof features === 'string') {\n      direction = language;\n      language = script;\n      script = features;\n      features = [];\n    } // Map string to glyphs if needed\n\n\n    if (typeof string === 'string') {\n      // Attempt to detect the script from the string if not provided.\n      if (script == null) {\n        script = forString(string);\n      }\n\n      var glyphs = this.font.glyphsForString(string);\n    } else {\n      // Attempt to detect the script from the glyph code points if not provided.\n      if (script == null) {\n        var codePoints = [];\n\n        for (var _iterator = string, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _getIterator(_iterator);;) {\n          var _ref;\n\n          if (_isArray) {\n            if (_i >= _iterator.length) break;\n            _ref = _iterator[_i++];\n          } else {\n            _i = _iterator.next();\n            if (_i.done) break;\n            _ref = _i.value;\n          }\n\n          var glyph = _ref;\n          codePoints.push.apply(codePoints, glyph.codePoints);\n        }\n\n        script = forCodePoints(codePoints);\n      }\n\n      var glyphs = string;\n    }\n\n    var glyphRun = new GlyphRun(glyphs, features, script, language, direction); // Return early if there are no glyphs\n\n    if (glyphs.length === 0) {\n      glyphRun.positions = [];\n      return glyphRun;\n    } // Setup the advanced layout engine\n\n\n    if (this.engine && this.engine.setup) {\n      this.engine.setup(glyphRun);\n    } // Substitute and position the glyphs\n\n\n    this.substitute(glyphRun);\n    this.position(glyphRun);\n    this.hideDefaultIgnorables(glyphRun.glyphs, glyphRun.positions); // Let the layout engine clean up any state it might have\n\n    if (this.engine && this.engine.cleanup) {\n      this.engine.cleanup();\n    }\n\n    return glyphRun;\n  };\n\n  LayoutEngine.prototype.substitute = function substitute(glyphRun) {\n    // Call the advanced layout engine to make substitutions\n    if (this.engine && this.engine.substitute) {\n      this.engine.substitute(glyphRun);\n    }\n  };\n\n  LayoutEngine.prototype.position = function position(glyphRun) {\n    // Get initial glyph positions\n    glyphRun.positions = glyphRun.glyphs.map(function (glyph) {\n      return new GlyphPosition(glyph.advanceWidth);\n    });\n    var positioned = null; // Call the advanced layout engine. Returns the features applied.\n\n    if (this.engine && this.engine.position) {\n      positioned = this.engine.position(glyphRun);\n    } // if there is no GPOS table, use unicode properties to position marks.\n\n\n    if (!positioned && (!this.engine || this.engine.fallbackPosition)) {\n      if (!this.unicodeLayoutEngine) {\n        this.unicodeLayoutEngine = new UnicodeLayoutEngine(this.font);\n      }\n\n      this.unicodeLayoutEngine.positionGlyphs(glyphRun.glyphs, glyphRun.positions);\n    } // if kerning is not supported by GPOS, do kerning with the TrueType/AAT kern table\n\n\n    if ((!positioned || !positioned.kern) && glyphRun.features.kern !== false && this.font.kern) {\n      if (!this.kernProcessor) {\n        this.kernProcessor = new KernProcessor(this.font);\n      }\n\n      this.kernProcessor.process(glyphRun.glyphs, glyphRun.positions);\n      glyphRun.features.kern = true;\n    }\n  };\n\n  LayoutEngine.prototype.hideDefaultIgnorables = function hideDefaultIgnorables(glyphs, positions) {\n    var space = this.font.glyphForCodePoint(0x20);\n\n    for (var i = 0; i < glyphs.length; i++) {\n      if (this.isDefaultIgnorable(glyphs[i].codePoints[0])) {\n        glyphs[i] = space;\n        positions[i].xAdvance = 0;\n        positions[i].yAdvance = 0;\n      }\n    }\n  };\n\n  LayoutEngine.prototype.isDefaultIgnorable = function isDefaultIgnorable(ch) {\n    // From DerivedCoreProperties.txt in the Unicode database,\n    // minus U+115F, U+1160, U+3164 and U+FFA0, which is what\n    // Harfbuzz and Uniscribe do.\n    var plane = ch >> 16;\n\n    if (plane === 0) {\n      // BMP\n      switch (ch >> 8) {\n        case 0x00:\n          return ch === 0x00AD;\n\n        case 0x03:\n          return ch === 0x034F;\n\n        case 0x06:\n          return ch === 0x061C;\n\n        case 0x17:\n          return 0x17B4 <= ch && ch <= 0x17B5;\n\n        case 0x18:\n          return 0x180B <= ch && ch <= 0x180E;\n\n        case 0x20:\n          return 0x200B <= ch && ch <= 0x200F || 0x202A <= ch && ch <= 0x202E || 0x2060 <= ch && ch <= 0x206F;\n\n        case 0xFE:\n          return 0xFE00 <= ch && ch <= 0xFE0F || ch === 0xFEFF;\n\n        case 0xFF:\n          return 0xFFF0 <= ch && ch <= 0xFFF8;\n\n        default:\n          return false;\n      }\n    } else {\n      // Other planes\n      switch (plane) {\n        case 0x01:\n          return 0x1BCA0 <= ch && ch <= 0x1BCA3 || 0x1D173 <= ch && ch <= 0x1D17A;\n\n        case 0x0E:\n          return 0xE0000 <= ch && ch <= 0xE0FFF;\n\n        default:\n          return false;\n      }\n    }\n  };\n\n  LayoutEngine.prototype.getAvailableFeatures = function getAvailableFeatures(script, language) {\n    var features = [];\n\n    if (this.engine) {\n      features.push.apply(features, this.engine.getAvailableFeatures(script, language));\n    }\n\n    if (this.font.kern && features.indexOf('kern') === -1) {\n      features.push('kern');\n    }\n\n    return features;\n  };\n\n  LayoutEngine.prototype.stringsForGlyph = function stringsForGlyph(gid) {\n    var result = new _Set();\n\n    var codePoints = this.font._cmapProcessor.codePointsForGlyph(gid);\n\n    for (var _iterator2 = codePoints, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _getIterator(_iterator2);;) {\n      var _ref2;\n\n      if (_isArray2) {\n        if (_i2 >= _iterator2.length) break;\n        _ref2 = _iterator2[_i2++];\n      } else {\n        _i2 = _iterator2.next();\n        if (_i2.done) break;\n        _ref2 = _i2.value;\n      }\n\n      var codePoint = _ref2;\n      result.add(_String$fromCodePoint(codePoint));\n    }\n\n    if (this.engine && this.engine.stringsForGlyph) {\n      for (var _iterator3 = this.engine.stringsForGlyph(gid), _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _getIterator(_iterator3);;) {\n        var _ref3;\n\n        if (_isArray3) {\n          if (_i3 >= _iterator3.length) break;\n          _ref3 = _iterator3[_i3++];\n        } else {\n          _i3 = _iterator3.next();\n          if (_i3.done) break;\n          _ref3 = _i3.value;\n        }\n\n        var string = _ref3;\n        result.add(string);\n      }\n    }\n\n    return _Array$from(result);\n  };\n\n  return LayoutEngine;\n}();\n\nvar SVG_COMMANDS = {\n  moveTo: 'M',\n  lineTo: 'L',\n  quadraticCurveTo: 'Q',\n  bezierCurveTo: 'C',\n  closePath: 'Z'\n};\n/**\n * Path objects are returned by glyphs and represent the actual\n * vector outlines for each glyph in the font. Paths can be converted\n * to SVG path data strings, or to functions that can be applied to\n * render the path to a graphics context.\n */\n\nvar Path = function () {\n  function Path() {\n    _classCallCheck(this, Path);\n\n    this.commands = [];\n    this._bbox = null;\n    this._cbox = null;\n  }\n  /**\n   * Compiles the path to a JavaScript function that can be applied with\n   * a graphics context in order to render the path.\n   * @return {string}\n   */\n\n\n  Path.prototype.toFunction = function toFunction() {\n    var _this = this;\n\n    return function (ctx) {\n      _this.commands.forEach(function (c) {\n        return ctx[c.command].apply(ctx, c.args);\n      });\n    };\n  };\n  /**\n   * Converts the path to an SVG path data string\n   * @return {string}\n   */\n\n\n  Path.prototype.toSVG = function toSVG() {\n    var cmds = this.commands.map(function (c) {\n      var args = c.args.map(function (arg) {\n        return Math.round(arg * 100) / 100;\n      });\n      return '' + SVG_COMMANDS[c.command] + args.join(' ');\n    });\n    return cmds.join('');\n  };\n  /**\n   * Gets the \"control box\" of a path.\n   * This is like the bounding box, but it includes all points including\n   * control points of bezier segments and is much faster to compute than\n   * the real bounding box.\n   * @type {BBox}\n   */\n\n  /**\n   * Applies a mapping function to each point in the path.\n   * @param {function} fn\n   * @return {Path}\n   */\n\n\n  Path.prototype.mapPoints = function mapPoints(fn) {\n    var path = new Path();\n\n    for (var _iterator = this.commands, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _getIterator(_iterator);;) {\n      var _ref;\n\n      if (_isArray) {\n        if (_i >= _iterator.length) break;\n        _ref = _iterator[_i++];\n      } else {\n        _i = _iterator.next();\n        if (_i.done) break;\n        _ref = _i.value;\n      }\n\n      var c = _ref;\n      var args = [];\n\n      for (var _i2 = 0; _i2 < c.args.length; _i2 += 2) {\n        var _fn = fn(c.args[_i2], c.args[_i2 + 1]),\n            x = _fn[0],\n            y = _fn[1];\n\n        args.push(x, y);\n      }\n\n      path[c.command].apply(path, args);\n    }\n\n    return path;\n  };\n  /**\n   * Transforms the path by the given matrix.\n   */\n\n\n  Path.prototype.transform = function transform(m0, m1, m2, m3, m4, m5) {\n    return this.mapPoints(function (x, y) {\n      x = m0 * x + m2 * y + m4;\n      y = m1 * x + m3 * y + m5;\n      return [x, y];\n    });\n  };\n  /**\n   * Translates the path by the given offset.\n   */\n\n\n  Path.prototype.translate = function translate(x, y) {\n    return this.transform(1, 0, 0, 1, x, y);\n  };\n  /**\n   * Rotates the path by the given angle (in radians).\n   */\n\n\n  Path.prototype.rotate = function rotate(angle) {\n    var cos = Math.cos(angle);\n    var sin = Math.sin(angle);\n    return this.transform(cos, sin, -sin, cos, 0, 0);\n  };\n  /**\n   * Scales the path.\n   */\n\n\n  Path.prototype.scale = function scale(scaleX) {\n    var scaleY = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : scaleX;\n    return this.transform(scaleX, 0, 0, scaleY, 0, 0);\n  };\n\n  _createClass(Path, [{\n    key: 'cbox',\n    get: function get() {\n      if (!this._cbox) {\n        var cbox = new BBox();\n\n        for (var _iterator2 = this.commands, _isArray2 = Array.isArray(_iterator2), _i3 = 0, _iterator2 = _isArray2 ? _iterator2 : _getIterator(_iterator2);;) {\n          var _ref2;\n\n          if (_isArray2) {\n            if (_i3 >= _iterator2.length) break;\n            _ref2 = _iterator2[_i3++];\n          } else {\n            _i3 = _iterator2.next();\n            if (_i3.done) break;\n            _ref2 = _i3.value;\n          }\n\n          var command = _ref2;\n\n          for (var _i4 = 0; _i4 < command.args.length; _i4 += 2) {\n            cbox.addPoint(command.args[_i4], command.args[_i4 + 1]);\n          }\n        }\n\n        this._cbox = _Object$freeze(cbox);\n      }\n\n      return this._cbox;\n    }\n    /**\n     * Gets the exact bounding box of the path by evaluating curve segments.\n     * Slower to compute than the control box, but more accurate.\n     * @type {BBox}\n     */\n\n  }, {\n    key: 'bbox',\n    get: function get() {\n      if (this._bbox) {\n        return this._bbox;\n      }\n\n      var bbox = new BBox();\n      var cx = 0,\n          cy = 0;\n\n      var f = function f(t) {\n        return Math.pow(1 - t, 3) * p0[i] + 3 * Math.pow(1 - t, 2) * t * p1[i] + 3 * (1 - t) * Math.pow(t, 2) * p2[i] + Math.pow(t, 3) * p3[i];\n      };\n\n      for (var _iterator3 = this.commands, _isArray3 = Array.isArray(_iterator3), _i5 = 0, _iterator3 = _isArray3 ? _iterator3 : _getIterator(_iterator3);;) {\n        var _ref3;\n\n        if (_isArray3) {\n          if (_i5 >= _iterator3.length) break;\n          _ref3 = _iterator3[_i5++];\n        } else {\n          _i5 = _iterator3.next();\n          if (_i5.done) break;\n          _ref3 = _i5.value;\n        }\n\n        var c = _ref3;\n\n        switch (c.command) {\n          case 'moveTo':\n          case 'lineTo':\n            var _c$args = c.args,\n                x = _c$args[0],\n                y = _c$args[1];\n            bbox.addPoint(x, y);\n            cx = x;\n            cy = y;\n            break;\n\n          case 'quadraticCurveTo':\n          case 'bezierCurveTo':\n            if (c.command === 'quadraticCurveTo') {\n              // http://fontforge.org/bezier.html\n              var _c$args2 = c.args,\n                  qp1x = _c$args2[0],\n                  qp1y = _c$args2[1],\n                  p3x = _c$args2[2],\n                  p3y = _c$args2[3];\n              var cp1x = cx + 2 / 3 * (qp1x - cx); // CP1 = QP0 + 2/3 * (QP1-QP0)\n\n              var cp1y = cy + 2 / 3 * (qp1y - cy);\n              var cp2x = p3x + 2 / 3 * (qp1x - p3x); // CP2 = QP2 + 2/3 * (QP1-QP2)\n\n              var cp2y = p3y + 2 / 3 * (qp1y - p3y);\n            } else {\n              var _c$args3 = c.args,\n                  cp1x = _c$args3[0],\n                  cp1y = _c$args3[1],\n                  cp2x = _c$args3[2],\n                  cp2y = _c$args3[3],\n                  p3x = _c$args3[4],\n                  p3y = _c$args3[5];\n            } // http://blog.hackers-cafe.net/2009/06/how-to-calculate-bezier-curves-bounding.html\n\n\n            bbox.addPoint(p3x, p3y);\n            var p0 = [cx, cy];\n            var p1 = [cp1x, cp1y];\n            var p2 = [cp2x, cp2y];\n            var p3 = [p3x, p3y];\n\n            for (var i = 0; i <= 1; i++) {\n              var b = 6 * p0[i] - 12 * p1[i] + 6 * p2[i];\n              var a = -3 * p0[i] + 9 * p1[i] - 9 * p2[i] + 3 * p3[i];\n              c = 3 * p1[i] - 3 * p0[i];\n\n              if (a === 0) {\n                if (b === 0) {\n                  continue;\n                }\n\n                var t = -c / b;\n\n                if (0 < t && t < 1) {\n                  if (i === 0) {\n                    bbox.addPoint(f(t), bbox.maxY);\n                  } else if (i === 1) {\n                    bbox.addPoint(bbox.maxX, f(t));\n                  }\n                }\n\n                continue;\n              }\n\n              var b2ac = Math.pow(b, 2) - 4 * c * a;\n\n              if (b2ac < 0) {\n                continue;\n              }\n\n              var t1 = (-b + Math.sqrt(b2ac)) / (2 * a);\n\n              if (0 < t1 && t1 < 1) {\n                if (i === 0) {\n                  bbox.addPoint(f(t1), bbox.maxY);\n                } else if (i === 1) {\n                  bbox.addPoint(bbox.maxX, f(t1));\n                }\n              }\n\n              var t2 = (-b - Math.sqrt(b2ac)) / (2 * a);\n\n              if (0 < t2 && t2 < 1) {\n                if (i === 0) {\n                  bbox.addPoint(f(t2), bbox.maxY);\n                } else if (i === 1) {\n                  bbox.addPoint(bbox.maxX, f(t2));\n                }\n              }\n            }\n\n            cx = p3x;\n            cy = p3y;\n            break;\n        }\n      }\n\n      return this._bbox = _Object$freeze(bbox);\n    }\n  }]);\n\n  return Path;\n}();\n\nvar _arr = ['moveTo', 'lineTo', 'quadraticCurveTo', 'bezierCurveTo', 'closePath'];\n\nvar _loop = function _loop() {\n  var command = _arr[_i6];\n\n  Path.prototype[command] = function () {\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    this._bbox = this._cbox = null;\n    this.commands.push({\n      command: command,\n      args: args\n    });\n    return this;\n  };\n};\n\nfor (var _i6 = 0; _i6 < _arr.length; _i6++) {\n  _loop();\n}\n\nvar StandardNames = ['.notdef', '.null', 'nonmarkingreturn', 'space', 'exclam', 'quotedbl', 'numbersign', 'dollar', 'percent', 'ampersand', 'quotesingle', 'parenleft', 'parenright', 'asterisk', 'plus', 'comma', 'hyphen', 'period', 'slash', 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'colon', 'semicolon', 'less', 'equal', 'greater', 'question', 'at', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'bracketleft', 'backslash', 'bracketright', 'asciicircum', 'underscore', 'grave', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'braceleft', 'bar', 'braceright', 'asciitilde', 'Adieresis', 'Aring', 'Ccedilla', 'Eacute', 'Ntilde', 'Odieresis', 'Udieresis', 'aacute', 'agrave', 'acircumflex', 'adieresis', 'atilde', 'aring', 'ccedilla', 'eacute', 'egrave', 'ecircumflex', 'edieresis', 'iacute', 'igrave', 'icircumflex', 'idieresis', 'ntilde', 'oacute', 'ograve', 'ocircumflex', 'odieresis', 'otilde', 'uacute', 'ugrave', 'ucircumflex', 'udieresis', 'dagger', 'degree', 'cent', 'sterling', 'section', 'bullet', 'paragraph', 'germandbls', 'registered', 'copyright', 'trademark', 'acute', 'dieresis', 'notequal', 'AE', 'Oslash', 'infinity', 'plusminus', 'lessequal', 'greaterequal', 'yen', 'mu', 'partialdiff', 'summation', 'product', 'pi', 'integral', 'ordfeminine', 'ordmasculine', 'Omega', 'ae', 'oslash', 'questiondown', 'exclamdown', 'logicalnot', 'radical', 'florin', 'approxequal', 'Delta', 'guillemotleft', 'guillemotright', 'ellipsis', 'nonbreakingspace', 'Agrave', 'Atilde', 'Otilde', 'OE', 'oe', 'endash', 'emdash', 'quotedblleft', 'quotedblright', 'quoteleft', 'quoteright', 'divide', 'lozenge', 'ydieresis', 'Ydieresis', 'fraction', 'currency', 'guilsinglleft', 'guilsinglright', 'fi', 'fl', 'daggerdbl', 'periodcentered', 'quotesinglbase', 'quotedblbase', 'perthousand', 'Acircumflex', 'Ecircumflex', 'Aacute', 'Edieresis', 'Egrave', 'Iacute', 'Icircumflex', 'Idieresis', 'Igrave', 'Oacute', 'Ocircumflex', 'apple', 'Ograve', 'Uacute', 'Ucircumflex', 'Ugrave', 'dotlessi', 'circumflex', 'tilde', 'macron', 'breve', 'dotaccent', 'ring', 'cedilla', 'hungarumlaut', 'ogonek', 'caron', 'Lslash', 'lslash', 'Scaron', 'scaron', 'Zcaron', 'zcaron', 'brokenbar', 'Eth', 'eth', 'Yacute', 'yacute', 'Thorn', 'thorn', 'minus', 'multiply', 'onesuperior', 'twosuperior', 'threesuperior', 'onehalf', 'onequarter', 'threequarters', 'franc', 'Gbreve', 'gbreve', 'Idotaccent', 'Scedilla', 'scedilla', 'Cacute', 'cacute', 'Ccaron', 'ccaron', 'dcroat'];\n\nvar _class$8;\n\nfunction _applyDecoratedDescriptor$4(target, property, decorators, descriptor, context) {\n  var desc = {};\n  Object['ke' + 'ys'](descriptor).forEach(function (key) {\n    desc[key] = descriptor[key];\n  });\n  desc.enumerable = !!desc.enumerable;\n  desc.configurable = !!desc.configurable;\n\n  if ('value' in desc || desc.initializer) {\n    desc.writable = true;\n  }\n\n  desc = decorators.slice().reverse().reduce(function (desc, decorator) {\n    return decorator(target, property, desc) || desc;\n  }, desc);\n\n  if (context && desc.initializer !== void 0) {\n    desc.value = desc.initializer ? desc.initializer.call(context) : void 0;\n    desc.initializer = undefined;\n  }\n\n  if (desc.initializer === void 0) {\n    Object['define' + 'Property'](target, property, desc);\n    desc = null;\n  }\n\n  return desc;\n}\n/**\n * Glyph objects represent a glyph in the font. They have various properties for accessing metrics and\n * the actual vector path the glyph represents, and methods for rendering the glyph to a graphics context.\n *\n * You do not create glyph objects directly. They are created by various methods on the font object.\n * There are several subclasses of the base Glyph class internally that may be returned depending\n * on the font format, but they all inherit from this class.\n */\n\n\nvar Glyph = (_class$8 = function () {\n  function Glyph(id, codePoints, font) {\n    _classCallCheck(this, Glyph);\n    /**\n     * The glyph id in the font\n     * @type {number}\n     */\n\n\n    this.id = id;\n    /**\n     * An array of unicode code points that are represented by this glyph.\n     * There can be multiple code points in the case of ligatures and other glyphs\n     * that represent multiple visual characters.\n     * @type {number[]}\n     */\n\n    this.codePoints = codePoints;\n    this._font = font; // TODO: get this info from GDEF if available\n\n    this.isMark = this.codePoints.length > 0 && this.codePoints.every(unicode.isMark);\n    this.isLigature = this.codePoints.length > 1;\n  }\n\n  Glyph.prototype._getPath = function _getPath() {\n    return new Path();\n  };\n\n  Glyph.prototype._getCBox = function _getCBox() {\n    return this.path.cbox;\n  };\n\n  Glyph.prototype._getBBox = function _getBBox() {\n    return this.path.bbox;\n  };\n\n  Glyph.prototype._getTableMetrics = function _getTableMetrics(table) {\n    if (this.id < table.metrics.length) {\n      return table.metrics.get(this.id);\n    }\n\n    var metric = table.metrics.get(table.metrics.length - 1);\n    var res = {\n      advance: metric ? metric.advance : 0,\n      bearing: table.bearings.get(this.id - table.metrics.length) || 0\n    };\n    return res;\n  };\n\n  Glyph.prototype._getMetrics = function _getMetrics(cbox) {\n    if (this._metrics) {\n      return this._metrics;\n    }\n\n    var _getTableMetrics2 = this._getTableMetrics(this._font.hmtx),\n        advanceWidth = _getTableMetrics2.advance,\n        leftBearing = _getTableMetrics2.bearing; // For vertical metrics, use vmtx if available, or fall back to global data from OS/2 or hhea\n\n\n    if (this._font.vmtx) {\n      var _getTableMetrics3 = this._getTableMetrics(this._font.vmtx),\n          advanceHeight = _getTableMetrics3.advance,\n          topBearing = _getTableMetrics3.bearing;\n    } else {\n      var os2 = void 0;\n\n      if (typeof cbox === 'undefined' || cbox === null) {\n        cbox = this.cbox;\n      }\n\n      if ((os2 = this._font['OS/2']) && os2.version > 0) {\n        var advanceHeight = Math.abs(os2.typoAscender - os2.typoDescender);\n        var topBearing = os2.typoAscender - cbox.maxY;\n      } else {\n        var hhea = this._font.hhea;\n        var advanceHeight = Math.abs(hhea.ascent - hhea.descent);\n        var topBearing = hhea.ascent - cbox.maxY;\n      }\n    }\n\n    if (this._font._variationProcessor && this._font.HVAR) {\n      advanceWidth += this._font._variationProcessor.getAdvanceAdjustment(this.id, this._font.HVAR);\n    }\n\n    return this._metrics = {\n      advanceWidth: advanceWidth,\n      advanceHeight: advanceHeight,\n      leftBearing: leftBearing,\n      topBearing: topBearing\n    };\n  };\n  /**\n   * The glyph’s control box.\n   * This is often the same as the bounding box, but is faster to compute.\n   * Because of the way bezier curves are defined, some of the control points\n   * can be outside of the bounding box. Where `bbox` takes this into account,\n   * `cbox` does not. Thus, cbox is less accurate, but faster to compute.\n   * See [here](http://www.freetype.org/freetype2/docs/glyphs/glyphs-6.html#section-2)\n   * for a more detailed description.\n   *\n   * @type {BBox}\n   */\n\n  /**\n   * Returns a path scaled to the given font size.\n   * @param {number} size\n   * @return {Path}\n   */\n\n\n  Glyph.prototype.getScaledPath = function getScaledPath(size) {\n    var scale = 1 / this._font.unitsPerEm * size;\n    return this.path.scale(scale);\n  };\n  /**\n   * The glyph's advance width.\n   * @type {number}\n   */\n\n\n  Glyph.prototype._getName = function _getName() {\n    var post = this._font.post;\n\n    if (!post) {\n      return null;\n    }\n\n    switch (post.version) {\n      case 1:\n        return StandardNames[this.id];\n\n      case 2:\n        var id = post.glyphNameIndex[this.id];\n\n        if (id < StandardNames.length) {\n          return StandardNames[id];\n        }\n\n        return post.names[id - StandardNames.length];\n\n      case 2.5:\n        return StandardNames[this.id + post.offsets[this.id]];\n\n      case 4:\n        return String.fromCharCode(post.map[this.id]);\n    }\n  };\n  /**\n   * The glyph's name\n   * @type {string}\n   */\n\n  /**\n   * Renders the glyph to the given graphics context, at the specified font size.\n   * @param {CanvasRenderingContext2d} ctx\n   * @param {number} size\n   */\n\n\n  Glyph.prototype.render = function render(ctx, size) {\n    ctx.save();\n    var scale = 1 / this._font.head.unitsPerEm * size;\n    ctx.scale(scale, scale);\n    var fn = this.path.toFunction();\n    fn(ctx);\n    ctx.fill();\n    ctx.restore();\n  };\n\n  _createClass(Glyph, [{\n    key: 'cbox',\n    get: function get() {\n      return this._getCBox();\n    }\n    /**\n     * The glyph’s bounding box, i.e. the rectangle that encloses the\n     * glyph outline as tightly as possible.\n     * @type {BBox}\n     */\n\n  }, {\n    key: 'bbox',\n    get: function get() {\n      return this._getBBox();\n    }\n    /**\n     * A vector Path object representing the glyph outline.\n     * @type {Path}\n     */\n\n  }, {\n    key: 'path',\n    get: function get() {\n      // Cache the path so we only decode it once\n      // Decoding is actually performed by subclasses\n      return this._getPath();\n    }\n  }, {\n    key: 'advanceWidth',\n    get: function get() {\n      return this._getMetrics().advanceWidth;\n    }\n    /**\n     * The glyph's advance height.\n     * @type {number}\n     */\n\n  }, {\n    key: 'advanceHeight',\n    get: function get() {\n      return this._getMetrics().advanceHeight;\n    }\n  }, {\n    key: 'ligatureCaretPositions',\n    get: function get() {}\n  }, {\n    key: 'name',\n    get: function get() {\n      return this._getName();\n    }\n  }]);\n\n  return Glyph;\n}(), (_applyDecoratedDescriptor$4(_class$8.prototype, 'cbox', [cache], _Object$getOwnPropertyDescriptor(_class$8.prototype, 'cbox'), _class$8.prototype), _applyDecoratedDescriptor$4(_class$8.prototype, 'bbox', [cache], _Object$getOwnPropertyDescriptor(_class$8.prototype, 'bbox'), _class$8.prototype), _applyDecoratedDescriptor$4(_class$8.prototype, 'path', [cache], _Object$getOwnPropertyDescriptor(_class$8.prototype, 'path'), _class$8.prototype), _applyDecoratedDescriptor$4(_class$8.prototype, 'advanceWidth', [cache], _Object$getOwnPropertyDescriptor(_class$8.prototype, 'advanceWidth'), _class$8.prototype), _applyDecoratedDescriptor$4(_class$8.prototype, 'advanceHeight', [cache], _Object$getOwnPropertyDescriptor(_class$8.prototype, 'advanceHeight'), _class$8.prototype), _applyDecoratedDescriptor$4(_class$8.prototype, 'name', [cache], _Object$getOwnPropertyDescriptor(_class$8.prototype, 'name'), _class$8.prototype)), _class$8); // The header for both simple and composite glyphs\n\nvar GlyfHeader = new r.Struct({\n  numberOfContours: r.int16,\n  // if negative, this is a composite glyph\n  xMin: r.int16,\n  yMin: r.int16,\n  xMax: r.int16,\n  yMax: r.int16\n}); // Flags for simple glyphs\n\nvar ON_CURVE = 1 << 0;\nvar X_SHORT_VECTOR = 1 << 1;\nvar Y_SHORT_VECTOR = 1 << 2;\nvar REPEAT = 1 << 3;\nvar SAME_X = 1 << 4;\nvar SAME_Y = 1 << 5; // Flags for composite glyphs\n\nvar ARG_1_AND_2_ARE_WORDS = 1 << 0;\nvar WE_HAVE_A_SCALE = 1 << 3;\nvar MORE_COMPONENTS = 1 << 5;\nvar WE_HAVE_AN_X_AND_Y_SCALE = 1 << 6;\nvar WE_HAVE_A_TWO_BY_TWO = 1 << 7;\nvar WE_HAVE_INSTRUCTIONS = 1 << 8; // Represents a point in a simple glyph\n\nvar Point = function () {\n  function Point(onCurve, endContour) {\n    var x = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    var y = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n\n    _classCallCheck(this, Point);\n\n    this.onCurve = onCurve;\n    this.endContour = endContour;\n    this.x = x;\n    this.y = y;\n  }\n\n  Point.prototype.copy = function copy() {\n    return new Point(this.onCurve, this.endContour, this.x, this.y);\n  };\n\n  return Point;\n}(); // Represents a component in a composite glyph\n\n\nvar Component = function Component(glyphID, dx, dy) {\n  _classCallCheck(this, Component);\n\n  this.glyphID = glyphID;\n  this.dx = dx;\n  this.dy = dy;\n  this.pos = 0;\n  this.scaleX = this.scaleY = 1;\n  this.scale01 = this.scale10 = 0;\n};\n/**\n * Represents a TrueType glyph.\n */\n\n\nvar TTFGlyph = function (_Glyph) {\n  _inherits(TTFGlyph, _Glyph);\n\n  function TTFGlyph() {\n    _classCallCheck(this, TTFGlyph);\n\n    return _possibleConstructorReturn(this, _Glyph.apply(this, arguments));\n  } // Parses just the glyph header and returns the bounding box\n\n\n  TTFGlyph.prototype._getCBox = function _getCBox(internal) {\n    // We need to decode the glyph if variation processing is requested,\n    // so it's easier just to recompute the path's cbox after decoding.\n    if (this._font._variationProcessor && !internal) {\n      return this.path.cbox;\n    }\n\n    var stream = this._font._getTableStream('glyf');\n\n    stream.pos += this._font.loca.offsets[this.id];\n    var glyph = GlyfHeader.decode(stream);\n    var cbox = new BBox(glyph.xMin, glyph.yMin, glyph.xMax, glyph.yMax);\n    return _Object$freeze(cbox);\n  }; // Parses a single glyph coordinate\n\n\n  TTFGlyph.prototype._parseGlyphCoord = function _parseGlyphCoord(stream, prev, short, same) {\n    if (short) {\n      var val = stream.readUInt8();\n\n      if (!same) {\n        val = -val;\n      }\n\n      val += prev;\n    } else {\n      if (same) {\n        var val = prev;\n      } else {\n        var val = prev + stream.readInt16BE();\n      }\n    }\n\n    return val;\n  }; // Decodes the glyph data into points for simple glyphs,\n  // or components for composite glyphs\n\n\n  TTFGlyph.prototype._decode = function _decode() {\n    var glyfPos = this._font.loca.offsets[this.id];\n    var nextPos = this._font.loca.offsets[this.id + 1]; // Nothing to do if there is no data for this glyph\n\n    if (glyfPos === nextPos) {\n      return null;\n    }\n\n    var stream = this._font._getTableStream('glyf');\n\n    stream.pos += glyfPos;\n    var startPos = stream.pos;\n    var glyph = GlyfHeader.decode(stream);\n\n    if (glyph.numberOfContours > 0) {\n      this._decodeSimple(glyph, stream);\n    } else if (glyph.numberOfContours < 0) {\n      this._decodeComposite(glyph, stream, startPos);\n    }\n\n    return glyph;\n  };\n\n  TTFGlyph.prototype._decodeSimple = function _decodeSimple(glyph, stream) {\n    // this is a simple glyph\n    glyph.points = [];\n    var endPtsOfContours = new r.Array(r.uint16, glyph.numberOfContours).decode(stream);\n    glyph.instructions = new r.Array(r.uint8, r.uint16).decode(stream);\n    var flags = [];\n    var numCoords = endPtsOfContours[endPtsOfContours.length - 1] + 1;\n\n    while (flags.length < numCoords) {\n      var flag = stream.readUInt8();\n      flags.push(flag); // check for repeat flag\n\n      if (flag & REPEAT) {\n        var count = stream.readUInt8();\n\n        for (var j = 0; j < count; j++) {\n          flags.push(flag);\n        }\n      }\n    }\n\n    for (var i = 0; i < flags.length; i++) {\n      var flag = flags[i];\n      var point = new Point(!!(flag & ON_CURVE), endPtsOfContours.indexOf(i) >= 0, 0, 0);\n      glyph.points.push(point);\n    }\n\n    var px = 0;\n\n    for (var i = 0; i < flags.length; i++) {\n      var flag = flags[i];\n      glyph.points[i].x = px = this._parseGlyphCoord(stream, px, flag & X_SHORT_VECTOR, flag & SAME_X);\n    }\n\n    var py = 0;\n\n    for (var i = 0; i < flags.length; i++) {\n      var flag = flags[i];\n      glyph.points[i].y = py = this._parseGlyphCoord(stream, py, flag & Y_SHORT_VECTOR, flag & SAME_Y);\n    }\n\n    if (this._font._variationProcessor) {\n      var points = glyph.points.slice();\n      points.push.apply(points, this._getPhantomPoints(glyph));\n\n      this._font._variationProcessor.transformPoints(this.id, points);\n\n      glyph.phantomPoints = points.slice(-4);\n    }\n\n    return;\n  };\n\n  TTFGlyph.prototype._decodeComposite = function _decodeComposite(glyph, stream) {\n    var offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0; // this is a composite glyph\n\n    glyph.components = [];\n    var haveInstructions = false;\n    var flags = MORE_COMPONENTS;\n\n    while (flags & MORE_COMPONENTS) {\n      flags = stream.readUInt16BE();\n      var gPos = stream.pos - offset;\n      var glyphID = stream.readUInt16BE();\n\n      if (!haveInstructions) {\n        haveInstructions = (flags & WE_HAVE_INSTRUCTIONS) !== 0;\n      }\n\n      if (flags & ARG_1_AND_2_ARE_WORDS) {\n        var dx = stream.readInt16BE();\n        var dy = stream.readInt16BE();\n      } else {\n        var dx = stream.readInt8();\n        var dy = stream.readInt8();\n      }\n\n      var component = new Component(glyphID, dx, dy);\n      component.pos = gPos;\n\n      if (flags & WE_HAVE_A_SCALE) {\n        // fixed number with 14 bits of fraction\n        component.scaleX = component.scaleY = (stream.readUInt8() << 24 | stream.readUInt8() << 16) / 1073741824;\n      } else if (flags & WE_HAVE_AN_X_AND_Y_SCALE) {\n        component.scaleX = (stream.readUInt8() << 24 | stream.readUInt8() << 16) / 1073741824;\n        component.scaleY = (stream.readUInt8() << 24 | stream.readUInt8() << 16) / 1073741824;\n      } else if (flags & WE_HAVE_A_TWO_BY_TWO) {\n        component.scaleX = (stream.readUInt8() << 24 | stream.readUInt8() << 16) / 1073741824;\n        component.scale01 = (stream.readUInt8() << 24 | stream.readUInt8() << 16) / 1073741824;\n        component.scale10 = (stream.readUInt8() << 24 | stream.readUInt8() << 16) / 1073741824;\n        component.scaleY = (stream.readUInt8() << 24 | stream.readUInt8() << 16) / 1073741824;\n      }\n\n      glyph.components.push(component);\n    }\n\n    if (this._font._variationProcessor) {\n      var points = [];\n\n      for (var j = 0; j < glyph.components.length; j++) {\n        var component = glyph.components[j];\n        points.push(new Point(true, true, component.dx, component.dy));\n      }\n\n      points.push.apply(points, this._getPhantomPoints(glyph));\n\n      this._font._variationProcessor.transformPoints(this.id, points);\n\n      glyph.phantomPoints = points.splice(-4, 4);\n\n      for (var i = 0; i < points.length; i++) {\n        var point = points[i];\n        glyph.components[i].dx = point.x;\n        glyph.components[i].dy = point.y;\n      }\n    }\n\n    return haveInstructions;\n  };\n\n  TTFGlyph.prototype._getPhantomPoints = function _getPhantomPoints(glyph) {\n    var cbox = this._getCBox(true);\n\n    if (this._metrics == null) {\n      this._metrics = Glyph.prototype._getMetrics.call(this, cbox);\n    }\n\n    var _metrics = this._metrics,\n        advanceWidth = _metrics.advanceWidth,\n        advanceHeight = _metrics.advanceHeight,\n        leftBearing = _metrics.leftBearing,\n        topBearing = _metrics.topBearing;\n    return [new Point(false, true, glyph.xMin - leftBearing, 0), new Point(false, true, glyph.xMin - leftBearing + advanceWidth, 0), new Point(false, true, 0, glyph.yMax + topBearing), new Point(false, true, 0, glyph.yMax + topBearing + advanceHeight)];\n  }; // Decodes font data, resolves composite glyphs, and returns an array of contours\n\n\n  TTFGlyph.prototype._getContours = function _getContours() {\n    var glyph = this._decode();\n\n    if (!glyph) {\n      return [];\n    }\n\n    var points = [];\n\n    if (glyph.numberOfContours < 0) {\n      // resolve composite glyphs\n      for (var _iterator = glyph.components, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _getIterator(_iterator);;) {\n        var _ref;\n\n        if (_isArray) {\n          if (_i >= _iterator.length) break;\n          _ref = _iterator[_i++];\n        } else {\n          _i = _iterator.next();\n          if (_i.done) break;\n          _ref = _i.value;\n        }\n\n        var component = _ref;\n\n        var _contours = this._font.getGlyph(component.glyphID)._getContours();\n\n        for (var i = 0; i < _contours.length; i++) {\n          var contour = _contours[i];\n\n          for (var j = 0; j < contour.length; j++) {\n            var _point = contour[j];\n            var x = _point.x * component.scaleX + _point.y * component.scale01 + component.dx;\n            var y = _point.y * component.scaleY + _point.x * component.scale10 + component.dy;\n            points.push(new Point(_point.onCurve, _point.endContour, x, y));\n          }\n        }\n      }\n    } else {\n      points = glyph.points || [];\n    } // Recompute and cache metrics if we performed variation processing, and don't have an HVAR table\n\n\n    if (glyph.phantomPoints && !this._font.directory.tables.HVAR) {\n      this._metrics.advanceWidth = glyph.phantomPoints[1].x - glyph.phantomPoints[0].x;\n      this._metrics.advanceHeight = glyph.phantomPoints[3].y - glyph.phantomPoints[2].y;\n      this._metrics.leftBearing = glyph.xMin - glyph.phantomPoints[0].x;\n      this._metrics.topBearing = glyph.phantomPoints[2].y - glyph.yMax;\n    }\n\n    var contours = [];\n    var cur = [];\n\n    for (var k = 0; k < points.length; k++) {\n      var point = points[k];\n      cur.push(point);\n\n      if (point.endContour) {\n        contours.push(cur);\n        cur = [];\n      }\n    }\n\n    return contours;\n  };\n\n  TTFGlyph.prototype._getMetrics = function _getMetrics() {\n    if (this._metrics) {\n      return this._metrics;\n    }\n\n    var cbox = this._getCBox(true);\n\n    _Glyph.prototype._getMetrics.call(this, cbox);\n\n    if (this._font._variationProcessor && !this._font.HVAR) {\n      // No HVAR table, decode the glyph. This triggers recomputation of metrics.\n      this.path;\n    }\n\n    return this._metrics;\n  }; // Converts contours to a Path object that can be rendered\n\n\n  TTFGlyph.prototype._getPath = function _getPath() {\n    var contours = this._getContours();\n\n    var path = new Path();\n\n    for (var i = 0; i < contours.length; i++) {\n      var contour = contours[i];\n      var firstPt = contour[0];\n      var lastPt = contour[contour.length - 1];\n      var start = 0;\n\n      if (firstPt.onCurve) {\n        // The first point will be consumed by the moveTo command, so skip in the loop\n        var curvePt = null;\n        start = 1;\n      } else {\n        if (lastPt.onCurve) {\n          // Start at the last point if the first point is off curve and the last point is on curve\n          firstPt = lastPt;\n        } else {\n          // Start at the middle if both the first and last points are off curve\n          firstPt = new Point(false, false, (firstPt.x + lastPt.x) / 2, (firstPt.y + lastPt.y) / 2);\n        }\n\n        var curvePt = firstPt;\n      }\n\n      path.moveTo(firstPt.x, firstPt.y);\n\n      for (var j = start; j < contour.length; j++) {\n        var pt = contour[j];\n        var prevPt = j === 0 ? firstPt : contour[j - 1];\n\n        if (prevPt.onCurve && pt.onCurve) {\n          path.lineTo(pt.x, pt.y);\n        } else if (prevPt.onCurve && !pt.onCurve) {\n          var curvePt = pt;\n        } else if (!prevPt.onCurve && !pt.onCurve) {\n          var midX = (prevPt.x + pt.x) / 2;\n          var midY = (prevPt.y + pt.y) / 2;\n          path.quadraticCurveTo(prevPt.x, prevPt.y, midX, midY);\n          var curvePt = pt;\n        } else if (!prevPt.onCurve && pt.onCurve) {\n          path.quadraticCurveTo(curvePt.x, curvePt.y, pt.x, pt.y);\n          var curvePt = null;\n        } else {\n          throw new Error(\"Unknown TTF path state\");\n        }\n      } // Connect the first and last points\n\n\n      if (curvePt) {\n        path.quadraticCurveTo(curvePt.x, curvePt.y, firstPt.x, firstPt.y);\n      }\n\n      path.closePath();\n    }\n\n    return path;\n  };\n\n  return TTFGlyph;\n}(Glyph);\n/**\n * Represents an OpenType PostScript glyph, in the Compact Font Format.\n */\n\n\nvar CFFGlyph = function (_Glyph) {\n  _inherits(CFFGlyph, _Glyph);\n\n  function CFFGlyph() {\n    _classCallCheck(this, CFFGlyph);\n\n    return _possibleConstructorReturn(this, _Glyph.apply(this, arguments));\n  }\n\n  CFFGlyph.prototype._getName = function _getName() {\n    if (this._font.CFF2) {\n      return _Glyph.prototype._getName.call(this);\n    }\n\n    return this._font['CFF '].getGlyphName(this.id);\n  };\n\n  CFFGlyph.prototype.bias = function bias(s) {\n    if (s.length < 1240) {\n      return 107;\n    } else if (s.length < 33900) {\n      return 1131;\n    } else {\n      return 32768;\n    }\n  };\n\n  CFFGlyph.prototype._getPath = function _getPath() {\n    var cff = this._font.CFF2 || this._font['CFF '];\n    var stream = cff.stream;\n    var str = cff.topDict.CharStrings[this.id];\n    var end = str.offset + str.length;\n    stream.pos = str.offset;\n    var path = new Path();\n    var stack = [];\n    var trans = [];\n    var width = null;\n    var nStems = 0;\n    var x = 0,\n        y = 0;\n    var usedGsubrs = void 0;\n    var usedSubrs = void 0;\n    var open = false;\n    this._usedGsubrs = usedGsubrs = {};\n    this._usedSubrs = usedSubrs = {};\n    var gsubrs = cff.globalSubrIndex || [];\n    var gsubrsBias = this.bias(gsubrs);\n    var privateDict = cff.privateDictForGlyph(this.id) || {};\n    var subrs = privateDict.Subrs || [];\n    var subrsBias = this.bias(subrs);\n    var vstore = cff.topDict.vstore && cff.topDict.vstore.itemVariationStore;\n    var vsindex = privateDict.vsindex;\n    var variationProcessor = this._font._variationProcessor;\n\n    function checkWidth() {\n      if (width == null) {\n        width = stack.shift() + privateDict.nominalWidthX;\n      }\n    }\n\n    function parseStems() {\n      if (stack.length % 2 !== 0) {\n        checkWidth();\n      }\n\n      nStems += stack.length >> 1;\n      return stack.length = 0;\n    }\n\n    function moveTo(x, y) {\n      if (open) {\n        path.closePath();\n      }\n\n      path.moveTo(x, y);\n      open = true;\n    }\n\n    var parse = function parse() {\n      while (stream.pos < end) {\n        var op = stream.readUInt8();\n\n        if (op < 32) {\n          switch (op) {\n            case 1: // hstem\n\n            case 3: // vstem\n\n            case 18: // hstemhm\n\n            case 23:\n              // vstemhm\n              parseStems();\n              break;\n\n            case 4:\n              // vmoveto\n              if (stack.length > 1) {\n                checkWidth();\n              }\n\n              y += stack.shift();\n              moveTo(x, y);\n              break;\n\n            case 5:\n              // rlineto\n              while (stack.length >= 2) {\n                x += stack.shift();\n                y += stack.shift();\n                path.lineTo(x, y);\n              }\n\n              break;\n\n            case 6: // hlineto\n\n            case 7:\n              // vlineto\n              var phase = op === 6;\n\n              while (stack.length >= 1) {\n                if (phase) {\n                  x += stack.shift();\n                } else {\n                  y += stack.shift();\n                }\n\n                path.lineTo(x, y);\n                phase = !phase;\n              }\n\n              break;\n\n            case 8:\n              // rrcurveto\n              while (stack.length > 0) {\n                var c1x = x + stack.shift();\n                var c1y = y + stack.shift();\n                var c2x = c1x + stack.shift();\n                var c2y = c1y + stack.shift();\n                x = c2x + stack.shift();\n                y = c2y + stack.shift();\n                path.bezierCurveTo(c1x, c1y, c2x, c2y, x, y);\n              }\n\n              break;\n\n            case 10:\n              // callsubr\n              var index = stack.pop() + subrsBias;\n              var subr = subrs[index];\n\n              if (subr) {\n                usedSubrs[index] = true;\n                var p = stream.pos;\n                var e = end;\n                stream.pos = subr.offset;\n                end = subr.offset + subr.length;\n                parse();\n                stream.pos = p;\n                end = e;\n              }\n\n              break;\n\n            case 11:\n              // return\n              if (cff.version >= 2) {\n                break;\n              }\n\n              return;\n\n            case 14:\n              // endchar\n              if (cff.version >= 2) {\n                break;\n              }\n\n              if (stack.length > 0) {\n                checkWidth();\n              }\n\n              if (open) {\n                path.closePath();\n                open = false;\n              }\n\n              break;\n\n            case 15:\n              {\n                // vsindex\n                if (cff.version < 2) {\n                  throw new Error('vsindex operator not supported in CFF v1');\n                }\n\n                vsindex = stack.pop();\n                break;\n              }\n\n            case 16:\n              {\n                // blend\n                if (cff.version < 2) {\n                  throw new Error('blend operator not supported in CFF v1');\n                }\n\n                if (!variationProcessor) {\n                  throw new Error('blend operator in non-variation font');\n                }\n\n                var blendVector = variationProcessor.getBlendVector(vstore, vsindex);\n                var numBlends = stack.pop();\n                var numOperands = numBlends * blendVector.length;\n                var delta = stack.length - numOperands;\n                var base = delta - numBlends;\n\n                for (var i = 0; i < numBlends; i++) {\n                  var sum = stack[base + i];\n\n                  for (var j = 0; j < blendVector.length; j++) {\n                    sum += blendVector[j] * stack[delta++];\n                  }\n\n                  stack[base + i] = sum;\n                }\n\n                while (numOperands--) {\n                  stack.pop();\n                }\n\n                break;\n              }\n\n            case 19: // hintmask\n\n            case 20:\n              // cntrmask\n              parseStems();\n              stream.pos += nStems + 7 >> 3;\n              break;\n\n            case 21:\n              // rmoveto\n              if (stack.length > 2) {\n                checkWidth();\n              }\n\n              x += stack.shift();\n              y += stack.shift();\n              moveTo(x, y);\n              break;\n\n            case 22:\n              // hmoveto\n              if (stack.length > 1) {\n                checkWidth();\n              }\n\n              x += stack.shift();\n              moveTo(x, y);\n              break;\n\n            case 24:\n              // rcurveline\n              while (stack.length >= 8) {\n                var c1x = x + stack.shift();\n                var c1y = y + stack.shift();\n                var c2x = c1x + stack.shift();\n                var c2y = c1y + stack.shift();\n                x = c2x + stack.shift();\n                y = c2y + stack.shift();\n                path.bezierCurveTo(c1x, c1y, c2x, c2y, x, y);\n              }\n\n              x += stack.shift();\n              y += stack.shift();\n              path.lineTo(x, y);\n              break;\n\n            case 25:\n              // rlinecurve\n              while (stack.length >= 8) {\n                x += stack.shift();\n                y += stack.shift();\n                path.lineTo(x, y);\n              }\n\n              var c1x = x + stack.shift();\n              var c1y = y + stack.shift();\n              var c2x = c1x + stack.shift();\n              var c2y = c1y + stack.shift();\n              x = c2x + stack.shift();\n              y = c2y + stack.shift();\n              path.bezierCurveTo(c1x, c1y, c2x, c2y, x, y);\n              break;\n\n            case 26:\n              // vvcurveto\n              if (stack.length % 2) {\n                x += stack.shift();\n              }\n\n              while (stack.length >= 4) {\n                c1x = x;\n                c1y = y + stack.shift();\n                c2x = c1x + stack.shift();\n                c2y = c1y + stack.shift();\n                x = c2x;\n                y = c2y + stack.shift();\n                path.bezierCurveTo(c1x, c1y, c2x, c2y, x, y);\n              }\n\n              break;\n\n            case 27:\n              // hhcurveto\n              if (stack.length % 2) {\n                y += stack.shift();\n              }\n\n              while (stack.length >= 4) {\n                c1x = x + stack.shift();\n                c1y = y;\n                c2x = c1x + stack.shift();\n                c2y = c1y + stack.shift();\n                x = c2x + stack.shift();\n                y = c2y;\n                path.bezierCurveTo(c1x, c1y, c2x, c2y, x, y);\n              }\n\n              break;\n\n            case 28:\n              // shortint\n              stack.push(stream.readInt16BE());\n              break;\n\n            case 29:\n              // callgsubr\n              index = stack.pop() + gsubrsBias;\n              subr = gsubrs[index];\n\n              if (subr) {\n                usedGsubrs[index] = true;\n                var p = stream.pos;\n                var e = end;\n                stream.pos = subr.offset;\n                end = subr.offset + subr.length;\n                parse();\n                stream.pos = p;\n                end = e;\n              }\n\n              break;\n\n            case 30: // vhcurveto\n\n            case 31:\n              // hvcurveto\n              phase = op === 31;\n\n              while (stack.length >= 4) {\n                if (phase) {\n                  c1x = x + stack.shift();\n                  c1y = y;\n                  c2x = c1x + stack.shift();\n                  c2y = c1y + stack.shift();\n                  y = c2y + stack.shift();\n                  x = c2x + (stack.length === 1 ? stack.shift() : 0);\n                } else {\n                  c1x = x;\n                  c1y = y + stack.shift();\n                  c2x = c1x + stack.shift();\n                  c2y = c1y + stack.shift();\n                  x = c2x + stack.shift();\n                  y = c2y + (stack.length === 1 ? stack.shift() : 0);\n                }\n\n                path.bezierCurveTo(c1x, c1y, c2x, c2y, x, y);\n                phase = !phase;\n              }\n\n              break;\n\n            case 12:\n              op = stream.readUInt8();\n\n              switch (op) {\n                case 3:\n                  // and\n                  var a = stack.pop();\n                  var b = stack.pop();\n                  stack.push(a && b ? 1 : 0);\n                  break;\n\n                case 4:\n                  // or\n                  a = stack.pop();\n                  b = stack.pop();\n                  stack.push(a || b ? 1 : 0);\n                  break;\n\n                case 5:\n                  // not\n                  a = stack.pop();\n                  stack.push(a ? 0 : 1);\n                  break;\n\n                case 9:\n                  // abs\n                  a = stack.pop();\n                  stack.push(Math.abs(a));\n                  break;\n\n                case 10:\n                  // add\n                  a = stack.pop();\n                  b = stack.pop();\n                  stack.push(a + b);\n                  break;\n\n                case 11:\n                  // sub\n                  a = stack.pop();\n                  b = stack.pop();\n                  stack.push(a - b);\n                  break;\n\n                case 12:\n                  // div\n                  a = stack.pop();\n                  b = stack.pop();\n                  stack.push(a / b);\n                  break;\n\n                case 14:\n                  // neg\n                  a = stack.pop();\n                  stack.push(-a);\n                  break;\n\n                case 15:\n                  // eq\n                  a = stack.pop();\n                  b = stack.pop();\n                  stack.push(a === b ? 1 : 0);\n                  break;\n\n                case 18:\n                  // drop\n                  stack.pop();\n                  break;\n\n                case 20:\n                  // put\n                  var val = stack.pop();\n                  var idx = stack.pop();\n                  trans[idx] = val;\n                  break;\n\n                case 21:\n                  // get\n                  idx = stack.pop();\n                  stack.push(trans[idx] || 0);\n                  break;\n\n                case 22:\n                  // ifelse\n                  var s1 = stack.pop();\n                  var s2 = stack.pop();\n                  var v1 = stack.pop();\n                  var v2 = stack.pop();\n                  stack.push(v1 <= v2 ? s1 : s2);\n                  break;\n\n                case 23:\n                  // random\n                  stack.push(Math.random());\n                  break;\n\n                case 24:\n                  // mul\n                  a = stack.pop();\n                  b = stack.pop();\n                  stack.push(a * b);\n                  break;\n\n                case 26:\n                  // sqrt\n                  a = stack.pop();\n                  stack.push(Math.sqrt(a));\n                  break;\n\n                case 27:\n                  // dup\n                  a = stack.pop();\n                  stack.push(a, a);\n                  break;\n\n                case 28:\n                  // exch\n                  a = stack.pop();\n                  b = stack.pop();\n                  stack.push(b, a);\n                  break;\n\n                case 29:\n                  // index\n                  idx = stack.pop();\n\n                  if (idx < 0) {\n                    idx = 0;\n                  } else if (idx > stack.length - 1) {\n                    idx = stack.length - 1;\n                  }\n\n                  stack.push(stack[idx]);\n                  break;\n\n                case 30:\n                  // roll\n                  var n = stack.pop();\n\n                  var _j = stack.pop();\n\n                  if (_j >= 0) {\n                    while (_j > 0) {\n                      var t = stack[n - 1];\n\n                      for (var _i = n - 2; _i >= 0; _i--) {\n                        stack[_i + 1] = stack[_i];\n                      }\n\n                      stack[0] = t;\n                      _j--;\n                    }\n                  } else {\n                    while (_j < 0) {\n                      var t = stack[0];\n\n                      for (var _i2 = 0; _i2 <= n; _i2++) {\n                        stack[_i2] = stack[_i2 + 1];\n                      }\n\n                      stack[n - 1] = t;\n                      _j++;\n                    }\n                  }\n\n                  break;\n\n                case 34:\n                  // hflex\n                  c1x = x + stack.shift();\n                  c1y = y;\n                  c2x = c1x + stack.shift();\n                  c2y = c1y + stack.shift();\n                  var c3x = c2x + stack.shift();\n                  var c3y = c2y;\n                  var c4x = c3x + stack.shift();\n                  var c4y = c3y;\n                  var c5x = c4x + stack.shift();\n                  var c5y = c4y;\n                  var c6x = c5x + stack.shift();\n                  var c6y = c5y;\n                  x = c6x;\n                  y = c6y;\n                  path.bezierCurveTo(c1x, c1y, c2x, c2y, c3x, c3y);\n                  path.bezierCurveTo(c4x, c4y, c5x, c5y, c6x, c6y);\n                  break;\n\n                case 35:\n                  // flex\n                  var pts = [];\n\n                  for (var _i3 = 0; _i3 <= 5; _i3++) {\n                    x += stack.shift();\n                    y += stack.shift();\n                    pts.push(x, y);\n                  }\n\n                  path.bezierCurveTo.apply(path, pts.slice(0, 6));\n                  path.bezierCurveTo.apply(path, pts.slice(6));\n                  stack.shift(); // fd\n\n                  break;\n\n                case 36:\n                  // hflex1\n                  c1x = x + stack.shift();\n                  c1y = y + stack.shift();\n                  c2x = c1x + stack.shift();\n                  c2y = c1y + stack.shift();\n                  c3x = c2x + stack.shift();\n                  c3y = c2y;\n                  c4x = c3x + stack.shift();\n                  c4y = c3y;\n                  c5x = c4x + stack.shift();\n                  c5y = c4y + stack.shift();\n                  c6x = c5x + stack.shift();\n                  c6y = c5y;\n                  x = c6x;\n                  y = c6y;\n                  path.bezierCurveTo(c1x, c1y, c2x, c2y, c3x, c3y);\n                  path.bezierCurveTo(c4x, c4y, c5x, c5y, c6x, c6y);\n                  break;\n\n                case 37:\n                  // flex1\n                  var startx = x;\n                  var starty = y;\n                  pts = [];\n\n                  for (var _i4 = 0; _i4 <= 4; _i4++) {\n                    x += stack.shift();\n                    y += stack.shift();\n                    pts.push(x, y);\n                  }\n\n                  if (Math.abs(x - startx) > Math.abs(y - starty)) {\n                    // horizontal\n                    x += stack.shift();\n                    y = starty;\n                  } else {\n                    x = startx;\n                    y += stack.shift();\n                  }\n\n                  pts.push(x, y);\n                  path.bezierCurveTo.apply(path, pts.slice(0, 6));\n                  path.bezierCurveTo.apply(path, pts.slice(6));\n                  break;\n\n                default:\n                  throw new Error('Unknown op: 12 ' + op);\n              }\n\n              break;\n\n            default:\n              throw new Error('Unknown op: ' + op);\n          }\n        } else if (op < 247) {\n          stack.push(op - 139);\n        } else if (op < 251) {\n          var b1 = stream.readUInt8();\n          stack.push((op - 247) * 256 + b1 + 108);\n        } else if (op < 255) {\n          var b1 = stream.readUInt8();\n          stack.push(-(op - 251) * 256 - b1 - 108);\n        } else {\n          stack.push(stream.readInt32BE() / 65536);\n        }\n      }\n    };\n\n    parse();\n\n    if (open) {\n      path.closePath();\n    }\n\n    return path;\n  };\n\n  return CFFGlyph;\n}(Glyph);\n\nvar SBIXImage = new r.Struct({\n  originX: r.uint16,\n  originY: r.uint16,\n  type: new r.String(4),\n  data: new r.Buffer(function (t) {\n    return t.parent.buflen - t._currentOffset;\n  })\n});\n/**\n * Represents a color (e.g. emoji) glyph in Apple's SBIX format.\n */\n\nvar SBIXGlyph = function (_TTFGlyph) {\n  _inherits(SBIXGlyph, _TTFGlyph);\n\n  function SBIXGlyph() {\n    _classCallCheck(this, SBIXGlyph);\n\n    return _possibleConstructorReturn(this, _TTFGlyph.apply(this, arguments));\n  }\n  /**\n   * Returns an object representing a glyph image at the given point size.\n   * The object has a data property with a Buffer containing the actual image data,\n   * along with the image type, and origin.\n   *\n   * @param {number} size\n   * @return {object}\n   */\n\n\n  SBIXGlyph.prototype.getImageForSize = function getImageForSize(size) {\n    for (var i = 0; i < this._font.sbix.imageTables.length; i++) {\n      var table = this._font.sbix.imageTables[i];\n\n      if (table.ppem >= size) {\n        break;\n      }\n    }\n\n    var offsets = table.imageOffsets;\n    var start = offsets[this.id];\n    var end = offsets[this.id + 1];\n\n    if (start === end) {\n      return null;\n    }\n\n    this._font.stream.pos = start;\n    return SBIXImage.decode(this._font.stream, {\n      buflen: end - start\n    });\n  };\n\n  SBIXGlyph.prototype.render = function render(ctx, size) {\n    var img = this.getImageForSize(size);\n\n    if (img != null) {\n      var scale = size / this._font.unitsPerEm;\n      ctx.image(img.data, {\n        height: size,\n        x: img.originX,\n        y: (this.bbox.minY - img.originY) * scale\n      });\n    }\n\n    if (this._font.sbix.flags.renderOutlines) {\n      _TTFGlyph.prototype.render.call(this, ctx, size);\n    }\n  };\n\n  return SBIXGlyph;\n}(TTFGlyph);\n\nvar COLRLayer = function COLRLayer(glyph, color) {\n  _classCallCheck(this, COLRLayer);\n\n  this.glyph = glyph;\n  this.color = color;\n};\n/**\n * Represents a color (e.g. emoji) glyph in Microsoft's COLR format.\n * Each glyph in this format contain a list of colored layers, each\n * of which  is another vector glyph.\n */\n\n\nvar COLRGlyph = function (_Glyph) {\n  _inherits(COLRGlyph, _Glyph);\n\n  function COLRGlyph() {\n    _classCallCheck(this, COLRGlyph);\n\n    return _possibleConstructorReturn(this, _Glyph.apply(this, arguments));\n  }\n\n  COLRGlyph.prototype._getBBox = function _getBBox() {\n    var bbox = new BBox();\n\n    for (var i = 0; i < this.layers.length; i++) {\n      var layer = this.layers[i];\n      var b = layer.glyph.bbox;\n      bbox.addPoint(b.minX, b.minY);\n      bbox.addPoint(b.maxX, b.maxY);\n    }\n\n    return bbox;\n  };\n  /**\n   * Returns an array of objects containing the glyph and color for\n   * each layer in the composite color glyph.\n   * @type {object[]}\n   */\n\n\n  COLRGlyph.prototype.render = function render(ctx, size) {\n    for (var _iterator = this.layers, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _getIterator(_iterator);;) {\n      var _ref;\n\n      if (_isArray) {\n        if (_i >= _iterator.length) break;\n        _ref = _iterator[_i++];\n      } else {\n        _i = _iterator.next();\n        if (_i.done) break;\n        _ref = _i.value;\n      }\n\n      var _ref2 = _ref,\n          glyph = _ref2.glyph,\n          color = _ref2.color;\n      ctx.fillColor([color.red, color.green, color.blue], color.alpha / 255 * 100);\n      glyph.render(ctx, size);\n    }\n\n    return;\n  };\n\n  _createClass(COLRGlyph, [{\n    key: 'layers',\n    get: function get() {\n      var cpal = this._font.CPAL;\n      var colr = this._font.COLR;\n      var low = 0;\n      var high = colr.baseGlyphRecord.length - 1;\n\n      while (low <= high) {\n        var mid = low + high >> 1;\n        var rec = colr.baseGlyphRecord[mid];\n\n        if (this.id < rec.gid) {\n          high = mid - 1;\n        } else if (this.id > rec.gid) {\n          low = mid + 1;\n        } else {\n          var baseLayer = rec;\n          break;\n        }\n      } // if base glyph not found in COLR table,\n      // default to normal glyph from glyf or CFF\n\n\n      if (baseLayer == null) {\n        var g = this._font._getBaseGlyph(this.id);\n\n        var color = {\n          red: 0,\n          green: 0,\n          blue: 0,\n          alpha: 255\n        };\n        return [new COLRLayer(g, color)];\n      } // otherwise, return an array of all the layers\n\n\n      var layers = [];\n\n      for (var i = baseLayer.firstLayerIndex; i < baseLayer.firstLayerIndex + baseLayer.numLayers; i++) {\n        var rec = colr.layerRecords[i];\n        var color = cpal.colorRecords[rec.paletteIndex];\n\n        var g = this._font._getBaseGlyph(rec.gid);\n\n        layers.push(new COLRLayer(g, color));\n      }\n\n      return layers;\n    }\n  }]);\n\n  return COLRGlyph;\n}(Glyph);\n\nvar TUPLES_SHARE_POINT_NUMBERS = 0x8000;\nvar TUPLE_COUNT_MASK = 0x0fff;\nvar EMBEDDED_TUPLE_COORD = 0x8000;\nvar INTERMEDIATE_TUPLE = 0x4000;\nvar PRIVATE_POINT_NUMBERS = 0x2000;\nvar TUPLE_INDEX_MASK = 0x0fff;\nvar POINTS_ARE_WORDS = 0x80;\nvar POINT_RUN_COUNT_MASK = 0x7f;\nvar DELTAS_ARE_ZERO = 0x80;\nvar DELTAS_ARE_WORDS = 0x40;\nvar DELTA_RUN_COUNT_MASK = 0x3f;\n/**\n * This class is transforms TrueType glyphs according to the data from\n * the Apple Advanced Typography variation tables (fvar, gvar, and avar).\n * These tables allow infinite adjustments to glyph weight, width, slant,\n * and optical size without the designer needing to specify every exact style.\n *\n * Apple's documentation for these tables is not great, so thanks to the\n * Freetype project for figuring much of this out.\n *\n * @private\n */\n\nvar GlyphVariationProcessor = function () {\n  function GlyphVariationProcessor(font, coords) {\n    _classCallCheck(this, GlyphVariationProcessor);\n\n    this.font = font;\n    this.normalizedCoords = this.normalizeCoords(coords);\n    this.blendVectors = new _Map();\n  }\n\n  GlyphVariationProcessor.prototype.normalizeCoords = function normalizeCoords(coords) {\n    // the default mapping is linear along each axis, in two segments:\n    // from the minValue to defaultValue, and from defaultValue to maxValue.\n    var normalized = [];\n\n    for (var i = 0; i < this.font.fvar.axis.length; i++) {\n      var axis = this.font.fvar.axis[i];\n\n      if (coords[i] < axis.defaultValue) {\n        normalized.push((coords[i] - axis.defaultValue + _Number$EPSILON) / (axis.defaultValue - axis.minValue + _Number$EPSILON));\n      } else {\n        normalized.push((coords[i] - axis.defaultValue + _Number$EPSILON) / (axis.maxValue - axis.defaultValue + _Number$EPSILON));\n      }\n    } // if there is an avar table, the normalized value is calculated\n    // by interpolating between the two nearest mapped values.\n\n\n    if (this.font.avar) {\n      for (var i = 0; i < this.font.avar.segment.length; i++) {\n        var segment = this.font.avar.segment[i];\n\n        for (var j = 0; j < segment.correspondence.length; j++) {\n          var pair = segment.correspondence[j];\n\n          if (j >= 1 && normalized[i] < pair.fromCoord) {\n            var prev = segment.correspondence[j - 1];\n            normalized[i] = ((normalized[i] - prev.fromCoord) * (pair.toCoord - prev.toCoord) + _Number$EPSILON) / (pair.fromCoord - prev.fromCoord + _Number$EPSILON) + prev.toCoord;\n            break;\n          }\n        }\n      }\n    }\n\n    return normalized;\n  };\n\n  GlyphVariationProcessor.prototype.transformPoints = function transformPoints(gid, glyphPoints) {\n    if (!this.font.fvar || !this.font.gvar) {\n      return;\n    }\n\n    var gvar = this.font.gvar;\n\n    if (gid >= gvar.glyphCount) {\n      return;\n    }\n\n    var offset = gvar.offsets[gid];\n\n    if (offset === gvar.offsets[gid + 1]) {\n      return;\n    } // Read the gvar data for this glyph\n\n\n    var stream = this.font.stream;\n    stream.pos = offset;\n\n    if (stream.pos >= stream.length) {\n      return;\n    }\n\n    var tupleCount = stream.readUInt16BE();\n    var offsetToData = offset + stream.readUInt16BE();\n\n    if (tupleCount & TUPLES_SHARE_POINT_NUMBERS) {\n      var here = stream.pos;\n      stream.pos = offsetToData;\n      var sharedPoints = this.decodePoints();\n      offsetToData = stream.pos;\n      stream.pos = here;\n    }\n\n    var origPoints = glyphPoints.map(function (pt) {\n      return pt.copy();\n    });\n    tupleCount &= TUPLE_COUNT_MASK;\n\n    for (var i = 0; i < tupleCount; i++) {\n      var tupleDataSize = stream.readUInt16BE();\n      var tupleIndex = stream.readUInt16BE();\n\n      if (tupleIndex & EMBEDDED_TUPLE_COORD) {\n        var tupleCoords = [];\n\n        for (var a = 0; a < gvar.axisCount; a++) {\n          tupleCoords.push(stream.readInt16BE() / 16384);\n        }\n      } else {\n        if ((tupleIndex & TUPLE_INDEX_MASK) >= gvar.globalCoordCount) {\n          throw new Error('Invalid gvar table');\n        }\n\n        var tupleCoords = gvar.globalCoords[tupleIndex & TUPLE_INDEX_MASK];\n      }\n\n      if (tupleIndex & INTERMEDIATE_TUPLE) {\n        var startCoords = [];\n\n        for (var _a = 0; _a < gvar.axisCount; _a++) {\n          startCoords.push(stream.readInt16BE() / 16384);\n        }\n\n        var endCoords = [];\n\n        for (var _a2 = 0; _a2 < gvar.axisCount; _a2++) {\n          endCoords.push(stream.readInt16BE() / 16384);\n        }\n      } // Get the factor at which to apply this tuple\n\n\n      var factor = this.tupleFactor(tupleIndex, tupleCoords, startCoords, endCoords);\n\n      if (factor === 0) {\n        offsetToData += tupleDataSize;\n        continue;\n      }\n\n      var here = stream.pos;\n      stream.pos = offsetToData;\n\n      if (tupleIndex & PRIVATE_POINT_NUMBERS) {\n        var points = this.decodePoints();\n      } else {\n        var points = sharedPoints;\n      } // points.length = 0 means there are deltas for all points\n\n\n      var nPoints = points.length === 0 ? glyphPoints.length : points.length;\n      var xDeltas = this.decodeDeltas(nPoints);\n      var yDeltas = this.decodeDeltas(nPoints);\n\n      if (points.length === 0) {\n        // all points\n        for (var _i = 0; _i < glyphPoints.length; _i++) {\n          var point = glyphPoints[_i];\n          point.x += Math.round(xDeltas[_i] * factor);\n          point.y += Math.round(yDeltas[_i] * factor);\n        }\n      } else {\n        var outPoints = origPoints.map(function (pt) {\n          return pt.copy();\n        });\n        var hasDelta = glyphPoints.map(function () {\n          return false;\n        });\n\n        for (var _i2 = 0; _i2 < points.length; _i2++) {\n          var idx = points[_i2];\n\n          if (idx < glyphPoints.length) {\n            var _point = outPoints[idx];\n            hasDelta[idx] = true;\n            _point.x += Math.round(xDeltas[_i2] * factor);\n            _point.y += Math.round(yDeltas[_i2] * factor);\n          }\n        }\n\n        this.interpolateMissingDeltas(outPoints, origPoints, hasDelta);\n\n        for (var _i3 = 0; _i3 < glyphPoints.length; _i3++) {\n          var deltaX = outPoints[_i3].x - origPoints[_i3].x;\n          var deltaY = outPoints[_i3].y - origPoints[_i3].y;\n          glyphPoints[_i3].x += deltaX;\n          glyphPoints[_i3].y += deltaY;\n        }\n      }\n\n      offsetToData += tupleDataSize;\n      stream.pos = here;\n    }\n  };\n\n  GlyphVariationProcessor.prototype.decodePoints = function decodePoints() {\n    var stream = this.font.stream;\n    var count = stream.readUInt8();\n\n    if (count & POINTS_ARE_WORDS) {\n      count = (count & POINT_RUN_COUNT_MASK) << 8 | stream.readUInt8();\n    }\n\n    var points = new Uint16Array(count);\n    var i = 0;\n    var point = 0;\n\n    while (i < count) {\n      var run = stream.readUInt8();\n      var runCount = (run & POINT_RUN_COUNT_MASK) + 1;\n      var fn = run & POINTS_ARE_WORDS ? stream.readUInt16 : stream.readUInt8;\n\n      for (var j = 0; j < runCount && i < count; j++) {\n        point += fn.call(stream);\n        points[i++] = point;\n      }\n    }\n\n    return points;\n  };\n\n  GlyphVariationProcessor.prototype.decodeDeltas = function decodeDeltas(count) {\n    var stream = this.font.stream;\n    var i = 0;\n    var deltas = new Int16Array(count);\n\n    while (i < count) {\n      var run = stream.readUInt8();\n      var runCount = (run & DELTA_RUN_COUNT_MASK) + 1;\n\n      if (run & DELTAS_ARE_ZERO) {\n        i += runCount;\n      } else {\n        var fn = run & DELTAS_ARE_WORDS ? stream.readInt16BE : stream.readInt8;\n\n        for (var j = 0; j < runCount && i < count; j++) {\n          deltas[i++] = fn.call(stream);\n        }\n      }\n    }\n\n    return deltas;\n  };\n\n  GlyphVariationProcessor.prototype.tupleFactor = function tupleFactor(tupleIndex, tupleCoords, startCoords, endCoords) {\n    var normalized = this.normalizedCoords;\n    var gvar = this.font.gvar;\n    var factor = 1;\n\n    for (var i = 0; i < gvar.axisCount; i++) {\n      if (tupleCoords[i] === 0) {\n        continue;\n      }\n\n      if (normalized[i] === 0) {\n        return 0;\n      }\n\n      if ((tupleIndex & INTERMEDIATE_TUPLE) === 0) {\n        if (normalized[i] < Math.min(0, tupleCoords[i]) || normalized[i] > Math.max(0, tupleCoords[i])) {\n          return 0;\n        }\n\n        factor = (factor * normalized[i] + _Number$EPSILON) / (tupleCoords[i] + _Number$EPSILON);\n      } else {\n        if (normalized[i] < startCoords[i] || normalized[i] > endCoords[i]) {\n          return 0;\n        } else if (normalized[i] < tupleCoords[i]) {\n          factor = factor * (normalized[i] - startCoords[i] + _Number$EPSILON) / (tupleCoords[i] - startCoords[i] + _Number$EPSILON);\n        } else {\n          factor = factor * (endCoords[i] - normalized[i] + _Number$EPSILON) / (endCoords[i] - tupleCoords[i] + _Number$EPSILON);\n        }\n      }\n    }\n\n    return factor;\n  }; // Interpolates points without delta values.\n  // Needed for the Ø and Q glyphs in Skia.\n  // Algorithm from Freetype.\n\n\n  GlyphVariationProcessor.prototype.interpolateMissingDeltas = function interpolateMissingDeltas(points, inPoints, hasDelta) {\n    if (points.length === 0) {\n      return;\n    }\n\n    var point = 0;\n\n    while (point < points.length) {\n      var firstPoint = point; // find the end point of the contour\n\n      var endPoint = point;\n      var pt = points[endPoint];\n\n      while (!pt.endContour) {\n        pt = points[++endPoint];\n      } // find the first point that has a delta\n\n\n      while (point <= endPoint && !hasDelta[point]) {\n        point++;\n      }\n\n      if (point > endPoint) {\n        continue;\n      }\n\n      var firstDelta = point;\n      var curDelta = point;\n      point++;\n\n      while (point <= endPoint) {\n        // find the next point with a delta, and interpolate intermediate points\n        if (hasDelta[point]) {\n          this.deltaInterpolate(curDelta + 1, point - 1, curDelta, point, inPoints, points);\n          curDelta = point;\n        }\n\n        point++;\n      } // shift contour if we only have a single delta\n\n\n      if (curDelta === firstDelta) {\n        this.deltaShift(firstPoint, endPoint, curDelta, inPoints, points);\n      } else {\n        // otherwise, handle the remaining points at the end and beginning of the contour\n        this.deltaInterpolate(curDelta + 1, endPoint, curDelta, firstDelta, inPoints, points);\n\n        if (firstDelta > 0) {\n          this.deltaInterpolate(firstPoint, firstDelta - 1, curDelta, firstDelta, inPoints, points);\n        }\n      }\n\n      point = endPoint + 1;\n    }\n  };\n\n  GlyphVariationProcessor.prototype.deltaInterpolate = function deltaInterpolate(p1, p2, ref1, ref2, inPoints, outPoints) {\n    if (p1 > p2) {\n      return;\n    }\n\n    var iterable = ['x', 'y'];\n\n    for (var i = 0; i < iterable.length; i++) {\n      var k = iterable[i];\n\n      if (inPoints[ref1][k] > inPoints[ref2][k]) {\n        var p = ref1;\n        ref1 = ref2;\n        ref2 = p;\n      }\n\n      var in1 = inPoints[ref1][k];\n      var in2 = inPoints[ref2][k];\n      var out1 = outPoints[ref1][k];\n      var out2 = outPoints[ref2][k]; // If the reference points have the same coordinate but different\n      // delta, inferred delta is zero.  Otherwise interpolate.\n\n      if (in1 !== in2 || out1 === out2) {\n        var scale = in1 === in2 ? 0 : (out2 - out1) / (in2 - in1);\n\n        for (var _p = p1; _p <= p2; _p++) {\n          var out = inPoints[_p][k];\n\n          if (out <= in1) {\n            out += out1 - in1;\n          } else if (out >= in2) {\n            out += out2 - in2;\n          } else {\n            out = out1 + (out - in1) * scale;\n          }\n\n          outPoints[_p][k] = out;\n        }\n      }\n    }\n  };\n\n  GlyphVariationProcessor.prototype.deltaShift = function deltaShift(p1, p2, ref, inPoints, outPoints) {\n    var deltaX = outPoints[ref].x - inPoints[ref].x;\n    var deltaY = outPoints[ref].y - inPoints[ref].y;\n\n    if (deltaX === 0 && deltaY === 0) {\n      return;\n    }\n\n    for (var p = p1; p <= p2; p++) {\n      if (p !== ref) {\n        outPoints[p].x += deltaX;\n        outPoints[p].y += deltaY;\n      }\n    }\n  };\n\n  GlyphVariationProcessor.prototype.getAdvanceAdjustment = function getAdvanceAdjustment(gid, table) {\n    var outerIndex = void 0,\n        innerIndex = void 0;\n\n    if (table.advanceWidthMapping) {\n      var idx = gid;\n\n      if (idx >= table.advanceWidthMapping.mapCount) {\n        idx = table.advanceWidthMapping.mapCount - 1;\n      }\n\n      var entryFormat = table.advanceWidthMapping.entryFormat;\n      var _table$advanceWidthMa = table.advanceWidthMapping.mapData[idx];\n      outerIndex = _table$advanceWidthMa.outerIndex;\n      innerIndex = _table$advanceWidthMa.innerIndex;\n    } else {\n      outerIndex = 0;\n      innerIndex = gid;\n    }\n\n    return this.getDelta(table.itemVariationStore, outerIndex, innerIndex);\n  }; // See pseudo code from `Font Variations Overview'\n  // in the OpenType specification.\n\n\n  GlyphVariationProcessor.prototype.getDelta = function getDelta(itemStore, outerIndex, innerIndex) {\n    if (outerIndex >= itemStore.itemVariationData.length) {\n      return 0;\n    }\n\n    var varData = itemStore.itemVariationData[outerIndex];\n\n    if (innerIndex >= varData.deltaSets.length) {\n      return 0;\n    }\n\n    var deltaSet = varData.deltaSets[innerIndex];\n    var blendVector = this.getBlendVector(itemStore, outerIndex);\n    var netAdjustment = 0;\n\n    for (var master = 0; master < varData.regionIndexCount; master++) {\n      netAdjustment += deltaSet.deltas[master] * blendVector[master];\n    }\n\n    return netAdjustment;\n  };\n\n  GlyphVariationProcessor.prototype.getBlendVector = function getBlendVector(itemStore, outerIndex) {\n    var varData = itemStore.itemVariationData[outerIndex];\n\n    if (this.blendVectors.has(varData)) {\n      return this.blendVectors.get(varData);\n    }\n\n    var normalizedCoords = this.normalizedCoords;\n    var blendVector = []; // outer loop steps through master designs to be blended\n\n    for (var master = 0; master < varData.regionIndexCount; master++) {\n      var scalar = 1;\n      var regionIndex = varData.regionIndexes[master];\n      var axes = itemStore.variationRegionList.variationRegions[regionIndex]; // inner loop steps through axes in this region\n\n      for (var j = 0; j < axes.length; j++) {\n        var axis = axes[j];\n        var axisScalar = void 0; // compute the scalar contribution of this axis\n        // ignore invalid ranges\n\n        if (axis.startCoord > axis.peakCoord || axis.peakCoord > axis.endCoord) {\n          axisScalar = 1;\n        } else if (axis.startCoord < 0 && axis.endCoord > 0 && axis.peakCoord !== 0) {\n          axisScalar = 1; // peak of 0 means ignore this axis\n        } else if (axis.peakCoord === 0) {\n          axisScalar = 1; // ignore this region if coords are out of range\n        } else if (normalizedCoords[j] < axis.startCoord || normalizedCoords[j] > axis.endCoord) {\n          axisScalar = 0; // calculate a proportional factor\n        } else {\n          if (normalizedCoords[j] === axis.peakCoord) {\n            axisScalar = 1;\n          } else if (normalizedCoords[j] < axis.peakCoord) {\n            axisScalar = (normalizedCoords[j] - axis.startCoord + _Number$EPSILON) / (axis.peakCoord - axis.startCoord + _Number$EPSILON);\n          } else {\n            axisScalar = (axis.endCoord - normalizedCoords[j] + _Number$EPSILON) / (axis.endCoord - axis.peakCoord + _Number$EPSILON);\n          }\n        } // take product of all the axis scalars\n\n\n        scalar *= axisScalar;\n      }\n\n      blendVector[master] = scalar;\n    }\n\n    this.blendVectors.set(varData, blendVector);\n    return blendVector;\n  };\n\n  return GlyphVariationProcessor;\n}();\n\nvar resolved = _Promise.resolve();\n\nvar Subset = function () {\n  function Subset(font) {\n    _classCallCheck(this, Subset);\n\n    this.font = font;\n    this.glyphs = [];\n    this.mapping = {}; // always include the missing glyph\n\n    this.includeGlyph(0);\n  }\n\n  Subset.prototype.includeGlyph = function includeGlyph(glyph) {\n    if ((typeof glyph === 'undefined' ? 'undefined' : _typeof(glyph)) === 'object') {\n      glyph = glyph.id;\n    }\n\n    if (this.mapping[glyph] == null) {\n      this.glyphs.push(glyph);\n      this.mapping[glyph] = this.glyphs.length - 1;\n    }\n\n    return this.mapping[glyph];\n  };\n\n  Subset.prototype.encodeStream = function encodeStream() {\n    var _this = this;\n\n    var s = new r.EncodeStream();\n    resolved.then(function () {\n      _this.encode(s);\n\n      return s.end();\n    });\n    return s;\n  };\n\n  return Subset;\n}(); // Flags for simple glyphs\n\n\nvar ON_CURVE$1 = 1 << 0;\nvar X_SHORT_VECTOR$1 = 1 << 1;\nvar Y_SHORT_VECTOR$1 = 1 << 2;\nvar REPEAT$1 = 1 << 3;\nvar SAME_X$1 = 1 << 4;\nvar SAME_Y$1 = 1 << 5;\n\nvar Point$1 = function () {\n  function Point() {\n    _classCallCheck(this, Point);\n  }\n\n  Point.size = function size(val) {\n    return val >= 0 && val <= 255 ? 1 : 2;\n  };\n\n  Point.encode = function encode(stream, value) {\n    if (value >= 0 && value <= 255) {\n      stream.writeUInt8(value);\n    } else {\n      stream.writeInt16BE(value);\n    }\n  };\n\n  return Point;\n}();\n\nvar Glyf = new r.Struct({\n  numberOfContours: r.int16,\n  // if negative, this is a composite glyph\n  xMin: r.int16,\n  yMin: r.int16,\n  xMax: r.int16,\n  yMax: r.int16,\n  endPtsOfContours: new r.Array(r.uint16, 'numberOfContours'),\n  instructions: new r.Array(r.uint8, r.uint16),\n  flags: new r.Array(r.uint8, 0),\n  xPoints: new r.Array(Point$1, 0),\n  yPoints: new r.Array(Point$1, 0)\n});\n/**\n * Encodes TrueType glyph outlines\n */\n\nvar TTFGlyphEncoder = function () {\n  function TTFGlyphEncoder() {\n    _classCallCheck(this, TTFGlyphEncoder);\n  }\n\n  TTFGlyphEncoder.prototype.encodeSimple = function encodeSimple(path) {\n    var instructions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    var endPtsOfContours = [];\n    var xPoints = [];\n    var yPoints = [];\n    var flags = [];\n    var same = 0;\n    var lastX = 0,\n        lastY = 0,\n        lastFlag = 0;\n    var pointCount = 0;\n\n    for (var i = 0; i < path.commands.length; i++) {\n      var c = path.commands[i];\n\n      for (var j = 0; j < c.args.length; j += 2) {\n        var x = c.args[j];\n        var y = c.args[j + 1];\n        var flag = 0; // If the ending point of a quadratic curve is the midpoint\n        // between the control point and the control point of the next\n        // quadratic curve, we can omit the ending point.\n\n        if (c.command === 'quadraticCurveTo' && j === 2) {\n          var next = path.commands[i + 1];\n\n          if (next && next.command === 'quadraticCurveTo') {\n            var midX = (lastX + next.args[0]) / 2;\n            var midY = (lastY + next.args[1]) / 2;\n\n            if (x === midX && y === midY) {\n              continue;\n            }\n          }\n        } // All points except control points are on curve.\n\n\n        if (!(c.command === 'quadraticCurveTo' && j === 0)) {\n          flag |= ON_CURVE$1;\n        }\n\n        flag = this._encodePoint(x, lastX, xPoints, flag, X_SHORT_VECTOR$1, SAME_X$1);\n        flag = this._encodePoint(y, lastY, yPoints, flag, Y_SHORT_VECTOR$1, SAME_Y$1);\n\n        if (flag === lastFlag && same < 255) {\n          flags[flags.length - 1] |= REPEAT$1;\n          same++;\n        } else {\n          if (same > 0) {\n            flags.push(same);\n            same = 0;\n          }\n\n          flags.push(flag);\n          lastFlag = flag;\n        }\n\n        lastX = x;\n        lastY = y;\n        pointCount++;\n      }\n\n      if (c.command === 'closePath') {\n        endPtsOfContours.push(pointCount - 1);\n      }\n    } // Close the path if the last command didn't already\n\n\n    if (path.commands.length > 1 && path.commands[path.commands.length - 1].command !== 'closePath') {\n      endPtsOfContours.push(pointCount - 1);\n    }\n\n    var bbox = path.bbox;\n    var glyf = {\n      numberOfContours: endPtsOfContours.length,\n      xMin: bbox.minX,\n      yMin: bbox.minY,\n      xMax: bbox.maxX,\n      yMax: bbox.maxY,\n      endPtsOfContours: endPtsOfContours,\n      instructions: instructions,\n      flags: flags,\n      xPoints: xPoints,\n      yPoints: yPoints\n    };\n    var size = Glyf.size(glyf);\n    var tail = 4 - size % 4;\n    var stream = new r.EncodeStream(size + tail);\n    Glyf.encode(stream, glyf); // Align to 4-byte length\n\n    if (tail !== 0) {\n      stream.fill(0, tail);\n    }\n\n    return stream.buffer;\n  };\n\n  TTFGlyphEncoder.prototype._encodePoint = function _encodePoint(value, last, points, flag, shortFlag, sameFlag) {\n    var diff = value - last;\n\n    if (value === last) {\n      flag |= sameFlag;\n    } else {\n      if (-255 <= diff && diff <= 255) {\n        flag |= shortFlag;\n\n        if (diff < 0) {\n          diff = -diff;\n        } else {\n          flag |= sameFlag;\n        }\n      }\n\n      points.push(diff);\n    }\n\n    return flag;\n  };\n\n  return TTFGlyphEncoder;\n}();\n\nvar TTFSubset = function (_Subset) {\n  _inherits(TTFSubset, _Subset);\n\n  function TTFSubset(font) {\n    _classCallCheck(this, TTFSubset);\n\n    var _this = _possibleConstructorReturn(this, _Subset.call(this, font));\n\n    _this.glyphEncoder = new TTFGlyphEncoder();\n    return _this;\n  }\n\n  TTFSubset.prototype._addGlyph = function _addGlyph(gid) {\n    var glyph = this.font.getGlyph(gid);\n\n    var glyf = glyph._decode(); // get the offset to the glyph from the loca table\n\n\n    var curOffset = this.font.loca.offsets[gid];\n    var nextOffset = this.font.loca.offsets[gid + 1];\n\n    var stream = this.font._getTableStream('glyf');\n\n    stream.pos += curOffset;\n    var buffer = stream.readBuffer(nextOffset - curOffset); // if it is a compound glyph, include its components\n\n    if (glyf && glyf.numberOfContours < 0) {\n      buffer = new Buffer(buffer);\n\n      for (var _iterator = glyf.components, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _getIterator(_iterator);;) {\n        var _ref;\n\n        if (_isArray) {\n          if (_i >= _iterator.length) break;\n          _ref = _iterator[_i++];\n        } else {\n          _i = _iterator.next();\n          if (_i.done) break;\n          _ref = _i.value;\n        }\n\n        var component = _ref;\n        gid = this.includeGlyph(component.glyphID);\n        buffer.writeUInt16BE(gid, component.pos);\n      }\n    } else if (glyf && this.font._variationProcessor) {\n      // If this is a TrueType variation glyph, re-encode the path\n      buffer = this.glyphEncoder.encodeSimple(glyph.path, glyf.instructions);\n    }\n\n    this.glyf.push(buffer);\n    this.loca.offsets.push(this.offset);\n    this.hmtx.metrics.push({\n      advance: glyph.advanceWidth,\n      bearing: glyph._getMetrics().leftBearing\n    });\n    this.offset += buffer.length;\n    return this.glyf.length - 1;\n  };\n\n  TTFSubset.prototype.encode = function encode(stream) {\n    // tables required by PDF spec:\n    //   head, hhea, loca, maxp, cvt , prep, glyf, hmtx, fpgm\n    //\n    // additional tables required for standalone fonts:\n    //   name, cmap, OS/2, post\n    this.glyf = [];\n    this.offset = 0;\n    this.loca = {\n      offsets: [],\n      version: this.font.loca.version\n    };\n    this.hmtx = {\n      metrics: [],\n      bearings: []\n    }; // include all the glyphs\n    // not using a for loop because we need to support adding more\n    // glyphs to the array as we go, and CoffeeScript caches the length.\n\n    var i = 0;\n\n    while (i < this.glyphs.length) {\n      this._addGlyph(this.glyphs[i++]);\n    }\n\n    var maxp = cloneDeep(this.font.maxp);\n    maxp.numGlyphs = this.glyf.length;\n    this.loca.offsets.push(this.offset);\n    var head = cloneDeep(this.font.head);\n    head.indexToLocFormat = this.loca.version;\n    var hhea = cloneDeep(this.font.hhea);\n    hhea.numberOfMetrics = this.hmtx.metrics.length; // map = []\n    // for index in [0...256]\n    //     if index < @numGlyphs\n    //         map[index] = index\n    //     else\n    //         map[index] = 0\n    //\n    // cmapTable =\n    //     version: 0\n    //     length: 262\n    //     language: 0\n    //     codeMap: map\n    //\n    // cmap =\n    //     version: 0\n    //     numSubtables: 1\n    //     tables: [\n    //         platformID: 1\n    //         encodingID: 0\n    //         table: cmapTable\n    //     ]\n    // TODO: subset prep, cvt, fpgm?\n\n    Directory.encode(stream, {\n      tables: {\n        head: head,\n        hhea: hhea,\n        loca: this.loca,\n        maxp: maxp,\n        'cvt ': this.font['cvt '],\n        prep: this.font.prep,\n        glyf: this.glyf,\n        hmtx: this.hmtx,\n        fpgm: this.font.fpgm // name: clone @font.name\n        // 'OS/2': clone @font['OS/2']\n        // post: clone @font.post\n        // cmap: cmap\n\n      }\n    });\n  };\n\n  return TTFSubset;\n}(Subset);\n\nvar CFFSubset = function (_Subset) {\n  _inherits(CFFSubset, _Subset);\n\n  function CFFSubset(font) {\n    _classCallCheck(this, CFFSubset);\n\n    var _this = _possibleConstructorReturn(this, _Subset.call(this, font));\n\n    _this.cff = _this.font['CFF '];\n\n    if (!_this.cff) {\n      throw new Error('Not a CFF Font');\n    }\n\n    return _this;\n  }\n\n  CFFSubset.prototype.subsetCharstrings = function subsetCharstrings() {\n    this.charstrings = [];\n    var gsubrs = {};\n\n    for (var _iterator = this.glyphs, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _getIterator(_iterator);;) {\n      var _ref;\n\n      if (_isArray) {\n        if (_i >= _iterator.length) break;\n        _ref = _iterator[_i++];\n      } else {\n        _i = _iterator.next();\n        if (_i.done) break;\n        _ref = _i.value;\n      }\n\n      var gid = _ref;\n      this.charstrings.push(this.cff.getCharString(gid));\n      var glyph = this.font.getGlyph(gid);\n      var path = glyph.path; // this causes the glyph to be parsed\n\n      for (var subr in glyph._usedGsubrs) {\n        gsubrs[subr] = true;\n      }\n    }\n\n    this.gsubrs = this.subsetSubrs(this.cff.globalSubrIndex, gsubrs);\n  };\n\n  CFFSubset.prototype.subsetSubrs = function subsetSubrs(subrs, used) {\n    var res = [];\n\n    for (var i = 0; i < subrs.length; i++) {\n      var subr = subrs[i];\n\n      if (used[i]) {\n        this.cff.stream.pos = subr.offset;\n        res.push(this.cff.stream.readBuffer(subr.length));\n      } else {\n        res.push(new Buffer([11])); // return\n      }\n    }\n\n    return res;\n  };\n\n  CFFSubset.prototype.subsetFontdict = function subsetFontdict(topDict) {\n    topDict.FDArray = [];\n    topDict.FDSelect = {\n      version: 0,\n      fds: []\n    };\n    var used_fds = {};\n    var used_subrs = [];\n\n    for (var _iterator2 = this.glyphs, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _getIterator(_iterator2);;) {\n      var _ref2;\n\n      if (_isArray2) {\n        if (_i2 >= _iterator2.length) break;\n        _ref2 = _iterator2[_i2++];\n      } else {\n        _i2 = _iterator2.next();\n        if (_i2.done) break;\n        _ref2 = _i2.value;\n      }\n\n      var gid = _ref2;\n      var fd = this.cff.fdForGlyph(gid);\n\n      if (fd == null) {\n        continue;\n      }\n\n      if (!used_fds[fd]) {\n        topDict.FDArray.push(_Object$assign({}, this.cff.topDict.FDArray[fd]));\n        used_subrs.push({});\n      }\n\n      used_fds[fd] = true;\n      topDict.FDSelect.fds.push(topDict.FDArray.length - 1);\n      var glyph = this.font.getGlyph(gid);\n      var path = glyph.path; // this causes the glyph to be parsed\n\n      for (var subr in glyph._usedSubrs) {\n        used_subrs[used_subrs.length - 1][subr] = true;\n      }\n    }\n\n    for (var i = 0; i < topDict.FDArray.length; i++) {\n      var dict = topDict.FDArray[i];\n      delete dict.FontName;\n\n      if (dict.Private && dict.Private.Subrs) {\n        dict.Private = _Object$assign({}, dict.Private);\n        dict.Private.Subrs = this.subsetSubrs(dict.Private.Subrs, used_subrs[i]);\n      }\n    }\n\n    return;\n  };\n\n  CFFSubset.prototype.createCIDFontdict = function createCIDFontdict(topDict) {\n    var used_subrs = {};\n\n    for (var _iterator3 = this.glyphs, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _getIterator(_iterator3);;) {\n      var _ref3;\n\n      if (_isArray3) {\n        if (_i3 >= _iterator3.length) break;\n        _ref3 = _iterator3[_i3++];\n      } else {\n        _i3 = _iterator3.next();\n        if (_i3.done) break;\n        _ref3 = _i3.value;\n      }\n\n      var gid = _ref3;\n      var glyph = this.font.getGlyph(gid);\n      var path = glyph.path; // this causes the glyph to be parsed\n\n      for (var subr in glyph._usedSubrs) {\n        used_subrs[subr] = true;\n      }\n    }\n\n    var privateDict = _Object$assign({}, this.cff.topDict.Private);\n\n    if (this.cff.topDict.Private && this.cff.topDict.Private.Subrs) {\n      privateDict.Subrs = this.subsetSubrs(this.cff.topDict.Private.Subrs, used_subrs);\n    }\n\n    topDict.FDArray = [{\n      Private: privateDict\n    }];\n    return topDict.FDSelect = {\n      version: 3,\n      nRanges: 1,\n      ranges: [{\n        first: 0,\n        fd: 0\n      }],\n      sentinel: this.charstrings.length\n    };\n  };\n\n  CFFSubset.prototype.addString = function addString(string) {\n    if (!string) {\n      return null;\n    }\n\n    if (!this.strings) {\n      this.strings = [];\n    }\n\n    this.strings.push(string);\n    return standardStrings.length + this.strings.length - 1;\n  };\n\n  CFFSubset.prototype.encode = function encode(stream) {\n    this.subsetCharstrings();\n    var charset = {\n      version: this.charstrings.length > 255 ? 2 : 1,\n      ranges: [{\n        first: 1,\n        nLeft: this.charstrings.length - 2\n      }]\n    };\n\n    var topDict = _Object$assign({}, this.cff.topDict);\n\n    topDict.Private = null;\n    topDict.charset = charset;\n    topDict.Encoding = null;\n    topDict.CharStrings = this.charstrings;\n    var _arr = ['version', 'Notice', 'Copyright', 'FullName', 'FamilyName', 'Weight', 'PostScript', 'BaseFontName', 'FontName'];\n\n    for (var _i4 = 0; _i4 < _arr.length; _i4++) {\n      var key = _arr[_i4];\n      topDict[key] = this.addString(this.cff.string(topDict[key]));\n    }\n\n    topDict.ROS = [this.addString('Adobe'), this.addString('Identity'), 0];\n    topDict.CIDCount = this.charstrings.length;\n\n    if (this.cff.isCIDFont) {\n      this.subsetFontdict(topDict);\n    } else {\n      this.createCIDFontdict(topDict);\n    }\n\n    var top = {\n      version: 1,\n      hdrSize: this.cff.hdrSize,\n      offSize: 4,\n      header: this.cff.header,\n      nameIndex: [this.cff.postscriptName],\n      topDictIndex: [topDict],\n      stringIndex: this.strings,\n      globalSubrIndex: this.gsubrs\n    };\n    CFFTop.encode(stream, top);\n  };\n\n  return CFFSubset;\n}(Subset);\n\nvar _class;\n\nfunction _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {\n  var desc = {};\n  Object['ke' + 'ys'](descriptor).forEach(function (key) {\n    desc[key] = descriptor[key];\n  });\n  desc.enumerable = !!desc.enumerable;\n  desc.configurable = !!desc.configurable;\n\n  if ('value' in desc || desc.initializer) {\n    desc.writable = true;\n  }\n\n  desc = decorators.slice().reverse().reduce(function (desc, decorator) {\n    return decorator(target, property, desc) || desc;\n  }, desc);\n\n  if (context && desc.initializer !== void 0) {\n    desc.value = desc.initializer ? desc.initializer.call(context) : void 0;\n    desc.initializer = undefined;\n  }\n\n  if (desc.initializer === void 0) {\n    Object['define' + 'Property'](target, property, desc);\n    desc = null;\n  }\n\n  return desc;\n}\n/**\n * This is the base class for all SFNT-based font formats in fontkit.\n * It supports TrueType, and PostScript glyphs, and several color glyph formats.\n */\n\n\nvar TTFFont = (_class = function () {\n  TTFFont.probe = function probe(buffer) {\n    var format = buffer.toString('ascii', 0, 4);\n    return format === 'true' || format === 'OTTO' || format === String.fromCharCode(0, 1, 0, 0);\n  };\n\n  function TTFFont(stream) {\n    var variationCoords = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n    _classCallCheck(this, TTFFont);\n\n    this.defaultLanguage = null;\n    this.stream = stream;\n    this.variationCoords = variationCoords;\n    this._directoryPos = this.stream.pos;\n    this._tables = {};\n    this._glyphs = {};\n\n    this._decodeDirectory(); // define properties for each table to lazily parse\n\n\n    for (var tag in this.directory.tables) {\n      var table = this.directory.tables[tag];\n\n      if (tables[tag] && table.length > 0) {\n        _Object$defineProperty(this, tag, {\n          get: this._getTable.bind(this, table)\n        });\n      }\n    }\n  }\n\n  TTFFont.prototype.setDefaultLanguage = function setDefaultLanguage() {\n    var lang = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    this.defaultLanguage = lang;\n  };\n\n  TTFFont.prototype._getTable = function _getTable(table) {\n    if (!(table.tag in this._tables)) {\n      try {\n        this._tables[table.tag] = this._decodeTable(table);\n      } catch (e) {\n        if (fontkit.logErrors) {\n          console.error('Error decoding table ' + table.tag);\n          console.error(e.stack);\n        }\n      }\n    }\n\n    return this._tables[table.tag];\n  };\n\n  TTFFont.prototype._getTableStream = function _getTableStream(tag) {\n    var table = this.directory.tables[tag];\n\n    if (table) {\n      this.stream.pos = table.offset;\n      return this.stream;\n    }\n\n    return null;\n  };\n\n  TTFFont.prototype._decodeDirectory = function _decodeDirectory() {\n    return this.directory = Directory.decode(this.stream, {\n      _startOffset: 0\n    });\n  };\n\n  TTFFont.prototype._decodeTable = function _decodeTable(table) {\n    var pos = this.stream.pos;\n\n    var stream = this._getTableStream(table.tag);\n\n    var result = tables[table.tag].decode(stream, this, table.length);\n    this.stream.pos = pos;\n    return result;\n  };\n  /**\n   * Gets a string from the font's `name` table\n   * `lang` is a BCP-47 language code.\n   * @return {string}\n   */\n\n\n  TTFFont.prototype.getName = function getName(key) {\n    var lang = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.defaultLanguage || fontkit.defaultLanguage;\n    var record = this.name && this.name.records[key];\n\n    if (record) {\n      // Attempt to retrieve the entry, depending on which translation is available:\n      return record[lang] || record[this.defaultLanguage] || record[fontkit.defaultLanguage] || record['en'] || record[_Object$keys(record)[0]] // Seriously, ANY language would be fine\n      || null;\n    }\n\n    return null;\n  };\n  /**\n   * The unique PostScript name for this font, e.g. \"Helvetica-Bold\"\n   * @type {string}\n   */\n\n  /**\n   * Returns whether there is glyph in the font for the given unicode code point.\n   *\n   * @param {number} codePoint\n   * @return {boolean}\n   */\n\n\n  TTFFont.prototype.hasGlyphForCodePoint = function hasGlyphForCodePoint(codePoint) {\n    return !!this._cmapProcessor.lookup(codePoint);\n  };\n  /**\n   * Maps a single unicode code point to a Glyph object.\n   * Does not perform any advanced substitutions (there is no context to do so).\n   *\n   * @param {number} codePoint\n   * @return {Glyph}\n   */\n\n\n  TTFFont.prototype.glyphForCodePoint = function glyphForCodePoint(codePoint) {\n    return this.getGlyph(this._cmapProcessor.lookup(codePoint), [codePoint]);\n  };\n  /**\n   * Returns an array of Glyph objects for the given string.\n   * This is only a one-to-one mapping from characters to glyphs.\n   * For most uses, you should use font.layout (described below), which\n   * provides a much more advanced mapping supporting AAT and OpenType shaping.\n   *\n   * @param {string} string\n   * @return {Glyph[]}\n   */\n\n\n  TTFFont.prototype.glyphsForString = function glyphsForString(string) {\n    var glyphs = [];\n    var len = string.length;\n    var idx = 0;\n    var last = -1;\n    var state = -1;\n\n    while (idx <= len) {\n      var code = 0;\n      var nextState = 0;\n\n      if (idx < len) {\n        // Decode the next codepoint from UTF 16\n        code = string.charCodeAt(idx++);\n\n        if (0xd800 <= code && code <= 0xdbff && idx < len) {\n          var next = string.charCodeAt(idx);\n\n          if (0xdc00 <= next && next <= 0xdfff) {\n            idx++;\n            code = ((code & 0x3ff) << 10) + (next & 0x3ff) + 0x10000;\n          }\n        } // Compute the next state: 1 if the next codepoint is a variation selector, 0 otherwise.\n\n\n        nextState = 0xfe00 <= code && code <= 0xfe0f || 0xe0100 <= code && code <= 0xe01ef ? 1 : 0;\n      } else {\n        idx++;\n      }\n\n      if (state === 0 && nextState === 1) {\n        // Variation selector following normal codepoint.\n        glyphs.push(this.getGlyph(this._cmapProcessor.lookup(last, code), [last, code]));\n      } else if (state === 0 && nextState === 0) {\n        // Normal codepoint following normal codepoint.\n        glyphs.push(this.glyphForCodePoint(last));\n      }\n\n      last = code;\n      state = nextState;\n    }\n\n    return glyphs;\n  };\n  /**\n   * Returns a GlyphRun object, which includes an array of Glyphs and GlyphPositions for the given string.\n   *\n   * @param {string} string\n   * @param {string[]} [userFeatures]\n   * @param {string} [script]\n   * @param {string} [language]\n   * @param {string} [direction]\n   * @return {GlyphRun}\n   */\n\n\n  TTFFont.prototype.layout = function layout(string, userFeatures, script, language, direction) {\n    return this._layoutEngine.layout(string, userFeatures, script, language, direction);\n  };\n  /**\n   * Returns an array of strings that map to the given glyph id.\n   * @param {number} gid - glyph id\n   */\n\n\n  TTFFont.prototype.stringsForGlyph = function stringsForGlyph(gid) {\n    return this._layoutEngine.stringsForGlyph(gid);\n  };\n  /**\n   * An array of all [OpenType feature tags](https://www.microsoft.com/typography/otspec/featuretags.htm)\n   * (or mapped AAT tags) supported by the font.\n   * The features parameter is an array of OpenType feature tags to be applied in addition to the default set.\n   * If this is an AAT font, the OpenType feature tags are mapped to AAT features.\n   *\n   * @type {string[]}\n   */\n\n\n  TTFFont.prototype.getAvailableFeatures = function getAvailableFeatures(script, language) {\n    return this._layoutEngine.getAvailableFeatures(script, language);\n  };\n\n  TTFFont.prototype._getBaseGlyph = function _getBaseGlyph(glyph) {\n    var characters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\n    if (!this._glyphs[glyph]) {\n      if (this.directory.tables.glyf) {\n        this._glyphs[glyph] = new TTFGlyph(glyph, characters, this);\n      } else if (this.directory.tables['CFF '] || this.directory.tables.CFF2) {\n        this._glyphs[glyph] = new CFFGlyph(glyph, characters, this);\n      }\n    }\n\n    return this._glyphs[glyph] || null;\n  };\n  /**\n   * Returns a glyph object for the given glyph id.\n   * You can pass the array of code points this glyph represents for\n   * your use later, and it will be stored in the glyph object.\n   *\n   * @param {number} glyph\n   * @param {number[]} characters\n   * @return {Glyph}\n   */\n\n\n  TTFFont.prototype.getGlyph = function getGlyph(glyph) {\n    var characters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\n    if (!this._glyphs[glyph]) {\n      if (this.directory.tables.sbix) {\n        this._glyphs[glyph] = new SBIXGlyph(glyph, characters, this);\n      } else if (this.directory.tables.COLR && this.directory.tables.CPAL) {\n        this._glyphs[glyph] = new COLRGlyph(glyph, characters, this);\n      } else {\n        this._getBaseGlyph(glyph, characters);\n      }\n    }\n\n    return this._glyphs[glyph] || null;\n  };\n  /**\n   * Returns a Subset for this font.\n   * @return {Subset}\n   */\n\n\n  TTFFont.prototype.createSubset = function createSubset() {\n    if (this.directory.tables['CFF ']) {\n      return new CFFSubset(this);\n    }\n\n    return new TTFSubset(this);\n  };\n  /**\n   * Returns an object describing the available variation axes\n   * that this font supports. Keys are setting tags, and values\n   * contain the axis name, range, and default value.\n   *\n   * @type {object}\n   */\n\n  /**\n   * Returns a new font with the given variation settings applied.\n   * Settings can either be an instance name, or an object containing\n   * variation tags as specified by the `variationAxes` property.\n   *\n   * @param {object} settings\n   * @return {TTFFont}\n   */\n\n\n  TTFFont.prototype.getVariation = function getVariation(settings) {\n    if (!(this.directory.tables.fvar && (this.directory.tables.gvar && this.directory.tables.glyf || this.directory.tables.CFF2))) {\n      throw new Error('Variations require a font with the fvar, gvar and glyf, or CFF2 tables.');\n    }\n\n    if (typeof settings === 'string') {\n      settings = this.namedVariations[settings];\n    }\n\n    if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) !== 'object') {\n      throw new Error('Variation settings must be either a variation name or settings object.');\n    } // normalize the coordinates\n\n\n    var coords = this.fvar.axis.map(function (axis, i) {\n      var axisTag = axis.axisTag.trim();\n\n      if (axisTag in settings) {\n        return Math.max(axis.minValue, Math.min(axis.maxValue, settings[axisTag]));\n      } else {\n        return axis.defaultValue;\n      }\n    });\n    var stream = new r.DecodeStream(this.stream.buffer);\n    stream.pos = this._directoryPos;\n    var font = new TTFFont(stream, coords);\n    font._tables = this._tables;\n    return font;\n  }; // Standardized format plugin API\n\n\n  TTFFont.prototype.getFont = function getFont(name) {\n    return this.getVariation(name);\n  };\n\n  _createClass(TTFFont, [{\n    key: 'postscriptName',\n    get: function get() {\n      return this.getName('postscriptName');\n    }\n    /**\n     * The font's full name, e.g. \"Helvetica Bold\"\n     * @type {string}\n     */\n\n  }, {\n    key: 'fullName',\n    get: function get() {\n      return this.getName('fullName');\n    }\n    /**\n     * The font's family name, e.g. \"Helvetica\"\n     * @type {string}\n     */\n\n  }, {\n    key: 'familyName',\n    get: function get() {\n      return this.getName('fontFamily');\n    }\n    /**\n     * The font's sub-family, e.g. \"Bold\".\n     * @type {string}\n     */\n\n  }, {\n    key: 'subfamilyName',\n    get: function get() {\n      return this.getName('fontSubfamily');\n    }\n    /**\n     * The font's copyright information\n     * @type {string}\n     */\n\n  }, {\n    key: 'copyright',\n    get: function get() {\n      return this.getName('copyright');\n    }\n    /**\n     * The font's version number\n     * @type {string}\n     */\n\n  }, {\n    key: 'version',\n    get: function get() {\n      return this.getName('version');\n    }\n    /**\n     * The font’s [ascender](https://en.wikipedia.org/wiki/Ascender_(typography))\n     * @type {number}\n     */\n\n  }, {\n    key: 'ascent',\n    get: function get() {\n      return this.hhea.ascent;\n    }\n    /**\n     * The font’s [descender](https://en.wikipedia.org/wiki/Descender)\n     * @type {number}\n     */\n\n  }, {\n    key: 'descent',\n    get: function get() {\n      return this.hhea.descent;\n    }\n    /**\n     * The amount of space that should be included between lines\n     * @type {number}\n     */\n\n  }, {\n    key: 'lineGap',\n    get: function get() {\n      return this.hhea.lineGap;\n    }\n    /**\n     * The offset from the normal underline position that should be used\n     * @type {number}\n     */\n\n  }, {\n    key: 'underlinePosition',\n    get: function get() {\n      return this.post.underlinePosition;\n    }\n    /**\n     * The weight of the underline that should be used\n     * @type {number}\n     */\n\n  }, {\n    key: 'underlineThickness',\n    get: function get() {\n      return this.post.underlineThickness;\n    }\n    /**\n     * If this is an italic font, the angle the cursor should be drawn at to match the font design\n     * @type {number}\n     */\n\n  }, {\n    key: 'italicAngle',\n    get: function get() {\n      return this.post.italicAngle;\n    }\n    /**\n     * The height of capital letters above the baseline.\n     * See [here](https://en.wikipedia.org/wiki/Cap_height) for more details.\n     * @type {number}\n     */\n\n  }, {\n    key: 'capHeight',\n    get: function get() {\n      var os2 = this['OS/2'];\n      return os2 ? os2.capHeight : this.ascent;\n    }\n    /**\n     * The height of lower case letters in the font.\n     * See [here](https://en.wikipedia.org/wiki/X-height) for more details.\n     * @type {number}\n     */\n\n  }, {\n    key: 'xHeight',\n    get: function get() {\n      var os2 = this['OS/2'];\n      return os2 ? os2.xHeight : 0;\n    }\n    /**\n     * The number of glyphs in the font.\n     * @type {number}\n     */\n\n  }, {\n    key: 'numGlyphs',\n    get: function get() {\n      return this.maxp.numGlyphs;\n    }\n    /**\n     * The size of the font’s internal coordinate grid\n     * @type {number}\n     */\n\n  }, {\n    key: 'unitsPerEm',\n    get: function get() {\n      return this.head.unitsPerEm;\n    }\n    /**\n     * The font’s bounding box, i.e. the box that encloses all glyphs in the font.\n     * @type {BBox}\n     */\n\n  }, {\n    key: 'bbox',\n    get: function get() {\n      return _Object$freeze(new BBox(this.head.xMin, this.head.yMin, this.head.xMax, this.head.yMax));\n    }\n  }, {\n    key: '_cmapProcessor',\n    get: function get() {\n      return new CmapProcessor(this.cmap);\n    }\n    /**\n     * An array of all of the unicode code points supported by the font.\n     * @type {number[]}\n     */\n\n  }, {\n    key: 'characterSet',\n    get: function get() {\n      return this._cmapProcessor.getCharacterSet();\n    }\n  }, {\n    key: '_layoutEngine',\n    get: function get() {\n      return new LayoutEngine(this);\n    }\n  }, {\n    key: 'availableFeatures',\n    get: function get() {\n      return this._layoutEngine.getAvailableFeatures();\n    }\n  }, {\n    key: 'variationAxes',\n    get: function get() {\n      var res = {};\n\n      if (!this.fvar) {\n        return res;\n      }\n\n      for (var _iterator = this.fvar.axis, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _getIterator(_iterator);;) {\n        var _ref;\n\n        if (_isArray) {\n          if (_i >= _iterator.length) break;\n          _ref = _iterator[_i++];\n        } else {\n          _i = _iterator.next();\n          if (_i.done) break;\n          _ref = _i.value;\n        }\n\n        var axis = _ref;\n        res[axis.axisTag.trim()] = {\n          name: axis.name.en,\n          min: axis.minValue,\n          default: axis.defaultValue,\n          max: axis.maxValue\n        };\n      }\n\n      return res;\n    }\n    /**\n     * Returns an object describing the named variation instances\n     * that the font designer has specified. Keys are variation names\n     * and values are the variation settings for this instance.\n     *\n     * @type {object}\n     */\n\n  }, {\n    key: 'namedVariations',\n    get: function get() {\n      var res = {};\n\n      if (!this.fvar) {\n        return res;\n      }\n\n      for (var _iterator2 = this.fvar.instance, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _getIterator(_iterator2);;) {\n        var _ref2;\n\n        if (_isArray2) {\n          if (_i2 >= _iterator2.length) break;\n          _ref2 = _iterator2[_i2++];\n        } else {\n          _i2 = _iterator2.next();\n          if (_i2.done) break;\n          _ref2 = _i2.value;\n        }\n\n        var instance = _ref2;\n        var settings = {};\n\n        for (var i = 0; i < this.fvar.axis.length; i++) {\n          var axis = this.fvar.axis[i];\n          settings[axis.axisTag.trim()] = instance.coord[i];\n        }\n\n        res[instance.name.en] = settings;\n      }\n\n      return res;\n    }\n  }, {\n    key: '_variationProcessor',\n    get: function get() {\n      if (!this.fvar) {\n        return null;\n      }\n\n      var variationCoords = this.variationCoords; // Ignore if no variation coords and not CFF2\n\n      if (!variationCoords && !this.CFF2) {\n        return null;\n      }\n\n      if (!variationCoords) {\n        variationCoords = this.fvar.axis.map(function (axis) {\n          return axis.defaultValue;\n        });\n      }\n\n      return new GlyphVariationProcessor(this, variationCoords);\n    }\n  }]);\n\n  return TTFFont;\n}(), (_applyDecoratedDescriptor(_class.prototype, 'bbox', [cache], _Object$getOwnPropertyDescriptor(_class.prototype, 'bbox'), _class.prototype), _applyDecoratedDescriptor(_class.prototype, '_cmapProcessor', [cache], _Object$getOwnPropertyDescriptor(_class.prototype, '_cmapProcessor'), _class.prototype), _applyDecoratedDescriptor(_class.prototype, 'characterSet', [cache], _Object$getOwnPropertyDescriptor(_class.prototype, 'characterSet'), _class.prototype), _applyDecoratedDescriptor(_class.prototype, '_layoutEngine', [cache], _Object$getOwnPropertyDescriptor(_class.prototype, '_layoutEngine'), _class.prototype), _applyDecoratedDescriptor(_class.prototype, 'variationAxes', [cache], _Object$getOwnPropertyDescriptor(_class.prototype, 'variationAxes'), _class.prototype), _applyDecoratedDescriptor(_class.prototype, 'namedVariations', [cache], _Object$getOwnPropertyDescriptor(_class.prototype, 'namedVariations'), _class.prototype), _applyDecoratedDescriptor(_class.prototype, '_variationProcessor', [cache], _Object$getOwnPropertyDescriptor(_class.prototype, '_variationProcessor'), _class.prototype)), _class);\nvar WOFFDirectoryEntry = new r.Struct({\n  tag: new r.String(4),\n  offset: new r.Pointer(r.uint32, 'void', {\n    type: 'global'\n  }),\n  compLength: r.uint32,\n  length: r.uint32,\n  origChecksum: r.uint32\n});\nvar WOFFDirectory = new r.Struct({\n  tag: new r.String(4),\n  // should be 'wOFF'\n  flavor: r.uint32,\n  length: r.uint32,\n  numTables: r.uint16,\n  reserved: new r.Reserved(r.uint16),\n  totalSfntSize: r.uint32,\n  majorVersion: r.uint16,\n  minorVersion: r.uint16,\n  metaOffset: r.uint32,\n  metaLength: r.uint32,\n  metaOrigLength: r.uint32,\n  privOffset: r.uint32,\n  privLength: r.uint32,\n  tables: new r.Array(WOFFDirectoryEntry, 'numTables')\n});\n\nWOFFDirectory.process = function () {\n  var tables = {};\n\n  for (var _iterator = this.tables, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _getIterator(_iterator);;) {\n    var _ref;\n\n    if (_isArray) {\n      if (_i >= _iterator.length) break;\n      _ref = _iterator[_i++];\n    } else {\n      _i = _iterator.next();\n      if (_i.done) break;\n      _ref = _i.value;\n    }\n\n    var table = _ref;\n    tables[table.tag] = table;\n  }\n\n  this.tables = tables;\n};\n\nvar WOFFFont = function (_TTFFont) {\n  _inherits(WOFFFont, _TTFFont);\n\n  function WOFFFont() {\n    _classCallCheck(this, WOFFFont);\n\n    return _possibleConstructorReturn(this, _TTFFont.apply(this, arguments));\n  }\n\n  WOFFFont.probe = function probe(buffer) {\n    return buffer.toString('ascii', 0, 4) === 'wOFF';\n  };\n\n  WOFFFont.prototype._decodeDirectory = function _decodeDirectory() {\n    this.directory = WOFFDirectory.decode(this.stream, {\n      _startOffset: 0\n    });\n  };\n\n  WOFFFont.prototype._getTableStream = function _getTableStream(tag) {\n    var table = this.directory.tables[tag];\n\n    if (table) {\n      this.stream.pos = table.offset;\n\n      if (table.compLength < table.length) {\n        this.stream.pos += 2; // skip deflate header\n\n        var outBuffer = new Buffer(table.length);\n        var buf = inflate(this.stream.readBuffer(table.compLength - 2), outBuffer);\n        return new r.DecodeStream(buf);\n      } else {\n        return this.stream;\n      }\n    }\n\n    return null;\n  };\n\n  return WOFFFont;\n}(TTFFont);\n/**\n * Represents a TrueType glyph in the WOFF2 format, which compresses glyphs differently.\n */\n\n\nvar WOFF2Glyph = function (_TTFGlyph) {\n  _inherits(WOFF2Glyph, _TTFGlyph);\n\n  function WOFF2Glyph() {\n    _classCallCheck(this, WOFF2Glyph);\n\n    return _possibleConstructorReturn(this, _TTFGlyph.apply(this, arguments));\n  }\n\n  WOFF2Glyph.prototype._decode = function _decode() {\n    // We have to decode in advance (in WOFF2Font), so just return the pre-decoded data.\n    return this._font._transformedGlyphs[this.id];\n  };\n\n  WOFF2Glyph.prototype._getCBox = function _getCBox() {\n    return this.path.bbox;\n  };\n\n  return WOFF2Glyph;\n}(TTFGlyph);\n\nvar Base128 = {\n  decode: function decode(stream) {\n    var result = 0;\n    var iterable = [0, 1, 2, 3, 4];\n\n    for (var j = 0; j < iterable.length; j++) {\n      var i = iterable[j];\n      var code = stream.readUInt8(); // If any of the top seven bits are set then we're about to overflow.\n\n      if (result & 0xe0000000) {\n        throw new Error('Overflow');\n      }\n\n      result = result << 7 | code & 0x7f;\n\n      if ((code & 0x80) === 0) {\n        return result;\n      }\n    }\n\n    throw new Error('Bad base 128 number');\n  }\n};\nvar knownTags = ['cmap', 'head', 'hhea', 'hmtx', 'maxp', 'name', 'OS/2', 'post', 'cvt ', 'fpgm', 'glyf', 'loca', 'prep', 'CFF ', 'VORG', 'EBDT', 'EBLC', 'gasp', 'hdmx', 'kern', 'LTSH', 'PCLT', 'VDMX', 'vhea', 'vmtx', 'BASE', 'GDEF', 'GPOS', 'GSUB', 'EBSC', 'JSTF', 'MATH', 'CBDT', 'CBLC', 'COLR', 'CPAL', 'SVG ', 'sbix', 'acnt', 'avar', 'bdat', 'bloc', 'bsln', 'cvar', 'fdsc', 'feat', 'fmtx', 'fvar', 'gvar', 'hsty', 'just', 'lcar', 'mort', 'morx', 'opbd', 'prop', 'trak', 'Zapf', 'Silf', 'Glat', 'Gloc', 'Feat', 'Sill'];\nvar WOFF2DirectoryEntry = new r.Struct({\n  flags: r.uint8,\n  customTag: new r.Optional(new r.String(4), function (t) {\n    return (t.flags & 0x3f) === 0x3f;\n  }),\n  tag: function tag(t) {\n    return t.customTag || knownTags[t.flags & 0x3f];\n  },\n  // || (() => { throw new Error(`Bad tag: ${flags & 0x3f}`); })(); },\n  length: Base128,\n  transformVersion: function transformVersion(t) {\n    return t.flags >>> 6 & 0x03;\n  },\n  transformed: function transformed(t) {\n    return t.tag === 'glyf' || t.tag === 'loca' ? t.transformVersion === 0 : t.transformVersion !== 0;\n  },\n  transformLength: new r.Optional(Base128, function (t) {\n    return t.transformed;\n  })\n});\nvar WOFF2Directory = new r.Struct({\n  tag: new r.String(4),\n  // should be 'wOF2'\n  flavor: r.uint32,\n  length: r.uint32,\n  numTables: r.uint16,\n  reserved: new r.Reserved(r.uint16),\n  totalSfntSize: r.uint32,\n  totalCompressedSize: r.uint32,\n  majorVersion: r.uint16,\n  minorVersion: r.uint16,\n  metaOffset: r.uint32,\n  metaLength: r.uint32,\n  metaOrigLength: r.uint32,\n  privOffset: r.uint32,\n  privLength: r.uint32,\n  tables: new r.Array(WOFF2DirectoryEntry, 'numTables')\n});\n\nWOFF2Directory.process = function () {\n  var tables = {};\n\n  for (var i = 0; i < this.tables.length; i++) {\n    var table = this.tables[i];\n    tables[table.tag] = table;\n  }\n\n  return this.tables = tables;\n};\n/**\n * Subclass of TTFFont that represents a TTF/OTF font compressed by WOFF2\n * See spec here: http://www.w3.org/TR/WOFF2/\n */\n\n\nvar WOFF2Font = function (_TTFFont) {\n  _inherits(WOFF2Font, _TTFFont);\n\n  function WOFF2Font() {\n    _classCallCheck(this, WOFF2Font);\n\n    return _possibleConstructorReturn(this, _TTFFont.apply(this, arguments));\n  }\n\n  WOFF2Font.probe = function probe(buffer) {\n    return buffer.toString('ascii', 0, 4) === 'wOF2';\n  };\n\n  WOFF2Font.prototype._decodeDirectory = function _decodeDirectory() {\n    this.directory = WOFF2Directory.decode(this.stream);\n    this._dataPos = this.stream.pos;\n  };\n\n  WOFF2Font.prototype._decompress = function _decompress() {\n    // decompress data and setup table offsets if we haven't already\n    if (!this._decompressed) {\n      this.stream.pos = this._dataPos;\n      var buffer = this.stream.readBuffer(this.directory.totalCompressedSize);\n      var decompressedSize = 0;\n\n      for (var tag in this.directory.tables) {\n        var entry = this.directory.tables[tag];\n        entry.offset = decompressedSize;\n        decompressedSize += entry.transformLength != null ? entry.transformLength : entry.length;\n      }\n\n      var decompressed = brotli(buffer, decompressedSize);\n\n      if (!decompressed) {\n        throw new Error('Error decoding compressed data in WOFF2');\n      }\n\n      this.stream = new r.DecodeStream(new Buffer(decompressed));\n      this._decompressed = true;\n    }\n  };\n\n  WOFF2Font.prototype._decodeTable = function _decodeTable(table) {\n    this._decompress();\n\n    return _TTFFont.prototype._decodeTable.call(this, table);\n  }; // Override this method to get a glyph and return our\n  // custom subclass if there is a glyf table.\n\n\n  WOFF2Font.prototype._getBaseGlyph = function _getBaseGlyph(glyph) {\n    var characters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\n    if (!this._glyphs[glyph]) {\n      if (this.directory.tables.glyf && this.directory.tables.glyf.transformed) {\n        if (!this._transformedGlyphs) {\n          this._transformGlyfTable();\n        }\n\n        return this._glyphs[glyph] = new WOFF2Glyph(glyph, characters, this);\n      } else {\n        return _TTFFont.prototype._getBaseGlyph.call(this, glyph, characters);\n      }\n    }\n  };\n\n  WOFF2Font.prototype._transformGlyfTable = function _transformGlyfTable() {\n    this._decompress();\n\n    this.stream.pos = this.directory.tables.glyf.offset;\n    var table = GlyfTable.decode(this.stream);\n    var glyphs = [];\n\n    for (var index = 0; index < table.numGlyphs; index++) {\n      var glyph = {};\n      var nContours = table.nContours.readInt16BE();\n      glyph.numberOfContours = nContours;\n\n      if (nContours > 0) {\n        // simple glyph\n        var nPoints = [];\n        var totalPoints = 0;\n\n        for (var i = 0; i < nContours; i++) {\n          var _r = read255UInt16(table.nPoints);\n\n          totalPoints += _r;\n          nPoints.push(totalPoints);\n        }\n\n        glyph.points = decodeTriplet(table.flags, table.glyphs, totalPoints);\n\n        for (var _i = 0; _i < nContours; _i++) {\n          glyph.points[nPoints[_i] - 1].endContour = true;\n        }\n\n        var instructionSize = read255UInt16(table.glyphs);\n      } else if (nContours < 0) {\n        // composite glyph\n        var haveInstructions = TTFGlyph.prototype._decodeComposite.call({\n          _font: this\n        }, glyph, table.composites);\n\n        if (haveInstructions) {\n          var instructionSize = read255UInt16(table.glyphs);\n        }\n      }\n\n      glyphs.push(glyph);\n    }\n\n    this._transformedGlyphs = glyphs;\n  };\n\n  return WOFF2Font;\n}(TTFFont);\n\nvar Substream = function () {\n  function Substream(length) {\n    _classCallCheck(this, Substream);\n\n    this.length = length;\n    this._buf = new r.Buffer(length);\n  }\n\n  Substream.prototype.decode = function decode(stream, parent) {\n    return new r.DecodeStream(this._buf.decode(stream, parent));\n  };\n\n  return Substream;\n}(); // This struct represents the entire glyf table\n\n\nvar GlyfTable = new r.Struct({\n  version: r.uint32,\n  numGlyphs: r.uint16,\n  indexFormat: r.uint16,\n  nContourStreamSize: r.uint32,\n  nPointsStreamSize: r.uint32,\n  flagStreamSize: r.uint32,\n  glyphStreamSize: r.uint32,\n  compositeStreamSize: r.uint32,\n  bboxStreamSize: r.uint32,\n  instructionStreamSize: r.uint32,\n  nContours: new Substream('nContourStreamSize'),\n  nPoints: new Substream('nPointsStreamSize'),\n  flags: new Substream('flagStreamSize'),\n  glyphs: new Substream('glyphStreamSize'),\n  composites: new Substream('compositeStreamSize'),\n  bboxes: new Substream('bboxStreamSize'),\n  instructions: new Substream('instructionStreamSize')\n});\nvar WORD_CODE = 253;\nvar ONE_MORE_BYTE_CODE2 = 254;\nvar ONE_MORE_BYTE_CODE1 = 255;\nvar LOWEST_U_CODE = 253;\n\nfunction read255UInt16(stream) {\n  var code = stream.readUInt8();\n\n  if (code === WORD_CODE) {\n    return stream.readUInt16BE();\n  }\n\n  if (code === ONE_MORE_BYTE_CODE1) {\n    return stream.readUInt8() + LOWEST_U_CODE;\n  }\n\n  if (code === ONE_MORE_BYTE_CODE2) {\n    return stream.readUInt8() + LOWEST_U_CODE * 2;\n  }\n\n  return code;\n}\n\nfunction withSign(flag, baseval) {\n  return flag & 1 ? baseval : -baseval;\n}\n\nfunction decodeTriplet(flags, glyphs, nPoints) {\n  var y = void 0;\n  var x = y = 0;\n  var res = [];\n\n  for (var i = 0; i < nPoints; i++) {\n    var dx = 0,\n        dy = 0;\n    var flag = flags.readUInt8();\n    var onCurve = !(flag >> 7);\n    flag &= 0x7f;\n\n    if (flag < 10) {\n      dx = 0;\n      dy = withSign(flag, ((flag & 14) << 7) + glyphs.readUInt8());\n    } else if (flag < 20) {\n      dx = withSign(flag, ((flag - 10 & 14) << 7) + glyphs.readUInt8());\n      dy = 0;\n    } else if (flag < 84) {\n      var b0 = flag - 20;\n      var b1 = glyphs.readUInt8();\n      dx = withSign(flag, 1 + (b0 & 0x30) + (b1 >> 4));\n      dy = withSign(flag >> 1, 1 + ((b0 & 0x0c) << 2) + (b1 & 0x0f));\n    } else if (flag < 120) {\n      var b0 = flag - 84;\n      dx = withSign(flag, 1 + (b0 / 12 << 8) + glyphs.readUInt8());\n      dy = withSign(flag >> 1, 1 + (b0 % 12 >> 2 << 8) + glyphs.readUInt8());\n    } else if (flag < 124) {\n      var b1 = glyphs.readUInt8();\n      var b2 = glyphs.readUInt8();\n      dx = withSign(flag, (b1 << 4) + (b2 >> 4));\n      dy = withSign(flag >> 1, ((b2 & 0x0f) << 8) + glyphs.readUInt8());\n    } else {\n      dx = withSign(flag, glyphs.readUInt16BE());\n      dy = withSign(flag >> 1, glyphs.readUInt16BE());\n    }\n\n    x += dx;\n    y += dy;\n    res.push(new Point(onCurve, false, x, y));\n  }\n\n  return res;\n}\n\nvar TTCHeader = new r.VersionedStruct(r.uint32, {\n  0x00010000: {\n    numFonts: r.uint32,\n    offsets: new r.Array(r.uint32, 'numFonts')\n  },\n  0x00020000: {\n    numFonts: r.uint32,\n    offsets: new r.Array(r.uint32, 'numFonts'),\n    dsigTag: r.uint32,\n    dsigLength: r.uint32,\n    dsigOffset: r.uint32\n  }\n});\n\nvar TrueTypeCollection = function () {\n  TrueTypeCollection.probe = function probe(buffer) {\n    return buffer.toString('ascii', 0, 4) === 'ttcf';\n  };\n\n  function TrueTypeCollection(stream) {\n    _classCallCheck(this, TrueTypeCollection);\n\n    this.stream = stream;\n\n    if (stream.readString(4) !== 'ttcf') {\n      throw new Error('Not a TrueType collection');\n    }\n\n    this.header = TTCHeader.decode(stream);\n  }\n\n  TrueTypeCollection.prototype.getFont = function getFont(name) {\n    for (var _iterator = this.header.offsets, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _getIterator(_iterator);;) {\n      var _ref;\n\n      if (_isArray) {\n        if (_i >= _iterator.length) break;\n        _ref = _iterator[_i++];\n      } else {\n        _i = _iterator.next();\n        if (_i.done) break;\n        _ref = _i.value;\n      }\n\n      var offset = _ref;\n      var stream = new r.DecodeStream(this.stream.buffer);\n      stream.pos = offset;\n      var font = new TTFFont(stream);\n\n      if (font.postscriptName === name) {\n        return font;\n      }\n    }\n\n    return null;\n  };\n\n  _createClass(TrueTypeCollection, [{\n    key: 'fonts',\n    get: function get() {\n      var fonts = [];\n\n      for (var _iterator2 = this.header.offsets, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _getIterator(_iterator2);;) {\n        var _ref2;\n\n        if (_isArray2) {\n          if (_i2 >= _iterator2.length) break;\n          _ref2 = _iterator2[_i2++];\n        } else {\n          _i2 = _iterator2.next();\n          if (_i2.done) break;\n          _ref2 = _i2.value;\n        }\n\n        var offset = _ref2;\n        var stream = new r.DecodeStream(this.stream.buffer);\n        stream.pos = offset;\n        fonts.push(new TTFFont(stream));\n      }\n\n      return fonts;\n    }\n  }]);\n\n  return TrueTypeCollection;\n}();\n\nvar DFontName = new r.String(r.uint8);\nvar DFontData = new r.Struct({\n  len: r.uint32,\n  buf: new r.Buffer('len')\n});\nvar Ref = new r.Struct({\n  id: r.uint16,\n  nameOffset: r.int16,\n  attr: r.uint8,\n  dataOffset: r.uint24,\n  handle: r.uint32\n});\nvar Type = new r.Struct({\n  name: new r.String(4),\n  maxTypeIndex: r.uint16,\n  refList: new r.Pointer(r.uint16, new r.Array(Ref, function (t) {\n    return t.maxTypeIndex + 1;\n  }), {\n    type: 'parent'\n  })\n});\nvar TypeList = new r.Struct({\n  length: r.uint16,\n  types: new r.Array(Type, function (t) {\n    return t.length + 1;\n  })\n});\nvar DFontMap = new r.Struct({\n  reserved: new r.Reserved(r.uint8, 24),\n  typeList: new r.Pointer(r.uint16, TypeList),\n  nameListOffset: new r.Pointer(r.uint16, 'void')\n});\nvar DFontHeader = new r.Struct({\n  dataOffset: r.uint32,\n  map: new r.Pointer(r.uint32, DFontMap),\n  dataLength: r.uint32,\n  mapLength: r.uint32\n});\n\nvar DFont = function () {\n  DFont.probe = function probe(buffer) {\n    var stream = new r.DecodeStream(buffer);\n\n    try {\n      var header = DFontHeader.decode(stream);\n    } catch (e) {\n      return false;\n    }\n\n    for (var _iterator = header.map.typeList.types, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _getIterator(_iterator);;) {\n      var _ref;\n\n      if (_isArray) {\n        if (_i >= _iterator.length) break;\n        _ref = _iterator[_i++];\n      } else {\n        _i = _iterator.next();\n        if (_i.done) break;\n        _ref = _i.value;\n      }\n\n      var type = _ref;\n\n      if (type.name === 'sfnt') {\n        return true;\n      }\n    }\n\n    return false;\n  };\n\n  function DFont(stream) {\n    _classCallCheck(this, DFont);\n\n    this.stream = stream;\n    this.header = DFontHeader.decode(this.stream);\n\n    for (var _iterator2 = this.header.map.typeList.types, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _getIterator(_iterator2);;) {\n      var _ref2;\n\n      if (_isArray2) {\n        if (_i2 >= _iterator2.length) break;\n        _ref2 = _iterator2[_i2++];\n      } else {\n        _i2 = _iterator2.next();\n        if (_i2.done) break;\n        _ref2 = _i2.value;\n      }\n\n      var type = _ref2;\n\n      for (var _iterator3 = type.refList, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _getIterator(_iterator3);;) {\n        var _ref3;\n\n        if (_isArray3) {\n          if (_i3 >= _iterator3.length) break;\n          _ref3 = _iterator3[_i3++];\n        } else {\n          _i3 = _iterator3.next();\n          if (_i3.done) break;\n          _ref3 = _i3.value;\n        }\n\n        var ref = _ref3;\n\n        if (ref.nameOffset >= 0) {\n          this.stream.pos = ref.nameOffset + this.header.map.nameListOffset;\n          ref.name = DFontName.decode(this.stream);\n        } else {\n          ref.name = null;\n        }\n      }\n\n      if (type.name === 'sfnt') {\n        this.sfnt = type;\n      }\n    }\n  }\n\n  DFont.prototype.getFont = function getFont(name) {\n    if (!this.sfnt) {\n      return null;\n    }\n\n    for (var _iterator4 = this.sfnt.refList, _isArray4 = Array.isArray(_iterator4), _i4 = 0, _iterator4 = _isArray4 ? _iterator4 : _getIterator(_iterator4);;) {\n      var _ref4;\n\n      if (_isArray4) {\n        if (_i4 >= _iterator4.length) break;\n        _ref4 = _iterator4[_i4++];\n      } else {\n        _i4 = _iterator4.next();\n        if (_i4.done) break;\n        _ref4 = _i4.value;\n      }\n\n      var ref = _ref4;\n      var pos = this.header.dataOffset + ref.dataOffset + 4;\n      var stream = new r.DecodeStream(this.stream.buffer.slice(pos));\n      var font = new TTFFont(stream);\n\n      if (font.postscriptName === name) {\n        return font;\n      }\n    }\n\n    return null;\n  };\n\n  _createClass(DFont, [{\n    key: 'fonts',\n    get: function get() {\n      var fonts = [];\n\n      for (var _iterator5 = this.sfnt.refList, _isArray5 = Array.isArray(_iterator5), _i5 = 0, _iterator5 = _isArray5 ? _iterator5 : _getIterator(_iterator5);;) {\n        var _ref5;\n\n        if (_isArray5) {\n          if (_i5 >= _iterator5.length) break;\n          _ref5 = _iterator5[_i5++];\n        } else {\n          _i5 = _iterator5.next();\n          if (_i5.done) break;\n          _ref5 = _i5.value;\n        }\n\n        var ref = _ref5;\n        var pos = this.header.dataOffset + ref.dataOffset + 4;\n        var stream = new r.DecodeStream(this.stream.buffer.slice(pos));\n        fonts.push(new TTFFont(stream));\n      }\n\n      return fonts;\n    }\n  }]);\n\n  return DFont;\n}(); // Register font formats\n\n\nfontkit.registerFormat(TTFFont);\nfontkit.registerFormat(WOFFFont);\nfontkit.registerFormat(WOFF2Font);\nfontkit.registerFormat(TrueTypeCollection);\nfontkit.registerFormat(DFont);\nmodule.exports = fontkit;","map":{"version":3,"sources":["src/base.js","src/decorators.js","src/tables/cmap.js","src/tables/head.js","src/tables/hhea.js","src/tables/hmtx.js","src/tables/maxp.js","src/encodings.js","src/tables/name.js","src/tables/OS2.js","src/tables/post.js","src/tables/cvt.js","src/tables/fpgm.js","src/tables/loca.js","src/tables/prep.js","src/tables/glyf.js","src/cff/CFFIndex.js","src/cff/CFFOperand.js","src/cff/CFFDict.js","src/cff/CFFPointer.js","src/cff/CFFPrivateDict.js","src/cff/CFFStandardStrings.js","src/cff/CFFEncodings.js","src/cff/CFFCharsets.js","src/tables/opentype.js","src/tables/variations.js","src/cff/CFFTop.js","src/cff/CFFFont.js","src/tables/VORG.js","src/tables/EBDT.js","src/tables/EBLC.js","src/tables/sbix.js","src/tables/COLR.js","src/tables/CPAL.js","src/tables/BASE.js","src/tables/GDEF.js","src/tables/GPOS.js","src/tables/GSUB.js","src/tables/JSTF.js","src/tables/HVAR.js","src/tables/DSIG.js","src/tables/gasp.js","src/tables/hdmx.js","src/tables/kern.js","src/tables/LTSH.js","src/tables/PCLT.js","src/tables/VDMX.js","src/tables/vhea.js","src/tables/vmtx.js","src/tables/avar.js","src/tables/aat.js","src/tables/bsln.js","src/tables/feat.js","src/tables/fvar.js","src/tables/gvar.js","src/tables/just.js","src/tables/morx.js","src/tables/opbd.js","src/tables/index.js","src/tables/directory.js","src/utils.js","src/CmapProcessor.js","src/layout/KernProcessor.js","src/layout/UnicodeLayoutEngine.js","src/glyph/BBox.js","src/layout/Script.js","src/layout/GlyphRun.js","src/layout/GlyphPosition.js","src/aat/AATFeatureMap.js","src/aat/AATLookupTable.js","src/aat/AATStateMachine.js","src/aat/AATMorxProcessor.js","src/aat/AATLayoutEngine.js","src/opentype/ShapingPlan.js","src/opentype/shapers/DefaultShaper.js","src/opentype/shapers/ArabicShaper.js","src/opentype/GlyphIterator.js","src/opentype/OTProcessor.js","src/opentype/GlyphInfo.js","src/opentype/shapers/HangulShaper.js","src/opentype/shapers/indic-data.js","src/opentype/shapers/IndicShaper.js","src/opentype/shapers/UniversalShaper.js","src/opentype/shapers/index.js","src/opentype/GSUBProcessor.js","src/opentype/GPOSProcessor.js","src/opentype/OTLayoutEngine.js","src/layout/LayoutEngine.js","src/glyph/Path.js","src/glyph/StandardNames.js","src/glyph/Glyph.js","src/glyph/TTFGlyph.js","src/glyph/CFFGlyph.js","src/glyph/SBIXGlyph.js","src/glyph/COLRGlyph.js","src/glyph/GlyphVariationProcessor.js","src/subset/Subset.js","src/glyph/TTFGlyphEncoder.js","src/subset/TTFSubset.js","src/subset/CFFSubset.js","src/TTFFont.js","src/tables/WOFFDirectory.js","src/WOFFFont.js","src/glyph/WOFF2Glyph.js","src/tables/WOFF2Directory.js","src/WOFF2Font.js","src/TrueTypeCollection.js","src/DFont.js","src/index.js"],"names":["fs","require","fontkit","formats","buffer","callback","font","i","format","r","lang","descriptor","get","value","fn","cache","args","key","result","SubHeader","uint16","CmapGroup","uint32","UnicodeValueRange","uint8","UVSMapping","DefaultUVS","NonDefaultUVS","VarSelectorRecord","type","CmapSubtable","Math","t","CmapEntry","lazy","HmtxEntry","int16","languageID","platformID","MAC_LANGUAGE_ENCODINGS","ENCODINGS","LANGUAGES","NameRecord","getEncoding","relativeTo","allowNull","LangTagRecord","NameTable","NAMES","records","record","language","obj","Array","val","Buffer","en","OS2","versions","loca","CFFIndex","getCFFVersion","ctx","decode","stream","parent","version","count","offSize","offsetType","ret","startPos","start","end","pos","size","arr","offset","item","encode","sizes","s","FLOAT_EOF","FLOAT_LOOKUP","FLOAT_ENCODE_LOOKUP","CFFOperand","str","b","n1","n2","parseFloat","Number","c1","c2","CFFDict","ops","field","decodeOperands","operands","encodeOperands","PropertyDescriptor","dict","includePointers","len","isEqual","op","ptr","CFFPointer","Pointer","options","Ptr","valueOf","CFFBlendOp","numBlends","StandardEncoding","ExpertEncoding","ISOAdobeCharset","ExpertCharset","ExpertSubsetCharset","LangSysTable","LangSysRecord","Script","ScriptRecord","ScriptList","Feature","FeatureRecord","FeatureList","LookupFlags","Lookup","RangeRecord","Coverage","ClassRangeRecord","ClassDef","Device","LookupRecord","Rule","RuleSet","ClassRule","ClassSet","Context","ChainRule","ChainRuleSet","ChainingContext","F2DOT14","RegionAxisCoordinates","VariationRegionList","DeltaSet","ItemVariationData","ItemVariationStore","ConditionTable","ConditionSet","FeatureTableSubstitutionRecord","FeatureTableSubstitution","FeatureVariationRecord","FeatureVariations","PredefinedOp","index","CFFEncodingVersion","Range1","Range2","CFFCustomEncoding","CFFEncoding","RangeArray","length","resolveLength","res","range","CFFCustomCharset","CFFCharset","FDRange3","FDRange4","FDSelect","CFFPrivateOp","CFFPrivateDict","FontDict","CFFTopDict","VariationStore","CFF2TopDict","CFFTop","CFFFont","top","string","sid","standardStrings","getCharString","glyph","getGlyphName","gid","charset","fdForGlyph","ranges","low","high","mid","privateDictForGlyph","fd","VerticalOrigin","BigMetrics","SmallMetrics","EBDTComponent","int8","ByteAligned","BitAligned","SBitLineMetrics","CodeOffsetPair","IndexSubtable","IndexSubtableArray","BitmapSizeTable","ImageTable","LayerRecord","BaseGlyphRecord","ColorRecord","BaseCoord","BaseValues","FeatMinMaxRecord","MinMax","BaseLangSysRecord","BaseScript","BaseScriptRecord","BaseScriptList","BaseTagList","Axis","AttachPoint","AttachList","CaretValue","LigGlyph","LigCaretList","MarkGlyphSetsDef","ValueFormat","types","ValueRecord","buildStruct","struct","fields","PairValueRecord","PairSet","Class2Record","Anchor","EntryExitRecord","MarkRecord","MarkArray","BaseRecord","BaseArray","ComponentRecord","LigatureAttach","LigatureArray","GPOSLookup","Sequence","AlternateSet","Ligature","LigatureSet","GSUBLookup","JstfGSUBModList","JstfPriority","JstfLangSys","JstfLangSysRecord","JstfScript","JstfScriptRecord","VariableSizeNumber","MapDataEntry","DeltaSetIndexMap","Signature","SignatureBlock","GaspRange","DeviceRecord","KernPair","ClassTable","Kern2Array","KernSubtable","KernTable","Ratio","vTable","VdmxGroup","VmtxEntry","shortFrac","Correspondence","Segment","UnboundedArrayAccessor","getItem","inspect","UnboundedArray","LookupTable","ValueType","Shadow","BinarySearchHeader","LookupSegmentSingle","LookupSegmentArray","LookupSingle","entryData","lookupType","entry","Entry","StateArray","StateHeader","ClassLookupTable","StateHeader1","BslnSubtable","Setting","FeatureName","Instance","Offset","gvar","WidthDeltaRecord","WidthDeltaCluster","ActionData","fixed32","Action","PostcompensationAction","PostCompensationTable","JustificationTable","LigatureData","ContextualData","InsertionData","SubstitutionTable","SubtableData","Subtable","FeatureEntry","MorxChain","OpticalBounds","tables","TableEntry","Directory","table","Tables","maxExponentFor2","maxPowerOf2","min","max","cmp","iconv","CmapProcessor","cmap","cmapTable","encoding","findSubtable","pairs","encodingID","lookup","codepoint","variationSelector","buf","rangeOffset","group","getVariationSelector","selectors","x","sel","getCharacterSet","endCodes","tail","codePointsForGlyph","delta","c","g","KernProcessor","process","glyphs","positions","glyphIndex","left","right","getKerning","pairIdx","pair","leftOffset","rightOffset","UnicodeLayoutEngine","positionGlyphs","clusterStart","clusterEnd","positionCluster","base","baseBox","xOffset","yOffset","yGap","mark","markBox","position","combiningClass","getCombiningClass","codePoint","unicode","BBox","minX","Infinity","minY","maxX","maxY","addPoint","y","copy","UNICODE_SCRIPTS","OPENTYPE_SCRIPTS","tag","idx","code","next","script","codePoints","RTL","GlyphRun","direction","width","height","bbox","p","GlyphPosition","xAdvance","yAdvance","features","feature","OTMapping","AATMapping","aat","setting","f","isNaN","typeCode","settingCode","k","mapFeatureStrings","AATLookupTable","seg","glyphsForValue","classValue","segment","START_OF_TEXT_STATE","END_OF_TEXT_CLASS","OUT_OF_BOUNDS_CLASS","DELETED_GLYPH_CLASS","DONT_ADVANCE","AATStateMachine","stateTable","reverse","processEntry","currentState","dir","classCode","shouldAdvance","row","entryIndex","traverse","opts","state","visited","nClasses","stateArray","entryTable","MARK_FIRST","MARK_LAST","VERB","SET_MARK","SET_COMPONENT","PERFORM_ACTION","LAST_MASK","STORE_MASK","OFFSET_MASK","REVERSE_DIRECTION","CURRENT_INSERT_BEFORE","MARKED_INSERT_BEFORE","CURRENT_INSERT_COUNT","MARKED_INSERT_COUNT","AATMorxProcessor","chain","flags","subtable","processSubtable","stateMachine","getStateMachine","getProcessor","processIndicRearragement","processContextualSubstitution","subsitutions","lookupTable","processLigature","actions","components","ligatureList","actionIndex","last","ligatureIndex","ligatureGlyphs","componentGlyph","action","store","component","ligatureEntry","processNoncontextualSubstitutions","_insertGlyphs","insertionActionIndex","isBefore","insertions","processGlyphInsertion","getSupportedFeatures","generateInputs","generateInputCache","generateInputsForSubtable","input","stack","found","reverseA","reverseB","rangeB","rangeA","lastGlyph","swap","AATLayoutEngine","substitute","glyphRun","AATFeatureMap","getAvailableFeatures","stringsForGlyph","glyphStrings","_addStrings","strings","ShapingPlan","_addFeatures","global","stageIndex","stage","add","arg","addStage","setFeatureOverrides","assignGlobalFeatures","processor","VARIATION_FEATURES","COMMON_FEATURES","FRACTIONAL_FEATURES","HORIZONTAL_FEATURES","DIRECTIONAL_FEATURES","DefaultShaper","zeroMarkWidths","plan","planPreprocessing","planFeatures","planPostprocessing","userFeatures","assignFeatures","trie","__dirname","FEATURES","ShapingClasses","ISOL","FINA","FIN2","FIN3","MEDI","MED2","INIT","NONE","STATE_TABLE","ArabicShaper","prev","curAction","prevAction","getShapingClass","category","GlyphIterator","reset","shouldIgnore","move","peek","peekIndex","increment","DEFAULT_SCRIPTS","OTProcessor","findScript","selectScript","changed","featureIndex","substituteFeature","lookupsForFeatures","exclude","lookups","lookupIndex","a","substituteFeatureForVariations","substitutions","substitution","findVariationsIndex","coords","variations","conditions","variationConditionsMatch","coord","condition","applyFeatures","advances","applyLookups","applyLookup","applyLookupList","lookupRecords","lookupRecord","coverageIndex","coverage","match","sequenceIndex","sequence","matched","sequenceMatches","sequenceMatchIndices","coverageSequenceMatches","getClassID","classDef","classSequenceMatches","classID","applyContext","set","rule","applyChainingContext","rules","GlyphInfo","id","GDEF","HangulShaper","getType","decompose","compose","insertDottedCircle","HANGUL_BASE","HANGUL_END","HANGUL_COUNT","L_BASE","V_BASE","T_BASE","L_COUNT","V_COUNT","T_COUNT","L_END","V_END","T_END","DOTTED_CIRCLE","isL","isV","isT","isTone","isLVT","isLV","isCombiningL","isCombiningV","isCombiningT","X","L","V","T","LV","LVT","M","NO_ACTION","DECOMPOSE","COMPOSE","TONE_MARK","INVALID","l","v","ljmo","getGlyph","vjmo","insert","tjmo","prevType","lv","del","getLength","dottedCircle","CATEGORIES","POSITIONS","CONSONANT_FLAGS","JOINER_FLAGS","HALANT_OR_COENG_FLAGS","INDIC_CONFIGS","INDIC_DECOMPOSITIONS","decompositions","useData","IndicShaper","d","decomposed","IndicInfo","syllable","tags","indicCategory","indicPosition","GSUB","wouldSubstitute","indicConfig","virama","info","consonantPosition","nextSyllable","syllableType","limit","hasReph","isJoiner","seenBelow","isConsonant","j","disallowDoubleHalants","lastPos","blwf","prefLen","nonJoiner","tryPref","isHalantOrCoeng","newPos","oldPos","tmp","newRephPos","rephPos","reph","categories","UniversalShaper","USEInfo","useCategory","isBase","isHalant","SHAPERS","shaper","GSUBProcessor","curGlyph","replacement","USER_INDEX","ligature","characters","ligatureGlyph","isMarkLigature","lastLigID","lastNumComps","curComps","matchIndex","ligatureComponent","GPOSProcessor","applyPositionValue","variationProcessor","variationStore","nextGlyph","class1","class2","nextIndex","curRecord","nextRecord","exit","cur","markIndex","baseGlyphIndex","baseIndex","markRecord","baseAnchor","ligIndex","ligAttach","markGlyph","ligGlyph","compIndex","mark1Index","prevIndex","good","mark2Index","applyAnchor","baseCoords","markCoords","basePos","markPos","getAnchor","anchor","fixCursiveAttachment","fixMarkAttachment","OTLayoutEngine","setup","Shapers","glyphInfo","zeroMarkAdvances","cleanup","LayoutEngine","layout","positioned","hideDefaultIgnorables","space","isDefaultIgnorable","ch","plane","SVG_COMMANDS","Path","toFunction","toSVG","cmds","cbox","command","cx","cy","p0","p1","p2","p3","qp1x","qp1y","p3x","p3y","cp1x","cp1y","cp2x","cp2y","b2ac","t1","t2","mapPoints","path","transform","m0","m1","m2","m3","m4","m5","translate","rotate","angle","cos","sin","scale","scaleX","scaleY","Glyph","_getPath","_getCBox","_getBBox","_getTableMetrics","metric","_getMetrics","advanceWidth","leftBearing","advanceHeight","topBearing","os2","hhea","getScaledPath","_getName","post","StandardNames","String","render","GlyfHeader","ON_CURVE","X_SHORT_VECTOR","Y_SHORT_VECTOR","REPEAT","SAME_X","SAME_Y","ARG_1_AND_2_ARE_WORDS","WE_HAVE_A_SCALE","MORE_COMPONENTS","WE_HAVE_AN_X_AND_Y_SCALE","WE_HAVE_A_TWO_BY_TWO","WE_HAVE_INSTRUCTIONS","Point","Component","TTFGlyph","internal","_parseGlyphCoord","short","same","_decode","glyfPos","nextPos","_decodeSimple","endPtsOfContours","numCoords","flag","point","px","py","points","_decodeComposite","haveInstructions","gPos","glyphID","dx","dy","_getPhantomPoints","_getContours","contours","contour","firstPt","lastPt","curvePt","pt","prevPt","midX","midY","CFFGlyph","bias","cff","trans","nStems","usedGsubrs","usedSubrs","open","gsubrs","gsubrsBias","privateDict","subrs","subrsBias","vstore","vsindex","parse","phase","c1x","c1y","c2x","c2y","subr","e","blendVector","numOperands","sum","s1","s2","v1","v2","n","c3x","c3y","c4x","c4y","c5x","c5y","c6x","c6y","pts","startx","starty","b1","SBIXImage","SBIXGlyph","getImageForSize","offsets","buflen","img","COLRLayer","COLRGlyph","layer","cpal","colr","rec","baseLayer","color","layers","TUPLES_SHARE_POINT_NUMBERS","TUPLE_COUNT_MASK","EMBEDDED_TUPLE_COORD","INTERMEDIATE_TUPLE","PRIVATE_POINT_NUMBERS","TUPLE_INDEX_MASK","POINTS_ARE_WORDS","POINT_RUN_COUNT_MASK","DELTAS_ARE_ZERO","DELTAS_ARE_WORDS","DELTA_RUN_COUNT_MASK","GlyphVariationProcessor","normalizeCoords","normalized","axis","transformPoints","glyphPoints","tupleCount","offsetToData","here","sharedPoints","origPoints","tupleDataSize","tupleIndex","tupleCoords","startCoords","endCoords","factor","nPoints","xDeltas","yDeltas","outPoints","hasDelta","deltaX","deltaY","decodePoints","run","runCount","decodeDeltas","deltas","tupleFactor","interpolateMissingDeltas","inPoints","firstPoint","endPoint","firstDelta","curDelta","deltaInterpolate","ref1","ref2","iterable","in1","in2","out1","out2","out","deltaShift","ref","getAdvanceAdjustment","outerIndex","innerIndex","entryFormat","getDelta","itemStore","varData","deltaSet","netAdjustment","master","getBlendVector","normalizedCoords","scalar","regionIndex","axes","axisScalar","resolved","Subset","includeGlyph","encodeStream","Glyf","TTFGlyphEncoder","encodeSimple","instructions","xPoints","yPoints","lastX","lastY","lastFlag","pointCount","glyf","_encodePoint","shortFlag","sameFlag","diff","TTFSubset","_addGlyph","curOffset","nextOffset","maxp","cloneDeep","head","fpgm","CFFSubset","subsetCharstrings","subsetSubrs","used","subsetFontdict","topDict","used_fds","used_subrs","createCIDFontdict","Private","first","addString","nLeft","TTFFont","probe","variationCoords","setDefaultLanguage","_getTable","_getTableStream","_decodeDirectory","_startOffset","_decodeTable","getName","defaultLanguage","hasGlyphForCodePoint","glyphForCodePoint","glyphsForString","nextState","_getBaseGlyph","createSubset","maxValue","instance","settings","getVariation","axisTag","getFont","name","WOFFDirectoryEntry","WOFFDirectory","WOFFFont","outBuffer","inflate","WOFF2Glyph","Base128","knownTags","WOFF2DirectoryEntry","WOFF2Directory","WOFF2Font","_decompress","decompressedSize","decompressed","brotli","_transformGlyfTable","GlyfTable","nContours","totalPoints","read255UInt16","decodeTriplet","instructionSize","_font","Substream","WORD_CODE","ONE_MORE_BYTE_CODE2","ONE_MORE_BYTE_CODE1","LOWEST_U_CODE","onCurve","withSign","b0","b2","TTCHeader","TrueTypeCollection","fonts","DFontName","DFontData","Ref","Type","TypeList","DFontMap","DFontHeader","DFont","header"],"mappings":"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","sourcesContent":["import r from 'restructure';\nconst fs = require('fs');\n\nvar fontkit = {};\nexport default fontkit;\n\nfontkit.logErrors = false;\n\nlet formats = [];\nfontkit.registerFormat = function(format) {\n  formats.push(format);\n};\n\nfontkit.openSync = function(filename, postscriptName) {\n  let buffer = fs.readFileSync(filename);\n  return fontkit.create(buffer, postscriptName);\n};\n\nfontkit.open = function(filename, postscriptName, callback) {\n  if (typeof postscriptName === 'function') {\n    callback = postscriptName;\n    postscriptName = null;\n  }\n\n  fs.readFile(filename, function(err, buffer) {\n    if (err) { return callback(err); }\n\n    try {\n      var font = fontkit.create(buffer, postscriptName);\n    } catch (e) {\n      return callback(e);\n    }\n\n    return callback(null, font);\n  });\n\n  return;\n};\n\nfontkit.create = function(buffer, postscriptName) {\n  for (let i = 0; i < formats.length; i++) {\n    let format = formats[i];\n    if (format.probe(buffer)) {\n      let font = new format(new r.DecodeStream(buffer));\n      if (postscriptName) {\n        return font.getFont(postscriptName);\n      }\n\n      return font;\n    }\n  }\n\n  throw new Error('Unknown font format');\n};\n\nfontkit.defaultLanguage = 'en';\nfontkit.setDefaultLanguage = function(lang = 'en') {\n  fontkit.defaultLanguage = lang;\n};","/**\n * This decorator caches the results of a getter or method such that\n * the results are lazily computed once, and then cached.\n * @private\n */\nexport function cache(target, key, descriptor) {\n  if (descriptor.get) {\n    let get = descriptor.get;\n    descriptor.get = function() {\n      let value = get.call(this);\n      Object.defineProperty(this, key, { value });\n      return value;\n    };\n  } else if (typeof descriptor.value === 'function') {\n    let fn = descriptor.value;\n\n    return {\n      get() {\n        let cache = new Map;\n        function memoized(...args) {\n          let key = args.length > 0 ? args[0] : 'value';\n          if (cache.has(key)) {\n            return cache.get(key);\n          }\n\n          let result = fn.apply(this, args);\n          cache.set(key, result);\n          return result;\n        };\n\n        Object.defineProperty(this, key, {value: memoized});\n        return memoized;\n      }\n    };\n  }\n}\n","import r from 'restructure';\n\nlet SubHeader = new r.Struct({\n  firstCode:      r.uint16,\n  entryCount:     r.uint16,\n  idDelta:        r.int16,\n  idRangeOffset:  r.uint16\n});\n\nlet CmapGroup = new r.Struct({\n  startCharCode:  r.uint32,\n  endCharCode:    r.uint32,\n  glyphID:        r.uint32\n});\n\nlet UnicodeValueRange = new r.Struct({\n  startUnicodeValue:  r.uint24,\n  additionalCount:    r.uint8\n});\n\nlet UVSMapping = new r.Struct({\n  unicodeValue: r.uint24,\n  glyphID:      r.uint16\n});\n\nlet DefaultUVS = new r.Array(UnicodeValueRange, r.uint32);\nlet NonDefaultUVS = new r.Array(UVSMapping, r.uint32);\n\nlet VarSelectorRecord = new r.Struct({\n  varSelector:    r.uint24,\n  defaultUVS:     new r.Pointer(r.uint32, DefaultUVS, {type: 'parent'}),\n  nonDefaultUVS:  new r.Pointer(r.uint32, NonDefaultUVS, {type: 'parent'})\n});\n\nlet CmapSubtable = new r.VersionedStruct(r.uint16, {\n  0: { // Byte encoding\n    length:     r.uint16,   // Total table length in bytes (set to 262 for format 0)\n    language:   r.uint16,   // Language code for this encoding subtable, or zero if language-independent\n    codeMap:    new r.LazyArray(r.uint8, 256)\n  },\n\n  2: { // High-byte mapping (CJK)\n    length:           r.uint16,\n    language:         r.uint16,\n    subHeaderKeys:    new r.Array(r.uint16, 256),\n    subHeaderCount:   t => Math.max.apply(Math, t.subHeaderKeys),\n    subHeaders:       new r.LazyArray(SubHeader, 'subHeaderCount'),\n    glyphIndexArray:  new r.LazyArray(r.uint16, 'subHeaderCount')\n  },\n\n  4: { // Segment mapping to delta values\n    length:           r.uint16,              // Total table length in bytes\n    language:         r.uint16,              // Language code\n    segCountX2:       r.uint16,\n    segCount:         t => t.segCountX2 >> 1,\n    searchRange:      r.uint16,\n    entrySelector:    r.uint16,\n    rangeShift:       r.uint16,\n    endCode:          new r.LazyArray(r.uint16, 'segCount'),\n    reservedPad:      new r.Reserved(r.uint16),       // This value should be zero\n    startCode:        new r.LazyArray(r.uint16, 'segCount'),\n    idDelta:          new r.LazyArray(r.int16, 'segCount'),\n    idRangeOffset:    new r.LazyArray(r.uint16, 'segCount'),\n    glyphIndexArray:  new r.LazyArray(r.uint16, t => (t.length - t._currentOffset) / 2)\n  },\n\n  6: { // Trimmed table\n    length:         r.uint16,\n    language:       r.uint16,\n    firstCode:      r.uint16,\n    entryCount:     r.uint16,\n    glyphIndices:   new r.LazyArray(r.uint16, 'entryCount')\n  },\n\n  8: { // mixed 16-bit and 32-bit coverage\n    reserved: new r.Reserved(r.uint16),\n    length:   r.uint32,\n    language: r.uint16,\n    is32:     new r.LazyArray(r.uint8, 8192),\n    nGroups:  r.uint32,\n    groups:   new r.LazyArray(CmapGroup, 'nGroups')\n  },\n\n  10: { // Trimmed Array\n    reserved:       new r.Reserved(r.uint16),\n    length:         r.uint32,\n    language:       r.uint32,\n    firstCode:      r.uint32,\n    entryCount:     r.uint32,\n    glyphIndices:   new r.LazyArray(r.uint16, 'numChars')\n  },\n\n  12: { // Segmented coverage\n    reserved: new r.Reserved(r.uint16),\n    length:   r.uint32,\n    language: r.uint32,\n    nGroups:  r.uint32,\n    groups:   new r.LazyArray(CmapGroup, 'nGroups')\n  },\n\n  13: { // Many-to-one range mappings (same as 12 except for group.startGlyphID)\n    reserved: new r.Reserved(r.uint16),\n    length:   r.uint32,\n    language: r.uint32,\n    nGroups:  r.uint32,\n    groups:   new r.LazyArray(CmapGroup, 'nGroups')\n  },\n\n  14: { // Unicode Variation Sequences\n    length:       r.uint32,\n    numRecords:   r.uint32,\n    varSelectors: new r.LazyArray(VarSelectorRecord, 'numRecords')\n  }\n});\n\nlet CmapEntry = new r.Struct({\n  platformID:  r.uint16,  // Platform identifier\n  encodingID:  r.uint16,  // Platform-specific encoding identifier\n  table:       new r.Pointer(r.uint32, CmapSubtable, {type: 'parent', lazy: true})\n});\n\n// character to glyph mapping\nexport default new r.Struct({\n  version:      r.uint16,\n  numSubtables: r.uint16,\n  tables:       new r.Array(CmapEntry, 'numSubtables')\n});\n","import r from 'restructure';\n\n// font header\nexport default new r.Struct({\n  version:            r.int32,                   // 0x00010000 (version 1.0)\n  revision:           r.int32,                   // set by font manufacturer\n  checkSumAdjustment: r.uint32,\n  magicNumber:        r.uint32,                  // set to 0x5F0F3CF5\n  flags:              r.uint16,\n  unitsPerEm:         r.uint16,                  // range from 64 to 16384\n  created:            new r.Array(r.int32, 2),\n  modified:           new r.Array(r.int32, 2),\n  xMin:               r.int16,                   // for all glyph bounding boxes\n  yMin:               r.int16,                   // for all glyph bounding boxes\n  xMax:               r.int16,                   // for all glyph bounding boxes\n  yMax:               r.int16,                   // for all glyph bounding boxes\n  macStyle:           new r.Bitfield(r.uint16, [\n    'bold', 'italic', 'underline', 'outline',\n    'shadow', 'condensed', 'extended'\n  ]),\n  lowestRecPPEM:      r.uint16,                  // smallest readable size in pixels\n  fontDirectionHint:  r.int16,\n  indexToLocFormat:   r.int16,                   // 0 for short offsets, 1 for long\n  glyphDataFormat:    r.int16                    // 0 for current format\n});\n","import r from 'restructure';\n\n// horizontal header\nexport default new r.Struct({\n  version:              r.int32,\n  ascent:               r.int16,   // Distance from baseline of highest ascender\n  descent:              r.int16,   // Distance from baseline of lowest descender\n  lineGap:              r.int16,   // Typographic line gap\n  advanceWidthMax:      r.uint16,  // Maximum advance width value in 'hmtx' table\n  minLeftSideBearing:   r.int16,   // Maximum advance width value in 'hmtx' table\n  minRightSideBearing:  r.int16,   // Minimum right sidebearing value\n  xMaxExtent:           r.int16,\n  caretSlopeRise:       r.int16,   // Used to calculate the slope of the cursor (rise/run); 1 for vertical\n  caretSlopeRun:        r.int16,   // 0 for vertical\n  caretOffset:          r.int16,   // Set to 0 for non-slanted fonts\n  reserved:             new r.Reserved(r.int16, 4),\n  metricDataFormat:     r.int16,   // 0 for current format\n  numberOfMetrics:      r.uint16   // Number of advance widths in 'hmtx' table\n});\n","import r from 'restructure';\n\nlet HmtxEntry = new r.Struct({\n  advance: r.uint16,\n  bearing: r.int16\n});\n\nexport default new r.Struct({\n  metrics:    new r.LazyArray(HmtxEntry, t => t.parent.hhea.numberOfMetrics),\n  bearings:   new r.LazyArray(r.int16, t => t.parent.maxp.numGlyphs - t.parent.hhea.numberOfMetrics)\n});\n","import r from 'restructure';\n\n// maxiumum profile\nexport default new r.Struct({\n  version:                r.int32,\n  numGlyphs:              r.uint16,  // The number of glyphs in the font\n  maxPoints:              r.uint16,  // Maximum points in a non-composite glyph\n  maxContours:            r.uint16,  // Maximum contours in a non-composite glyph\n  maxComponentPoints:     r.uint16,  // Maximum points in a composite glyph\n  maxComponentContours:   r.uint16,  // Maximum contours in a composite glyph\n  maxZones:               r.uint16,  // 1 if instructions do not use the twilight zone, 2 otherwise\n  maxTwilightPoints:      r.uint16,  // Maximum points used in Z0\n  maxStorage:             r.uint16,  // Number of Storage Area locations\n  maxFunctionDefs:        r.uint16,  // Number of FDEFs\n  maxInstructionDefs:     r.uint16,  // Number of IDEFs\n  maxStackElements:       r.uint16,  // Maximum stack depth\n  maxSizeOfInstructions:  r.uint16,  // Maximum byte count for glyph instructions\n  maxComponentElements:   r.uint16,  // Maximum number of components referenced at “top level” for any composite glyph\n  maxComponentDepth:      r.uint16   // Maximum levels of recursion; 1 for simple components\n});\n","/**\n * Gets an encoding name from platform, encoding, and language ids.\n * Returned encoding names can be used in iconv-lite to decode text.\n */\nexport function getEncoding(platformID, encodingID, languageID = 0) {\n  if (platformID === 1 && MAC_LANGUAGE_ENCODINGS[languageID]) {\n    return MAC_LANGUAGE_ENCODINGS[languageID];\n  }\n  \n  return ENCODINGS[platformID][encodingID];\n}\n\n// Map of platform ids to encoding ids.\nexport const ENCODINGS = [\n  // unicode\n  ['utf16be', 'utf16be', 'utf16be', 'utf16be', 'utf16be', 'utf16be'],\n  \n  // macintosh\n  // Mappings available at http://unicode.org/Public/MAPPINGS/VENDORS/APPLE/\n  // 0\tRoman                 17\tMalayalam\n  // 1\tJapanese\t            18\tSinhalese\n  // 2\tTraditional Chinese\t  19\tBurmese\n  // 3\tKorean\t              20\tKhmer\n  // 4\tArabic\t              21\tThai\n  // 5\tHebrew\t              22\tLaotian\n  // 6\tGreek\t                23\tGeorgian\n  // 7\tRussian\t              24\tArmenian\n  // 8\tRSymbol\t              25\tSimplified Chinese\n  // 9\tDevanagari\t          26\tTibetan\n  // 10\tGurmukhi\t            27\tMongolian\n  // 11\tGujarati\t            28\tGeez\n  // 12\tOriya\t                29\tSlavic\n  // 13\tBengali\t              30\tVietnamese\n  // 14\tTamil\t                31\tSindhi\n  // 15\tTelugu\t              32\t(Uninterpreted)\n  // 16\tKannada\n  ['macroman', 'shift-jis', 'big5', 'euc-kr', 'iso-8859-6', 'iso-8859-8',\n   'macgreek', 'maccyrillic', 'symbol', 'Devanagari', 'Gurmukhi', 'Gujarati',\n   'Oriya', 'Bengali', 'Tamil', 'Telugu', 'Kannada', 'Malayalam', 'Sinhalese',\n   'Burmese', 'Khmer', 'macthai', 'Laotian', 'Georgian', 'Armenian', 'gb-2312-80', \n   'Tibetan', 'Mongolian', 'Geez', 'maccenteuro', 'Vietnamese', 'Sindhi'],\n  \n  // ISO (deprecated)\n  ['ascii'],\n  \n  // windows\n  // Docs here: http://msdn.microsoft.com/en-us/library/system.text.encoding(v=vs.110).aspx\n  ['symbol', 'utf16be', 'shift-jis', 'gb18030', 'big5', 'wansung', 'johab', null, null, null, 'utf16be']\n];\n\n// Overrides for Mac scripts by language id.\n// See http://unicode.org/Public/MAPPINGS/VENDORS/APPLE/Readme.txt\nexport const MAC_LANGUAGE_ENCODINGS = {\n  15: 'maciceland',\n  17: 'macturkish',\n  18: 'maccroatian',\n  24: 'maccenteuro',\n  25: 'maccenteuro',\n  26: 'maccenteuro',\n  27: 'maccenteuro',\n  28: 'maccenteuro',\n  30: 'maciceland',\n  37: 'macromania',\n  38: 'maccenteuro',\n  39: 'maccenteuro',\n  40: 'maccenteuro',\n  143: 'macinuit', // Unsupported by iconv-lite\n  146: 'macgaelic' // Unsupported by iconv-lite\n};\n\n// Map of platform ids to BCP-47 language codes.\nexport const LANGUAGES = [\n  // unicode\n  [],\n  \n  { // macintosh\n    0: 'en',        30: 'fo',       60: 'ks',       90: 'rw',\n    1: 'fr',        31: 'fa',       61: 'ku',       91: 'rn',\n    2: 'de',        32: 'ru',       62: 'sd',       92: 'ny',\n    3: 'it',        33: 'zh',       63: 'bo',       93: 'mg',\n    4: 'nl',        34: 'nl-BE',    64: 'ne',       94: 'eo',\n    5: 'sv',        35: 'ga',       65: 'sa',       128: 'cy',\n    6: 'es',        36: 'sq',       66: 'mr',       129: 'eu',\n    7: 'da',        37: 'ro',       67: 'bn',       130: 'ca',\n    8: 'pt',        38: 'cz',       68: 'as',       131: 'la',\n    9: 'no',        39: 'sk',       69: 'gu',       132: 'qu',\n    10: 'he',       40: 'si',       70: 'pa',       133: 'gn',\n    11: 'ja',       41: 'yi',       71: 'or',       134: 'ay',\n    12: 'ar',       42: 'sr',       72: 'ml',       135: 'tt',\n    13: 'fi',       43: 'mk',       73: 'kn',       136: 'ug',\n    14: 'el',       44: 'bg',       74: 'ta',       137: 'dz',\n    15: 'is',       45: 'uk',       75: 'te',       138: 'jv',\n    16: 'mt',       46: 'be',       76: 'si',       139: 'su',\n    17: 'tr',       47: 'uz',       77: 'my',       140: 'gl',\n    18: 'hr',       48: 'kk',       78: 'km',       141: 'af',\n    19: 'zh-Hant',  49: 'az-Cyrl',  79: 'lo',       142: 'br',\n    20: 'ur',       50: 'az-Arab',  80: 'vi',       143: 'iu',\n    21: 'hi',       51: 'hy',       81: 'id',       144: 'gd',\n    22: 'th',       52: 'ka',       82: 'tl',       145: 'gv',\n    23: 'ko',       53: 'mo',       83: 'ms',       146: 'ga',\n    24: 'lt',       54: 'ky',       84: 'ms-Arab',  147: 'to',\n    25: 'pl',       55: 'tg',       85: 'am',       148: 'el-polyton',\n    26: 'hu',       56: 'tk',       86: 'ti',       149: 'kl',\n    27: 'es',       57: 'mn-CN',    87: 'om',       150: 'az',\n    28: 'lv',       58: 'mn',       88: 'so',       151: 'nn',\n    29: 'se',       59: 'ps',       89: 'sw',\n  },\n  \n  // ISO (deprecated)\n  [],\n  \n  { // windows                                        \n    0x0436: 'af',       0x4009: 'en-IN',    0x0487: 'rw',          0x0432: 'tn',       \n    0x041C: 'sq',       0x1809: 'en-IE',    0x0441: 'sw',          0x045B: 'si',          \n    0x0484: 'gsw',      0x2009: 'en-JM',    0x0457: 'kok',         0x041B: 'sk',          \n    0x045E: 'am',       0x4409: 'en-MY',    0x0412: 'ko',          0x0424: 'sl',          \n    0x1401: 'ar-DZ',    0x1409: 'en-NZ',    0x0440: 'ky',          0x2C0A: 'es-AR',       \n    0x3C01: 'ar-BH',    0x3409: 'en-PH',    0x0454: 'lo',          0x400A: 'es-BO',       \n    0x0C01: 'ar',       0x4809: 'en-SG',    0x0426: 'lv',          0x340A: 'es-CL',       \n    0x0801: 'ar-IQ',    0x1C09: 'en-ZA',    0x0427: 'lt',          0x240A: 'es-CO',       \n    0x2C01: 'ar-JO',    0x2C09: 'en-TT',    0x082E: 'dsb',         0x140A: 'es-CR',       \n    0x3401: 'ar-KW',    0x0809: 'en-GB',    0x046E: 'lb',          0x1C0A: 'es-DO',       \n    0x3001: 'ar-LB',    0x0409: 'en',       0x042F: 'mk',          0x300A: 'es-EC',       \n    0x1001: 'ar-LY',    0x3009: 'en-ZW',    0x083E: 'ms-BN',       0x440A: 'es-SV',       \n    0x1801: 'ary',      0x0425: 'et',       0x043E: 'ms',          0x100A: 'es-GT',       \n    0x2001: 'ar-OM',    0x0438: 'fo',       0x044C: 'ml',          0x480A: 'es-HN',       \n    0x4001: 'ar-QA',    0x0464: 'fil',      0x043A: 'mt',          0x080A: 'es-MX',       \n    0x0401: 'ar-SA',    0x040B: 'fi',       0x0481: 'mi',          0x4C0A: 'es-NI',       \n    0x2801: 'ar-SY',    0x080C: 'fr-BE',    0x047A: 'arn',         0x180A: 'es-PA',       \n    0x1C01: 'aeb',      0x0C0C: 'fr-CA',    0x044E: 'mr',          0x3C0A: 'es-PY',       \n    0x3801: 'ar-AE',    0x040C: 'fr',       0x047C: 'moh',         0x280A: 'es-PE',       \n    0x2401: 'ar-YE',    0x140C: 'fr-LU',    0x0450: 'mn',          0x500A: 'es-PR',       \n    0x042B: 'hy',       0x180C: 'fr-MC',    0x0850: 'mn-CN',       0x0C0A: 'es',          \n    0x044D: 'as',       0x100C: 'fr-CH',    0x0461: 'ne',          0x040A: 'es',          \n    0x082C: 'az-Cyrl',  0x0462: 'fy',       0x0414: 'nb',          0x540A: 'es-US',       \n    0x042C: 'az',       0x0456: 'gl',       0x0814: 'nn',          0x380A: 'es-UY',     \n    0x046D: 'ba',       0x0437: 'ka',       0x0482: 'oc',          0x200A: 'es-VE',       \n    0x042D: 'eu',       0x0C07: 'de-AT',    0x0448: 'or',          0x081D: 'sv-FI',       \n    0x0423: 'be',       0x0407: 'de',       0x0463: 'ps',          0x041D: 'sv',          \n    0x0845: 'bn',       0x1407: 'de-LI',    0x0415: 'pl',          0x045A: 'syr',         \n    0x0445: 'bn-IN',    0x1007: 'de-LU',    0x0416: 'pt',          0x0428: 'tg',          \n    0x201A: 'bs-Cyrl',  0x0807: 'de-CH',    0x0816: 'pt-PT',       0x085F: 'tzm',         \n    0x141A: 'bs',       0x0408: 'el',       0x0446: 'pa',          0x0449: 'ta',          \n    0x047E: 'br',       0x046F: 'kl',       0x046B: 'qu-BO',       0x0444: 'tt',          \n    0x0402: 'bg',       0x0447: 'gu',       0x086B: 'qu-EC',       0x044A: 'te',          \n    0x0403: 'ca',       0x0468: 'ha',       0x0C6B: 'qu',          0x041E: 'th',          \n    0x0C04: 'zh-HK',    0x040D: 'he',       0x0418: 'ro',          0x0451: 'bo',          \n    0x1404: 'zh-MO',    0x0439: 'hi',       0x0417: 'rm',          0x041F: 'tr',          \n    0x0804: 'zh',       0x040E: 'hu',       0x0419: 'ru',          0x0442: 'tk',          \n    0x1004: 'zh-SG',    0x040F: 'is',       0x243B: 'smn',         0x0480: 'ug',          \n    0x0404: 'zh-TW',    0x0470: 'ig',       0x103B: 'smj-NO',      0x0422: 'uk',          \n    0x0483: 'co',       0x0421: 'id',       0x143B: 'smj',         0x042E: 'hsb',         \n    0x041A: 'hr',       0x045D: 'iu',       0x0C3B: 'se-FI',       0x0420: 'ur',          \n    0x101A: 'hr-BA',    0x085D: 'iu-Latn',  0x043B: 'se',          0x0843: 'uz-Cyrl',     \n    0x0405: 'cs',       0x083C: 'ga',       0x083B: 'se-SE',       0x0443: 'uz',          \n    0x0406: 'da',       0x0434: 'xh',       0x203B: 'sms',         0x042A: 'vi',          \n    0x048C: 'prs',      0x0435: 'zu',       0x183B: 'sma-NO',      0x0452: 'cy',          \n    0x0465: 'dv',       0x0410: 'it',       0x1C3B: 'sms',         0x0488: 'wo',          \n    0x0813: 'nl-BE',    0x0810: 'it-CH',    0x044F: 'sa',          0x0485: 'sah',         \n    0x0413: 'nl',       0x0411: 'ja',       0x1C1A: 'sr-Cyrl-BA',  0x0478: 'ii',          \n    0x0C09: 'en-AU',    0x044B: 'kn',       0x0C1A: 'sr',          0x046A: 'yo',           \n    0x2809: 'en-BZ',    0x043F: 'kk',       0x181A: 'sr-Latn-BA',  \n    0x1009: 'en-CA',    0x0453: 'km',       0x081A: 'sr-Latn',     \n    0x2409: 'en-029',   0x0486: 'quc',      0x046C: 'nso',         \n  }\n];\n","import r from 'restructure';\nimport {getEncoding, LANGUAGES} from '../encodings';\n\nlet NameRecord = new r.Struct({\n  platformID: r.uint16,\n  encodingID: r.uint16,\n  languageID: r.uint16,\n  nameID:     r.uint16,\n  length:     r.uint16,\n  string:     new r.Pointer(r.uint16,\n    new r.String('length', t => getEncoding(t.platformID, t.encodingID, t.languageID)),\n    { type: 'parent', relativeTo: 'parent.stringOffset', allowNull: false }\n  )\n});\n\nlet LangTagRecord = new r.Struct({\n  length:  r.uint16,\n  tag:     new r.Pointer(r.uint16, new r.String('length', 'utf16be'), {type: 'parent', relativeTo: 'stringOffset'})\n});\n\nvar NameTable = new r.VersionedStruct(r.uint16, {\n  0: {\n    count:          r.uint16,\n    stringOffset:   r.uint16,\n    records:        new r.Array(NameRecord, 'count')\n  },\n  1: {\n    count:          r.uint16,\n    stringOffset:   r.uint16,\n    records:        new r.Array(NameRecord, 'count'),\n    langTagCount:   r.uint16,\n    langTags:       new r.Array(LangTagRecord, 'langTagCount')\n  }\n});\n\nexport default NameTable;\n\nconst NAMES = [\n  'copyright',\n  'fontFamily',\n  'fontSubfamily',\n  'uniqueSubfamily',\n  'fullName',\n  'version',\n  'postscriptName', // Note: A font may have only one PostScript name and that name must be ASCII.\n  'trademark',\n  'manufacturer',\n  'designer',\n  'description',\n  'vendorURL',\n  'designerURL',\n  'license',\n  'licenseURL',\n  null, // reserved\n  'preferredFamily',\n  'preferredSubfamily',\n  'compatibleFull',\n  'sampleText',\n  'postscriptCIDFontName',\n  'wwsFamilyName',\n  'wwsSubfamilyName'\n];\n\nNameTable.process = function(stream) {\n  var records = {};\n  for (let record of this.records) {\n    // find out what language this is for\n    let language = LANGUAGES[record.platformID][record.languageID];\n\n    if (language == null && this.langTags != null && record.languageID >= 0x8000) {\n      language = this.langTags[record.languageID - 0x8000].tag;\n    }\n\n    if (language == null) {\n      language = record.platformID + '-' + record.languageID;\n    }\n\n    // if the nameID is >= 256, it is a font feature record (AAT)\n    let key = record.nameID >= 256 ? 'fontFeatures' : (NAMES[record.nameID] || record.nameID);\n    if (records[key] == null) {\n      records[key] = {};\n    }\n\n    let obj = records[key];\n    if (record.nameID >= 256) {\n      obj = obj[record.nameID] || (obj[record.nameID] = {});\n    }\n\n    if (typeof record.string === 'string' || typeof obj[language] !== 'string') {\n      obj[language] = record.string;\n    }\n  }\n\n  this.records = records;\n};\n\nNameTable.preEncode = function() {\n  if (Array.isArray(this.records)) return;\n  this.version = 0;\n\n  let records = [];\n  for (let key in this.records) {\n    let val = this.records[key];\n    if (key === 'fontFeatures') continue;\n\n    records.push({\n      platformID: 3,\n      encodingID: 1,\n      languageID: 0x409,\n      nameID: NAMES.indexOf(key),\n      length: Buffer.byteLength(val.en, 'utf16le'),\n      string: val.en\n    });\n\n    if (key === 'postscriptName') {\n      records.push({\n        platformID: 1,\n        encodingID: 0,\n        languageID: 0,\n        nameID: NAMES.indexOf(key),\n        length: val.en.length,\n        string: val.en\n      });\n    }\n  }\n\n  this.records = records;\n  this.count = records.length;\n  this.stringOffset = NameTable.size(this, null, false);\n};\n","import r from 'restructure';\n\nvar OS2 = new r.VersionedStruct(r.uint16, {\n  header: {\n    xAvgCharWidth:          r.int16,   // average weighted advance width of lower case letters and space\n    usWeightClass:          r.uint16,  // visual weight of stroke in glyphs\n    usWidthClass:           r.uint16,  // relative change from the normal aspect ratio (width to height ratio)\n    fsType:                 new r.Bitfield(r.uint16, [ // Indicates font embedding licensing rights\n      null, 'noEmbedding', 'viewOnly', 'editable', null,\n      null, null, null, 'noSubsetting', 'bitmapOnly'\n    ]),\n    ySubscriptXSize:        r.int16,   // recommended horizontal size in pixels for subscripts\n    ySubscriptYSize:        r.int16,   // recommended vertical size in pixels for subscripts\n    ySubscriptXOffset:      r.int16,   // recommended horizontal offset for subscripts\n    ySubscriptYOffset:      r.int16,   // recommended vertical offset form the baseline for subscripts\n    ySuperscriptXSize:      r.int16,   // recommended horizontal size in pixels for superscripts\n    ySuperscriptYSize:      r.int16,   // recommended vertical size in pixels for superscripts\n    ySuperscriptXOffset:    r.int16,   // recommended horizontal offset for superscripts\n    ySuperscriptYOffset:    r.int16,   // recommended vertical offset from the baseline for superscripts\n    yStrikeoutSize:         r.int16,   // width of the strikeout stroke\n    yStrikeoutPosition:     r.int16,   // position of the strikeout stroke relative to the baseline\n    sFamilyClass:           r.int16,   // classification of font-family design\n    panose:                 new r.Array(r.uint8, 10),   // describe the visual characteristics of a given typeface\n    ulCharRange:            new r.Array(r.uint32, 4),\n    vendorID:               new r.String(4),          // four character identifier for the font vendor\n    fsSelection:            new r.Bitfield(r.uint16, [  // bit field containing information about the font\n      'italic', 'underscore', 'negative', 'outlined', 'strikeout',\n      'bold', 'regular', 'useTypoMetrics', 'wws', 'oblique'\n    ]),\n    usFirstCharIndex:       r.uint16,  // The minimum Unicode index in this font\n    usLastCharIndex:        r.uint16   // The maximum Unicode index in this font\n  },\n\n  // The Apple version of this table ends here, but the Microsoft one continues on...\n  0: {},\n\n  1: {\n    typoAscender:       r.int16,\n    typoDescender:      r.int16,\n    typoLineGap:        r.int16,\n    winAscent:          r.uint16,\n    winDescent:         r.uint16,\n    codePageRange:      new r.Array(r.uint32, 2)\n  },\n\n  2: {\n    // these should be common with version 1 somehow\n    typoAscender:       r.int16,\n    typoDescender:      r.int16,\n    typoLineGap:        r.int16,\n    winAscent:          r.uint16,\n    winDescent:         r.uint16,\n    codePageRange:      new r.Array(r.uint32, 2),\n\n    xHeight:            r.int16,\n    capHeight:          r.int16,\n    defaultChar:        r.uint16,\n    breakChar:          r.uint16,\n    maxContent:         r.uint16\n  },\n\n  5: {\n    typoAscender:       r.int16,\n    typoDescender:      r.int16,\n    typoLineGap:        r.int16,\n    winAscent:          r.uint16,\n    winDescent:         r.uint16,\n    codePageRange:      new r.Array(r.uint32, 2),\n\n    xHeight:            r.int16,\n    capHeight:          r.int16,\n    defaultChar:        r.uint16,\n    breakChar:          r.uint16,\n    maxContent:         r.uint16,\n\n    usLowerOpticalPointSize: r.uint16,\n    usUpperOpticalPointSize: r.uint16\n  }\n});\n\nlet versions = OS2.versions;\nversions[3] = versions[4] = versions[2];\n\nexport default OS2;\n","import r from 'restructure';\n\n// PostScript information\nexport default new r.VersionedStruct(r.fixed32, {\n  header: { // these fields exist at the top of all versions\n    italicAngle:        r.fixed32, // Italic angle in counter-clockwise degrees from the vertical.\n    underlinePosition:  r.int16,   // Suggested distance of the top of the underline from the baseline\n    underlineThickness: r.int16,   // Suggested values for the underline thickness\n    isFixedPitch:       r.uint32,  // Whether the font is monospaced\n    minMemType42:       r.uint32,  // Minimum memory usage when a TrueType font is downloaded as a Type 42 font\n    maxMemType42:       r.uint32,  // Maximum memory usage when a TrueType font is downloaded as a Type 42 font\n    minMemType1:        r.uint32,  // Minimum memory usage when a TrueType font is downloaded as a Type 1 font\n    maxMemType1:        r.uint32   // Maximum memory usage when a TrueType font is downloaded as a Type 1 font\n  },\n\n  1: {}, // version 1 has no additional fields\n\n  2: {\n    numberOfGlyphs: r.uint16,\n    glyphNameIndex: new r.Array(r.uint16, 'numberOfGlyphs'),\n    names:          new r.Array(new r.String(r.uint8))\n  },\n\n  2.5: {\n    numberOfGlyphs: r.uint16,\n    offsets:        new r.Array(r.uint8, 'numberOfGlyphs')\n  },\n\n  3: {}, // version 3 has no additional fields\n\n  4: {\n    map: new r.Array(r.uint32, t => t.parent.maxp.numGlyphs)\n  }\n});\n","import r from 'restructure';\n\n// An array of predefined values accessible by instructions\nexport default new r.Struct({\n  controlValues: new r.Array(r.int16)\n});\n","import r from 'restructure';\n\n// A list of instructions that are executed once when a font is first used.\n// These instructions are known as the font program. The main use of this table\n// is for the definition of functions that are used in many different glyph programs.\nexport default new r.Struct({\n  instructions: new r.Array(r.uint8)\n});\n","import r from 'restructure';\n\nlet loca = new r.VersionedStruct('head.indexToLocFormat', {\n  0: {\n    offsets: new r.Array(r.uint16)\n  },\n  1: {\n    offsets: new r.Array(r.uint32)\n  }\n});\n\nloca.process = function() {\n  if (this.version === 0) {\n    for (let i = 0; i < this.offsets.length; i++) {\n      this.offsets[i] <<= 1;\n    }\n  }\n};\n\nloca.preEncode = function() {\n  if (this.version === 0) {\n    for (let i = 0; i < this.offsets.length; i++) {\n      this.offsets[i] >>>= 1;\n    }\n  }\n};\n\nexport default loca;\n","import r from 'restructure';\n\n// Set of instructions executed whenever the point size or font transformation change\nexport default new r.Struct({\n  controlValueProgram: new r.Array(r.uint8)\n});\n","import r from 'restructure';\n\n// only used for encoding\nexport default new r.Array(new r.Buffer);\n","import r from 'restructure';\n\nexport default class CFFIndex {\n  constructor(type) {\n    this.type = type;\n  }\n\n  getCFFVersion(ctx) {\n    while (ctx && !ctx.hdrSize) {\n      ctx = ctx.parent;\n    }\n\n    return ctx ? ctx.version : -1;\n  }\n\n  decode(stream, parent) {\n    let version = this.getCFFVersion(parent);\n    let count = version >= 2\n      ? stream.readUInt32BE()\n      : stream.readUInt16BE();\n\n    if (count === 0) {\n      return [];\n    }\n\n    let offSize = stream.readUInt8();\n    let offsetType;\n    if (offSize === 1) {\n      offsetType = r.uint8;\n    } else if (offSize === 2) {\n      offsetType = r.uint16;\n    } else if (offSize === 3) {\n      offsetType = r.uint24;\n    } else if (offSize === 4) {\n      offsetType = r.uint32;\n    } else {\n      throw new Error(`Bad offset size in CFFIndex: ${offSize} ${stream.pos}`);\n    }\n\n    let ret = [];\n    let startPos = stream.pos + ((count + 1) * offSize) - 1;\n\n    let start = offsetType.decode(stream);\n    for (let i = 0; i < count; i++) {\n      let end = offsetType.decode(stream);\n\n      if (this.type != null) {\n        let pos = stream.pos;\n        stream.pos = startPos + start;\n\n        parent.length = end - start;\n        ret.push(this.type.decode(stream, parent));\n        stream.pos = pos;\n      } else {\n        ret.push({\n          offset: startPos + start,\n          length: end - start\n        });\n      }\n\n      start = end;\n    }\n\n    stream.pos = startPos + start;\n    return ret;\n  }\n\n  size(arr, parent) {\n    let size = 2;\n    if (arr.length === 0) {\n      return size;\n    }\n\n    let type = this.type || new r.Buffer;\n\n    // find maximum offset to detminine offset type\n    let offset = 1;\n    for (let i = 0; i < arr.length; i++) {\n      let item = arr[i];\n      offset += type.size(item, parent);\n    }\n\n    let offsetType;\n    if (offset <= 0xff) {\n      offsetType = r.uint8;\n    } else if (offset <= 0xffff) {\n      offsetType = r.uint16;\n    } else if (offset <= 0xffffff) {\n      offsetType = r.uint24;\n    } else if (offset <= 0xffffffff) {\n      offsetType = r.uint32;\n    } else {\n      throw new Error(\"Bad offset in CFFIndex\");\n    }\n\n    size += 1 + offsetType.size() * (arr.length + 1);\n    size += offset - 1;\n\n    return size;\n  }\n\n  encode(stream, arr, parent) {\n    stream.writeUInt16BE(arr.length);\n    if (arr.length === 0) {\n      return;\n    }\n\n    let type = this.type || new r.Buffer;\n\n    // find maximum offset to detminine offset type\n    let sizes = [];\n    let offset = 1;\n    for (let item of arr) {\n      let s = type.size(item, parent);\n      sizes.push(s);\n      offset += s;\n    }\n\n    let offsetType;\n    if (offset <= 0xff) {\n      offsetType = r.uint8;\n    } else if (offset <= 0xffff) {\n      offsetType = r.uint16;\n    } else if (offset <= 0xffffff) {\n      offsetType = r.uint24;\n    } else if (offset <= 0xffffffff) {\n      offsetType = r.uint32;\n    } else {\n      throw new Error(\"Bad offset in CFFIndex\");\n    }\n\n    // write offset size\n    stream.writeUInt8(offsetType.size());\n\n    // write elements\n    offset = 1;\n    offsetType.encode(stream, offset);\n\n    for (let size of sizes) {\n      offset += size;\n      offsetType.encode(stream, offset);\n    }\n\n    for (let item of arr) {\n      type.encode(stream, item, parent);\n    }\n\n    return;\n  }\n}\n","const FLOAT_EOF = 0xf;\nconst FLOAT_LOOKUP = [\n  '0', '1', '2', '3', '4', '5', '6', '7',\n  '8', '9', '.', 'E', 'E-', null, '-'\n];\n\nconst FLOAT_ENCODE_LOOKUP = {\n  '.': 10,\n  'E': 11,\n  'E-': 12,\n  '-': 14\n};\n\nexport default class CFFOperand {\n  static decode(stream, value) {\n    if (32 <= value && value <= 246) {\n      return value - 139;\n    }\n\n    if (247 <= value && value <= 250) {\n      return (value - 247) * 256 + stream.readUInt8() + 108;\n    }\n\n    if (251 <= value && value <= 254) {\n      return -(value - 251) * 256 - stream.readUInt8() - 108;\n    }\n\n    if (value === 28) {\n      return stream.readInt16BE();\n    }\n\n    if (value === 29) {\n      return stream.readInt32BE();\n    }\n\n    if (value === 30) {\n      let str = '';\n      while (true) {\n        let b = stream.readUInt8();\n\n        let n1 = b >> 4;\n        if (n1 === FLOAT_EOF) { break; }\n        str += FLOAT_LOOKUP[n1];\n\n        let n2 = b & 15;\n        if (n2 === FLOAT_EOF) { break; }\n        str += FLOAT_LOOKUP[n2];\n      }\n\n      return parseFloat(str);\n    }\n\n    return null;\n  }\n\n  static size(value) {\n    // if the value needs to be forced to the largest size (32 bit)\n    // e.g. for unknown pointers, set to 32768\n    if (value.forceLarge) {\n      value = 32768;\n    }\n\n    if ((value | 0) !== value) { // floating point\n      let str = '' + value;\n      return 1 + Math.ceil((str.length + 1) / 2);\n\n    } else if (-107 <= value && value <= 107) {\n      return 1;\n\n    } else if (108 <= value && value <= 1131 || -1131 <= value && value <= -108) {\n      return 2;\n\n    } else if (-32768 <= value && value <= 32767) {\n      return 3;\n\n    } else {\n      return 5;\n    }\n  }\n\n  static encode(stream, value) {\n    // if the value needs to be forced to the largest size (32 bit)\n    // e.g. for unknown pointers, save the old value and set to 32768\n    let val = Number(value);\n\n    if (value.forceLarge) {\n      stream.writeUInt8(29);\n      return stream.writeInt32BE(val);\n\n    } else if ((val | 0) !== val) { // floating point\n      stream.writeUInt8(30);\n\n      let str = '' + val;\n      for (let i = 0; i < str.length; i += 2) {\n        let c1 = str[i];\n        let n1 = FLOAT_ENCODE_LOOKUP[c1] || +c1;\n\n        if (i === str.length - 1) {\n          var n2 = FLOAT_EOF;\n        } else {\n          let c2 = str[i + 1];\n          var n2 = FLOAT_ENCODE_LOOKUP[c2] || +c2;\n        }\n\n        stream.writeUInt8((n1 << 4) | (n2 & 15));\n      }\n\n      if (n2 !== FLOAT_EOF) {\n        return stream.writeUInt8((FLOAT_EOF << 4));\n      }\n\n    } else if (-107 <= val && val <= 107) {\n      return stream.writeUInt8(val + 139);\n\n    } else if (108 <= val && val <= 1131) {\n      val -= 108;\n      stream.writeUInt8((val >> 8) + 247);\n      return stream.writeUInt8(val & 0xff);\n\n    } else if (-1131 <= val && val <= -108) {\n      val = -val - 108;\n      stream.writeUInt8((val >> 8) + 251);\n      return stream.writeUInt8(val & 0xff);\n\n    } else if (-32768 <= val && val <= 32767) {\n      stream.writeUInt8(28);\n      return stream.writeInt16BE(val);\n\n    } else {\n      stream.writeUInt8(29);\n      return stream.writeInt32BE(val);\n    }\n  }\n}\n","import isEqual from 'deep-equal';\nimport r from 'restructure';\nimport CFFOperand from './CFFOperand';\nimport { PropertyDescriptor } from 'restructure/src/utils';\n\nexport default class CFFDict {\n  constructor(ops = []) {\n    this.ops = ops;\n    this.fields = {};\n    for (let field of ops) {\n      let key = Array.isArray(field[0]) ? field[0][0] << 8 | field[0][1] : field[0];\n      this.fields[key] = field;\n    }\n  }\n\n  decodeOperands(type, stream, ret, operands) {\n    if (Array.isArray(type)) {\n      return operands.map((op, i) => this.decodeOperands(type[i], stream, ret, [op]));\n    } else if (type.decode != null) {\n      return type.decode(stream, ret, operands);\n    } else {\n      switch (type) {\n        case 'number':\n        case 'offset':\n        case 'sid':\n          return operands[0];\n        case 'boolean':\n          return !!operands[0];\n        default:\n          return operands;\n      }\n    }\n  }\n\n  encodeOperands(type, stream, ctx, operands) {\n    if (Array.isArray(type)) {\n      return operands.map((op, i) => this.encodeOperands(type[i], stream, ctx, op)[0]);\n    } else if (type.encode != null) {\n      return type.encode(stream, operands, ctx);\n    } else if (typeof operands === 'number') {\n      return [operands];\n    } else if (typeof operands === 'boolean') {\n      return [+operands];\n    } else if (Array.isArray(operands)) {\n      return operands;\n    } else {\n      return [operands];\n    }\n  }\n\n  decode(stream, parent) {\n    let end = stream.pos + parent.length;\n    let ret = {};\n    let operands = [];\n\n    // define hidden properties\n    Object.defineProperties(ret, {\n      parent:         { value: parent },\n      _startOffset:   { value: stream.pos }\n    });\n\n    // fill in defaults\n    for (let key in this.fields) {\n      let field = this.fields[key];\n      ret[field[1]] = field[3];\n    }\n\n    while (stream.pos < end) {\n      let b = stream.readUInt8();\n      if (b < 28) {\n        if (b === 12) {\n          b = (b << 8) | stream.readUInt8();\n        }\n\n        let field = this.fields[b];\n        if (!field) {\n          throw new Error(`Unknown operator ${b}`);\n        }\n\n        let val = this.decodeOperands(field[2], stream, ret, operands);\n        if (val != null) {\n          if (val instanceof PropertyDescriptor) {\n            Object.defineProperty(ret, field[1], val);\n          } else {\n            ret[field[1]] = val;\n          }\n        }\n\n        operands = [];\n      } else {\n        operands.push(CFFOperand.decode(stream, b));\n      }\n    }\n\n    return ret;\n  }\n\n  size(dict, parent, includePointers = true) {\n    let ctx = {\n      parent,\n      val: dict,\n      pointerSize: 0,\n      startOffset: parent.startOffset || 0\n    };\n\n    let len = 0;\n\n    for (let k in this.fields) {\n      let field = this.fields[k];\n      let val = dict[field[1]];\n      if (val == null || isEqual(val, field[3])) {\n        continue;\n      }\n\n      let operands = this.encodeOperands(field[2], null, ctx, val);\n      for (let op of operands) {\n        len += CFFOperand.size(op);\n      }\n\n      let key = Array.isArray(field[0]) ? field[0] : [field[0]];\n      len += key.length;\n    }\n\n    if (includePointers) {\n      len += ctx.pointerSize;\n    }\n\n    return len;\n  }\n\n  encode(stream, dict, parent) {\n    let ctx = {\n      pointers: [],\n      startOffset: stream.pos,\n      parent,\n      val: dict,\n      pointerSize: 0\n    };\n\n    ctx.pointerOffset = stream.pos + this.size(dict, ctx, false);\n\n    for (let field of this.ops) {\n      let val = dict[field[1]];\n      if (val == null || isEqual(val, field[3])) {\n        continue;\n      }\n\n      let operands = this.encodeOperands(field[2], stream, ctx, val);\n      for (let op of operands) {\n        CFFOperand.encode(stream, op);\n      }\n\n      let key = Array.isArray(field[0]) ? field[0] : [field[0]];\n      for (let op of key) {\n        stream.writeUInt8(op);\n      }\n    }\n\n    let i = 0;\n    while (i < ctx.pointers.length) {\n      let ptr = ctx.pointers[i++];\n      ptr.type.encode(stream, ptr.val, ptr.parent);\n    }\n\n    return;\n  }\n}\n","import r from 'restructure';\n\nexport default class CFFPointer extends r.Pointer {\n  constructor(type, options = {}) {\n    if (options.type == null) {\n      options.type = 'global';\n    }\n\n    super(null, type, options);\n  }\n\n  decode(stream, parent, operands) {\n    this.offsetType = {\n      decode: () => operands[0]\n    };\n\n    return super.decode(stream, parent, operands);\n  }\n\n  encode(stream, value, ctx) {\n    if (!stream) {\n      // compute the size (so ctx.pointerSize is correct)\n      this.offsetType = {\n        size: () => 0\n      };\n\n      this.size(value, ctx);\n      return [new Ptr(0)];\n    }\n\n    let ptr = null;\n    this.offsetType = {\n      encode: (stream, val) => ptr = val\n    };\n\n    super.encode(stream, value, ctx);\n    return [new Ptr(ptr)];\n  }\n}\n\nclass Ptr {\n  constructor(val) {\n    this.val = val;\n    this.forceLarge = true;\n  }\n\n  valueOf() {\n    return this.val;\n  }\n}\n","import CFFDict from './CFFDict';\nimport CFFIndex from './CFFIndex';\nimport CFFPointer from './CFFPointer';\n\nclass CFFBlendOp {\n  static decode(stream, parent, operands) {\n    let numBlends = operands.pop();\n\n    // TODO: actually blend. For now just consume the deltas\n    // since we don't use any of the values anyway.\n    while (operands.length > numBlends) {\n      operands.pop();\n    }\n  }\n}\n\nexport default new CFFDict([\n  // key       name                    type                                          default\n  [6,         'BlueValues',           'delta',                                       null],\n  [7,         'OtherBlues',           'delta',                                       null],\n  [8,         'FamilyBlues',          'delta',                                       null],\n  [9,         'FamilyOtherBlues',     'delta',                                       null],\n  [[12, 9],   'BlueScale',            'number',                                      0.039625],\n  [[12, 10],  'BlueShift',            'number',                                      7],\n  [[12, 11],  'BlueFuzz',             'number',                                      1],\n  [10,        'StdHW',                'number',                                      null],\n  [11,        'StdVW',                'number',                                      null],\n  [[12, 12],  'StemSnapH',            'delta',                                       null],\n  [[12, 13],  'StemSnapV',            'delta',                                       null],\n  [[12, 14],  'ForceBold',            'boolean',                                     false],\n  [[12, 17],  'LanguageGroup',        'number',                                      0],\n  [[12, 18],  'ExpansionFactor',      'number',                                      0.06],\n  [[12, 19],  'initialRandomSeed',    'number',                                      0],\n  [20,        'defaultWidthX',        'number',                                      0],\n  [21,        'nominalWidthX',        'number',                                      0],\n  [22,        'vsindex',              'number',                                      0],\n  [23,        'blend',                CFFBlendOp,                                    null],\n  [19,        'Subrs',                new CFFPointer(new CFFIndex, {type: 'local'}), null]\n]);\n","// Automatically generated from Appendix A of the CFF specification; do\n// not edit. Length should be 391.\nexport default [\n  \".notdef\", \"space\", \"exclam\", \"quotedbl\", \"numbersign\", \"dollar\",\n  \"percent\", \"ampersand\", \"quoteright\", \"parenleft\", \"parenright\",\n  \"asterisk\", \"plus\", \"comma\", \"hyphen\", \"period\", \"slash\", \"zero\", \"one\",\n  \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\", \"colon\",\n  \"semicolon\", \"less\", \"equal\", \"greater\", \"question\", \"at\", \"A\", \"B\", \"C\",\n  \"D\", \"E\", \"F\", \"G\", \"H\", \"I\", \"J\", \"K\", \"L\", \"M\", \"N\", \"O\", \"P\", \"Q\", \"R\",\n  \"S\", \"T\", \"U\", \"V\", \"W\", \"X\", \"Y\", \"Z\", \"bracketleft\", \"backslash\",\n  \"bracketright\", \"asciicircum\", \"underscore\", \"quoteleft\", \"a\", \"b\", \"c\",\n  \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\",\n  \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\", \"braceleft\", \"bar\", \"braceright\",\n  \"asciitilde\", \"exclamdown\", \"cent\", \"sterling\", \"fraction\", \"yen\",\n  \"florin\", \"section\", \"currency\", \"quotesingle\", \"quotedblleft\",\n  \"guillemotleft\", \"guilsinglleft\", \"guilsinglright\", \"fi\", \"fl\", \"endash\",\n  \"dagger\", \"daggerdbl\", \"periodcentered\", \"paragraph\", \"bullet\",\n  \"quotesinglbase\", \"quotedblbase\", \"quotedblright\", \"guillemotright\",\n  \"ellipsis\", \"perthousand\", \"questiondown\", \"grave\", \"acute\", \"circumflex\",\n  \"tilde\", \"macron\", \"breve\", \"dotaccent\", \"dieresis\", \"ring\", \"cedilla\",\n  \"hungarumlaut\", \"ogonek\", \"caron\", \"emdash\", \"AE\", \"ordfeminine\", \"Lslash\",\n  \"Oslash\", \"OE\", \"ordmasculine\", \"ae\", \"dotlessi\", \"lslash\", \"oslash\", \"oe\",\n  \"germandbls\", \"onesuperior\", \"logicalnot\", \"mu\", \"trademark\", \"Eth\",\n  \"onehalf\", \"plusminus\", \"Thorn\", \"onequarter\", \"divide\", \"brokenbar\",\n  \"degree\", \"thorn\", \"threequarters\", \"twosuperior\", \"registered\", \"minus\",\n  \"eth\", \"multiply\", \"threesuperior\", \"copyright\", \"Aacute\", \"Acircumflex\",\n  \"Adieresis\", \"Agrave\", \"Aring\", \"Atilde\", \"Ccedilla\", \"Eacute\",\n  \"Ecircumflex\", \"Edieresis\", \"Egrave\", \"Iacute\", \"Icircumflex\", \"Idieresis\",\n  \"Igrave\", \"Ntilde\", \"Oacute\", \"Ocircumflex\", \"Odieresis\", \"Ograve\",\n  \"Otilde\", \"Scaron\", \"Uacute\", \"Ucircumflex\", \"Udieresis\", \"Ugrave\",\n  \"Yacute\", \"Ydieresis\", \"Zcaron\", \"aacute\", \"acircumflex\", \"adieresis\",\n  \"agrave\", \"aring\", \"atilde\", \"ccedilla\", \"eacute\", \"ecircumflex\",\n  \"edieresis\", \"egrave\", \"iacute\", \"icircumflex\", \"idieresis\", \"igrave\",\n  \"ntilde\", \"oacute\", \"ocircumflex\", \"odieresis\", \"ograve\", \"otilde\",\n  \"scaron\", \"uacute\", \"ucircumflex\", \"udieresis\", \"ugrave\", \"yacute\",\n  \"ydieresis\", \"zcaron\", \"exclamsmall\", \"Hungarumlautsmall\",\n  \"dollaroldstyle\", \"dollarsuperior\", \"ampersandsmall\", \"Acutesmall\",\n  \"parenleftsuperior\", \"parenrightsuperior\", \"twodotenleader\",\n  \"onedotenleader\", \"zerooldstyle\", \"oneoldstyle\", \"twooldstyle\",\n  \"threeoldstyle\", \"fouroldstyle\", \"fiveoldstyle\", \"sixoldstyle\",\n  \"sevenoldstyle\", \"eightoldstyle\", \"nineoldstyle\", \"commasuperior\",\n  \"threequartersemdash\", \"periodsuperior\", \"questionsmall\", \"asuperior\",\n  \"bsuperior\", \"centsuperior\", \"dsuperior\", \"esuperior\", \"isuperior\",\n  \"lsuperior\", \"msuperior\", \"nsuperior\", \"osuperior\", \"rsuperior\",\n  \"ssuperior\", \"tsuperior\", \"ff\", \"ffi\", \"ffl\", \"parenleftinferior\",\n  \"parenrightinferior\", \"Circumflexsmall\", \"hyphensuperior\", \"Gravesmall\",\n  \"Asmall\", \"Bsmall\", \"Csmall\", \"Dsmall\", \"Esmall\", \"Fsmall\", \"Gsmall\",\n  \"Hsmall\", \"Ismall\", \"Jsmall\", \"Ksmall\", \"Lsmall\", \"Msmall\", \"Nsmall\",\n  \"Osmall\", \"Psmall\", \"Qsmall\", \"Rsmall\", \"Ssmall\", \"Tsmall\", \"Usmall\",\n  \"Vsmall\", \"Wsmall\", \"Xsmall\", \"Ysmall\", \"Zsmall\", \"colonmonetary\",\n  \"onefitted\", \"rupiah\", \"Tildesmall\", \"exclamdownsmall\", \"centoldstyle\",\n  \"Lslashsmall\", \"Scaronsmall\", \"Zcaronsmall\", \"Dieresissmall\", \"Brevesmall\",\n  \"Caronsmall\", \"Dotaccentsmall\", \"Macronsmall\", \"figuredash\",\n  \"hypheninferior\", \"Ogoneksmall\", \"Ringsmall\", \"Cedillasmall\",\n  \"questiondownsmall\", \"oneeighth\", \"threeeighths\", \"fiveeighths\",\n  \"seveneighths\", \"onethird\", \"twothirds\", \"zerosuperior\", \"foursuperior\",\n  \"fivesuperior\", \"sixsuperior\", \"sevensuperior\", \"eightsuperior\",\n  \"ninesuperior\", \"zeroinferior\", \"oneinferior\", \"twoinferior\",\n  \"threeinferior\", \"fourinferior\", \"fiveinferior\", \"sixinferior\",\n  \"seveninferior\", \"eightinferior\", \"nineinferior\", \"centinferior\",\n  \"dollarinferior\", \"periodinferior\", \"commainferior\", \"Agravesmall\",\n  \"Aacutesmall\", \"Acircumflexsmall\", \"Atildesmall\", \"Adieresissmall\",\n  \"Aringsmall\", \"AEsmall\", \"Ccedillasmall\", \"Egravesmall\", \"Eacutesmall\",\n  \"Ecircumflexsmall\", \"Edieresissmall\", \"Igravesmall\", \"Iacutesmall\",\n  \"Icircumflexsmall\", \"Idieresissmall\", \"Ethsmall\", \"Ntildesmall\",\n  \"Ogravesmall\", \"Oacutesmall\", \"Ocircumflexsmall\", \"Otildesmall\",\n  \"Odieresissmall\", \"OEsmall\", \"Oslashsmall\", \"Ugravesmall\", \"Uacutesmall\",\n  \"Ucircumflexsmall\", \"Udieresissmall\", \"Yacutesmall\", \"Thornsmall\",\n  \"Ydieresissmall\", \"001.000\", \"001.001\", \"001.002\", \"001.003\", \"Black\",\n  \"Bold\", \"Book\", \"Light\", \"Medium\", \"Regular\", \"Roman\", \"Semibold\"\n];\n","export let StandardEncoding = [\n  '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '',\n  '', '', '', '', 'space', 'exclam', 'quotedbl', 'numbersign', 'dollar', 'percent', 'ampersand', 'quoteright',\n  'parenleft', 'parenright', 'asterisk', 'plus', 'comma', 'hyphen', 'period', 'slash', 'zero', 'one', 'two',\n  'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'colon', 'semicolon', 'less', 'equal', 'greater',\n  'question', 'at', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S',\n  'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'bracketleft', 'backslash', 'bracketright', 'asciicircum', 'underscore',\n  'quoteleft', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't',\n  'u', 'v', 'w', 'x', 'y', 'z', 'braceleft', 'bar', 'braceright', 'asciitilde', '', '', '', '', '', '', '', '',\n  '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '',\n  'exclamdown', 'cent', 'sterling', 'fraction', 'yen', 'florin', 'section', 'currency', 'quotesingle',\n  'quotedblleft', 'guillemotleft', 'guilsinglleft', 'guilsinglright', 'fi', 'fl', '', 'endash', 'dagger',\n  'daggerdbl', 'periodcentered', '', 'paragraph', 'bullet', 'quotesinglbase', 'quotedblbase', 'quotedblright',\n  'guillemotright', 'ellipsis', 'perthousand', '', 'questiondown', '', 'grave', 'acute', 'circumflex', 'tilde',\n  'macron', 'breve', 'dotaccent', 'dieresis', '', 'ring', 'cedilla', '', 'hungarumlaut', 'ogonek', 'caron',\n  'emdash', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', 'AE', '', 'ordfeminine', '', '', '',\n  '', 'Lslash', 'Oslash', 'OE', 'ordmasculine', '', '', '', '', '', 'ae', '', '', '', 'dotlessi', '', '',\n  'lslash', 'oslash', 'oe', 'germandbls'\n];\n\nexport let ExpertEncoding = [\n  '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '',\n  '', '', '', '', 'space', 'exclamsmall', 'Hungarumlautsmall', '', 'dollaroldstyle', 'dollarsuperior',\n  'ampersandsmall', 'Acutesmall', 'parenleftsuperior', 'parenrightsuperior', 'twodotenleader', 'onedotenleader',\n  'comma', 'hyphen', 'period', 'fraction', 'zerooldstyle', 'oneoldstyle', 'twooldstyle', 'threeoldstyle',\n  'fouroldstyle', 'fiveoldstyle', 'sixoldstyle', 'sevenoldstyle', 'eightoldstyle', 'nineoldstyle', 'colon',\n  'semicolon', 'commasuperior', 'threequartersemdash', 'periodsuperior', 'questionsmall', '', 'asuperior',\n  'bsuperior', 'centsuperior', 'dsuperior', 'esuperior', '', '', 'isuperior', '', '', 'lsuperior', 'msuperior',\n  'nsuperior', 'osuperior', '', '', 'rsuperior', 'ssuperior', 'tsuperior', '', 'ff', 'fi', 'fl', 'ffi', 'ffl',\n  'parenleftinferior', '', 'parenrightinferior', 'Circumflexsmall', 'hyphensuperior', 'Gravesmall', 'Asmall',\n  'Bsmall', 'Csmall', 'Dsmall', 'Esmall', 'Fsmall', 'Gsmall', 'Hsmall', 'Ismall', 'Jsmall', 'Ksmall', 'Lsmall',\n  'Msmall', 'Nsmall', 'Osmall', 'Psmall', 'Qsmall', 'Rsmall', 'Ssmall', 'Tsmall', 'Usmall', 'Vsmall', 'Wsmall',\n  'Xsmall', 'Ysmall', 'Zsmall', 'colonmonetary', 'onefitted', 'rupiah', 'Tildesmall', '', '', '', '', '', '', '',\n  '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '',\n  'exclamdownsmall', 'centoldstyle', 'Lslashsmall', '', '', 'Scaronsmall', 'Zcaronsmall', 'Dieresissmall',\n  'Brevesmall', 'Caronsmall', '', 'Dotaccentsmall', '', '', 'Macronsmall', '', '', 'figuredash', 'hypheninferior',\n  '', '', 'Ogoneksmall', 'Ringsmall', 'Cedillasmall', '', '', '', 'onequarter', 'onehalf', 'threequarters',\n  'questiondownsmall', 'oneeighth', 'threeeighths', 'fiveeighths', 'seveneighths', 'onethird', 'twothirds', '',\n  '', 'zerosuperior', 'onesuperior', 'twosuperior', 'threesuperior', 'foursuperior', 'fivesuperior',\n  'sixsuperior', 'sevensuperior', 'eightsuperior', 'ninesuperior', 'zeroinferior', 'oneinferior', 'twoinferior',\n  'threeinferior', 'fourinferior', 'fiveinferior', 'sixinferior', 'seveninferior', 'eightinferior',\n  'nineinferior', 'centinferior', 'dollarinferior', 'periodinferior', 'commainferior', 'Agravesmall',\n  'Aacutesmall', 'Acircumflexsmall', 'Atildesmall', 'Adieresissmall', 'Aringsmall', 'AEsmall', 'Ccedillasmall',\n  'Egravesmall', 'Eacutesmall', 'Ecircumflexsmall', 'Edieresissmall', 'Igravesmall', 'Iacutesmall',\n  'Icircumflexsmall', 'Idieresissmall', 'Ethsmall', 'Ntildesmall', 'Ogravesmall', 'Oacutesmall',\n  'Ocircumflexsmall', 'Otildesmall', 'Odieresissmall', 'OEsmall', 'Oslashsmall', 'Ugravesmall', 'Uacutesmall',\n  'Ucircumflexsmall', 'Udieresissmall', 'Yacutesmall', 'Thornsmall', 'Ydieresissmall'\n];\n","export let ISOAdobeCharset = [\n  '.notdef', 'space', 'exclam', 'quotedbl', 'numbersign', 'dollar',\n  'percent', 'ampersand', 'quoteright', 'parenleft', 'parenright',\n  'asterisk', 'plus', 'comma', 'hyphen', 'period', 'slash', 'zero',\n  'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight',\n  'nine', 'colon', 'semicolon', 'less', 'equal', 'greater', 'question',\n  'at', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',\n  'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',\n  'bracketleft', 'backslash', 'bracketright', 'asciicircum', 'underscore',\n  'quoteleft', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l',\n  'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',\n  'braceleft', 'bar', 'braceright', 'asciitilde', 'exclamdown', 'cent',\n  'sterling', 'fraction', 'yen', 'florin', 'section', 'currency',\n  'quotesingle', 'quotedblleft', 'guillemotleft', 'guilsinglleft',\n  'guilsinglright', 'fi', 'fl', 'endash', 'dagger', 'daggerdbl',\n  'periodcentered', 'paragraph', 'bullet', 'quotesinglbase',\n  'quotedblbase', 'quotedblright', 'guillemotright', 'ellipsis',\n  'perthousand', 'questiondown', 'grave', 'acute', 'circumflex', 'tilde',\n  'macron', 'breve', 'dotaccent', 'dieresis', 'ring', 'cedilla',\n  'hungarumlaut', 'ogonek', 'caron', 'emdash', 'AE', 'ordfeminine',\n  'Lslash', 'Oslash', 'OE', 'ordmasculine', 'ae', 'dotlessi', 'lslash',\n  'oslash', 'oe', 'germandbls', 'onesuperior', 'logicalnot', 'mu',\n  'trademark', 'Eth', 'onehalf', 'plusminus', 'Thorn', 'onequarter',\n  'divide', 'brokenbar', 'degree', 'thorn', 'threequarters', 'twosuperior',\n  'registered', 'minus', 'eth', 'multiply', 'threesuperior', 'copyright',\n  'Aacute', 'Acircumflex', 'Adieresis', 'Agrave', 'Aring', 'Atilde',\n  'Ccedilla', 'Eacute', 'Ecircumflex', 'Edieresis', 'Egrave', 'Iacute',\n  'Icircumflex', 'Idieresis', 'Igrave', 'Ntilde', 'Oacute', 'Ocircumflex',\n  'Odieresis', 'Ograve', 'Otilde', 'Scaron', 'Uacute', 'Ucircumflex',\n  'Udieresis', 'Ugrave', 'Yacute', 'Ydieresis', 'Zcaron', 'aacute',\n  'acircumflex', 'adieresis', 'agrave', 'aring', 'atilde', 'ccedilla',\n  'eacute', 'ecircumflex', 'edieresis', 'egrave', 'iacute', 'icircumflex',\n  'idieresis', 'igrave', 'ntilde', 'oacute', 'ocircumflex', 'odieresis',\n  'ograve', 'otilde', 'scaron', 'uacute', 'ucircumflex', 'udieresis',\n  'ugrave', 'yacute', 'ydieresis', 'zcaron'\n];\n\nexport let ExpertCharset = [\n  '.notdef', 'space', 'exclamsmall', 'Hungarumlautsmall', 'dollaroldstyle',\n  'dollarsuperior', 'ampersandsmall', 'Acutesmall', 'parenleftsuperior',\n  'parenrightsuperior', 'twodotenleader', 'onedotenleader', 'comma',\n  'hyphen', 'period', 'fraction', 'zerooldstyle', 'oneoldstyle',\n  'twooldstyle', 'threeoldstyle', 'fouroldstyle', 'fiveoldstyle',\n  'sixoldstyle', 'sevenoldstyle', 'eightoldstyle', 'nineoldstyle',\n  'colon', 'semicolon', 'commasuperior', 'threequartersemdash',\n  'periodsuperior', 'questionsmall', 'asuperior', 'bsuperior',\n  'centsuperior', 'dsuperior', 'esuperior', 'isuperior', 'lsuperior',\n  'msuperior', 'nsuperior', 'osuperior', 'rsuperior', 'ssuperior',\n  'tsuperior', 'ff', 'fi', 'fl', 'ffi', 'ffl', 'parenleftinferior',\n  'parenrightinferior', 'Circumflexsmall', 'hyphensuperior', 'Gravesmall',\n  'Asmall', 'Bsmall', 'Csmall', 'Dsmall', 'Esmall', 'Fsmall', 'Gsmall',\n  'Hsmall', 'Ismall', 'Jsmall', 'Ksmall', 'Lsmall', 'Msmall', 'Nsmall',\n  'Osmall', 'Psmall', 'Qsmall', 'Rsmall', 'Ssmall', 'Tsmall', 'Usmall',\n  'Vsmall', 'Wsmall', 'Xsmall', 'Ysmall', 'Zsmall', 'colonmonetary',\n  'onefitted', 'rupiah', 'Tildesmall', 'exclamdownsmall', 'centoldstyle',\n  'Lslashsmall', 'Scaronsmall', 'Zcaronsmall', 'Dieresissmall',\n  'Brevesmall', 'Caronsmall', 'Dotaccentsmall', 'Macronsmall',\n  'figuredash', 'hypheninferior', 'Ogoneksmall', 'Ringsmall',\n  'Cedillasmall', 'onequarter', 'onehalf', 'threequarters',\n  'questiondownsmall', 'oneeighth', 'threeeighths', 'fiveeighths',\n  'seveneighths', 'onethird', 'twothirds', 'zerosuperior', 'onesuperior',\n  'twosuperior', 'threesuperior', 'foursuperior', 'fivesuperior',\n  'sixsuperior', 'sevensuperior', 'eightsuperior', 'ninesuperior',\n  'zeroinferior', 'oneinferior', 'twoinferior', 'threeinferior',\n  'fourinferior', 'fiveinferior', 'sixinferior', 'seveninferior',\n  'eightinferior', 'nineinferior', 'centinferior', 'dollarinferior',\n  'periodinferior', 'commainferior', 'Agravesmall', 'Aacutesmall',\n  'Acircumflexsmall', 'Atildesmall', 'Adieresissmall', 'Aringsmall',\n  'AEsmall', 'Ccedillasmall', 'Egravesmall', 'Eacutesmall',\n  'Ecircumflexsmall', 'Edieresissmall', 'Igravesmall', 'Iacutesmall',\n  'Icircumflexsmall', 'Idieresissmall', 'Ethsmall', 'Ntildesmall',\n  'Ogravesmall', 'Oacutesmall', 'Ocircumflexsmall', 'Otildesmall',\n  'Odieresissmall', 'OEsmall', 'Oslashsmall', 'Ugravesmall', 'Uacutesmall',\n  'Ucircumflexsmall', 'Udieresissmall', 'Yacutesmall', 'Thornsmall',\n  'Ydieresissmall'\n];\n\nexport let ExpertSubsetCharset = [\n  '.notdef', 'space', 'dollaroldstyle', 'dollarsuperior',\n  'parenleftsuperior', 'parenrightsuperior', 'twodotenleader',\n  'onedotenleader', 'comma', 'hyphen', 'period', 'fraction',\n  'zerooldstyle', 'oneoldstyle', 'twooldstyle', 'threeoldstyle',\n  'fouroldstyle', 'fiveoldstyle', 'sixoldstyle', 'sevenoldstyle',\n  'eightoldstyle', 'nineoldstyle', 'colon', 'semicolon', 'commasuperior',\n  'threequartersemdash', 'periodsuperior', 'asuperior', 'bsuperior',\n  'centsuperior', 'dsuperior', 'esuperior', 'isuperior', 'lsuperior',\n  'msuperior', 'nsuperior', 'osuperior', 'rsuperior', 'ssuperior',\n  'tsuperior', 'ff', 'fi', 'fl', 'ffi', 'ffl', 'parenleftinferior',\n  'parenrightinferior', 'hyphensuperior', 'colonmonetary', 'onefitted',\n  'rupiah', 'centoldstyle', 'figuredash', 'hypheninferior', 'onequarter',\n  'onehalf', 'threequarters', 'oneeighth', 'threeeighths', 'fiveeighths',\n  'seveneighths', 'onethird', 'twothirds', 'zerosuperior', 'onesuperior',\n  'twosuperior', 'threesuperior', 'foursuperior', 'fivesuperior',\n  'sixsuperior', 'sevensuperior', 'eightsuperior', 'ninesuperior',\n  'zeroinferior', 'oneinferior', 'twoinferior', 'threeinferior',\n  'fourinferior', 'fiveinferior', 'sixinferior', 'seveninferior',\n  'eightinferior', 'nineinferior', 'centinferior', 'dollarinferior',\n  'periodinferior', 'commainferior'\n];\n","import r from 'restructure';\n\n//########################\n// Scripts and Languages #\n//########################\n\nlet LangSysTable = new r.Struct({\n  reserved:         new r.Reserved(r.uint16),\n  reqFeatureIndex:  r.uint16,\n  featureCount:     r.uint16,\n  featureIndexes:   new r.Array(r.uint16, 'featureCount')\n});\n\nlet LangSysRecord = new r.Struct({\n  tag:      new r.String(4),\n  langSys:  new r.Pointer(r.uint16, LangSysTable, { type: 'parent' })\n});\n\nlet Script = new r.Struct({\n  defaultLangSys: new r.Pointer(r.uint16, LangSysTable),\n  count:          r.uint16,\n  langSysRecords: new r.Array(LangSysRecord, 'count')\n});\n\nlet ScriptRecord = new r.Struct({\n  tag:    new r.String(4),\n  script: new r.Pointer(r.uint16, Script, { type: 'parent' })\n});\n\nexport let ScriptList = new r.Array(ScriptRecord, r.uint16);\n\n//#######################\n// Features and Lookups #\n//#######################\n\nexport let Feature = new r.Struct({\n  featureParams:      r.uint16, // pointer\n  lookupCount:        r.uint16,\n  lookupListIndexes:  new r.Array(r.uint16, 'lookupCount')\n});\n\nlet FeatureRecord = new r.Struct({\n  tag:      new r.String(4),\n  feature:  new r.Pointer(r.uint16, Feature, { type: 'parent' })\n});\n\nexport let FeatureList = new r.Array(FeatureRecord, r.uint16);\n\nlet LookupFlags = new r.Struct({\n  markAttachmentType: r.uint8,\n  flags: new r.Bitfield(r.uint8, [\n    'rightToLeft', 'ignoreBaseGlyphs', 'ignoreLigatures',\n    'ignoreMarks', 'useMarkFilteringSet'\n  ])\n});\n\nexport function LookupList(SubTable) {\n  let Lookup = new r.Struct({\n    lookupType:         r.uint16,\n    flags:              LookupFlags,\n    subTableCount:      r.uint16,\n    subTables:          new r.Array(new r.Pointer(r.uint16, SubTable), 'subTableCount'),\n    markFilteringSet:   new r.Optional(r.uint16, t => t.flags.flags.useMarkFilteringSet)\n  });\n\n  return new r.LazyArray(new r.Pointer(r.uint16, Lookup), r.uint16);\n}\n\n//#################\n// Coverage Table #\n//#################\n\nlet RangeRecord = new r.Struct({\n  start:              r.uint16,\n  end:                r.uint16,\n  startCoverageIndex: r.uint16\n});\n\nexport let Coverage = new r.VersionedStruct(r.uint16, {\n  1: {\n    glyphCount:   r.uint16,\n    glyphs:       new r.Array(r.uint16, 'glyphCount')\n  },\n  2: {\n    rangeCount:   r.uint16,\n    rangeRecords: new r.Array(RangeRecord, 'rangeCount')\n  }\n});\n\n//#########################\n// Class Definition Table #\n//#########################\n\nlet ClassRangeRecord = new r.Struct({\n  start:  r.uint16,\n  end:    r.uint16,\n  class:  r.uint16\n});\n\nexport let ClassDef = new r.VersionedStruct(r.uint16, {\n  1: { // Class array\n    startGlyph:       r.uint16,\n    glyphCount:       r.uint16,\n    classValueArray:  new r.Array(r.uint16, 'glyphCount')\n  },\n  2: { // Class ranges\n    classRangeCount:  r.uint16,\n    classRangeRecord: new r.Array(ClassRangeRecord, 'classRangeCount')\n  }\n});\n\n//###############\n// Device Table #\n//###############\n\nexport let Device = new r.Struct({\n  a: r.uint16, // startSize for hinting Device, outerIndex for VariationIndex\n  b: r.uint16, // endSize for Device, innerIndex for VariationIndex\n  deltaFormat: r.uint16\n});\n\n//#############################################\n// Contextual Substitution/Positioning Tables #\n//#############################################\n\nlet LookupRecord = new r.Struct({\n  sequenceIndex:      r.uint16,\n  lookupListIndex:    r.uint16\n});\n\nlet Rule = new r.Struct({\n  glyphCount:     r.uint16,\n  lookupCount:    r.uint16,\n  input:          new r.Array(r.uint16, t => t.glyphCount - 1),\n  lookupRecords:  new r.Array(LookupRecord, 'lookupCount')\n});\n\nlet RuleSet = new r.Array(new r.Pointer(r.uint16, Rule), r.uint16);\n\nlet ClassRule = new r.Struct({\n  glyphCount:     r.uint16,\n  lookupCount:    r.uint16,\n  classes:        new r.Array(r.uint16, t => t.glyphCount - 1),\n  lookupRecords:  new r.Array(LookupRecord, 'lookupCount')\n});\n\nlet ClassSet = new r.Array(new r.Pointer(r.uint16, ClassRule), r.uint16);\n\nexport let Context = new r.VersionedStruct(r.uint16, {\n  1: { // Simple context\n    coverage:      new r.Pointer(r.uint16, Coverage),\n    ruleSetCount:  r.uint16,\n    ruleSets:      new r.Array(new r.Pointer(r.uint16, RuleSet), 'ruleSetCount')\n  },\n  2: { // Class-based context\n    coverage:      new r.Pointer(r.uint16, Coverage),\n    classDef:      new r.Pointer(r.uint16, ClassDef),\n    classSetCnt:   r.uint16,\n    classSet:      new r.Array(new r.Pointer(r.uint16, ClassSet), 'classSetCnt')\n  },\n  3: {\n    glyphCount:    r.uint16,\n    lookupCount:   r.uint16,\n    coverages:     new r.Array(new r.Pointer(r.uint16, Coverage), 'glyphCount'),\n    lookupRecords: new r.Array(LookupRecord, 'lookupCount')\n  }\n});\n\n//######################################################\n// Chaining Contextual Substitution/Positioning Tables #\n//######################################################\n\nlet ChainRule = new r.Struct({\n  backtrackGlyphCount:  r.uint16,\n  backtrack:            new r.Array(r.uint16, 'backtrackGlyphCount'),\n  inputGlyphCount:      r.uint16,\n  input:                new r.Array(r.uint16, t => t.inputGlyphCount - 1),\n  lookaheadGlyphCount:  r.uint16,\n  lookahead:            new r.Array(r.uint16, 'lookaheadGlyphCount'),\n  lookupCount:          r.uint16,\n  lookupRecords:        new r.Array(LookupRecord, 'lookupCount')\n});\n\nlet ChainRuleSet = new r.Array(new r.Pointer(r.uint16, ChainRule), r.uint16);\n\nexport let ChainingContext = new r.VersionedStruct(r.uint16, {\n  1: { // Simple context glyph substitution\n    coverage:           new r.Pointer(r.uint16, Coverage),\n    chainCount:         r.uint16,\n    chainRuleSets:      new r.Array(new r.Pointer(r.uint16, ChainRuleSet), 'chainCount')\n  },\n\n  2: { // Class-based chaining context\n    coverage:           new r.Pointer(r.uint16, Coverage),\n    backtrackClassDef:  new r.Pointer(r.uint16, ClassDef),\n    inputClassDef:      new r.Pointer(r.uint16, ClassDef),\n    lookaheadClassDef:  new r.Pointer(r.uint16, ClassDef),\n    chainCount:         r.uint16,\n    chainClassSet:      new r.Array(new r.Pointer(r.uint16, ChainRuleSet), 'chainCount')\n  },\n\n  3: { // Coverage-based chaining context\n    backtrackGlyphCount:    r.uint16,\n    backtrackCoverage:      new r.Array(new r.Pointer(r.uint16, Coverage), 'backtrackGlyphCount'),\n    inputGlyphCount:        r.uint16,\n    inputCoverage:          new r.Array(new r.Pointer(r.uint16, Coverage), 'inputGlyphCount'),\n    lookaheadGlyphCount:    r.uint16,\n    lookaheadCoverage:      new r.Array(new r.Pointer(r.uint16, Coverage), 'lookaheadGlyphCount'),\n    lookupCount:            r.uint16,\n    lookupRecords:          new r.Array(LookupRecord, 'lookupCount')\n  }\n});\n","import {Feature} from './opentype';\nimport r from 'restructure';\n\n/*******************\n * Variation Store *\n *******************/\n\nlet F2DOT14 = new r.Fixed(16, 'BE', 14);\nlet RegionAxisCoordinates = new r.Struct({\n  startCoord: F2DOT14,\n  peakCoord: F2DOT14,\n  endCoord: F2DOT14\n});\n\nlet VariationRegionList = new r.Struct({\n  axisCount: r.uint16,\n  regionCount: r.uint16,\n  variationRegions: new r.Array(new r.Array(RegionAxisCoordinates, 'axisCount'), 'regionCount')\n});\n\nlet DeltaSet = new r.Struct({\n  shortDeltas: new r.Array(r.int16, t => t.parent.shortDeltaCount),\n  regionDeltas: new r.Array(r.int8, t => t.parent.regionIndexCount - t.parent.shortDeltaCount),\n  deltas: t => t.shortDeltas.concat(t.regionDeltas)\n});\n\nlet ItemVariationData = new r.Struct({\n  itemCount: r.uint16,\n  shortDeltaCount: r.uint16,\n  regionIndexCount: r.uint16,\n  regionIndexes: new r.Array(r.uint16, 'regionIndexCount'),\n  deltaSets: new r.Array(DeltaSet, 'itemCount')\n});\n\nexport let ItemVariationStore = new r.Struct({\n  format: r.uint16,\n  variationRegionList: new r.Pointer(r.uint32, VariationRegionList),\n  variationDataCount: r.uint16,\n  itemVariationData: new r.Array(new r.Pointer(r.uint32, ItemVariationData), 'variationDataCount')\n});\n\n/**********************\n * Feature Variations *\n **********************/\n\nlet ConditionTable = new r.VersionedStruct(r.uint16, {\n  1: {\n    axisIndex: r.uint16,\n    axisIndex: r.uint16,\n    filterRangeMinValue: F2DOT14,\n    filterRangeMaxValue: F2DOT14\n  }\n});\n\nlet ConditionSet = new r.Struct({\n  conditionCount: r.uint16,\n  conditionTable: new r.Array(new r.Pointer(r.uint32, ConditionTable), 'conditionCount')\n});\n\nlet FeatureTableSubstitutionRecord = new r.Struct({\n  featureIndex: r.uint16,\n  alternateFeatureTable: new r.Pointer(r.uint32, Feature, {type: 'parent'})\n});\n\nlet FeatureTableSubstitution = new r.Struct({\n  version: r.fixed32,\n  substitutionCount: r.uint16,\n  substitutions: new r.Array(FeatureTableSubstitutionRecord, 'substitutionCount')\n});\n\nlet FeatureVariationRecord = new r.Struct({\n  conditionSet: new r.Pointer(r.uint32, ConditionSet, {type: 'parent'}),\n  featureTableSubstitution: new r.Pointer(r.uint32, FeatureTableSubstitution, {type: 'parent'})\n});\n\nexport let FeatureVariations = new r.Struct({\n  majorVersion: r.uint16,\n  minorVersion: r.uint16,\n  featureVariationRecordCount: r.uint32,\n  featureVariationRecords: new r.Array(FeatureVariationRecord, 'featureVariationRecordCount')\n});\n","import r from 'restructure';\nimport { resolveLength } from 'restructure/src/utils';\nimport CFFDict from './CFFDict';\nimport CFFIndex from './CFFIndex';\nimport CFFPointer from './CFFPointer';\nimport CFFPrivateDict from './CFFPrivateDict';\nimport StandardStrings from './CFFStandardStrings';\nimport { StandardEncoding, ExpertEncoding } from './CFFEncodings';\nimport { ISOAdobeCharset, ExpertCharset, ExpertSubsetCharset } from './CFFCharsets';\nimport { ItemVariationStore } from '../tables/variations';\n\n// Checks if an operand is an index of a predefined value,\n// otherwise delegates to the provided type.\nclass PredefinedOp {\n  constructor(predefinedOps, type) {\n    this.predefinedOps = predefinedOps;\n    this.type = type;\n  }\n\n  decode(stream, parent, operands) {\n    if (this.predefinedOps[operands[0]]) {\n      return this.predefinedOps[operands[0]];\n    }\n\n    return this.type.decode(stream, parent, operands);\n  }\n\n  size(value, ctx) {\n    return this.type.size(value, ctx);\n  }\n\n  encode(stream, value, ctx) {\n    let index = this.predefinedOps.indexOf(value);\n    if (index !== -1) {\n      return index;\n    }\n\n    return this.type.encode(stream, value, ctx);\n  }\n}\n\nclass CFFEncodingVersion extends r.Number {\n  constructor() {\n    super('UInt8');\n  }\n\n  decode(stream) {\n    return r.uint8.decode(stream) & 0x7f;\n  }\n}\n\nlet Range1 = new r.Struct({\n  first: r.uint16,\n  nLeft: r.uint8\n});\n\nlet Range2 = new r.Struct({\n  first: r.uint16,\n  nLeft: r.uint16\n});\n\nlet CFFCustomEncoding = new r.VersionedStruct(new CFFEncodingVersion(), {\n  0: {\n    nCodes: r.uint8,\n    codes: new r.Array(r.uint8, 'nCodes')\n  },\n\n  1: {\n    nRanges: r.uint8,\n    ranges: new r.Array(Range1, 'nRanges')\n  }\n\n  // TODO: supplement?\n});\n\nlet CFFEncoding = new PredefinedOp([ StandardEncoding, ExpertEncoding ], new CFFPointer(CFFCustomEncoding, { lazy: true }));\n\n// Decodes an array of ranges until the total\n// length is equal to the provided length.\nclass RangeArray extends r.Array {\n  decode(stream, parent) {\n    let length = resolveLength(this.length, stream, parent);\n    let count = 0;\n    let res = [];\n    while (count < length) {\n      let range = this.type.decode(stream, parent);\n      range.offset = count;\n      count += range.nLeft + 1;\n      res.push(range);\n    }\n\n    return res;\n  }\n}\n\nlet CFFCustomCharset = new r.VersionedStruct(r.uint8, {\n  0: {\n    glyphs: new r.Array(r.uint16, t => t.parent.CharStrings.length - 1)\n  },\n\n  1: {\n    ranges: new RangeArray(Range1, t => t.parent.CharStrings.length - 1)\n  },\n\n  2: {\n    ranges: new RangeArray(Range2, t => t.parent.CharStrings.length - 1)\n  }\n});\n\nlet CFFCharset = new PredefinedOp([ ISOAdobeCharset, ExpertCharset, ExpertSubsetCharset ], new CFFPointer(CFFCustomCharset, {lazy: true}));\n\nlet FDRange3 = new r.Struct({\n  first: r.uint16,\n  fd: r.uint8\n});\n\nlet FDRange4 = new r.Struct({\n  first: r.uint32,\n  fd: r.uint16\n});\n\nlet FDSelect = new r.VersionedStruct(r.uint8, {\n  0: {\n    fds: new r.Array(r.uint8, t => t.parent.CharStrings.length)\n  },\n\n  3: {\n    nRanges: r.uint16,\n    ranges: new r.Array(FDRange3, 'nRanges'),\n    sentinel: r.uint16\n  },\n\n  4: {\n    nRanges: r.uint32,\n    ranges: new r.Array(FDRange4, 'nRanges'),\n    sentinel: r.uint32\n  }\n});\n\nlet ptr = new CFFPointer(CFFPrivateDict);\nclass CFFPrivateOp {\n  decode(stream, parent, operands) {\n    parent.length = operands[0];\n    return ptr.decode(stream, parent, [operands[1]]);\n  }\n\n  size(dict, ctx) {\n    return [CFFPrivateDict.size(dict, ctx, false), ptr.size(dict, ctx)[0]];\n  }\n\n  encode(stream, dict, ctx) {\n    return [CFFPrivateDict.size(dict, ctx, false), ptr.encode(stream, dict, ctx)[0]];\n  }\n}\n\nlet FontDict = new CFFDict([\n  // key       name                   type(s)                                 default\n  [18,        'Private',              new CFFPrivateOp,                       null],\n  [[12, 38],  'FontName',             'sid',                                  null],\n  [[12, 7],   'FontMatrix',           'array',                                [0.001, 0, 0, 0.001, 0, 0]],\n  [[12, 5],   'PaintType',            'number',                               0],\n]);\n\nlet CFFTopDict = new CFFDict([\n  // key       name                   type(s)                                 default\n  [[12, 30],  'ROS',                  ['sid', 'sid', 'number'],               null],\n\n  [0,         'version',              'sid',                                  null],\n  [1,         'Notice',               'sid',                                  null],\n  [[12, 0],   'Copyright',            'sid',                                  null],\n  [2,         'FullName',             'sid',                                  null],\n  [3,         'FamilyName',           'sid',                                  null],\n  [4,         'Weight',               'sid',                                  null],\n  [[12, 1],   'isFixedPitch',         'boolean',                              false],\n  [[12, 2],   'ItalicAngle',          'number',                               0],\n  [[12, 3],   'UnderlinePosition',    'number',                               -100],\n  [[12, 4],   'UnderlineThickness',   'number',                               50],\n  [[12, 5],   'PaintType',            'number',                               0],\n  [[12, 6],   'CharstringType',       'number',                               2],\n  [[12, 7],   'FontMatrix',           'array',                                [0.001, 0, 0, 0.001, 0, 0]],\n  [13,        'UniqueID',             'number',                               null],\n  [5,         'FontBBox',             'array',                                [0, 0, 0, 0]],\n  [[12, 8],   'StrokeWidth',          'number',                               0],\n  [14,        'XUID',                 'array',                                null],\n  [15,        'charset',              CFFCharset,                             ISOAdobeCharset],\n  [16,        'Encoding',             CFFEncoding,                            StandardEncoding],\n  [17,        'CharStrings',          new CFFPointer(new CFFIndex),           null],\n  [18,        'Private',              new CFFPrivateOp,                       null],\n  [[12, 20],  'SyntheticBase',        'number',                               null],\n  [[12, 21],  'PostScript',           'sid',                                  null],\n  [[12, 22],  'BaseFontName',         'sid',                                  null],\n  [[12, 23],  'BaseFontBlend',        'delta',                                null],\n\n  // CID font specific\n  [[12, 31],  'CIDFontVersion',       'number',                               0],\n  [[12, 32],  'CIDFontRevision',      'number',                               0],\n  [[12, 33],  'CIDFontType',          'number',                               0],\n  [[12, 34],  'CIDCount',             'number',                               8720],\n  [[12, 35],  'UIDBase',              'number',                               null],\n  [[12, 37],  'FDSelect',             new CFFPointer(FDSelect),               null],\n  [[12, 36],  'FDArray',              new CFFPointer(new CFFIndex(FontDict)), null],\n  [[12, 38],  'FontName',             'sid',                                  null]\n]);\n\nlet VariationStore = new r.Struct({\n  length: r.uint16,\n  itemVariationStore: ItemVariationStore\n})\n\nlet CFF2TopDict = new CFFDict([\n  [[12, 7],   'FontMatrix',           'array',                                [0.001, 0, 0, 0.001, 0, 0]],\n  [17,        'CharStrings',          new CFFPointer(new CFFIndex),           null],\n  [[12, 37],  'FDSelect',             new CFFPointer(FDSelect),               null],\n  [[12, 36],  'FDArray',              new CFFPointer(new CFFIndex(FontDict)), null],\n  [24,        'vstore',               new CFFPointer(VariationStore),         null],\n  [25,        'maxstack',             'number',                               193]\n]);\n\nlet CFFTop = new r.VersionedStruct(r.fixed16, {\n  1: {\n    hdrSize:            r.uint8,\n    offSize:            r.uint8,\n    nameIndex:          new CFFIndex(new r.String('length')),\n    topDictIndex:       new CFFIndex(CFFTopDict),\n    stringIndex:        new CFFIndex(new r.String('length')),\n    globalSubrIndex:    new CFFIndex\n  },\n\n  2: {\n    hdrSize:            r.uint8,\n    length:             r.uint16,\n    topDict:            CFF2TopDict,\n    globalSubrIndex:    new CFFIndex\n  }\n});\n\nexport default CFFTop;\n","import r from 'restructure';\nimport CFFIndex from './CFFIndex';\nimport CFFTop from './CFFTop';\nimport CFFPrivateDict from './CFFPrivateDict';\nimport standardStrings from './CFFStandardStrings';\n\nclass CFFFont {\n  constructor(stream) {\n    this.stream = stream;\n    this.decode();\n  }\n\n  static decode(stream) {\n    return new CFFFont(stream);\n  }\n\n  decode() {\n    let start = this.stream.pos;\n    let top = CFFTop.decode(this.stream);\n    for (let key in top) {\n      let val = top[key];\n      this[key] = val;\n    }\n\n    if (this.version < 2) {\n      if (this.topDictIndex.length !== 1) {\n        throw new Error(\"Only a single font is allowed in CFF\");\n      }\n\n      this.topDict = this.topDictIndex[0];\n    }\n\n    this.isCIDFont = this.topDict.ROS != null;\n    return this;\n  }\n\n  string(sid) {\n    if (this.version >= 2) {\n      return null;\n    }\n\n    if (sid < standardStrings.length) {\n      return standardStrings[sid];\n    }\n\n    return this.stringIndex[sid - standardStrings.length];\n  }\n\n  get postscriptName() {\n    if (this.version < 2) {\n      return this.nameIndex[0];\n    }\n\n    return null;\n  }\n\n  get fullName() {\n    return this.string(this.topDict.FullName);\n  }\n\n  get familyName() {\n    return this.string(this.topDict.FamilyName);\n  }\n\n  getCharString(glyph) {\n    this.stream.pos = this.topDict.CharStrings[glyph].offset;\n    return this.stream.readBuffer(this.topDict.CharStrings[glyph].length);\n  }\n\n  getGlyphName(gid) {\n    // CFF2 glyph names are in the post table.\n    if (this.version >= 2) {\n      return null;\n    }\n\n    // CID-keyed fonts don't have glyph names\n    if (this.isCIDFont) {\n      return null;\n    }\n\n    let { charset } = this.topDict;\n    if (Array.isArray(charset)) {\n      return charset[gid];\n    }\n\n    if (gid === 0) {\n      return '.notdef';\n    }\n\n    gid -= 1;\n\n    switch (charset.version) {\n      case 0:\n        return this.string(charset.glyphs[gid]);\n\n      case 1:\n      case 2:\n        for (let i = 0; i < charset.ranges.length; i++) {\n          let range = charset.ranges[i];\n          if (range.offset <= gid && gid <= range.offset + range.nLeft) {\n            return this.string(range.first + (gid - range.offset));\n          }\n        }\n        break;\n    }\n\n    return null;\n  }\n\n  fdForGlyph(gid) {\n    if (!this.topDict.FDSelect) {\n      return null;\n    }\n\n    switch (this.topDict.FDSelect.version) {\n      case 0:\n        return this.topDict.FDSelect.fds[gid];\n\n      case 3:\n      case 4:\n        let { ranges } = this.topDict.FDSelect;\n        let low = 0;\n        let high = ranges.length - 1;\n\n        while (low <= high) {\n          let mid = (low + high) >> 1;\n\n          if (gid < ranges[mid].first) {\n            high = mid - 1;\n          } else if (mid < high && gid >= ranges[mid + 1].first) {\n            low = mid + 1;\n          } else {\n            return ranges[mid].fd;\n          }\n        }\n      default:\n        throw new Error(`Unknown FDSelect version: ${this.topDict.FDSelect.version}`);\n    }\n  }\n\n  privateDictForGlyph(gid) {\n    if (this.topDict.FDSelect) {\n      let fd = this.fdForGlyph(gid);\n      if (this.topDict.FDArray[fd]) {\n        return this.topDict.FDArray[fd].Private;\n      }\n\n      return null;\n    }\n\n    if (this.version < 2) {\n      return this.topDict.Private;\n    }\n\n    return this.topDict.FDArray[0].Private;\n  }\n}\n\nexport default CFFFont;\n","import r from 'restructure';\n\nlet VerticalOrigin = new r.Struct({\n  glyphIndex:   r.uint16,\n  vertOriginY:  r.int16\n});\n\nexport default new r.Struct({\n  majorVersion:           r.uint16,\n  minorVersion:           r.uint16,\n  defaultVertOriginY:     r.int16,\n  numVertOriginYMetrics:  r.uint16,\n  metrics:                new r.Array(VerticalOrigin, 'numVertOriginYMetrics')\n});\n","import r from 'restructure';\n\nexport let BigMetrics = new r.Struct({\n  height: r.uint8,\n  width: r.uint8,\n  horiBearingX: r.int8,\n  horiBearingY: r.int8,\n  horiAdvance: r.uint8,\n  vertBearingX: r.int8,\n  vertBearingY: r.int8,\n  vertAdvance: r.uint8\n});\n\nexport let SmallMetrics = new r.Struct({\n  height: r.uint8,\n  width: r.uint8,\n  bearingX: r.int8,\n  bearingY: r.int8,\n  advance: r.uint8\n});\n\nlet EBDTComponent = new r.Struct({\n  glyph: r.uint16,\n  xOffset: r.int8,\n  yOffset: r.int8\n});\n\nclass ByteAligned {}\n\nclass BitAligned {}\n\nexport let glyph = new r.VersionedStruct('version', {\n  1: {\n    metrics: SmallMetrics,\n    data: ByteAligned\n  },\n\n  2: {\n    metrics: SmallMetrics,\n    data: BitAligned\n  },\n\n  // format 3 is deprecated\n  // format 4 is not supported by Microsoft\n\n  5: {\n    data: BitAligned\n  },\n\n  6: {\n    metrics: BigMetrics,\n    data: ByteAligned\n  },\n\n  7: {\n    metrics: BigMetrics,\n    data: BitAligned\n  },\n\n  8: {\n    metrics: SmallMetrics,\n    pad: new r.Reserved(r.uint8),\n    numComponents: r.uint16,\n    components: new r.Array(EBDTComponent, 'numComponents')\n  },\n\n  9: {\n    metrics: BigMetrics,\n    pad: new r.Reserved(r.uint8),\n    numComponents: r.uint16,\n    components: new r.Array(EBDTComponent, 'numComponents')\n  },\n\n  17: {\n    metrics: SmallMetrics,\n    dataLen: r.uint32,\n    data: new r.Buffer('dataLen')\n  },\n\n  18: {\n    metrics: BigMetrics,\n    dataLen: r.uint32,\n    data: new r.Buffer('dataLen')\n  },\n\n  19: {\n    dataLen: r.uint32,\n    data: new r.Buffer('dataLen')\n  }\n});\n\n","import r from 'restructure';\nimport {BigMetrics} from './EBDT';\n\nlet SBitLineMetrics = new r.Struct({\n  ascender: r.int8,\n  descender: r.int8,\n  widthMax: r.uint8,\n  caretSlopeNumerator: r.int8,\n  caretSlopeDenominator: r.int8,\n  caretOffset: r.int8,\n  minOriginSB: r.int8,\n  minAdvanceSB: r.int8,\n  maxBeforeBL: r.int8,\n  minAfterBL: r.int8,\n  pad: new r.Reserved(r.int8, 2)\n});\n\nlet CodeOffsetPair = new r.Struct({\n  glyphCode: r.uint16,\n  offset: r.uint16\n});\n\nlet IndexSubtable = new r.VersionedStruct(r.uint16, {\n  header: {\n    imageFormat: r.uint16,\n    imageDataOffset: r.uint32\n  },\n\n  1: {\n    offsetArray: new r.Array(r.uint32, t => t.parent.lastGlyphIndex - t.parent.firstGlyphIndex + 1)\n  },\n\n  2: {\n    imageSize: r.uint32,\n    bigMetrics: BigMetrics\n  },\n\n  3: {\n    offsetArray: new r.Array(r.uint16, t => t.parent.lastGlyphIndex - t.parent.firstGlyphIndex + 1)\n  },\n\n  4: {\n    numGlyphs: r.uint32,\n    glyphArray: new r.Array(CodeOffsetPair, t => t.numGlyphs + 1)\n  },\n\n  5: {\n    imageSize: r.uint32,\n    bigMetrics: BigMetrics,\n    numGlyphs: r.uint32,\n    glyphCodeArray: new r.Array(r.uint16, 'numGlyphs')\n  }\n});\n\nlet IndexSubtableArray = new r.Struct({\n  firstGlyphIndex: r.uint16,\n  lastGlyphIndex: r.uint16,\n  subtable: new r.Pointer(r.uint32, IndexSubtable)\n});\n\nlet BitmapSizeTable = new r.Struct({\n  indexSubTableArray: new r.Pointer(r.uint32, new r.Array(IndexSubtableArray, 1), { type: 'parent' }),\n  indexTablesSize: r.uint32,\n  numberOfIndexSubTables: r.uint32,\n  colorRef: r.uint32,\n  hori: SBitLineMetrics,\n  vert: SBitLineMetrics,\n  startGlyphIndex: r.uint16,\n  endGlyphIndex: r.uint16,\n  ppemX: r.uint8,\n  ppemY: r.uint8,\n  bitDepth: r.uint8,\n  flags: new r.Bitfield(r.uint8, ['horizontal', 'vertical'])\n});\n\nexport default new r.Struct({\n  version:  r.uint32, // 0x00020000\n  numSizes: r.uint32,\n  sizes:    new r.Array(BitmapSizeTable, 'numSizes')\n});\n","import r from 'restructure';\n\nlet ImageTable = new r.Struct({\n  ppem: r.uint16,\n  resolution: r.uint16,\n  imageOffsets: new r.Array(new r.Pointer(r.uint32, 'void'), t => t.parent.parent.maxp.numGlyphs + 1)\n});\n\n// This is the Apple sbix table, used by the \"Apple Color Emoji\" font.\n// It includes several image tables with images for each bitmap glyph\n// of several different sizes.\nexport default new r.Struct({\n  version: r.uint16,\n  flags: new r.Bitfield(r.uint16, ['renderOutlines']),\n  numImgTables: r.uint32,\n  imageTables: new r.Array(new r.Pointer(r.uint32, ImageTable), 'numImgTables')\n});\n","import r from 'restructure';\n\nlet LayerRecord = new r.Struct({\n  gid: r.uint16,          // Glyph ID of layer glyph (must be in z-order from bottom to top).\n  paletteIndex: r.uint16  // Index value to use in the appropriate palette. This value must\n});                       // be less than numPaletteEntries in the CPAL table, except for\n                          // the special case noted below. Each palette entry is 16 bits.\n                          // A palette index of 0xFFFF is a special case indicating that\n                          // the text foreground color should be used.\n\nlet BaseGlyphRecord = new r.Struct({\n  gid: r.uint16,             // Glyph ID of reference glyph. This glyph is for reference only\n                             // and is not rendered for color.\n  firstLayerIndex: r.uint16, // Index (from beginning of the Layer Records) to the layer record.\n                             // There will be numLayers consecutive entries for this base glyph.\n  numLayers: r.uint16\n});\n\nexport default new r.Struct({\n  version: r.uint16,\n  numBaseGlyphRecords: r.uint16,\n  baseGlyphRecord: new r.Pointer(r.uint32, new r.Array(BaseGlyphRecord, 'numBaseGlyphRecords')),\n  layerRecords: new r.Pointer(r.uint32, new r.Array(LayerRecord, 'numLayerRecords'), { lazy: true }),\n  numLayerRecords: r.uint16\n});\n","import r from 'restructure';\n\nlet ColorRecord = new r.Struct({\n  blue: r.uint8,\n  green: r.uint8,\n  red: r.uint8,\n  alpha: r.uint8\n});\n\nexport default new r.VersionedStruct(r.uint16, {\n  header: {\n    numPaletteEntries: r.uint16,\n    numPalettes: r.uint16,\n    numColorRecords: r.uint16,\n    colorRecords: new r.Pointer(r.uint32, new r.Array(ColorRecord, 'numColorRecords')),\n    colorRecordIndices: new r.Array(r.uint16, 'numPalettes'),\n  },\n  0: {},\n  1: {\n    offsetPaletteTypeArray: new r.Pointer(r.uint32, new r.Array(r.uint32, 'numPalettes')),\n    offsetPaletteLabelArray: new r.Pointer(r.uint32, new r.Array(r.uint16, 'numPalettes')),\n    offsetPaletteEntryLabelArray: new r.Pointer(r.uint32, new r.Array(r.uint16, 'numPaletteEntries'))\n  }\n});\n","import r from 'restructure';\nimport {ScriptList, FeatureList, LookupList, Coverage, ClassDef, Device} from './opentype';\nimport {ItemVariationStore} from './variations';\n\nlet BaseCoord = new r.VersionedStruct(r.uint16, {\n  1: { // Design units only\n    coordinate:   r.int16 // X or Y value, in design units\n  },\n\n  2: { // Design units plus contour point\n    coordinate:     r.int16,   // X or Y value, in design units\n    referenceGlyph: r.uint16,  // GlyphID of control glyph\n    baseCoordPoint: r.uint16   // Index of contour point on the referenceGlyph\n  },\n\n  3: { // Design units plus Device table\n    coordinate:   r.int16,                         // X or Y value, in design units\n    deviceTable:  new r.Pointer(r.uint16, Device)  // Device table for X or Y value\n  }\n});\n\nlet BaseValues = new r.Struct({\n  defaultIndex:   r.uint16,  // Index of default baseline for this script-same index in the BaseTagList\n  baseCoordCount: r.uint16,\n  baseCoords:     new r.Array(new r.Pointer(r.uint16, BaseCoord), 'baseCoordCount')\n});\n\nlet FeatMinMaxRecord = new r.Struct({\n  tag:        new r.String(4),  // 4-byte feature identification tag-must match FeatureTag in FeatureList\n  minCoord:   new r.Pointer(r.uint16, BaseCoord, {type: 'parent'}), // May be NULL\n  maxCoord:   new r.Pointer(r.uint16, BaseCoord, {type: 'parent'})  // May be NULL\n});\n\nlet MinMax = new r.Struct({\n  minCoord:           new r.Pointer(r.uint16, BaseCoord),  // May be NULL\n  maxCoord:           new r.Pointer(r.uint16, BaseCoord),  // May be NULL\n  featMinMaxCount:    r.uint16,                            // May be 0\n  featMinMaxRecords:  new r.Array(FeatMinMaxRecord, 'featMinMaxCount') // In alphabetical order\n});\n\nlet BaseLangSysRecord = new r.Struct({\n  tag:    new r.String(4),  // 4-byte language system identification tag\n  minMax: new r.Pointer(r.uint16, MinMax, {type: 'parent'})\n});\n\nlet BaseScript = new r.Struct({\n  baseValues:         new r.Pointer(r.uint16, BaseValues), // May be NULL\n  defaultMinMax:      new r.Pointer(r.uint16, MinMax),     // May be NULL\n  baseLangSysCount:   r.uint16,                            // May be 0\n  baseLangSysRecords: new r.Array(BaseLangSysRecord, 'baseLangSysCount') // in alphabetical order by BaseLangSysTag\n});\n\nlet BaseScriptRecord = new r.Struct({\n  tag:      new r.String(4),  // 4-byte script identification tag\n  script:   new r.Pointer(r.uint16, BaseScript, {type: 'parent'})\n});\n\nlet BaseScriptList = new r.Array(BaseScriptRecord, r.uint16);\n\n// Array of 4-byte baseline identification tags-must be in alphabetical order\nlet BaseTagList = new r.Array(new r.String(4), r.uint16);\n\nlet Axis = new r.Struct({\n  baseTagList:    new r.Pointer(r.uint16, BaseTagList),  // May be NULL\n  baseScriptList: new r.Pointer(r.uint16, BaseScriptList)\n});\n\nexport default new r.VersionedStruct(r.uint32, {\n  header: {\n    horizAxis:    new r.Pointer(r.uint16, Axis),   // May be NULL\n    vertAxis:     new r.Pointer(r.uint16, Axis)    // May be NULL\n  },\n\n  0x00010000: {},\n  0x00010001: {\n    itemVariationStore: new r.Pointer(r.uint32, ItemVariationStore)\n  }\n});\n","import r from 'restructure';\nimport {ScriptList, FeatureList, LookupList, Coverage, ClassDef, Device} from './opentype';\nimport {ItemVariationStore} from './variations';\n\nlet AttachPoint = new r.Array(r.uint16, r.uint16);\nlet AttachList = new r.Struct({\n  coverage:       new r.Pointer(r.uint16, Coverage),\n  glyphCount:     r.uint16,\n  attachPoints:   new r.Array(new r.Pointer(r.uint16, AttachPoint), 'glyphCount')\n});\n\nlet CaretValue = new r.VersionedStruct(r.uint16, {\n  1: { // Design units only\n    coordinate: r.int16\n  },\n\n  2: { // Contour point\n    caretValuePoint: r.uint16\n  },\n\n  3: { // Design units plus Device table\n    coordinate:     r.int16,\n    deviceTable:    new r.Pointer(r.uint16, Device)\n  }\n});\n\nlet LigGlyph = new r.Array(new r.Pointer(r.uint16, CaretValue), r.uint16);\n\nlet LigCaretList = new r.Struct({\n  coverage:       new r.Pointer(r.uint16, Coverage),\n  ligGlyphCount:  r.uint16,\n  ligGlyphs:      new r.Array(new r.Pointer(r.uint16, LigGlyph), 'ligGlyphCount')\n});\n\nlet MarkGlyphSetsDef = new r.Struct({\n  markSetTableFormat: r.uint16,\n  markSetCount:       r.uint16,\n  coverage:           new r.Array(new r.Pointer(r.uint32, Coverage), 'markSetCount')\n});\n\nexport default new r.VersionedStruct(r.uint32, {\n  header: {\n    glyphClassDef:      new r.Pointer(r.uint16, ClassDef),\n    attachList:         new r.Pointer(r.uint16, AttachList),\n    ligCaretList:       new r.Pointer(r.uint16, LigCaretList),\n    markAttachClassDef: new r.Pointer(r.uint16, ClassDef)\n  },\n\n  0x00010000: {},\n  0x00010002: {\n    markGlyphSetsDef:   new r.Pointer(r.uint16, MarkGlyphSetsDef)\n  },\n  0x00010003: {\n    markGlyphSetsDef:   new r.Pointer(r.uint16, MarkGlyphSetsDef),\n    itemVariationStore: new r.Pointer(r.uint32, ItemVariationStore)\n  }\n});\n","import r from 'restructure';\nimport {ScriptList, FeatureList, LookupList, Coverage, ClassDef, Device, Context, ChainingContext} from './opentype';\nimport {FeatureVariations} from './variations';\n\nlet ValueFormat = new r.Bitfield(r.uint16, [\n  'xPlacement', 'yPlacement',\n  'xAdvance', 'yAdvance',\n  'xPlaDevice', 'yPlaDevice',\n  'xAdvDevice', 'yAdvDevice'\n]);\n\nlet types = {\n  xPlacement: r.int16,\n  yPlacement: r.int16,\n  xAdvance:   r.int16,\n  yAdvance:   r.int16,\n  xPlaDevice: new r.Pointer(r.uint16, Device, { type: 'global', relativeTo: 'rel' }),\n  yPlaDevice: new r.Pointer(r.uint16, Device, { type: 'global', relativeTo: 'rel' }),\n  xAdvDevice: new r.Pointer(r.uint16, Device, { type: 'global', relativeTo: 'rel' }),\n  yAdvDevice: new r.Pointer(r.uint16, Device, { type: 'global', relativeTo: 'rel' })\n};\n\nclass ValueRecord {\n  constructor(key = 'valueFormat') {\n    this.key = key;\n  }\n\n  buildStruct(parent) {\n    let struct = parent;\n    while (!struct[this.key] && struct.parent) {\n      struct = struct.parent;\n    }\n\n    if (!struct[this.key]) return;\n\n    let fields = {};\n    fields.rel = () => struct._startOffset;\n\n    let format = struct[this.key];\n    for (let key in format) {\n      if (format[key]) {\n        fields[key] = types[key];\n      }\n    }\n\n    return new r.Struct(fields);\n  }\n\n  size(val, ctx) {\n    return this.buildStruct(ctx).size(val, ctx);\n  }\n\n  decode(stream, parent) {\n    let res = this.buildStruct(parent).decode(stream, parent);\n    delete res.rel;\n    return res;\n  }\n}\n\nlet PairValueRecord = new r.Struct({\n  secondGlyph:    r.uint16,\n  value1:         new ValueRecord('valueFormat1'),\n  value2:         new ValueRecord('valueFormat2')\n});\n\nlet PairSet = new r.Array(PairValueRecord, r.uint16);\n\nlet Class2Record = new r.Struct({\n  value1: new ValueRecord('valueFormat1'),\n  value2: new ValueRecord('valueFormat2')\n});\n\nlet Anchor = new r.VersionedStruct(r.uint16, {\n  1: { // Design units only\n    xCoordinate:    r.int16,\n    yCoordinate:    r.int16\n  },\n\n  2: { // Design units plus contour point\n    xCoordinate:    r.int16,\n    yCoordinate:    r.int16,\n    anchorPoint:    r.uint16\n  },\n\n  3: { // Design units plus Device tables\n    xCoordinate:    r.int16,\n    yCoordinate:    r.int16,\n    xDeviceTable:   new r.Pointer(r.uint16, Device),\n    yDeviceTable:   new r.Pointer(r.uint16, Device)\n  }\n});\n\nlet EntryExitRecord = new r.Struct({\n  entryAnchor:    new r.Pointer(r.uint16, Anchor, {type: 'parent'}),\n  exitAnchor:     new r.Pointer(r.uint16, Anchor, {type: 'parent'})\n});\n\nlet MarkRecord = new r.Struct({\n  class:      r.uint16,\n  markAnchor: new r.Pointer(r.uint16, Anchor, {type: 'parent'})\n});\n\nlet MarkArray = new r.Array(MarkRecord, r.uint16);\n\nlet BaseRecord  = new r.Array(new r.Pointer(r.uint16, Anchor), t => t.parent.classCount);\nlet BaseArray   = new r.Array(BaseRecord, r.uint16);\n\nlet ComponentRecord = new r.Array(new r.Pointer(r.uint16, Anchor), t => t.parent.parent.classCount);\nlet LigatureAttach  = new r.Array(ComponentRecord, r.uint16);\nlet LigatureArray   = new r.Array(new r.Pointer(r.uint16, LigatureAttach), r.uint16);\n\nlet GPOSLookup = new r.VersionedStruct('lookupType', {\n  1: new r.VersionedStruct(r.uint16, { // Single Adjustment\n    1: { // Single positioning value\n      coverage:       new r.Pointer(r.uint16, Coverage),\n      valueFormat:    ValueFormat,\n      value:          new ValueRecord()\n    },\n    2: {\n      coverage:       new r.Pointer(r.uint16, Coverage),\n      valueFormat:    ValueFormat,\n      valueCount:     r.uint16,\n      values:         new r.LazyArray(new ValueRecord(), 'valueCount')\n    }\n  }),\n\n  2: new r.VersionedStruct(r.uint16, { // Pair Adjustment Positioning\n    1: { // Adjustments for glyph pairs\n      coverage:       new r.Pointer(r.uint16, Coverage),\n      valueFormat1:   ValueFormat,\n      valueFormat2:   ValueFormat,\n      pairSetCount:   r.uint16,\n      pairSets:       new r.LazyArray(new r.Pointer(r.uint16, PairSet), 'pairSetCount')\n    },\n\n    2: { // Class pair adjustment\n      coverage:       new r.Pointer(r.uint16, Coverage),\n      valueFormat1:   ValueFormat,\n      valueFormat2:   ValueFormat,\n      classDef1:      new r.Pointer(r.uint16, ClassDef),\n      classDef2:      new r.Pointer(r.uint16, ClassDef),\n      class1Count:    r.uint16,\n      class2Count:    r.uint16,\n      classRecords:   new r.LazyArray(new r.LazyArray(Class2Record, 'class2Count'), 'class1Count')\n    }\n  }),\n\n  3: { // Cursive Attachment Positioning\n    format:             r.uint16,\n    coverage:           new r.Pointer(r.uint16, Coverage),\n    entryExitCount:     r.uint16,\n    entryExitRecords:   new r.Array(EntryExitRecord, 'entryExitCount')\n  },\n\n  4: { // MarkToBase Attachment Positioning\n    format:             r.uint16,\n    markCoverage:       new r.Pointer(r.uint16, Coverage),\n    baseCoverage:       new r.Pointer(r.uint16, Coverage),\n    classCount:         r.uint16,\n    markArray:          new r.Pointer(r.uint16, MarkArray),\n    baseArray:          new r.Pointer(r.uint16, BaseArray)\n  },\n\n  5: { // MarkToLigature Attachment Positioning\n    format:             r.uint16,\n    markCoverage:       new r.Pointer(r.uint16, Coverage),\n    ligatureCoverage:   new r.Pointer(r.uint16, Coverage),\n    classCount:         r.uint16,\n    markArray:          new r.Pointer(r.uint16, MarkArray),\n    ligatureArray:      new r.Pointer(r.uint16, LigatureArray)\n  },\n\n  6: { // MarkToMark Attachment Positioning\n    format:             r.uint16,\n    mark1Coverage:      new r.Pointer(r.uint16, Coverage),\n    mark2Coverage:      new r.Pointer(r.uint16, Coverage),\n    classCount:         r.uint16,\n    mark1Array:         new r.Pointer(r.uint16, MarkArray),\n    mark2Array:         new r.Pointer(r.uint16, BaseArray)\n  },\n\n  7: Context,          // Contextual positioning\n  8: ChainingContext,  // Chaining contextual positioning\n\n  9: { // Extension Positioning\n    posFormat:   r.uint16,\n    lookupType:  r.uint16,   // cannot also be 9\n    extension:   new r.Pointer(r.uint32, GPOSLookup)\n  }\n});\n\n// Fix circular reference\nGPOSLookup.versions[9].extension.type = GPOSLookup;\n\nexport default new r.VersionedStruct(r.uint32, {\n  header: {\n    scriptList:     new r.Pointer(r.uint16, ScriptList),\n    featureList:    new r.Pointer(r.uint16, FeatureList),\n    lookupList:     new r.Pointer(r.uint16, new LookupList(GPOSLookup))\n  },\n\n  0x00010000: {},\n  0x00010001: {\n    featureVariations: new r.Pointer(r.uint32, FeatureVariations)\n  }\n});\n\n// export GPOSLookup for JSTF table\nexport { GPOSLookup };\n","import r from 'restructure';\nimport {ScriptList, FeatureList, LookupList, Coverage, ClassDef, Device, Context, ChainingContext} from './opentype';\nimport {FeatureVariations} from './variations';\n\nlet Sequence = new r.Array(r.uint16, r.uint16);\nlet AlternateSet = Sequence;\n\nlet Ligature = new r.Struct({\n  glyph:      r.uint16,\n  compCount:  r.uint16,\n  components: new r.Array(r.uint16, t => t.compCount - 1)\n});\n\nlet LigatureSet = new r.Array(new r.Pointer(r.uint16, Ligature), r.uint16);\n\nlet GSUBLookup = new r.VersionedStruct('lookupType', {\n  1: new r.VersionedStruct(r.uint16, {// Single Substitution\n    1: {\n      coverage:       new r.Pointer(r.uint16, Coverage),\n      deltaGlyphID:   r.int16\n    },\n    2: {\n      coverage:       new r.Pointer(r.uint16, Coverage),\n      glyphCount:     r.uint16,\n      substitute:     new r.LazyArray(r.uint16, 'glyphCount')\n    }\n  }),\n\n  2: { // Multiple Substitution\n    substFormat:    r.uint16,\n    coverage:       new r.Pointer(r.uint16, Coverage),\n    count:          r.uint16,\n    sequences:      new r.LazyArray(new r.Pointer(r.uint16, Sequence), 'count')\n  },\n\n  3: { // Alternate Substitution\n    substFormat:    r.uint16,\n    coverage:       new r.Pointer(r.uint16, Coverage),\n    count:          r.uint16,\n    alternateSet:   new r.LazyArray(new r.Pointer(r.uint16, AlternateSet), 'count')\n  },\n\n  4: { // Ligature Substitution\n    substFormat:    r.uint16,\n    coverage:       new r.Pointer(r.uint16, Coverage),\n    count:          r.uint16,\n    ligatureSets:   new r.LazyArray(new r.Pointer(r.uint16, LigatureSet), 'count')\n  },\n\n  5: Context,         // Contextual Substitution\n  6: ChainingContext, // Chaining Contextual Substitution\n\n  7: { // Extension Substitution\n    substFormat:   r.uint16,\n    lookupType:    r.uint16,   // cannot also be 7\n    extension:     new r.Pointer(r.uint32, GSUBLookup)\n  },\n\n  8: { // Reverse Chaining Contextual Single Substitution\n    substFormat:            r.uint16,\n    coverage:               new r.Pointer(r.uint16, Coverage),\n    backtrackCoverage:      new r.Array(new r.Pointer(r.uint16, Coverage), 'backtrackGlyphCount'),\n    lookaheadGlyphCount:    r.uint16,\n    lookaheadCoverage:      new r.Array(new r.Pointer(r.uint16, Coverage), 'lookaheadGlyphCount'),\n    glyphCount:             r.uint16,\n    substitutes:            new r.Array(r.uint16, 'glyphCount')\n  }\n});\n\n// Fix circular reference\nGSUBLookup.versions[7].extension.type = GSUBLookup;\n\nexport default new r.VersionedStruct(r.uint32, {\n  header: {\n    scriptList:     new r.Pointer(r.uint16, ScriptList),\n    featureList:    new r.Pointer(r.uint16, FeatureList),\n    lookupList:     new r.Pointer(r.uint16, new LookupList(GSUBLookup))\n  },\n\n  0x00010000: {},\n  0x00010001: {\n    featureVariations: new r.Pointer(r.uint32, FeatureVariations)\n  }\n});\n","import r from 'restructure';\nimport { ScriptList, FeatureList, LookupList, Coverage, ClassDef, Device } from './opentype';\nimport { GPOSLookup } from './GPOS';\n\nlet JstfGSUBModList = new r.Array(r.uint16, r.uint16);\n\nlet JstfPriority = new r.Struct({\n  shrinkageEnableGSUB:    new r.Pointer(r.uint16, JstfGSUBModList),\n  shrinkageDisableGSUB:   new r.Pointer(r.uint16, JstfGSUBModList),\n  shrinkageEnableGPOS:    new r.Pointer(r.uint16, JstfGSUBModList),\n  shrinkageDisableGPOS:   new r.Pointer(r.uint16, JstfGSUBModList),\n  shrinkageJstfMax:       new r.Pointer(r.uint16, new LookupList(GPOSLookup)),\n  extensionEnableGSUB:    new r.Pointer(r.uint16, JstfGSUBModList),\n  extensionDisableGSUB:   new r.Pointer(r.uint16, JstfGSUBModList),\n  extensionEnableGPOS:    new r.Pointer(r.uint16, JstfGSUBModList),\n  extensionDisableGPOS:   new r.Pointer(r.uint16, JstfGSUBModList),\n  extensionJstfMax:       new r.Pointer(r.uint16, new LookupList(GPOSLookup))\n});\n\nlet JstfLangSys = new r.Array(new r.Pointer(r.uint16, JstfPriority), r.uint16);\n\nlet JstfLangSysRecord = new r.Struct({\n  tag:         new r.String(4),\n  jstfLangSys: new r.Pointer(r.uint16, JstfLangSys)\n});\n\nlet JstfScript = new r.Struct({\n  extenderGlyphs: new r.Pointer(r.uint16, new r.Array(r.uint16, r.uint16)), // array of glyphs to extend line length\n  defaultLangSys: new r.Pointer(r.uint16, JstfLangSys),\n  langSysCount:   r.uint16,\n  langSysRecords: new r.Array(JstfLangSysRecord, 'langSysCount')\n});\n\nlet JstfScriptRecord = new r.Struct({\n  tag:    new r.String(4),\n  script: new r.Pointer(r.uint16, JstfScript, {type: 'parent'})\n});\n\nexport default new r.Struct({\n  version:     r.uint32,  // should be 0x00010000\n  scriptCount: r.uint16,\n  scriptList:  new r.Array(JstfScriptRecord, 'scriptCount')\n});\n","import r from 'restructure';\nimport {resolveLength} from 'restructure/src/utils';\nimport {ItemVariationStore} from './variations';\n\n// TODO: add this to restructure\nclass VariableSizeNumber {\n  constructor(size) {\n    this._size = size;\n  }\n\n  decode(stream, parent) {\n    switch (this.size(0, parent)) {\n      case 1: return stream.readUInt8();\n      case 2: return stream.readUInt16BE();\n      case 3: return stream.readUInt24BE();\n      case 4: return stream.readUInt32BE();\n    }\n  }\n\n  size(val, parent) {\n    return resolveLength(this._size, null, parent);\n  }\n}\n\nlet MapDataEntry = new r.Struct({\n  entry: new VariableSizeNumber(t => ((t.parent.entryFormat & 0x0030) >> 4) + 1),\n  outerIndex: t => t.entry >> ((t.parent.entryFormat & 0x000F) + 1),\n  innerIndex: t => t.entry & ((1 << ((t.parent.entryFormat & 0x000F) + 1)) - 1)\n});\n\nlet DeltaSetIndexMap = new r.Struct({\n  entryFormat: r.uint16,\n  mapCount: r.uint16,\n  mapData: new r.Array(MapDataEntry, 'mapCount')\n});\n\nexport default new r.Struct({\n  majorVersion: r.uint16,\n  minorVersion: r.uint16,\n  itemVariationStore: new r.Pointer(r.uint32, ItemVariationStore),\n  advanceWidthMapping: new r.Pointer(r.uint32, DeltaSetIndexMap),\n  LSBMapping: new r.Pointer(r.uint32, DeltaSetIndexMap),\n  RSBMapping: new r.Pointer(r.uint32, DeltaSetIndexMap)\n});\n","import r from 'restructure';\n\nlet Signature = new r.Struct({\n  format: r.uint32,\n  length: r.uint32,\n  offset: r.uint32\n});\n\nlet SignatureBlock = new r.Struct({\n  reserved:       new r.Reserved(r.uint16, 2),\n  cbSignature:    r.uint32,  // Length (in bytes) of the PKCS#7 packet in pbSignature\n  signature:      new r.Buffer('cbSignature')\n});\n\nexport default new r.Struct({\n  ulVersion:       r.uint32,  // Version number of the DSIG table (0x00000001)\n  usNumSigs:       r.uint16,  // Number of signatures in the table\n  usFlag:          r.uint16,  // Permission flags\n  signatures:      new r.Array(Signature, 'usNumSigs'),\n  signatureBlocks: new r.Array(SignatureBlock, 'usNumSigs')\n});\n","import r from 'restructure';\n\nlet GaspRange = new r.Struct({\n  rangeMaxPPEM:       r.uint16,                  // Upper limit of range, in ppem\n  rangeGaspBehavior:  new r.Bitfield(r.uint16, [ // Flags describing desired rasterizer behavior\n    'grayscale', 'gridfit',\n    'symmetricSmoothing', 'symmetricGridfit'     // only in version 1, for ClearType\n  ])\n});\n\nexport default new r.Struct({\n  version:    r.uint16,  // set to 0\n  numRanges:  r.uint16,\n  gaspRanges: new r.Array(GaspRange, 'numRanges') // Sorted by ppem\n});\n","import r from 'restructure';\n\nlet DeviceRecord = new r.Struct({\n  pixelSize:      r.uint8,\n  maximumWidth:   r.uint8,\n  widths:         new r.Array(r.uint8, t => t.parent.parent.maxp.numGlyphs)\n});\n\n// The Horizontal Device Metrics table stores integer advance widths scaled to particular pixel sizes\nexport default new r.Struct({\n  version:            r.uint16,\n  numRecords:         r.int16,\n  sizeDeviceRecord:   r.int32,\n  records:            new r.Array(DeviceRecord, 'numRecords')\n});\n","import r from 'restructure';\n\nlet KernPair = new r.Struct({\n  left:   r.uint16,\n  right:  r.uint16,\n  value:  r.int16\n});\n\nlet ClassTable = new r.Struct({\n  firstGlyph: r.uint16,\n  nGlyphs: r.uint16,\n  offsets: new r.Array(r.uint16, 'nGlyphs'),\n  max: t => t.offsets.length && Math.max.apply(Math, t.offsets)\n});\n\nlet Kern2Array = new r.Struct({\n  off: t => t._startOffset - t.parent.parent._startOffset,\n  len: t => (((t.parent.leftTable.max - t.off) / t.parent.rowWidth) + 1) * (t.parent.rowWidth / 2),\n  values: new r.LazyArray(r.int16, 'len')\n});\n\nlet KernSubtable = new r.VersionedStruct('format', {\n  0: {\n    nPairs:         r.uint16,\n    searchRange:    r.uint16,\n    entrySelector:  r.uint16,\n    rangeShift:     r.uint16,\n    pairs:          new r.Array(KernPair, 'nPairs')\n  },\n\n  2: {\n    rowWidth:   r.uint16,\n    leftTable:  new r.Pointer(r.uint16, ClassTable, {type: 'parent'}),\n    rightTable: new r.Pointer(r.uint16, ClassTable, {type: 'parent'}),\n    array:      new r.Pointer(r.uint16, Kern2Array, {type: 'parent'})\n  },\n\n  3: {\n    glyphCount:       r.uint16,\n    kernValueCount:   r.uint8,\n    leftClassCount:   r.uint8,\n    rightClassCount:  r.uint8,\n    flags:            r.uint8,\n    kernValue:        new r.Array(r.int16, 'kernValueCount'),\n    leftClass:        new r.Array(r.uint8, 'glyphCount'),\n    rightClass:       new r.Array(r.uint8, 'glyphCount'),\n    kernIndex:        new r.Array(r.uint8, t => t.leftClassCount * t.rightClassCount)\n  }\n});\n\nlet KernTable = new r.VersionedStruct('version', {\n  0: { // Microsoft uses this format\n    subVersion: r.uint16,  // Microsoft has an extra sub-table version number\n    length:     r.uint16,  // Length of the subtable, in bytes\n    format:     r.uint8,   // Format of subtable\n    coverage:   new r.Bitfield(r.uint8, [\n      'horizontal',    // 1 if table has horizontal data, 0 if vertical\n      'minimum',       // If set to 1, the table has minimum values. If set to 0, the table has kerning values.\n      'crossStream',   // If set to 1, kerning is perpendicular to the flow of the text\n      'override'      // If set to 1 the value in this table replaces the accumulated value\n    ]),\n    subtable:   KernSubtable,\n    padding: new r.Reserved(r.uint8, t => t.length - t._currentOffset)\n  },\n  1: { // Apple uses this format\n    length:     r.uint32,\n    coverage:   new r.Bitfield(r.uint8, [\n      null, null, null, null, null,\n      'variation',     // Set if table has variation kerning values\n      'crossStream',   // Set if table has cross-stream kerning values\n      'vertical'      // Set if table has vertical kerning values\n    ]),\n    format:     r.uint8,\n    tupleIndex: r.uint16,\n    subtable:   KernSubtable,\n    padding: new r.Reserved(r.uint8, t => t.length - t._currentOffset)\n  }\n});\n\nexport default new r.VersionedStruct(r.uint16, {\n  0: { // Microsoft Version\n    nTables:    r.uint16,\n    tables:     new r.Array(KernTable, 'nTables')\n  },\n\n  1: { // Apple Version\n    reserved:   new r.Reserved(r.uint16), // the other half of the version number\n    nTables:    r.uint32,\n    tables:     new r.Array(KernTable, 'nTables')\n  }\n});\n","import r from 'restructure';\n\n// Linear Threshold table\n// Records the ppem for each glyph at which the scaling becomes linear again,\n// despite instructions effecting the advance width\nexport default new r.Struct({\n  version:    r.uint16,\n  numGlyphs:  r.uint16,\n  yPels:      new r.Array(r.uint8, 'numGlyphs')\n});\n","import r from 'restructure';\n\n// PCL 5 Table\n// NOTE: The PCLT table is strongly discouraged for OpenType fonts with TrueType outlines\nexport default new r.Struct({\n  version:              r.uint16,\n  fontNumber:           r.uint32,\n  pitch:                r.uint16,\n  xHeight:              r.uint16,\n  style:                r.uint16,\n  typeFamily:           r.uint16,\n  capHeight:            r.uint16,\n  symbolSet:            r.uint16,\n  typeface:             new r.String(16),\n  characterComplement:  new r.String(8),\n  fileName:             new r.String(6),\n  strokeWeight:         new r.String(1),\n  widthType:            new r.String(1),\n  serifStyle:           r.uint8,\n  reserved:             new r.Reserved(r.uint8)\n});\n","import r from 'restructure';\n\n// VDMX tables contain ascender/descender overrides for certain (usually small)\n// sizes. This is needed in order to match font metrics on Windows.\n\nlet Ratio = new r.Struct({\n  bCharSet:       r.uint8,                             // Character set\n  xRatio:         r.uint8,                             // Value to use for x-Ratio\n  yStartRatio:    r.uint8,                             // Starting y-Ratio value\n  yEndRatio:      r.uint8                              // Ending y-Ratio value\n});\n\nlet vTable = new r.Struct({\n  yPelHeight:     r.uint16,                            // yPelHeight to which values apply\n  yMax:           r.int16,                             // Maximum value (in pels) for this yPelHeight\n  yMin:           r.int16                              // Minimum value (in pels) for this yPelHeight\n});\n\nlet VdmxGroup = new r.Struct({\n  recs:           r.uint16,                            // Number of height records in this group\n  startsz:        r.uint8,                             // Starting yPelHeight\n  endsz:          r.uint8,                             // Ending yPelHeight\n  entries:        new r.Array(vTable, 'recs')          // The VDMX records\n});\n\nexport default new r.Struct({\n  version:        r.uint16,                            // Version number (0 or 1)\n  numRecs:        r.uint16,                            // Number of VDMX groups present\n  numRatios:      r.uint16,                            // Number of aspect ratio groupings\n  ratioRanges:    new r.Array(Ratio, 'numRatios'),     // Ratio ranges\n  offsets:        new r.Array(r.uint16, 'numRatios'),  // Offset to the VDMX group for this ratio range\n  groups:         new r.Array(VdmxGroup, 'numRecs')    // The actual VDMX groupings\n});\n","import r from 'restructure';\n\n// Vertical Header Table\nexport default new r.Struct({\n  version:                r.uint16,  // Version number of the Vertical Header Table\n  ascent:                 r.int16,   // The vertical typographic ascender for this font\n  descent:                r.int16,   // The vertical typographic descender for this font\n  lineGap:                r.int16,   // The vertical typographic line gap for this font\n  advanceHeightMax:       r.int16,   // The maximum advance height measurement found in the font\n  minTopSideBearing:      r.int16,   // The minimum top side bearing measurement found in the font\n  minBottomSideBearing:   r.int16,   // The minimum bottom side bearing measurement found in the font\n  yMaxExtent:             r.int16,\n  caretSlopeRise:         r.int16,   // Caret slope (rise/run)\n  caretSlopeRun:          r.int16,\n  caretOffset:            r.int16,   // Set value equal to 0 for nonslanted fonts\n  reserved:               new r.Reserved(r.int16, 4),\n  metricDataFormat:       r.int16,   // Set to 0\n  numberOfMetrics:        r.uint16   // Number of advance heights in the Vertical Metrics table\n});\n","import r from 'restructure';\n\nlet VmtxEntry = new r.Struct({\n  advance: r.uint16,  // The advance height of the glyph\n  bearing: r.int16    // The top sidebearing of the glyph\n});\n\n// Vertical Metrics Table\nexport default new r.Struct({\n  metrics:  new r.LazyArray(VmtxEntry, t => t.parent.vhea.numberOfMetrics),\n  bearings: new r.LazyArray(r.int16, t => t.parent.maxp.numGlyphs - t.parent.vhea.numberOfMetrics)\n});\n","import r from 'restructure';\n\nlet shortFrac = new r.Fixed(16, 'BE', 14);\n\nlet Correspondence = new r.Struct({\n  fromCoord: shortFrac,\n  toCoord: shortFrac\n});\n\nlet Segment = new r.Struct({\n  pairCount: r.uint16,\n  correspondence: new r.Array(Correspondence, 'pairCount')\n});\n\nexport default new r.Struct({\n  version: r.fixed32,\n  axisCount: r.uint32,\n  segment: new r.Array(Segment, 'axisCount')\n});\n","import r from 'restructure';\n\nclass UnboundedArrayAccessor {\n  constructor(type, stream, parent) {\n    this.type = type;\n    this.stream = stream;\n    this.parent = parent;\n    this.base = this.stream.pos;\n    this._items = [];\n  }\n\n  getItem(index) {\n    if (this._items[index] == null) {\n      let pos = this.stream.pos;\n      this.stream.pos = this.base + this.type.size(null, this.parent) * index;\n      this._items[index] = this.type.decode(this.stream, this.parent);\n      this.stream.pos = pos;\n    }\n\n    return this._items[index];\n  }\n\n  inspect() {\n    return `[UnboundedArray ${this.type.constructor.name}]`;\n  }\n}\n\nexport class UnboundedArray extends r.Array {\n  constructor(type) {\n    super(type, 0);\n  }\n\n  decode(stream, parent) {\n    return new UnboundedArrayAccessor(this.type, stream, parent);\n  }\n}\n\nexport let LookupTable = function(ValueType = r.uint16) {\n  // Helper class that makes internal structures invisible to pointers\n  class Shadow {\n    constructor(type) {\n      this.type = type;\n    }\n\n    decode(stream, ctx) {\n      ctx = ctx.parent.parent;\n      return this.type.decode(stream, ctx);\n    }\n\n    size(val, ctx) {\n      ctx = ctx.parent.parent;\n      return this.type.size(val, ctx);\n    }\n\n    encode(stream, val, ctx) {\n      ctx = ctx.parent.parent;\n      return this.type.encode(stream, val, ctx);\n    }\n  }\n\n  ValueType = new Shadow(ValueType);\n\n  let BinarySearchHeader = new r.Struct({\n    unitSize: r.uint16,\n    nUnits: r.uint16,\n    searchRange: r.uint16,\n    entrySelector: r.uint16,\n    rangeShift: r.uint16\n  });\n\n  let LookupSegmentSingle = new r.Struct({\n    lastGlyph: r.uint16,\n    firstGlyph: r.uint16,\n    value: ValueType\n  });\n\n  let LookupSegmentArray = new r.Struct({\n    lastGlyph: r.uint16,\n    firstGlyph: r.uint16,\n    values: new r.Pointer(r.uint16, new r.Array(ValueType, t => t.lastGlyph - t.firstGlyph + 1), {type: 'parent'})\n  });\n\n  let LookupSingle = new r.Struct({\n    glyph: r.uint16,\n    value: ValueType\n  });\n\n  return new r.VersionedStruct(r.uint16, {\n    0: {\n      values: new UnboundedArray(ValueType) // length == number of glyphs maybe?\n    },\n    2: {\n      binarySearchHeader: BinarySearchHeader,\n      segments: new r.Array(LookupSegmentSingle, t => t.binarySearchHeader.nUnits)\n    },\n    4: {\n      binarySearchHeader: BinarySearchHeader,\n      segments: new r.Array(LookupSegmentArray, t => t.binarySearchHeader.nUnits)\n    },\n    6: {\n      binarySearchHeader: BinarySearchHeader,\n      segments: new r.Array(LookupSingle, t => t.binarySearchHeader.nUnits)\n    },\n    8: {\n      firstGlyph: r.uint16,\n      count: r.uint16,\n      values: new r.Array(ValueType, 'count')\n    }\n  });\n};\n\nexport function StateTable(entryData = {}, lookupType = r.uint16) {\n  let entry = Object.assign({\n    newState: r.uint16,\n    flags: r.uint16\n  }, entryData);\n\n  let Entry = new r.Struct(entry);\n  let StateArray = new UnboundedArray(new r.Array(r.uint16, t => t.nClasses));\n\n  let StateHeader = new r.Struct({\n    nClasses: r.uint32,\n    classTable: new r.Pointer(r.uint32, new LookupTable(lookupType)),\n    stateArray: new r.Pointer(r.uint32, StateArray),\n    entryTable: new r.Pointer(r.uint32, new UnboundedArray(Entry))\n  });\n\n  return StateHeader;\n}\n\n// This is the old version of the StateTable structure\nexport function StateTable1(entryData = {}, lookupType = r.uint16) {\n  let ClassLookupTable = new r.Struct({\n    version() { return 8; }, // simulate LookupTable\n    firstGlyph: r.uint16,\n    values: new r.Array(r.uint8, r.uint16)\n  });\n\n  let entry = Object.assign({\n    newStateOffset: r.uint16,\n    // convert offset to stateArray index\n    newState: t => (t.newStateOffset - (t.parent.stateArray.base - t.parent._startOffset)) / t.parent.nClasses,\n    flags: r.uint16\n  }, entryData);\n\n  let Entry = new r.Struct(entry);\n  let StateArray = new UnboundedArray(new r.Array(r.uint8, t => t.nClasses));\n\n  let StateHeader1 = new r.Struct({\n    nClasses: r.uint16,\n    classTable: new r.Pointer(r.uint16, ClassLookupTable),\n    stateArray: new r.Pointer(r.uint16, StateArray),\n    entryTable: new r.Pointer(r.uint16, new UnboundedArray(Entry))\n  });\n\n  return StateHeader1;\n}\n","import r from 'restructure';\nimport { LookupTable } from './aat';\n\nlet BslnSubtable = new r.VersionedStruct('format', {\n  0: { // Distance-based, no mapping\n    deltas: new r.Array(r.int16, 32)\n  },\n\n  1: { // Distance-based, with mapping\n    deltas: new r.Array(r.int16, 32),\n    mappingData: new LookupTable(r.uint16)\n  },\n\n  2: { // Control point-based, no mapping\n    standardGlyph: r.uint16,\n    controlPoints: new r.Array(r.uint16, 32)\n  },\n\n  3: { // Control point-based, with mapping\n    standardGlyph: r.uint16,\n    controlPoints: new r.Array(r.uint16, 32),\n    mappingData: new LookupTable(r.uint16)\n  }\n});\n\nexport default new r.Struct({\n  version: r.fixed32,\n  format: r.uint16,\n  defaultBaseline: r.uint16,\n  subtable: BslnSubtable\n});\n","import r from 'restructure';\n\nlet Setting = new r.Struct({\n  setting: r.uint16,\n  nameIndex: r.int16,\n  name: t => t.parent.parent.parent.name.records.fontFeatures[t.nameIndex]\n});\n\nlet FeatureName = new r.Struct({\n  feature: r.uint16,\n  nSettings: r.uint16,\n  settingTable: new r.Pointer(r.uint32, new r.Array(Setting, 'nSettings'), { type: 'parent' }),\n  featureFlags: new r.Bitfield(r.uint8, [\n    null, null, null, null, null, null,\n    'hasDefault', 'exclusive'\n  ]),\n  defaultSetting: r.uint8,\n  nameIndex: r.int16,\n  name: t => t.parent.parent.name.records.fontFeatures[t.nameIndex]\n});\n\nexport default new r.Struct({\n  version: r.fixed32,\n  featureNameCount: r.uint16,\n  reserved1: new r.Reserved(r.uint16),\n  reserved2: new r.Reserved(r.uint32),\n  featureNames: new r.Array(FeatureName, 'featureNameCount')\n});\n","import r from 'restructure';\n\nlet Axis = new r.Struct({\n  axisTag: new r.String(4),\n  minValue: r.fixed32,\n  defaultValue: r.fixed32,\n  maxValue: r.fixed32,\n  flags: r.uint16,\n  nameID: r.uint16,\n  name: t => t.parent.parent.name.records.fontFeatures[t.nameID]\n});\n\nlet Instance = new r.Struct({\n  nameID: r.uint16,\n  name: t => t.parent.parent.name.records.fontFeatures[t.nameID],\n  flags: r.uint16,\n  coord: new r.Array(r.fixed32, t => t.parent.axisCount),\n  postscriptNameID: new r.Optional(r.uint16, t => t.parent.instanceSize - t._currentOffset > 0)\n});\n\nexport default new r.Struct({\n  version: r.fixed32,\n  offsetToData: r.uint16,\n  countSizePairs: r.uint16,\n  axisCount: r.uint16,\n  axisSize: r.uint16,\n  instanceCount: r.uint16,\n  instanceSize: r.uint16,\n  axis: new r.Array(Axis, 'axisCount'),\n  instance: new r.Array(Instance, 'instanceCount')\n});\n","import r from 'restructure';\n\nlet shortFrac = new r.Fixed(16, 'BE', 14);\nclass Offset {\n  static decode(stream, parent) {\n    // In short format, offsets are multiplied by 2.\n    // This doesn't seem to be documented by Apple, but it\n    // is implemented this way in Freetype.\n    return parent.flags \n      ? stream.readUInt32BE()\n      : stream.readUInt16BE() * 2;\n  }\n}\n\nlet gvar = new r.Struct({\n  version: r.uint16,\n  reserved: new r.Reserved(r.uint16),\n  axisCount: r.uint16,\n  globalCoordCount: r.uint16,\n  globalCoords: new r.Pointer(r.uint32, new r.Array(new r.Array(shortFrac, 'axisCount'), 'globalCoordCount')),\n  glyphCount: r.uint16,\n  flags: r.uint16,\n  offsetToData: r.uint32,\n  offsets: new r.Array(new r.Pointer(Offset, 'void', { relativeTo: 'offsetToData', allowNull: false }), t => t.glyphCount + 1)\n});\n\nexport default gvar;\n","import r from 'restructure';\nimport { LookupTable, StateTable1 } from './aat';\n\nlet ClassTable = new r.Struct({\n  length: r.uint16,\n  coverage: r.uint16,\n  subFeatureFlags: r.uint32,\n  stateTable: new StateTable1\n});\n\nlet WidthDeltaRecord = new r.Struct({\n  justClass: r.uint32,\n  beforeGrowLimit: r.fixed32,\n  beforeShrinkLimit: r.fixed32,\n  afterGrowLimit: r.fixed32,\n  afterShrinkLimit: r.fixed32,\n  growFlags: r.uint16,\n  shrinkFlags: r.uint16\n});\n\nlet WidthDeltaCluster = new r.Array(WidthDeltaRecord, r.uint32);\n\nlet ActionData = new r.VersionedStruct('actionType', {\n  0: { // Decomposition action\n    lowerLimit: r.fixed32,\n    upperLimit: r.fixed32,\n    order: r.uint16,\n    glyphs: new r.Array(r.uint16, r.uint16)\n  },\n\n  1: { // Unconditional add glyph action\n    addGlyph: r.uint16\n  },\n\n  2: { // Conditional add glyph action\n    substThreshold: r.fixed32,\n    addGlyph: r.uint16,\n    substGlyph: r.uint16\n  },\n\n  3: {}, // Stretch glyph action (no data, not supported by CoreText)\n\n  4: { // Ductile glyph action (not supported by CoreText)\n    variationAxis: r.uint32,\n    minimumLimit: r.fixed32,\n    noStretchValue: r.fixed32,\n    maximumLimit: r.fixed32\n  },\n\n  5: { // Repeated add glyph action\n    flags: r.uint16,\n    glyph: r.uint16\n  }\n});\n\nlet Action = new r.Struct({\n  actionClass: r.uint16,\n  actionType: r.uint16,\n  actionLength: r.uint32,\n  actionData: ActionData,\n  padding: new r.Reserved(r.uint8, t => t.actionLength - t._currentOffset)\n});\n\nlet PostcompensationAction = new r.Array(Action, r.uint32);\nlet PostCompensationTable = new r.Struct({\n  lookupTable: new LookupTable(new r.Pointer(r.uint16, PostcompensationAction))\n});\n\nlet JustificationTable = new r.Struct({\n  classTable: new r.Pointer(r.uint16, ClassTable, { type: 'parent' }),\n  wdcOffset: r.uint16,\n  postCompensationTable: new r.Pointer(r.uint16, PostCompensationTable, { type: 'parent' }),\n  widthDeltaClusters: new LookupTable(new r.Pointer(r.uint16, WidthDeltaCluster, { type: 'parent', relativeTo: 'wdcOffset' }))\n});\n\nexport default new r.Struct({\n  version: r.uint32,\n  format: r.uint16,\n  horizontal: new r.Pointer(r.uint16, JustificationTable),\n  vertical: new r.Pointer(r.uint16, JustificationTable)\n});\n","import r from 'restructure';\nimport { UnboundedArray, LookupTable, StateTable } from './aat';\n\nlet LigatureData = {\n  action: r.uint16\n};\n\nlet ContextualData = {\n  markIndex: r.uint16,\n  currentIndex: r.uint16\n};\n\nlet InsertionData = {\n  currentInsertIndex: r.uint16,\n  markedInsertIndex: r.uint16\n};\n\nlet SubstitutionTable = new r.Struct({\n  items: new UnboundedArray(new r.Pointer(r.uint32, new LookupTable))\n});\n\nlet SubtableData = new r.VersionedStruct('type', {\n  0: { // Indic Rearrangement Subtable\n    stateTable: new StateTable\n  },\n\n  1: { // Contextual Glyph Substitution Subtable\n    stateTable: new StateTable(ContextualData),\n    substitutionTable: new r.Pointer(r.uint32, SubstitutionTable)\n  },\n\n  2: { // Ligature subtable\n    stateTable: new StateTable(LigatureData),\n    ligatureActions: new r.Pointer(r.uint32, new UnboundedArray(r.uint32)),\n    components: new r.Pointer(r.uint32, new UnboundedArray(r.uint16)),\n    ligatureList: new r.Pointer(r.uint32, new UnboundedArray(r.uint16))\n  },\n\n  4: { // Non-contextual Glyph Substitution Subtable\n    lookupTable: new LookupTable\n  },\n\n  5: { // Glyph Insertion Subtable\n    stateTable: new StateTable(InsertionData),\n    insertionActions: new r.Pointer(r.uint32, new UnboundedArray(r.uint16))\n  }\n});\n\nlet Subtable = new r.Struct({\n  length: r.uint32,\n  coverage: r.uint24,\n  type: r.uint8,\n  subFeatureFlags: r.uint32,\n  table: SubtableData,\n  padding: new r.Reserved(r.uint8, t => t.length - t._currentOffset)\n});\n\nlet FeatureEntry = new r.Struct({\n  featureType:    r.uint16,\n  featureSetting: r.uint16,\n  enableFlags:    r.uint32,\n  disableFlags:   r.uint32\n});\n\nlet MorxChain = new r.Struct({\n  defaultFlags:     r.uint32,\n  chainLength:      r.uint32,\n  nFeatureEntries:  r.uint32,\n  nSubtables:       r.uint32,\n  features:         new r.Array(FeatureEntry, 'nFeatureEntries'),\n  subtables:        new r.Array(Subtable, 'nSubtables')\n});\n\nexport default new r.Struct({\n  version:  r.uint16,\n  unused:   new r.Reserved(r.uint16),\n  nChains:  r.uint32,\n  chains:   new r.Array(MorxChain, 'nChains')\n});\n","import r from 'restructure';\nimport { LookupTable } from './aat';\n\nlet OpticalBounds = new r.Struct({\n  left: r.int16,\n  top: r.int16,\n  right: r.int16,\n  bottom: r.int16\n});\n\nexport default new r.Struct({\n  version: r.fixed32,\n  format: r.uint16,\n  lookupTable: new LookupTable(OpticalBounds)\n});\n","let tables = {};\nexport default tables;\n\n// Required Tables\nimport cmap from './cmap';\nimport head from './head';\nimport hhea from './hhea';\nimport hmtx from './hmtx';\nimport maxp from './maxp';\nimport name from './name';\nimport OS2 from './OS2';\nimport post from './post';\n\ntables.cmap = cmap;\ntables.head = head;\ntables.hhea = hhea;\ntables.hmtx = hmtx;\ntables.maxp = maxp;\ntables.name = name;\ntables['OS/2'] = OS2;\ntables.post = post;\n\n\n// TrueType Outlines\nimport cvt from './cvt';\nimport fpgm from './fpgm';\nimport loca from './loca';\nimport prep from './prep';\nimport glyf from './glyf';\n\ntables.fpgm = fpgm;\ntables.loca = loca;\ntables.prep = prep;\ntables['cvt '] = cvt;\ntables.glyf = glyf;\n\n\n// PostScript Outlines\nimport CFFFont from '../cff/CFFFont';\nimport VORG from './VORG';\n\ntables['CFF '] = CFFFont;\ntables['CFF2'] = CFFFont;\ntables.VORG = VORG;\n\n\n// Bitmap Glyphs\nimport EBLC from './EBLC';\nimport sbix from './sbix';\nimport COLR from './COLR';\nimport CPAL from './CPAL';\n\ntables.EBLC = EBLC;\ntables.CBLC = tables.EBLC;\ntables.sbix = sbix;\ntables.COLR = COLR;\ntables.CPAL = CPAL;\n\n\n// Advanced OpenType Tables\nimport BASE from './BASE';\nimport GDEF from './GDEF';\nimport GPOS from './GPOS';\nimport GSUB from './GSUB';\nimport JSTF from './JSTF';\n\ntables.BASE = BASE;\ntables.GDEF = GDEF;\ntables.GPOS = GPOS;\ntables.GSUB = GSUB;\ntables.JSTF = JSTF;\n\n// OpenType variations tables\nimport HVAR from './HVAR';\n\ntables.HVAR = HVAR;\n\n// Other OpenType Tables\nimport DSIG from './DSIG';\nimport gasp from './gasp';\nimport hdmx from './hdmx';\nimport kern from './kern';\nimport LTSH from './LTSH';\nimport PCLT from './PCLT';\nimport VDMX from './VDMX';\nimport vhea from './vhea';\nimport vmtx from './vmtx';\n\ntables.DSIG = DSIG;\ntables.gasp = gasp;\ntables.hdmx = hdmx;\ntables.kern = kern;\ntables.LTSH = LTSH;\ntables.PCLT = PCLT;\ntables.VDMX = VDMX;\ntables.vhea = vhea;\ntables.vmtx = vmtx;\n\n\n// Apple Advanced Typography Tables\nimport avar from './avar';\nimport bsln from './bsln';\nimport feat from './feat';\nimport fvar from './fvar';\nimport gvar from './gvar';\nimport just from './just';\nimport morx from './morx';\nimport opbd from './opbd';\n\ntables.avar = avar;\ntables.bsln = bsln;\ntables.feat = feat;\ntables.fvar = fvar;\ntables.gvar = gvar;\ntables.just = just;\ntables.morx = morx;\ntables.opbd = opbd;\n","import r from 'restructure';\nimport Tables from './';\n\nlet TableEntry = new r.Struct({\n  tag:        new r.String(4),\n  checkSum:   r.uint32,\n  offset:     new r.Pointer(r.uint32, 'void', { type: 'global' }),\n  length:     r.uint32\n});\n\nlet Directory = new r.Struct({\n  tag:            new r.String(4),\n  numTables:      r.uint16,\n  searchRange:    r.uint16,\n  entrySelector:  r.uint16,\n  rangeShift:     r.uint16,\n  tables:         new r.Array(TableEntry, 'numTables')\n});\n\nDirectory.process = function() {\n  let tables = {};\n  for (let table of this.tables) {\n    tables[table.tag] = table;\n  }\n\n  this.tables = tables;\n};\n\nDirectory.preEncode = function(stream) {\n  let tables = [];\n  for (let tag in this.tables) {\n    let table = this.tables[tag];\n    if (table) {\n      tables.push({\n        tag: tag,\n        checkSum: 0,\n        offset: new r.VoidPointer(Tables[tag], table),\n        length: Tables[tag].size(table)\n      });\n    }\n  }\n\n  this.tag = 'true';\n  this.numTables = tables.length;\n  this.tables = tables;\n\n  let maxExponentFor2 = Math.floor((Math.log(this.numTables) / Math.LN2));\n  let maxPowerOf2 = Math.pow(2, maxExponentFor2);\n\n  this.searchRange =  maxPowerOf2 * 16;\n  this.entrySelector = Math.log(maxPowerOf2) / Math.LN2;\n  this.rangeShift = this.numTables * 16 - this.searchRange;\n};\n\nexport default Directory;\n","export function binarySearch(arr, cmp) {\n  let min = 0;\n  let max = arr.length - 1;\n  while (min <= max) {\n    let mid = (min + max) >> 1;\n    let res = cmp(arr[mid]);\n\n    if (res < 0) {\n      max = mid - 1;\n    } else if (res > 0) {\n      min = mid + 1;\n    } else {\n      return mid;\n    }\n  }\n\n  return -1;\n}\n\nexport function range(index, end) {\n  let range = [];\n  while (index < end) {\n    range.push(index++);\n  }\n  return range;\n}\n","import {binarySearch} from './utils';\nimport {getEncoding} from './encodings';\nimport {cache} from './decorators';\nimport {range} from './utils';\n\n// iconv-lite is an optional dependency.\ntry {\n  var iconv = require('iconv-lite');\n} catch (err) {}\n\nexport default class CmapProcessor {\n  constructor(cmapTable) {\n    // Attempt to find a Unicode cmap first\n    this.encoding = null;\n    this.cmap = this.findSubtable(cmapTable, [\n      // 32-bit subtables\n      [3, 10],\n      [0, 6],\n      [0, 4],\n\n      // 16-bit subtables\n      [3, 1],\n      [0, 3],\n      [0, 2],\n      [0, 1],\n      [0, 0]\n    ]);\n\n    // If not unicode cmap was found, and iconv-lite is installed,\n    // take the first table with a supported encoding.\n    if (!this.cmap && iconv) {\n      for (let cmap of cmapTable.tables) {\n        let encoding = getEncoding(cmap.platformID, cmap.encodingID, cmap.table.language - 1);\n        if (iconv.encodingExists(encoding)) {\n          this.cmap = cmap.table;\n          this.encoding = encoding;\n        }\n      }\n    }\n\n    if (!this.cmap) {\n      throw new Error(\"Could not find a supported cmap table\");\n    }\n\n    this.uvs = this.findSubtable(cmapTable, [[0, 5]]);\n    if (this.uvs && this.uvs.version !== 14) {\n      this.uvs = null;\n    }\n  }\n\n  findSubtable(cmapTable, pairs) {\n    for (let [platformID, encodingID] of pairs) {\n      for (let cmap of cmapTable.tables) {\n        if (cmap.platformID === platformID && cmap.encodingID === encodingID) {\n          return cmap.table;\n        }\n      }\n    }\n\n    return null;\n  }\n\n  lookup(codepoint, variationSelector) {\n    // If there is no Unicode cmap in this font, we need to re-encode\n    // the codepoint in the encoding that the cmap supports.\n    if (this.encoding) {\n      let buf = iconv.encode(String.fromCodePoint(codepoint), this.encoding);\n      codepoint = 0;\n      for (let i = 0; i < buf.length; i++) {\n        codepoint = (codepoint << 8) | buf[i];\n      }\n\n    // Otherwise, try to get a Unicode variation selector for this codepoint if one is provided.\n    } else if (variationSelector) {\n      let gid = this.getVariationSelector(codepoint, variationSelector);\n      if (gid) {\n        return gid;\n      }\n    }\n\n    let cmap = this.cmap;\n    switch (cmap.version) {\n      case 0:\n        return cmap.codeMap.get(codepoint) || 0;\n\n      case 4: {\n        let min = 0;\n        let max = cmap.segCount - 1;\n        while (min <= max) {\n          let mid = (min + max) >> 1;\n\n          if (codepoint < cmap.startCode.get(mid)) {\n            max = mid - 1;\n          } else if (codepoint > cmap.endCode.get(mid)) {\n            min = mid + 1;\n          } else {\n            let rangeOffset = cmap.idRangeOffset.get(mid);\n            let gid;\n\n            if (rangeOffset === 0) {\n              gid = codepoint + cmap.idDelta.get(mid);\n            } else {\n              let index = rangeOffset / 2 + (codepoint - cmap.startCode.get(mid)) - (cmap.segCount - mid);\n              gid = cmap.glyphIndexArray.get(index) || 0;\n              if (gid !== 0) {\n                gid += cmap.idDelta.get(mid);\n              }\n            }\n\n            return gid & 0xffff;\n          }\n        }\n\n        return 0;\n      }\n\n      case 8:\n        throw new Error('TODO: cmap format 8');\n\n      case 6:\n      case 10:\n        return cmap.glyphIndices.get(codepoint - cmap.firstCode) || 0;\n\n      case 12:\n      case 13: {\n        let min = 0;\n        let max = cmap.nGroups - 1;\n        while (min <= max) {\n          let mid = (min + max) >> 1;\n          let group = cmap.groups.get(mid);\n\n          if (codepoint < group.startCharCode) {\n            max = mid - 1;\n          } else if (codepoint > group.endCharCode) {\n            min = mid + 1;\n          } else {\n            if (cmap.version === 12) {\n              return group.glyphID + (codepoint - group.startCharCode);\n            } else {\n              return group.glyphID;\n            }\n          }\n        }\n\n        return 0;\n      }\n\n      case 14:\n        throw new Error('TODO: cmap format 14');\n\n      default:\n        throw new Error(`Unknown cmap format ${cmap.version}`);\n    }\n  }\n\n  getVariationSelector(codepoint, variationSelector) {\n    if (!this.uvs) {\n      return 0;\n    }\n\n    let selectors = this.uvs.varSelectors.toArray();\n    let i = binarySearch(selectors, x => variationSelector - x.varSelector);\n    let sel = selectors[i];\n\n    if (i !== -1 && sel.defaultUVS) {\n      i = binarySearch(sel.defaultUVS, x =>\n        codepoint < x.startUnicodeValue ? -1 : codepoint > x.startUnicodeValue + x.additionalCount ? +1 : 0\n      );\n    }\n\n    if (i !== -1 && sel.nonDefaultUVS) {\n      i = binarySearch(sel.nonDefaultUVS, x => codepoint - x.unicodeValue);\n      if (i !== -1) {\n        return sel.nonDefaultUVS[i].glyphID;\n      }\n    }\n\n    return 0;\n  }\n\n  @cache\n  getCharacterSet() {\n    let cmap = this.cmap;\n    switch (cmap.version) {\n      case 0:\n        return range(0, cmap.codeMap.length);\n\n      case 4: {\n        let res = [];\n        let endCodes = cmap.endCode.toArray();\n        for (let i = 0; i < endCodes.length; i++) {\n          let tail = endCodes[i] + 1;\n          let start = cmap.startCode.get(i);\n          res.push(...range(start, tail));\n        }\n\n        return res;\n      }\n\n      case 8:\n        throw new Error('TODO: cmap format 8');\n\n      case 6:\n      case 10:\n        return range(cmap.firstCode, cmap.firstCode + cmap.glyphIndices.length);\n\n      case 12:\n      case 13: {\n        let res = [];\n        for (let group of cmap.groups.toArray()) {\n          res.push(...range(group.startCharCode, group.endCharCode + 1));\n        }\n\n        return res;\n      }\n\n      case 14:\n        throw new Error('TODO: cmap format 14');\n\n      default:\n        throw new Error(`Unknown cmap format ${cmap.version}`);\n    }\n  }\n\n  @cache\n  codePointsForGlyph(gid) {\n    let cmap = this.cmap;\n    switch (cmap.version) {\n      case 0: {\n        let res = [];\n        for (let i = 0; i < 256; i++) {\n          if (cmap.codeMap.get(i) === gid) {\n            res.push(i);\n          }\n        }\n\n        return res;\n      }\n\n      case 4: {\n        let res = [];\n        for (let i = 0; i < cmap.segCount; i++) {\n          let end = cmap.endCode.get(i);\n          let start = cmap.startCode.get(i);\n          let rangeOffset = cmap.idRangeOffset.get(i);\n          let delta = cmap.idDelta.get(i);\n\n          for (var c = start; c <= end; c++) {\n            let g = 0;\n            if (rangeOffset === 0) {\n              g = c + delta;\n            } else {\n              let index = rangeOffset / 2 + (c - start) - (cmap.segCount - i);\n              g = cmap.glyphIndexArray.get(index) || 0;\n              if (g !== 0) {\n                g += delta;\n              }\n            }\n\n            if (g === gid) {\n              res.push(c);\n            }\n          }\n        }\n\n        return res;\n      }\n\n      case 12: {\n        let res = [];\n        for (let group of cmap.groups.toArray()) {\n          if (gid >= group.glyphID && gid <= group.glyphID + (group.endCharCode - group.startCharCode)) {\n            res.push(group.startCharCode + (gid - group.glyphID));\n          }\n        }\n\n        return res;\n      }\n\n      case 13: {\n        let res = [];\n        for (let group of cmap.groups.toArray()) {\n          if (gid === group.glyphID) {\n            res.push(...range(group.startCharCode, group.endCharCode + 1));\n          }\n        }\n\n        return res;\n      }\n\n      default:\n        throw new Error(`Unknown cmap format ${cmap.version}`);\n    }\n  }\n}\n","import {binarySearch} from '../utils';\n\nexport default class KernProcessor {\n  constructor(font) {\n    this.kern = font.kern;\n  }\n\n  process(glyphs, positions) {\n    for (let glyphIndex = 0; glyphIndex < glyphs.length - 1; glyphIndex++) {\n      let left = glyphs[glyphIndex].id;\n      let right = glyphs[glyphIndex + 1].id;\n      positions[glyphIndex].xAdvance += this.getKerning(left, right);\n    }\n  }\n\n  getKerning(left, right) {\n    let res = 0;\n\n    for (let table of this.kern.tables) {\n      if (table.coverage.crossStream) {\n        continue;\n      }\n\n      switch (table.version) {\n        case 0:\n          if (!table.coverage.horizontal) {\n            continue;\n          }\n\n          break;\n        case 1:\n          if (table.coverage.vertical || table.coverage.variation) {\n            continue;\n          }\n\n          break;\n        default:\n          throw new Error(`Unsupported kerning table version ${table.version}`);\n      }\n\n      let val = 0;\n      let s = table.subtable;\n      switch (table.format) {\n        case 0:\n          let pairIdx = binarySearch(s.pairs, function (pair) {\n            return (left - pair.left) || (right - pair.right);\n          });\n\n          if (pairIdx >= 0) {\n            val = s.pairs[pairIdx].value;\n          }\n\n          break;\n\n        case 2:\n          let leftOffset = 0, rightOffset = 0;\n          if (left >= s.leftTable.firstGlyph && left < s.leftTable.firstGlyph + s.leftTable.nGlyphs) {\n            leftOffset = s.leftTable.offsets[left - s.leftTable.firstGlyph];\n          } else {\n            leftOffset = s.array.off;\n          }\n\n          if (right >= s.rightTable.firstGlyph && right < s.rightTable.firstGlyph + s.rightTable.nGlyphs) {\n            rightOffset = s.rightTable.offsets[right - s.rightTable.firstGlyph];\n          }\n\n          let index = (leftOffset + rightOffset - s.array.off) / 2;\n          val = s.array.values.get(index);\n          break;\n\n        case 3:\n          if (left >= s.glyphCount || right >= s.glyphCount) {\n            return 0;\n          }\n\n          val = s.kernValue[s.kernIndex[s.leftClass[left] * s.rightClassCount + s.rightClass[right]]];\n          break;\n\n        default:\n          throw new Error(`Unsupported kerning sub-table format ${table.format}`);\n      }\n\n      // Microsoft supports the override flag, which resets the result\n      // Otherwise, the sum of the results from all subtables is returned\n      if (table.coverage.override) {\n        res = val;\n      } else {\n        res += val;\n      }\n    }\n\n    return res;\n  }\n}\n","import unicode from 'unicode-properties';\n\n/**\n * This class is used when GPOS does not define 'mark' or 'mkmk' features\n * for positioning marks relative to base glyphs. It uses the unicode\n * combining class property to position marks.\n *\n * Based on code from Harfbuzz, thanks!\n * https://github.com/behdad/harfbuzz/blob/master/src/hb-ot-shape-fallback.cc\n */\nexport default class UnicodeLayoutEngine {\n  constructor(font) {\n    this.font = font;\n  }\n\n  positionGlyphs(glyphs, positions) {\n    // find each base + mark cluster, and position the marks relative to the base\n    let clusterStart = 0;\n    let clusterEnd = 0;\n    for (let index = 0; index < glyphs.length; index++) {\n      let glyph = glyphs[index];\n      if (glyph.isMark) { // TODO: handle ligatures\n        clusterEnd = index;\n      } else {\n        if (clusterStart !== clusterEnd) {\n          this.positionCluster(glyphs, positions, clusterStart, clusterEnd);\n        }\n\n        clusterStart = clusterEnd = index;\n      }\n    }\n\n    if (clusterStart !== clusterEnd) {\n      this.positionCluster(glyphs, positions, clusterStart, clusterEnd);\n    }\n\n    return positions;\n  }\n\n  positionCluster(glyphs, positions, clusterStart, clusterEnd) {\n    let base = glyphs[clusterStart];\n    let baseBox = base.cbox.copy();\n\n    // adjust bounding box for ligature glyphs\n    if (base.codePoints.length > 1) {\n      // LTR. TODO: RTL support.\n      baseBox.minX += ((base.codePoints.length - 1) * baseBox.width) / base.codePoints.length;\n    }\n\n    let xOffset = -positions[clusterStart].xAdvance;\n    let yOffset = 0;\n    let yGap = this.font.unitsPerEm / 16;\n\n    // position each of the mark glyphs relative to the base glyph\n    for (let index = clusterStart + 1; index <= clusterEnd; index++) {\n      let mark = glyphs[index];\n      let markBox = mark.cbox;\n      let position = positions[index];\n\n      let combiningClass = this.getCombiningClass(mark.codePoints[0]);\n\n      if (combiningClass !== 'Not_Reordered') {\n        position.xOffset = position.yOffset = 0;\n\n        // x positioning\n        switch (combiningClass) {\n          case 'Double_Above':\n          case 'Double_Below':\n            // LTR. TODO: RTL support.\n            position.xOffset += baseBox.minX - markBox.width / 2 - markBox.minX;\n            break;\n\n          case 'Attached_Below_Left':\n          case 'Below_Left':\n          case 'Above_Left':\n            // left align\n            position.xOffset += baseBox.minX - markBox.minX;\n            break;\n\n          case 'Attached_Above_Right':\n          case 'Below_Right':\n          case 'Above_Right':\n            // right align\n            position.xOffset += baseBox.maxX - markBox.width - markBox.minX;\n            break;\n\n          default: // Attached_Below, Attached_Above, Below, Above, other\n            // center align\n            position.xOffset += baseBox.minX + (baseBox.width - markBox.width) / 2 - markBox.minX;\n        }\n\n        // y positioning\n        switch (combiningClass) {\n          case 'Double_Below':\n          case 'Below_Left':\n          case 'Below':\n          case 'Below_Right':\n          case 'Attached_Below_Left':\n          case 'Attached_Below':\n            // add a small gap between the glyphs if they are not attached\n            if (combiningClass === 'Attached_Below_Left' || combiningClass === 'Attached_Below') {\n              baseBox.minY += yGap;\n            }\n\n            position.yOffset = -baseBox.minY - markBox.maxY;\n            baseBox.minY += markBox.height;\n            break;\n\n          case 'Double_Above':\n          case 'Above_Left':\n          case 'Above':\n          case 'Above_Right':\n          case 'Attached_Above':\n          case 'Attached_Above_Right':\n            // add a small gap between the glyphs if they are not attached\n            if (combiningClass === 'Attached_Above' || combiningClass === 'Attached_Above_Right') {\n              baseBox.maxY += yGap;\n            }\n\n            position.yOffset = baseBox.maxY - markBox.minY;\n            baseBox.maxY += markBox.height;\n            break;\n        }\n\n        position.xAdvance = position.yAdvance = 0;\n        position.xOffset += xOffset;\n        position.yOffset += yOffset;\n\n      } else {\n        xOffset -= position.xAdvance;\n        yOffset -= position.yAdvance;\n      }\n    }\n\n    return;\n  }\n\n  getCombiningClass(codePoint) {\n    let combiningClass = unicode.getCombiningClass(codePoint);\n\n    // Thai / Lao need some per-character work\n    if ((codePoint & ~0xff) === 0x0e00) {\n      if (combiningClass === 'Not_Reordered') {\n        switch (codePoint) {\n          case 0x0e31:\n          case 0x0e34:\n          case 0x0e35:\n          case 0x0e36:\n          case 0x0e37:\n          case 0x0e47:\n          case 0x0e4c:\n          case 0x0e3d:\n          case 0x0e4e:\n            return 'Above_Right';\n\n          case 0x0eb1:\n          case 0x0eb4:\n          case 0x0eb5:\n          case 0x0eb6:\n          case 0x0eb7:\n          case 0x0ebb:\n          case 0x0ecc:\n          case 0x0ecd:\n            return 'Above';\n\n          case 0x0ebc:\n            return 'Below';\n        }\n      } else if (codePoint === 0x0e3a) { // virama\n        return 'Below_Right';\n      }\n    }\n\n    switch (combiningClass) {\n      // Hebrew\n\n      case 'CCC10': // sheva\n      case 'CCC11': // hataf segol\n      case 'CCC12': // hataf patah\n      case 'CCC13': // hataf qamats\n      case 'CCC14': // hiriq\n      case 'CCC15': // tsere\n      case 'CCC16': // segol\n      case 'CCC17': // patah\n      case 'CCC18': // qamats\n      case 'CCC20': // qubuts\n      case 'CCC22': // meteg\n        return 'Below';\n\n      case 'CCC23': // rafe\n        return 'Attached_Above';\n\n      case 'CCC24': // shin dot\n        return 'Above_Right';\n\n      case 'CCC25': // sin dot\n      case 'CCC19': // holam\n        return 'Above_Left';\n\n      case 'CCC26': // point varika\n        return 'Above';\n\n      case 'CCC21': // dagesh\n        break;\n\n      // Arabic and Syriac\n\n      case 'CCC27': // fathatan\n      case 'CCC28': // dammatan\n      case 'CCC30': // fatha\n      case 'CCC31': // damma\n      case 'CCC33': // shadda\n      case 'CCC34': // sukun\n      case 'CCC35': // superscript alef\n      case 'CCC36': // superscript alaph\n        return 'Above';\n\n      case 'CCC29': // kasratan\n      case 'CCC32': // kasra\n        return 'Below';\n\n      // Thai\n\n      case 'CCC103': // sara u / sara uu\n        return 'Below_Right';\n\n      case 'CCC107': // mai\n        return 'Above_Right';\n\n      // Lao\n\n      case 'CCC118': // sign u / sign uu\n        return 'Below';\n\n      case 'CCC122': // mai\n        return 'Above';\n\n      // Tibetan\n\n      case 'CCC129': // sign aa\n      case 'CCC132': // sign u\n        return 'Below';\n\n      case 'CCC130': // sign i\n        return 'Above';\n    }\n\n    return combiningClass;\n  }\n}\n","/**\n * Represents a glyph bounding box\n */\nexport default class BBox {\n  constructor(minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity) {\n    /**\n     * The minimum X position in the bounding box\n     * @type {number}\n     */\n    this.minX = minX;\n\n    /**\n     * The minimum Y position in the bounding box\n     * @type {number}\n     */\n    this.minY = minY;\n\n    /**\n     * The maxmimum X position in the bounding box\n     * @type {number}\n     */\n    this.maxX = maxX;\n\n    /**\n     * The maxmimum Y position in the bounding box\n     * @type {number}\n     */\n    this.maxY = maxY;\n  }\n\n  /**\n   * The width of the bounding box\n   * @type {number}\n   */\n  get width() {\n    return this.maxX - this.minX;\n  }\n\n  /**\n   * The height of the bounding box\n   * @type {number}\n   */\n  get height() {\n    return this.maxY - this.minY;\n  }\n\n  addPoint(x, y) {\n    if (Math.abs(x) !== Infinity) {\n      if (x < this.minX) {\n        this.minX = x;\n      }\n\n      if (x > this.maxX) {\n        this.maxX = x;\n      }\n    }\n\n    if (Math.abs(y) !== Infinity) {\n      if (y < this.minY) {\n        this.minY = y;\n      }\n\n      if (y > this.maxY) {\n        this.maxY = y;\n      }\n    }\n  }\n\n  copy() {\n    return new BBox(this.minX, this.minY, this.maxX, this.maxY);\n  }\n}\n","import unicode from 'unicode-properties';\n\n// This maps the Unicode Script property to an OpenType script tag\n// Data from http://www.microsoft.com/typography/otspec/scripttags.htm\n// and http://www.unicode.org/Public/UNIDATA/PropertyValueAliases.txt.\nconst UNICODE_SCRIPTS = {\n  Caucasian_Albanian: 'aghb',\n  Arabic: 'arab',\n  Imperial_Aramaic: 'armi',\n  Armenian: 'armn',\n  Avestan: 'avst',\n  Balinese: 'bali',\n  Bamum: 'bamu',\n  Bassa_Vah: 'bass',\n  Batak: 'batk',\n  Bengali: ['bng2', 'beng'],\n  Bopomofo: 'bopo',\n  Brahmi: 'brah',\n  Braille: 'brai',\n  Buginese: 'bugi',\n  Buhid: 'buhd',\n  Chakma: 'cakm',\n  Canadian_Aboriginal: 'cans',\n  Carian: 'cari',\n  Cham: 'cham',\n  Cherokee: 'cher',\n  Coptic: 'copt',\n  Cypriot: 'cprt',\n  Cyrillic: 'cyrl',\n  Devanagari: ['dev2', 'deva'],\n  Deseret: 'dsrt',\n  Duployan: 'dupl',\n  Egyptian_Hieroglyphs: 'egyp',\n  Elbasan: 'elba',\n  Ethiopic: 'ethi',\n  Georgian: 'geor',\n  Glagolitic: 'glag',\n  Gothic: 'goth',\n  Grantha: 'gran',\n  Greek: 'grek',\n  Gujarati: ['gjr2', 'gujr'],\n  Gurmukhi: ['gur2', 'guru'],\n  Hangul: 'hang',\n  Han: 'hani',\n  Hanunoo: 'hano',\n  Hebrew: 'hebr',\n  Hiragana: 'hira',\n  Pahawh_Hmong: 'hmng',\n  Katakana_Or_Hiragana: 'hrkt',\n  Old_Italic: 'ital',\n  Javanese: 'java',\n  Kayah_Li: 'kali',\n  Katakana: 'kana',\n  Kharoshthi: 'khar',\n  Khmer: 'khmr',\n  Khojki: 'khoj',\n  Kannada: ['knd2', 'knda'],\n  Kaithi: 'kthi',\n  Tai_Tham: 'lana',\n  Lao: 'lao ',\n  Latin: 'latn',\n  Lepcha: 'lepc',\n  Limbu: 'limb',\n  Linear_A: 'lina',\n  Linear_B: 'linb',\n  Lisu: 'lisu',\n  Lycian: 'lyci',\n  Lydian: 'lydi',\n  Mahajani: 'mahj',\n  Mandaic: 'mand',\n  Manichaean: 'mani',\n  Mende_Kikakui: 'mend',\n  Meroitic_Cursive: 'merc',\n  Meroitic_Hieroglyphs: 'mero',\n  Malayalam: ['mlm2', 'mlym'],\n  Modi: 'modi',\n  Mongolian: 'mong',\n  Mro: 'mroo',\n  Meetei_Mayek: 'mtei',\n  Myanmar: ['mym2', 'mymr'],\n  Old_North_Arabian: 'narb',\n  Nabataean: 'nbat',\n  Nko: 'nko ',\n  Ogham: 'ogam',\n  Ol_Chiki: 'olck',\n  Old_Turkic: 'orkh',\n  Oriya: ['ory2', 'orya'],\n  Osmanya: 'osma',\n  Palmyrene: 'palm',\n  Pau_Cin_Hau: 'pauc',\n  Old_Permic: 'perm',\n  Phags_Pa: 'phag',\n  Inscriptional_Pahlavi: 'phli',\n  Psalter_Pahlavi: 'phlp',\n  Phoenician: 'phnx',\n  Miao: 'plrd',\n  Inscriptional_Parthian: 'prti',\n  Rejang: 'rjng',\n  Runic: 'runr',\n  Samaritan: 'samr',\n  Old_South_Arabian: 'sarb',\n  Saurashtra: 'saur',\n  Shavian: 'shaw',\n  Sharada: 'shrd',\n  Siddham: 'sidd',\n  Khudawadi: 'sind',\n  Sinhala: 'sinh',\n  Sora_Sompeng: 'sora',\n  Sundanese: 'sund',\n  Syloti_Nagri: 'sylo',\n  Syriac: 'syrc',\n  Tagbanwa: 'tagb',\n  Takri: 'takr',\n  Tai_Le: 'tale',\n  New_Tai_Lue: 'talu',\n  Tamil: ['tml2', 'taml'],\n  Tai_Viet: 'tavt',\n  Telugu: ['tel2', 'telu'],\n  Tifinagh: 'tfng',\n  Tagalog: 'tglg',\n  Thaana: 'thaa',\n  Thai: 'thai',\n  Tibetan: 'tibt',\n  Tirhuta: 'tirh',\n  Ugaritic: 'ugar',\n  Vai: 'vai ',\n  Warang_Citi: 'wara',\n  Old_Persian: 'xpeo',\n  Cuneiform: 'xsux',\n  Yi: 'yi  ',\n  Inherited: 'zinh',\n  Common: 'zyyy',\n  Unknown: 'zzzz'\n};\n\nconst OPENTYPE_SCRIPTS = {};\nfor (let script in UNICODE_SCRIPTS) {\n  let tag = UNICODE_SCRIPTS[script];\n  if (Array.isArray(tag)) {\n    for (let t of tag) {\n      OPENTYPE_SCRIPTS[t] = script;\n    }\n  } else {\n    OPENTYPE_SCRIPTS[tag] = script;\n  }\n}\n\nexport function fromUnicode(script) {\n  return UNICODE_SCRIPTS[script];\n}\n\nexport function fromOpenType(tag) {\n  return OPENTYPE_SCRIPTS[tag];\n}\n\nexport function forString(string) {\n  let len = string.length;\n  let idx = 0;\n  while (idx < len) {\n    let code = string.charCodeAt(idx++);\n\n    // Check if this is a high surrogate\n    if (0xd800 <= code && code <= 0xdbff && idx < len) {\n      let next = string.charCodeAt(idx);\n\n      // Check if this is a low surrogate\n      if (0xdc00 <= next && next <= 0xdfff) {\n        idx++;\n        code = ((code & 0x3FF) << 10) + (next & 0x3FF) + 0x10000;\n      }\n    }\n\n    let script = unicode.getScript(code);\n    if (script !== 'Common' && script !== 'Inherited' && script !== 'Unknown') {\n      return UNICODE_SCRIPTS[script];\n    }\n  }\n\n  return UNICODE_SCRIPTS.Unknown;\n}\n\nexport function forCodePoints(codePoints) {\n  for (let i = 0; i < codePoints.length; i++) {\n    let codePoint = codePoints[i];\n    let script = unicode.getScript(codePoint);\n    if (script !== 'Common' && script !== 'Inherited' && script !== 'Unknown') {\n      return UNICODE_SCRIPTS[script];\n    }\n  }\n\n  return UNICODE_SCRIPTS.Unknown;\n}\n\n// The scripts in this map are written from right to left\nconst RTL = {\n  arab: true,   // Arabic\n  hebr: true,   // Hebrew\n  syrc: true,   // Syriac\n  thaa: true,   // Thaana\n  cprt: true,   // Cypriot Syllabary\n  khar: true,   // Kharosthi\n  phnx: true,   // Phoenician\n  'nko ': true, // N'Ko\n  lydi: true,   // Lydian\n  avst: true,   // Avestan\n  armi: true,   // Imperial Aramaic\n  phli: true,   // Inscriptional Pahlavi\n  prti: true,   // Inscriptional Parthian\n  sarb: true,   // Old South Arabian\n  orkh: true,   // Old Turkic, Orkhon Runic\n  samr: true,   // Samaritan\n  mand: true,   // Mandaic, Mandaean\n  merc: true,   // Meroitic Cursive\n  mero: true,   // Meroitic Hieroglyphs\n\n  // Unicode 7.0 (not listed on http://www.microsoft.com/typography/otspec/scripttags.htm)\n  mani: true,   // Manichaean\n  mend: true,   // Mende Kikakui\n  nbat: true,   // Nabataean\n  narb: true,   // Old North Arabian\n  palm: true,   // Palmyrene\n  phlp: true    // Psalter Pahlavi\n};\n\nexport function direction(script) {\n  if (RTL[script]) {\n    return 'rtl';\n  }\n\n  return 'ltr';\n}\n","import BBox from '../glyph/BBox';\nimport * as Script from '../layout/Script';\n\n/**\n * Represents a run of Glyph and GlyphPosition objects.\n * Returned by the font layout method.\n */\nexport default class GlyphRun {\n  constructor(glyphs, features, script, language, direction) {\n    /**\n     * An array of Glyph objects in the run\n     * @type {Glyph[]}\n     */\n    this.glyphs = glyphs;\n\n    /**\n     * An array of GlyphPosition objects for each glyph in the run\n     * @type {GlyphPosition[]}\n     */\n    this.positions = null;\n\n    /**\n     * The script that was requested for shaping. This was either passed in or detected automatically.\n     * @type {string}\n     */\n    this.script = script;\n\n    /**\n     * The language requested for shaping, as passed in. If `null`, the default language for the\n     * script was used.\n     * @type {string}\n     */\n    this.language = language || null;\n\n    /**\n     * The direction requested for shaping, as passed in (either ltr or rtl).\n     * If `null`, the default direction of the script is used.\n     * @type {string}\n     */\n    this.direction = direction || Script.direction(script);\n\n    /**\n     * The features requested during shaping. This is a combination of user\n     * specified features and features chosen by the shaper.\n     * @type {object}\n     */\n    this.features = {};\n\n    // Convert features to an object\n    if (Array.isArray(features)) {\n      for (let tag of features) {\n        this.features[tag] = true;\n      }\n    } else if (typeof features === 'object') {\n      this.features = features;\n    }\n  }\n\n  /**\n   * The total advance width of the run.\n   * @type {number}\n   */\n  get advanceWidth() {\n    let width = 0;\n    for (let position of this.positions) {\n      width += position.xAdvance;\n    }\n\n    return width;\n  }\n\n /**\n  * The total advance height of the run.\n  * @type {number}\n  */\n  get advanceHeight() {\n    let height = 0;\n    for (let position of this.positions) {\n      height += position.yAdvance;\n    }\n\n    return height;\n  }\n\n /**\n  * The bounding box containing all glyphs in the run.\n  * @type {BBox}\n  */\n  get bbox() {\n    let bbox = new BBox;\n\n    let x = 0;\n    let y = 0;\n    for (let index = 0; index < this.glyphs.length; index++) {\n      let glyph = this.glyphs[index];\n      let p = this.positions[index];\n      let b = glyph.bbox;\n\n      bbox.addPoint(b.minX + x + p.xOffset, b.minY + y + p.yOffset);\n      bbox.addPoint(b.maxX + x + p.xOffset, b.maxY + y + p.yOffset);\n\n      x += p.xAdvance;\n      y += p.yAdvance;\n    }\n\n    return bbox;\n  }\n}\n","/**\n * Represents positioning information for a glyph in a GlyphRun.\n */\nexport default class GlyphPosition {\n  constructor(xAdvance = 0, yAdvance = 0, xOffset = 0, yOffset = 0) {\n    /**\n     * The amount to move the virtual pen in the X direction after rendering this glyph.\n     * @type {number}\n     */\n    this.xAdvance = xAdvance;\n\n    /**\n     * The amount to move the virtual pen in the Y direction after rendering this glyph.\n     * @type {number}\n     */\n    this.yAdvance = yAdvance;\n\n    /**\n     * The offset from the pen position in the X direction at which to render this glyph.\n     * @type {number}\n     */\n    this.xOffset = xOffset;\n\n    /**\n     * The offset from the pen position in the Y direction at which to render this glyph.\n     * @type {number}\n     */\n    this.yOffset = yOffset;\n  }\n}\n","// see https://developer.apple.com/fonts/TrueType-Reference-Manual/RM09/AppendixF.html\n// and /System/Library/Frameworks/CoreText.framework/Versions/A/Headers/SFNTLayoutTypes.h on a Mac\nconst features = {\n  allTypographicFeatures: {\n    code: 0,\n    exclusive: false,\n    allTypeFeatures: 0\n  },\n  ligatures: {\n    code: 1,\n    exclusive: false,\n    requiredLigatures: 0,\n    commonLigatures: 2,\n    rareLigatures: 4,\n    // logos: 6\n    rebusPictures: 8,\n    diphthongLigatures: 10,\n    squaredLigatures: 12,\n    abbrevSquaredLigatures: 14,\n    symbolLigatures: 16,\n    contextualLigatures: 18,\n    historicalLigatures: 20\n  },\n  cursiveConnection: {\n    code: 2,\n    exclusive: true,\n    unconnected: 0,\n    partiallyConnected: 1,\n    cursive: 2\n  },\n  letterCase: {\n    code: 3,\n    exclusive: true\n  },\n    // upperAndLowerCase: 0          # deprecated\n    // allCaps: 1                    # deprecated\n    // allLowerCase: 2               # deprecated\n    // smallCaps: 3                  # deprecated\n    // initialCaps: 4                # deprecated\n    // initialCapsAndSmallCaps: 5    # deprecated\n  verticalSubstitution: {\n    code: 4,\n    exclusive: false,\n    substituteVerticalForms: 0\n  },\n  linguisticRearrangement: {\n    code: 5,\n    exclusive: false,\n    linguisticRearrangement: 0\n  },\n  numberSpacing: {\n    code: 6,\n    exclusive: true,\n    monospacedNumbers: 0,\n    proportionalNumbers: 1,\n    thirdWidthNumbers: 2,\n    quarterWidthNumbers: 3\n  },\n  smartSwash: {\n    code: 8,\n    exclusive: false,\n    wordInitialSwashes: 0,\n    wordFinalSwashes: 2,\n    // lineInitialSwashes: 4\n    // lineFinalSwashes: 6\n    nonFinalSwashes: 8\n  },\n  diacritics: {\n    code: 9,\n    exclusive: true,\n    showDiacritics: 0,\n    hideDiacritics: 1,\n    decomposeDiacritics: 2\n  },\n  verticalPosition: {\n    code: 10,\n    exclusive: true,\n    normalPosition: 0,\n    superiors: 1,\n    inferiors: 2,\n    ordinals: 3,\n    scientificInferiors: 4\n  },\n  fractions: {\n    code: 11,\n    exclusive: true,\n    noFractions: 0,\n    verticalFractions: 1,\n    diagonalFractions: 2\n  },\n  overlappingCharacters: {\n    code: 13,\n    exclusive: false,\n    preventOverlap: 0\n  },\n  typographicExtras: {\n    code: 14,\n    exclusive: false,\n    // hyphensToEmDash: 0\n    // hyphenToEnDash: 2\n    slashedZero: 4\n  },\n    // formInterrobang: 6\n    // smartQuotes: 8\n    // periodsToEllipsis: 10\n  mathematicalExtras: {\n    code: 15,\n    exclusive: false,\n    // hyphenToMinus: 0\n    // asteristoMultiply: 2\n    // slashToDivide: 4\n    // inequalityLigatures: 6\n    // exponents: 8\n    mathematicalGreek: 10\n  },\n  ornamentSets: {\n    code: 16,\n    exclusive: true,\n    noOrnaments: 0,\n    dingbats: 1,\n    piCharacters: 2,\n    fleurons: 3,\n    decorativeBorders: 4,\n    internationalSymbols: 5,\n    mathSymbols: 6\n  },\n  characterAlternatives: {\n    code: 17,\n    exclusive: true,\n    noAlternates: 0\n  },\n    // user defined options\n  designComplexity: {\n    code: 18,\n    exclusive: true,\n    designLevel1: 0,\n    designLevel2: 1,\n    designLevel3: 2,\n    designLevel4: 3,\n    designLevel5: 4\n  },\n  styleOptions: {\n    code: 19,\n    exclusive: true,\n    noStyleOptions: 0,\n    displayText: 1,\n    engravedText: 2,\n    illuminatedCaps: 3,\n    titlingCaps: 4,\n    tallCaps: 5\n  },\n  characterShape: {\n    code: 20,\n    exclusive: true,\n    traditionalCharacters: 0,\n    simplifiedCharacters: 1,\n    JIS1978Characters: 2,\n    JIS1983Characters: 3,\n    JIS1990Characters: 4,\n    traditionalAltOne: 5,\n    traditionalAltTwo: 6,\n    traditionalAltThree: 7,\n    traditionalAltFour: 8,\n    traditionalAltFive: 9,\n    expertCharacters: 10,\n    JIS2004Characters: 11,\n    hojoCharacters: 12,\n    NLCCharacters: 13,\n    traditionalNamesCharacters: 14\n  },\n  numberCase: {\n    code: 21,\n    exclusive: true,\n    lowerCaseNumbers: 0,\n    upperCaseNumbers: 1\n  },\n  textSpacing: {\n    code: 22,\n    exclusive: true,\n    proportionalText: 0,\n    monospacedText: 1,\n    halfWidthText: 2,\n    thirdWidthText: 3,\n    quarterWidthText: 4,\n    altProportionalText: 5,\n    altHalfWidthText: 6\n  },\n  transliteration: {\n    code: 23,\n    exclusive: true,\n    noTransliteration: 0\n  },\n    // hanjaToHangul: 1\n    // hiraganaToKatakana: 2\n    // katakanaToHiragana: 3\n    // kanaToRomanization: 4\n    // romanizationToHiragana: 5\n    // romanizationToKatakana: 6\n    // hanjaToHangulAltOne: 7\n    // hanjaToHangulAltTwo: 8\n    // hanjaToHangulAltThree: 9\n  annotation: {\n    code: 24,\n    exclusive: true,\n    noAnnotation: 0,\n    boxAnnotation: 1,\n    roundedBoxAnnotation: 2,\n    circleAnnotation: 3,\n    invertedCircleAnnotation: 4,\n    parenthesisAnnotation: 5,\n    periodAnnotation: 6,\n    romanNumeralAnnotation: 7,\n    diamondAnnotation: 8,\n    invertedBoxAnnotation: 9,\n    invertedRoundedBoxAnnotation: 10\n  },\n  kanaSpacing: {\n    code: 25,\n    exclusive: true,\n    fullWidthKana: 0,\n    proportionalKana: 1\n  },\n  ideographicSpacing: {\n    code: 26,\n    exclusive: true,\n    fullWidthIdeographs: 0,\n    proportionalIdeographs: 1,\n    halfWidthIdeographs: 2\n  },\n  unicodeDecomposition: {\n    code: 27,\n    exclusive: false,\n    canonicalComposition: 0,\n    compatibilityComposition: 2,\n    transcodingComposition: 4\n  },\n  rubyKana: {\n    code: 28,\n    exclusive: false,\n    // noRubyKana: 0     # deprecated - use rubyKanaOff instead\n    // rubyKana: 1     # deprecated - use rubyKanaOn instead\n    rubyKana: 2\n  },\n  CJKSymbolAlternatives: {\n    code: 29,\n    exclusive: true,\n    noCJKSymbolAlternatives: 0,\n    CJKSymbolAltOne: 1,\n    CJKSymbolAltTwo: 2,\n    CJKSymbolAltThree: 3,\n    CJKSymbolAltFour: 4,\n    CJKSymbolAltFive: 5\n  },\n  ideographicAlternatives: {\n    code: 30,\n    exclusive: true,\n    noIdeographicAlternatives: 0,\n    ideographicAltOne: 1,\n    ideographicAltTwo: 2,\n    ideographicAltThree: 3,\n    ideographicAltFour: 4,\n    ideographicAltFive: 5\n  },\n  CJKVerticalRomanPlacement: {\n    code: 31,\n    exclusive: true,\n    CJKVerticalRomanCentered: 0,\n    CJKVerticalRomanHBaseline: 1\n  },\n  italicCJKRoman: {\n    code: 32,\n    exclusive: false,\n    // noCJKItalicRoman: 0     # deprecated - use CJKItalicRomanOff instead\n    // CJKItalicRoman: 1     # deprecated - use CJKItalicRomanOn instead\n    CJKItalicRoman: 2\n  },\n  caseSensitiveLayout: {\n    code: 33,\n    exclusive: false,\n    caseSensitiveLayout: 0,\n    caseSensitiveSpacing: 2\n  },\n  alternateKana: {\n    code: 34,\n    exclusive: false,\n    alternateHorizKana: 0,\n    alternateVertKana: 2\n  },\n  stylisticAlternatives: {\n    code: 35,\n    exclusive: false,\n    noStylisticAlternates: 0,\n    stylisticAltOne: 2,\n    stylisticAltTwo: 4,\n    stylisticAltThree: 6,\n    stylisticAltFour: 8,\n    stylisticAltFive: 10,\n    stylisticAltSix: 12,\n    stylisticAltSeven: 14,\n    stylisticAltEight: 16,\n    stylisticAltNine: 18,\n    stylisticAltTen: 20,\n    stylisticAltEleven: 22,\n    stylisticAltTwelve: 24,\n    stylisticAltThirteen: 26,\n    stylisticAltFourteen: 28,\n    stylisticAltFifteen: 30,\n    stylisticAltSixteen: 32,\n    stylisticAltSeventeen: 34,\n    stylisticAltEighteen: 36,\n    stylisticAltNineteen: 38,\n    stylisticAltTwenty: 40\n  },\n  contextualAlternates: {\n    code: 36,\n    exclusive: false,\n    contextualAlternates: 0,\n    swashAlternates: 2,\n    contextualSwashAlternates: 4\n  },\n  lowerCase: {\n    code: 37,\n    exclusive: true,\n    defaultLowerCase: 0,\n    lowerCaseSmallCaps: 1,\n    lowerCasePetiteCaps: 2\n  },\n  upperCase: {\n    code: 38,\n    exclusive: true,\n    defaultUpperCase: 0,\n    upperCaseSmallCaps: 1,\n    upperCasePetiteCaps: 2\n  },\n  languageTag: { // indices into ltag table\n    code: 39,\n    exclusive: true\n  },\n  CJKRomanSpacing: {\n    code: 103,\n    exclusive: true,\n    halfWidthCJKRoman: 0,\n    proportionalCJKRoman: 1,\n    defaultCJKRoman: 2,\n    fullWidthCJKRoman: 3\n  }\n};\n\nconst feature = (name, selector) => [features[name].code, features[name][selector]];\n\nconst OTMapping = {\n  rlig: feature('ligatures', 'requiredLigatures'),\n  clig: feature('ligatures', 'contextualLigatures'),\n  dlig: feature('ligatures', 'rareLigatures'),\n  hlig: feature('ligatures', 'historicalLigatures'),\n  liga: feature('ligatures', 'commonLigatures'),\n  hist: feature('ligatures', 'historicalLigatures'), // ??\n\n  smcp: feature('lowerCase', 'lowerCaseSmallCaps'),\n  pcap: feature('lowerCase', 'lowerCasePetiteCaps'),\n\n  frac: feature('fractions', 'diagonalFractions'),\n  dnom: feature('fractions', 'diagonalFractions'), // ??\n  numr: feature('fractions', 'diagonalFractions'), // ??\n  afrc: feature('fractions', 'verticalFractions'),\n  // aalt\n  // abvf, abvm, abvs, akhn, blwf, blwm, blws, cfar, cjct, cpsp, falt, isol, jalt, ljmo, mset?\n  // ltra, ltrm, nukt, pref, pres, pstf, psts, rand, rkrf, rphf, rtla, rtlm, size, tjmo, tnum?\n  // unic, vatu, vhal, vjmo, vpal, vrt2\n  // dist -> trak table?\n  // kern, vkrn -> kern table\n  // lfbd + opbd + rtbd -> opbd table?\n  // mark, mkmk -> acnt table?\n  // locl -> languageTag + ltag table\n\n  case: feature('caseSensitiveLayout', 'caseSensitiveLayout'), // also caseSensitiveSpacing\n  ccmp: feature('unicodeDecomposition', 'canonicalComposition'), // compatibilityComposition?\n  cpct: feature('CJKVerticalRomanPlacement', 'CJKVerticalRomanCentered'), // guess..., probably not given below\n  valt: feature('CJKVerticalRomanPlacement', 'CJKVerticalRomanCentered'),\n  swsh: feature('contextualAlternates', 'swashAlternates'),\n  cswh: feature('contextualAlternates', 'contextualSwashAlternates'),\n  curs: feature('cursiveConnection', 'cursive'), // ??\n  c2pc: feature('upperCase', 'upperCasePetiteCaps'),\n  c2sc: feature('upperCase', 'upperCaseSmallCaps'),\n\n  init: feature('smartSwash', 'wordInitialSwashes'), // ??\n  fin2: feature('smartSwash', 'wordFinalSwashes'), // ??\n  medi: feature('smartSwash', 'nonFinalSwashes'), // ??\n  med2: feature('smartSwash', 'nonFinalSwashes'), // ??\n  fin3: feature('smartSwash', 'wordFinalSwashes'), // ??\n  fina: feature('smartSwash', 'wordFinalSwashes'), // ??\n\n  pkna: feature('kanaSpacing', 'proportionalKana'),\n  half: feature('textSpacing', 'halfWidthText'), // also HalfWidthCJKRoman, HalfWidthIdeographs?\n  halt: feature('textSpacing', 'altHalfWidthText'),\n\n  hkna: feature('alternateKana', 'alternateHorizKana'),\n  vkna: feature('alternateKana', 'alternateVertKana'),\n  // hngl: feature 'transliteration', 'hanjaToHangulSelector' # deprecated\n\n  ital: feature('italicCJKRoman', 'CJKItalicRoman'),\n  lnum: feature('numberCase', 'upperCaseNumbers'),\n  onum: feature('numberCase', 'lowerCaseNumbers'),\n  mgrk: feature('mathematicalExtras', 'mathematicalGreek'),\n\n  // nalt: not enough info. what type of annotation?\n  // ornm: ditto, which ornament style?\n\n  calt: feature('contextualAlternates', 'contextualAlternates'), // or more?\n  vrt2: feature('verticalSubstitution', 'substituteVerticalForms'), // oh... below?\n  vert: feature('verticalSubstitution', 'substituteVerticalForms'),\n  tnum: feature('numberSpacing', 'monospacedNumbers'),\n  pnum: feature('numberSpacing', 'proportionalNumbers'),\n  sups: feature('verticalPosition', 'superiors'),\n  subs: feature('verticalPosition', 'inferiors'),\n  ordn: feature('verticalPosition', 'ordinals'),\n  pwid: feature('textSpacing', 'proportionalText'),\n  hwid: feature('textSpacing', 'halfWidthText'),\n  qwid: feature('textSpacing', 'quarterWidthText'), // also QuarterWidthNumbers?\n  twid: feature('textSpacing', 'thirdWidthText'), // also ThirdWidthNumbers?\n  fwid: feature('textSpacing', 'proportionalText'), //??\n  palt: feature('textSpacing', 'altProportionalText'),\n  trad: feature('characterShape', 'traditionalCharacters'),\n  smpl: feature('characterShape', 'simplifiedCharacters'),\n  jp78: feature('characterShape', 'JIS1978Characters'),\n  jp83: feature('characterShape', 'JIS1983Characters'),\n  jp90: feature('characterShape', 'JIS1990Characters'),\n  jp04: feature('characterShape', 'JIS2004Characters'),\n  expt: feature('characterShape', 'expertCharacters'),\n  hojo: feature('characterShape', 'hojoCharacters'),\n  nlck: feature('characterShape', 'NLCCharacters'),\n  tnam: feature('characterShape', 'traditionalNamesCharacters'),\n  ruby: feature('rubyKana', 'rubyKana'),\n  titl: feature('styleOptions', 'titlingCaps'),\n  zero: feature('typographicExtras', 'slashedZero'),\n\n  ss01: feature('stylisticAlternatives', 'stylisticAltOne'),\n  ss02: feature('stylisticAlternatives', 'stylisticAltTwo'),\n  ss03: feature('stylisticAlternatives', 'stylisticAltThree'),\n  ss04: feature('stylisticAlternatives', 'stylisticAltFour'),\n  ss05: feature('stylisticAlternatives', 'stylisticAltFive'),\n  ss06: feature('stylisticAlternatives', 'stylisticAltSix'),\n  ss07: feature('stylisticAlternatives', 'stylisticAltSeven'),\n  ss08: feature('stylisticAlternatives', 'stylisticAltEight'),\n  ss09: feature('stylisticAlternatives', 'stylisticAltNine'),\n  ss10: feature('stylisticAlternatives', 'stylisticAltTen'),\n  ss11: feature('stylisticAlternatives', 'stylisticAltEleven'),\n  ss12: feature('stylisticAlternatives', 'stylisticAltTwelve'),\n  ss13: feature('stylisticAlternatives', 'stylisticAltThirteen'),\n  ss14: feature('stylisticAlternatives', 'stylisticAltFourteen'),\n  ss15: feature('stylisticAlternatives', 'stylisticAltFifteen'),\n  ss16: feature('stylisticAlternatives', 'stylisticAltSixteen'),\n  ss17: feature('stylisticAlternatives', 'stylisticAltSeventeen'),\n  ss18: feature('stylisticAlternatives', 'stylisticAltEighteen'),\n  ss19: feature('stylisticAlternatives', 'stylisticAltNineteen'),\n  ss20: feature('stylisticAlternatives', 'stylisticAltTwenty')\n};\n\n  // salt: feature 'stylisticAlternatives', 'stylisticAltOne' # hmm, which one to choose\n\n// Add cv01-cv99 features\nfor (let i = 1; i <= 99; i++) {\n  OTMapping[`cv${`00${i}`.slice(-2)}`] = [features.characterAlternatives.code, i];\n}\n\n// create inverse mapping\nlet AATMapping = {};\nfor (let ot in OTMapping) {\n  let aat = OTMapping[ot];\n  if (AATMapping[aat[0]] == null) {\n    AATMapping[aat[0]] = {};\n  }\n\n  AATMapping[aat[0]][aat[1]] = ot;\n}\n\n// Maps an array of OpenType features to AAT features\n// in the form of {featureType:{featureSetting:true}}\nexport function mapOTToAAT(features) {\n  let res = {};\n  for (let k in features) {\n    let r;\n    if (r = OTMapping[k]) {\n      if (res[r[0]] == null) {\n        res[r[0]] = {};\n      }\n\n      res[r[0]][r[1]] = features[k];\n    }\n  }\n\n  return res;\n}\n\n// Maps strings in a [featureType, featureSetting]\n// to their equivalent number codes\nfunction mapFeatureStrings(f) {\n  let [type, setting] = f;\n  if (isNaN(type)) {\n    var typeCode = features[type] && features[type].code;\n  } else {\n    var typeCode = type;\n  }\n\n  if (isNaN(setting)) {\n    var settingCode = features[type] && features[type][setting];\n  } else {\n    var settingCode = setting;\n  }\n\n  return [typeCode, settingCode];\n}\n\n// Maps AAT features to an array of OpenType features\n// Supports both arrays in the form of [[featureType, featureSetting]]\n// and objects in the form of {featureType:{featureSetting:true}}\n// featureTypes and featureSettings can be either strings or number codes\nexport function mapAATToOT(features) {\n  let res = {};\n  if (Array.isArray(features)) {\n    for (let k = 0; k < features.length; k++) {\n      let r;\n      let f = mapFeatureStrings(features[k]);\n      if (r = AATMapping[f[0]] && AATMapping[f[0]][f[1]]) {\n        res[r] = true;\n      }\n    }\n\n  } else if (typeof features === 'object') {\n    for (let type in features) {\n      let feature = features[type];\n      for (let setting in feature) {\n        let r;\n        let f = mapFeatureStrings([type, setting]);\n        if (feature[setting] && (r = AATMapping[f[0]] && AATMapping[f[0]][f[1]])) {\n          res[r] = true;\n        }\n      }\n    }\n  }\n\n  return Object.keys(res);\n}\n","import {cache} from '../decorators';\nimport {range} from '../utils';\n\nexport default class AATLookupTable {\n  constructor(table) {\n    this.table = table;\n  }\n\n  lookup(glyph) {\n    switch (this.table.version) {\n      case 0: // simple array format\n        return this.table.values.getItem(glyph);\n\n      case 2: // segment format\n      case 4: {\n        let min = 0;\n        let max = this.table.binarySearchHeader.nUnits - 1;\n\n        while (min <= max) {\n          var mid = (min + max) >> 1;\n          var seg = this.table.segments[mid];\n\n          // special end of search value\n          if (seg.firstGlyph === 0xffff) {\n            return null;\n          }\n\n          if (glyph < seg.firstGlyph) {\n            max = mid - 1;\n          } else if (glyph > seg.lastGlyph) {\n            min = mid + 1;\n          } else {\n            if (this.table.version === 2) {\n              return seg.value;\n            } else {\n              return seg.values[glyph - seg.firstGlyph];\n            }\n          }\n        }\n\n        return null;\n      }\n\n      case 6: { // lookup single\n        let min = 0;\n        let max = this.table.binarySearchHeader.nUnits - 1;\n\n        while (min <= max) {\n          var mid = (min + max) >> 1;\n          var seg = this.table.segments[mid];\n\n          // special end of search value\n          if (seg.glyph === 0xffff) {\n            return null;\n          }\n\n          if (glyph < seg.glyph) {\n            max = mid - 1;\n          } else if (glyph > seg.glyph) {\n            min = mid + 1;\n          } else {\n            return seg.value;\n          }\n        }\n\n        return null;\n      }\n\n      case 8: // lookup trimmed\n        return this.table.values[glyph - this.table.firstGlyph];\n\n      default:\n        throw new Error(`Unknown lookup table format: ${this.table.version}`);\n    }\n  }\n\n  @cache\n  glyphsForValue(classValue) {\n    let res = [];\n\n    switch (this.table.version) {\n      case 2: // segment format\n      case 4: {\n        for (let segment of this.table.segments) {\n          if ((this.table.version === 2 && segment.value === classValue)) {\n            res.push(...range(segment.firstGlyph, segment.lastGlyph + 1));\n          } else {\n            for (let index = 0; index < segment.values.length; index++) {\n              if (segment.values[index] === classValue) {\n                res.push(segment.firstGlyph + index);\n              }\n            }\n          }\n        }\n\n        break;\n      }\n\n      case 6: { // lookup single\n        for (let segment of this.table.segments) {\n          if (segment.value === classValue) {\n            res.push(segment.glyph);\n          }\n        }\n\n        break;\n      }\n\n      case 8: { // lookup trimmed\n        for (let i = 0; i < this.table.values.length; i++) {\n          if (this.table.values[i] === classValue) {\n            res.push(this.table.firstGlyph + i);\n          }\n        }\n\n        break;\n      }\n\n      default:\n        throw new Error(`Unknown lookup table format: ${this.table.version}`);\n    }\n\n    return res;\n  }\n}\n","import AATLookupTable from './AATLookupTable';\n\nconst START_OF_TEXT_STATE = 0;\nconst START_OF_LINE_STATE = 1;\n\nconst END_OF_TEXT_CLASS = 0;\nconst OUT_OF_BOUNDS_CLASS = 1;\nconst DELETED_GLYPH_CLASS = 2;\nconst END_OF_LINE_CLASS = 3;\n\nconst DONT_ADVANCE = 0x4000;\n\nexport default class AATStateMachine {\n  constructor(stateTable) {\n    this.stateTable = stateTable;\n    this.lookupTable = new AATLookupTable(stateTable.classTable);\n  }\n\n  process(glyphs, reverse, processEntry) {\n    let currentState = START_OF_TEXT_STATE; // START_OF_LINE_STATE is used for kashida glyph insertions sometimes I think?\n    let index = reverse ? glyphs.length - 1 : 0;\n    let dir = reverse ? -1 : 1;\n\n    while ((dir === 1 && index <= glyphs.length) || (dir === -1 && index >= -1)) {\n      let glyph = null;\n      let classCode = OUT_OF_BOUNDS_CLASS;\n      let shouldAdvance = true;\n\n      if (index === glyphs.length || index === -1) {\n        classCode = END_OF_TEXT_CLASS;\n      } else {\n        glyph = glyphs[index];\n        if (glyph.id === 0xffff) { // deleted glyph\n          classCode = DELETED_GLYPH_CLASS;\n        } else {\n          classCode = this.lookupTable.lookup(glyph.id);\n          if (classCode == null) {\n            classCode = OUT_OF_BOUNDS_CLASS;\n          }\n        }\n      }\n\n      let row = this.stateTable.stateArray.getItem(currentState);\n      let entryIndex = row[classCode];\n      let entry = this.stateTable.entryTable.getItem(entryIndex);\n\n      if (classCode !== END_OF_TEXT_CLASS && classCode !==  DELETED_GLYPH_CLASS) {\n        processEntry(glyph, entry, index);\n        shouldAdvance = !(entry.flags & DONT_ADVANCE);\n      }\n\n      currentState = entry.newState;\n      if (shouldAdvance) {\n        index += dir;\n      }\n    }\n\n    return glyphs;\n  }\n\n  /**\n   * Performs a depth-first traversal of the glyph strings\n   * represented by the state machine.\n   */\n  traverse(opts, state = 0, visited = new Set) {\n    if (visited.has(state)) {\n      return;\n    }\n\n    visited.add(state);\n\n    let {nClasses, stateArray, entryTable} = this.stateTable;\n    let row = stateArray.getItem(state);\n\n    // Skip predefined classes\n    for (let classCode = 4; classCode < nClasses; classCode++) {\n      let entryIndex = row[classCode];\n      let entry = entryTable.getItem(entryIndex);\n\n      // Try all glyphs in the class\n      for (let glyph of this.lookupTable.glyphsForValue(classCode)) {\n        if (opts.enter) {\n          opts.enter(glyph, entry);\n        }\n\n        if (entry.newState !== 0) {\n          this.traverse(opts, entry.newState, visited);\n        }\n\n        if (opts.exit) {\n          opts.exit(glyph, entry);\n        }\n      }\n    }\n  }\n}\n","import AATStateMachine from './AATStateMachine';\nimport AATLookupTable from './AATLookupTable';\nimport {cache} from '../decorators';\n\n// indic replacement flags\nconst MARK_FIRST = 0x8000;\nconst MARK_LAST  = 0x2000;\nconst VERB       = 0x000F;\n\n// contextual substitution and glyph insertion flag\nconst SET_MARK = 0x8000;\n\n// ligature entry flags\nconst SET_COMPONENT  = 0x8000;\nconst PERFORM_ACTION = 0x2000;\n\n// ligature action masks\nconst LAST_MASK   = 0x80000000;\nconst STORE_MASK  = 0x40000000;\nconst OFFSET_MASK = 0x3FFFFFFF;\n\nconst VERTICAL_ONLY           = 0x800000;\nconst REVERSE_DIRECTION       = 0x400000;\nconst HORIZONTAL_AND_VERTICAL = 0x200000;\n\n// glyph insertion flags\nconst CURRENT_IS_KASHIDA_LIKE = 0x2000;\nconst MARKED_IS_KASHIDA_LIKE  = 0x1000;\nconst CURRENT_INSERT_BEFORE   = 0x0800;\nconst MARKED_INSERT_BEFORE    = 0x0400;\nconst CURRENT_INSERT_COUNT    = 0x03E0;\nconst MARKED_INSERT_COUNT     = 0x001F;\n\nexport default class AATMorxProcessor {\n  constructor(font) {\n    this.processIndicRearragement = this.processIndicRearragement.bind(this);\n    this.processContextualSubstitution = this.processContextualSubstitution.bind(this);\n    this.processLigature = this.processLigature.bind(this);\n    this.processNoncontextualSubstitutions = this.processNoncontextualSubstitutions.bind(this);\n    this.processGlyphInsertion = this.processGlyphInsertion.bind(this);\n    this.font = font;\n    this.morx = font.morx;\n    this.inputCache = null;\n  }\n\n  // Processes an array of glyphs and applies the specified features\n  // Features should be in the form of {featureType:{featureSetting:boolean}}\n  process(glyphs, features = {}) {\n    for (let chain of this.morx.chains) {\n      let flags = chain.defaultFlags;\n\n      // enable/disable the requested features\n      for (let feature of chain.features) {\n        let f;\n        if (f = features[feature.featureType]) {\n          if (f[feature.featureSetting]) {\n            flags &= feature.disableFlags;\n            flags |= feature.enableFlags;\n          } else if (f[feature.featureSetting] === false) {\n            flags |= ~feature.disableFlags;\n            flags &= ~feature.enableFlags;\n          }\n        }\n      }\n\n      for (let subtable of chain.subtables) {\n        if (subtable.subFeatureFlags & flags) {\n          this.processSubtable(subtable, glyphs);\n        }\n      }\n    }\n\n    // remove deleted glyphs\n    let index = glyphs.length - 1;\n    while (index >= 0) {\n      if (glyphs[index].id === 0xffff) {\n        glyphs.splice(index, 1);\n      }\n\n      index--;\n    }\n\n    return glyphs;\n  }\n\n  processSubtable(subtable, glyphs) {\n    this.subtable = subtable;\n    this.glyphs = glyphs;\n    if (this.subtable.type === 4) {\n      this.processNoncontextualSubstitutions(this.subtable, this.glyphs);\n      return;\n    }\n\n    this.ligatureStack = [];\n    this.markedGlyph = null;\n    this.firstGlyph = null;\n    this.lastGlyph = null;\n    this.markedIndex = null;\n\n    let stateMachine = this.getStateMachine(subtable);\n    let process = this.getProcessor();\n\n    let reverse = !!(this.subtable.coverage & REVERSE_DIRECTION);\n    return stateMachine.process(this.glyphs, reverse, process);\n  }\n\n  @cache\n  getStateMachine(subtable) {\n    return new AATStateMachine(subtable.table.stateTable);\n  }\n\n  getProcessor() {\n    switch (this.subtable.type) {\n      case 0:\n        return this.processIndicRearragement;\n      case 1:\n        return this.processContextualSubstitution;\n      case 2:\n        return this.processLigature;\n      case 4:\n        return this.processNoncontextualSubstitutions;\n      case 5:\n        return this.processGlyphInsertion;\n      default:\n        throw new Error(`Invalid morx subtable type: ${this.subtable.type}`);\n    }\n  }\n\n  processIndicRearragement(glyph, entry, index) {\n    if (entry.flags & MARK_FIRST) {\n      this.firstGlyph = index;\n    }\n\n    if (entry.flags & MARK_LAST) {\n      this.lastGlyph = index;\n    }\n\n    reorderGlyphs(this.glyphs, entry.flags & VERB, this.firstGlyph, this.lastGlyph);\n  }\n\n  processContextualSubstitution(glyph, entry, index) {\n    let subsitutions = this.subtable.table.substitutionTable.items;\n    if (entry.markIndex !== 0xffff) {\n      let lookup = subsitutions.getItem(entry.markIndex);\n      let lookupTable = new AATLookupTable(lookup);\n      glyph = this.glyphs[this.markedGlyph];\n      var gid = lookupTable.lookup(glyph.id);\n      if (gid) {\n        this.glyphs[this.markedGlyph] = this.font.getGlyph(gid, glyph.codePoints);\n      }\n    }\n\n    if (entry.currentIndex !== 0xffff) {\n      let lookup = subsitutions.getItem(entry.currentIndex);\n      let lookupTable = new AATLookupTable(lookup);\n      glyph = this.glyphs[index];\n      var gid = lookupTable.lookup(glyph.id);\n      if (gid) {\n        this.glyphs[index] = this.font.getGlyph(gid, glyph.codePoints);\n      }\n    }\n\n    if (entry.flags & SET_MARK) {\n      this.markedGlyph = index;\n    }\n  }\n\n  processLigature(glyph, entry, index) {\n    if (entry.flags & SET_COMPONENT) {\n      this.ligatureStack.push(index);\n    }\n\n    if (entry.flags & PERFORM_ACTION) {\n      let actions = this.subtable.table.ligatureActions;\n      let components = this.subtable.table.components;\n      let ligatureList = this.subtable.table.ligatureList;\n\n      let actionIndex = entry.action;\n      let last = false;\n      let ligatureIndex = 0;\n      let codePoints = [];\n      let ligatureGlyphs = [];\n\n      while (!last) {\n        let componentGlyph = this.ligatureStack.pop();\n        codePoints.unshift(...this.glyphs[componentGlyph].codePoints);\n\n        let action = actions.getItem(actionIndex++);\n        last = !!(action & LAST_MASK);\n        let store = !!(action & STORE_MASK);\n        let offset = (action & OFFSET_MASK) << 2 >> 2; // sign extend 30 to 32 bits\n        offset += this.glyphs[componentGlyph].id;\n\n        let component = components.getItem(offset);\n        ligatureIndex += component;\n\n        if (last || store) {\n          let ligatureEntry = ligatureList.getItem(ligatureIndex);\n          this.glyphs[componentGlyph] = this.font.getGlyph(ligatureEntry, codePoints);\n          ligatureGlyphs.push(componentGlyph);\n          ligatureIndex = 0;\n          codePoints = [];\n        } else {\n          this.glyphs[componentGlyph] = this.font.getGlyph(0xffff);\n        }\n      }\n\n      // Put ligature glyph indexes back on the stack\n      this.ligatureStack.push(...ligatureGlyphs);\n    }\n  }\n\n  processNoncontextualSubstitutions(subtable, glyphs, index) {\n    let lookupTable = new AATLookupTable(subtable.table.lookupTable);\n\n    for (index = 0; index < glyphs.length; index++) {\n      let glyph = glyphs[index];\n      if (glyph.id !== 0xffff) {\n        let gid = lookupTable.lookup(glyph.id);\n        if (gid) { // 0 means do nothing\n          glyphs[index] = this.font.getGlyph(gid, glyph.codePoints);\n        }\n      }\n    }\n  }\n\n  _insertGlyphs(glyphIndex, insertionActionIndex, count, isBefore) {\n    let insertions = [];\n    while (count--) {\n      let gid = this.subtable.table.insertionActions.getItem(insertionActionIndex++);\n      insertions.push(this.font.getGlyph(gid));\n    }\n\n    if (!isBefore) {\n      glyphIndex++;\n    }\n\n    this.glyphs.splice(glyphIndex, 0, ...insertions);\n  }\n\n  processGlyphInsertion(glyph, entry, index) {\n    if (entry.flags & SET_MARK) {\n      this.markedIndex = index;\n    }\n\n    if (entry.markedInsertIndex !== 0xffff) {\n      let count = (entry.flags & MARKED_INSERT_COUNT) >>> 5;\n      let isBefore = !!(entry.flags & MARKED_INSERT_BEFORE);\n      this._insertGlyphs(this.markedIndex, entry.markedInsertIndex, count, isBefore);\n    }\n\n    if (entry.currentInsertIndex !== 0xffff) {\n      let count = (entry.flags & CURRENT_INSERT_COUNT) >>> 5;\n      let isBefore = !!(entry.flags & CURRENT_INSERT_BEFORE);\n      this._insertGlyphs(index, entry.currentInsertIndex, count, isBefore);\n    }\n  }\n\n  getSupportedFeatures() {\n    let features = [];\n    for (let chain of this.morx.chains) {\n      for (let feature of chain.features) {\n        features.push([feature.featureType, feature.featureSetting]);\n      }\n    }\n\n    return features;\n  }\n\n  generateInputs(gid) {\n    if (!this.inputCache) {\n      this.generateInputCache();\n    }\n\n    return this.inputCache[gid] || [];\n  }\n\n  generateInputCache() {\n    this.inputCache = {};\n\n    for (let chain of this.morx.chains) {\n      let flags = chain.defaultFlags;\n\n      for (let subtable of chain.subtables) {\n        if (subtable.subFeatureFlags & flags) {\n          this.generateInputsForSubtable(subtable);\n        }\n      }\n    }\n  }\n\n  generateInputsForSubtable(subtable) {\n    // Currently, only supporting ligature subtables.\n    if (subtable.type !== 2) {\n      return;\n    }\n\n    let reverse = !!(subtable.coverage & REVERSE_DIRECTION);\n    if (reverse) {\n      throw new Error('Reverse subtable, not supported.');\n    }\n\n    this.subtable = subtable;\n    this.ligatureStack = [];\n\n    let stateMachine = this.getStateMachine(subtable);\n    let process = this.getProcessor();\n\n    let input = [];\n    let stack = [];\n    this.glyphs = [];\n\n    stateMachine.traverse({\n      enter: (glyph, entry) => {\n        let glyphs = this.glyphs;\n        stack.push({\n          glyphs: glyphs.slice(),\n          ligatureStack: this.ligatureStack.slice()\n        });\n\n        // Add glyph to input and glyphs to process.\n        let g = this.font.getGlyph(glyph);\n        input.push(g);\n        glyphs.push(input[input.length - 1]);\n\n        // Process ligature substitution\n        process(glyphs[glyphs.length - 1], entry, glyphs.length - 1);\n\n        // Add input to result if only one matching (non-deleted) glyph remains.\n        let count = 0;\n        let found = 0;\n        for (let i = 0; i < glyphs.length && count <= 1; i++) {\n          if (glyphs[i].id !== 0xffff) {\n            count++;\n            found = glyphs[i].id;\n          }\n        }\n\n        if (count === 1) {\n          let result = input.map(g => g.id);\n          let cache = this.inputCache[found];\n          if (cache) {\n            cache.push(result);\n          } else {\n            this.inputCache[found] = [result];\n          }\n        }\n      },\n\n      exit: () => {\n        ({glyphs: this.glyphs, ligatureStack: this.ligatureStack} = stack.pop());\n        input.pop();\n      }\n    });\n  }\n}\n\n// swaps the glyphs in rangeA with those in rangeB\n// reverse the glyphs inside those ranges if specified\n// ranges are in [offset, length] format\nfunction swap(glyphs, rangeA, rangeB, reverseA = false, reverseB = false) {\n  let end = glyphs.splice(rangeB[0] - (rangeB[1] - 1), rangeB[1]);\n  if (reverseB) {\n    end.reverse();\n  }\n\n  let start = glyphs.splice(rangeA[0], rangeA[1], ...end);\n  if (reverseA) {\n    start.reverse();\n  }\n\n  glyphs.splice(rangeB[0] - (rangeA[1] - 1), 0, ...start);\n  return glyphs;\n}\n\nfunction reorderGlyphs(glyphs, verb, firstGlyph, lastGlyph) {\n  let length = lastGlyph - firstGlyph + 1;\n  switch (verb) {\n    case 0: // no change\n      return glyphs;\n\n    case 1: // Ax => xA\n      return swap(glyphs, [firstGlyph, 1], [lastGlyph, 0]);\n\n    case 2: // xD => Dx\n      return swap(glyphs, [firstGlyph, 0], [lastGlyph, 1]);\n\n    case 3: // AxD => DxA\n      return swap(glyphs, [firstGlyph, 1], [lastGlyph, 1]);\n\n    case 4: // ABx => xAB\n      return swap(glyphs, [firstGlyph, 2], [lastGlyph, 0]);\n\n    case 5: // ABx => xBA\n      return swap(glyphs, [firstGlyph, 2], [lastGlyph, 0], true, false);\n\n    case 6: // xCD => CDx\n      return swap(glyphs, [firstGlyph, 0], [lastGlyph, 2]);\n\n    case 7: // xCD => DCx\n      return swap(glyphs, [firstGlyph, 0], [lastGlyph, 2], false, true);\n\n    case 8: // AxCD => CDxA\n      return swap(glyphs, [firstGlyph, 1], [lastGlyph, 2]);\n\n    case 9: // AxCD => DCxA\n      return swap(glyphs, [firstGlyph, 1], [lastGlyph, 2], false, true);\n\n    case 10: // ABxD => DxAB\n      return swap(glyphs, [firstGlyph, 2], [lastGlyph, 1]);\n\n    case 11: // ABxD => DxBA\n      return swap(glyphs, [firstGlyph, 2], [lastGlyph, 1], true, false);\n\n    case 12: // ABxCD => CDxAB\n      return swap(glyphs, [firstGlyph, 2], [lastGlyph, 2]);\n\n    case 13: // ABxCD => CDxBA\n      return swap(glyphs, [firstGlyph, 2], [lastGlyph, 2], true, false);\n\n    case 14: // ABxCD => DCxAB\n      return swap(glyphs, [firstGlyph, 2], [lastGlyph, 2], false, true);\n\n    case 15: // ABxCD => DCxBA\n      return swap(glyphs, [firstGlyph, 2], [lastGlyph, 2], true, true);\n\n    default:\n      throw new Error(`Unknown verb: ${verb}`);\n  }\n}\n","import * as AATFeatureMap from './AATFeatureMap';\nimport * as Script from '../layout/Script';\nimport AATMorxProcessor from './AATMorxProcessor';\n\nexport default class AATLayoutEngine {\n  constructor(font) {\n    this.font = font;\n    this.morxProcessor = new AATMorxProcessor(font);\n    this.fallbackPosition = false;\n  }\n\n  substitute(glyphRun) {\n    // AAT expects the glyphs to be in visual order prior to morx processing,\n    // so reverse the glyphs if the script is right-to-left.\n    if (glyphRun.direction === 'rtl') {\n      glyphRun.glyphs.reverse();\n    }\n\n    this.morxProcessor.process(glyphRun.glyphs, AATFeatureMap.mapOTToAAT(glyphRun.features));\n  }\n\n  getAvailableFeatures(script, language) {\n    return AATFeatureMap.mapAATToOT(this.morxProcessor.getSupportedFeatures());\n  }\n\n  stringsForGlyph(gid) {\n    let glyphStrings = this.morxProcessor.generateInputs(gid);\n    let result = new Set;\n\n    for (let glyphs of glyphStrings) {\n      this._addStrings(glyphs, 0, result, '');\n    }\n\n    return result;\n  }\n\n  _addStrings(glyphs, index, strings, string) {\n    let codePoints = this.font._cmapProcessor.codePointsForGlyph(glyphs[index]);\n\n    for (let codePoint of codePoints) {\n      let s = string + String.fromCodePoint(codePoint);\n      if (index < glyphs.length - 1) {\n        this._addStrings(glyphs, index + 1, strings, s);\n      } else {\n        strings.add(s);\n      }\n    }\n  }\n}\n","import * as Script from '../layout/Script';\n\n/**\n * ShapingPlans are used by the OpenType shapers to store which\n * features should by applied, and in what order to apply them.\n * The features are applied in groups called stages. A feature\n * can be applied globally to all glyphs, or locally to only\n * specific glyphs.\n *\n * @private\n */\nexport default class ShapingPlan {\n  constructor(font, script, direction) {\n    this.font = font;\n    this.script = script;\n    this.direction = direction;\n    this.stages = [];\n    this.globalFeatures = {};\n    this.allFeatures = {};\n  }\n\n  /**\n   * Adds the given features to the last stage.\n   * Ignores features that have already been applied.\n   */\n  _addFeatures(features, global) {\n    let stageIndex = this.stages.length - 1;\n    let stage = this.stages[stageIndex];\n    for (let feature of features) {\n      if (this.allFeatures[feature] == null) {\n        stage.push(feature);\n        this.allFeatures[feature] = stageIndex;\n\n        if (global) {\n          this.globalFeatures[feature] = true;\n        }\n      }\n    }\n  }\n\n  /**\n   * Add features to the last stage\n   */\n  add(arg, global = true) {\n    if (this.stages.length === 0) {\n      this.stages.push([]);\n    }\n\n    if (typeof arg === 'string') {\n      arg = [arg];\n    }\n\n    if (Array.isArray(arg)) {\n      this._addFeatures(arg, global);\n    } else if (typeof arg === 'object') {\n      this._addFeatures(arg.global || [], true);\n      this._addFeatures(arg.local || [], false);\n    } else {\n      throw new Error(\"Unsupported argument to ShapingPlan#add\");\n    }\n  }\n\n  /**\n   * Add a new stage\n   */\n  addStage(arg, global) {\n    if (typeof arg === 'function') {\n      this.stages.push(arg, []);\n    } else {\n      this.stages.push([]);\n      this.add(arg, global);\n    }\n  }\n\n  setFeatureOverrides(features) {\n    if (Array.isArray(features)) {\n      this.add(features);\n    } else if (typeof features === 'object') {\n      for (let tag in features) {\n        if (features[tag]) {\n          this.add(tag);\n        } else if (this.allFeatures[tag] != null) {\n          let stage = this.stages[this.allFeatures[tag]];\n          stage.splice(stage.indexOf(tag), 1);\n          delete this.allFeatures[tag];\n          delete this.globalFeatures[tag];\n        }\n      }\n    }\n  }\n\n  /**\n   * Assigns the global features to the given glyphs\n   */\n  assignGlobalFeatures(glyphs) {\n    for (let glyph of glyphs) {\n      for (let feature in this.globalFeatures) {\n        glyph.features[feature] = true;\n      }\n    }\n  }\n\n  /**\n   * Executes the planned stages using the given OTProcessor\n   */\n  process(processor, glyphs, positions) {\n    for (let stage of this.stages) {\n      if (typeof stage === 'function') {\n        if (!positions) {\n          stage(this.font, glyphs, this);\n        }\n\n      } else if (stage.length > 0) {\n        processor.applyFeatures(stage, glyphs, positions);\n      }\n    }\n  }\n}\n","import unicode from 'unicode-properties';\n\nconst VARIATION_FEATURES = ['rvrn'];\nconst COMMON_FEATURES = ['ccmp', 'locl', 'rlig', 'mark', 'mkmk'];\nconst FRACTIONAL_FEATURES = ['frac', 'numr', 'dnom'];\nconst HORIZONTAL_FEATURES = ['calt', 'clig', 'liga', 'rclt', 'curs', 'kern'];\nconst VERTICAL_FEATURES = ['vert'];\nconst DIRECTIONAL_FEATURES = {\n  ltr: ['ltra', 'ltrm'],\n  rtl: ['rtla', 'rtlm']\n};\n\nexport default class DefaultShaper {\n  static zeroMarkWidths = 'AFTER_GPOS';\n  static plan(plan, glyphs, features) {\n    // Plan the features we want to apply\n    this.planPreprocessing(plan);\n    this.planFeatures(plan);\n    this.planPostprocessing(plan, features);\n\n    // Assign the global features to all the glyphs\n    plan.assignGlobalFeatures(glyphs);\n\n    // Assign local features to glyphs\n    this.assignFeatures(plan, glyphs);\n  }\n\n  static planPreprocessing(plan) {\n    plan.add({\n      global: [...VARIATION_FEATURES, ...DIRECTIONAL_FEATURES[plan.direction]],\n      local: FRACTIONAL_FEATURES\n    });\n  }\n\n  static planFeatures(plan) {\n    // Do nothing by default. Let subclasses override this.\n  }\n\n  static planPostprocessing(plan, userFeatures) {\n    plan.add([...COMMON_FEATURES, ...HORIZONTAL_FEATURES]);\n    plan.setFeatureOverrides(userFeatures);\n  }\n\n  static assignFeatures(plan, glyphs) {\n    // Enable contextual fractions\n    for (let i = 0; i < glyphs.length; i++) {\n      let glyph = glyphs[i];\n      if (glyph.codePoints[0] === 0x2044) { // fraction slash\n        let start = i;\n        let end = i + 1;\n\n        // Apply numerator\n        while (start > 0 && unicode.isDigit(glyphs[start - 1].codePoints[0])) {\n          glyphs[start - 1].features.numr = true;\n          glyphs[start - 1].features.frac = true;\n          start--;\n        }\n\n        // Apply denominator\n        while (end < glyphs.length && unicode.isDigit(glyphs[end].codePoints[0])) {\n          glyphs[end].features.dnom = true;\n          glyphs[end].features.frac = true;\n          end++;\n        }\n\n        // Apply fraction slash\n        glyph.features.frac = true;\n        i = end - 1;\n      }\n    }\n  }\n}\n","import DefaultShaper from './DefaultShaper';\nimport unicode from 'unicode-properties';\nimport UnicodeTrie from 'unicode-trie';\n\nconst trie = new UnicodeTrie(require('fs').readFileSync(__dirname + '/data.trie'));\nconst FEATURES = ['isol', 'fina', 'fin2', 'fin3', 'medi', 'med2', 'init'];\n\nconst ShapingClasses = {\n  Non_Joining: 0,\n  Left_Joining: 1,\n  Right_Joining: 2,\n  Dual_Joining: 3,\n  Join_Causing: 3,\n  ALAPH: 4,\n  'DALATH RISH': 5,\n  Transparent: 6\n};\n\nconst ISOL = 'isol';\nconst FINA = 'fina';\nconst FIN2 = 'fin2';\nconst FIN3 = 'fin3';\nconst MEDI = 'medi';\nconst MED2 = 'med2';\nconst INIT = 'init';\nconst NONE = null;\n\n// Each entry is [prevAction, curAction, nextState]\nconst STATE_TABLE = [\n  //   Non_Joining,        Left_Joining,       Right_Joining,     Dual_Joining,           ALAPH,            DALATH RISH\n  // State 0: prev was U,  not willing to join.\n  [ [ NONE, NONE, 0 ],  [ NONE, ISOL, 2 ],  [ NONE, ISOL, 1 ],  [ NONE, ISOL, 2 ],  [ NONE, ISOL, 1 ],  [ NONE, ISOL, 6 ] ],\n\n  // State 1: prev was R or ISOL/ALAPH,  not willing to join.\n  [ [ NONE, NONE, 0 ],  [ NONE, ISOL, 2 ],  [ NONE, ISOL, 1 ],  [ NONE, ISOL, 2 ],  [ NONE, FIN2, 5 ],  [ NONE, ISOL, 6 ] ],\n\n  // State 2: prev was D/L in ISOL form,  willing to join.\n  [ [ NONE, NONE, 0 ],  [ NONE, ISOL, 2 ],  [ INIT, FINA, 1 ],  [ INIT, FINA, 3 ],  [ INIT, FINA, 4 ],  [ INIT, FINA, 6 ] ],\n\n  // State 3: prev was D in FINA form,  willing to join.\n  [ [ NONE, NONE, 0 ],  [ NONE, ISOL, 2 ],  [ MEDI, FINA, 1 ],  [ MEDI, FINA, 3 ],  [ MEDI, FINA, 4 ],  [ MEDI, FINA, 6 ] ],\n\n  // State 4: prev was FINA ALAPH,  not willing to join.\n  [ [ NONE, NONE, 0 ],  [ NONE, ISOL, 2 ],  [ MED2, ISOL, 1 ],  [ MED2, ISOL, 2 ],  [ MED2, FIN2, 5 ],  [ MED2, ISOL, 6 ] ],\n\n  // State 5: prev was FIN2/FIN3 ALAPH,  not willing to join.\n  [ [ NONE, NONE, 0 ],  [ NONE, ISOL, 2 ],  [ ISOL, ISOL, 1 ],  [ ISOL, ISOL, 2 ],  [ ISOL, FIN2, 5 ],  [ ISOL, ISOL, 6 ] ],\n\n  // State 6: prev was DALATH/RISH,  not willing to join.\n  [ [ NONE, NONE, 0 ],  [ NONE, ISOL, 2 ],  [ NONE, ISOL, 1 ],  [ NONE, ISOL, 2 ],  [ NONE, FIN3, 5 ],  [ NONE, ISOL, 6 ] ]\n];\n\n/**\n * This is a shaper for Arabic, and other cursive scripts.\n * It uses data from ArabicShaping.txt in the Unicode database,\n * compiled to a UnicodeTrie by generate-data.coffee.\n *\n * The shaping state machine was ported from Harfbuzz.\n * https://github.com/behdad/harfbuzz/blob/master/src/hb-ot-shape-complex-arabic.cc\n */\nexport default class ArabicShaper extends DefaultShaper {\n  static planFeatures(plan) {\n    plan.add(['ccmp', 'locl']);\n    for (let i = 0; i < FEATURES.length; i++) {\n      let feature = FEATURES[i];\n      plan.addStage(feature, false);\n    }\n\n    plan.addStage('mset');\n  }\n\n  static assignFeatures(plan, glyphs) {\n    super.assignFeatures(plan, glyphs);\n\n    let prev = -1;\n    let state = 0;\n    let actions = [];\n\n    // Apply the state machine to map glyphs to features\n    for (let i = 0; i < glyphs.length; i++) {\n      let curAction, prevAction;\n      var glyph = glyphs[i];\n      let type = getShapingClass(glyph.codePoints[0]);\n      if (type === ShapingClasses.Transparent) {\n        actions[i] = NONE;\n        continue;\n      }\n\n      [prevAction, curAction, state] = STATE_TABLE[state][type];\n\n      if (prevAction !== NONE && prev !== -1) {\n        actions[prev] = prevAction;\n      }\n\n      actions[i] = curAction;\n      prev = i;\n    }\n\n    // Apply the chosen features to their respective glyphs\n    for (let index = 0; index < glyphs.length; index++) {\n      let feature;\n      var glyph = glyphs[index];\n      if (feature = actions[index]) {\n        glyph.features[feature] = true;\n      }\n    }\n  }\n}\n\nfunction getShapingClass(codePoint) {\n  let res = trie.get(codePoint);\n  if (res) {\n    return res - 1;\n  }\n\n  let category = unicode.getCategory(codePoint);\n  if (category === 'Mn' || category === 'Me' || category === 'Cf') {\n    return ShapingClasses.Transparent;\n  }\n\n  return ShapingClasses.Non_Joining;\n}\n","export default class GlyphIterator {\n  constructor(glyphs, options) {\n    this.glyphs = glyphs;\n    this.reset(options);\n  }\n\n  reset(options = {}, index = 0) {\n    this.options = options;\n    this.flags = options.flags || {};\n    this.markAttachmentType = options.markAttachmentType || 0;\n    this.index = index;\n  }\n\n  get cur() {\n    return this.glyphs[this.index] || null;\n  }\n\n  shouldIgnore(glyph) {\n    return (this.flags.ignoreMarks && glyph.isMark) ||\n           (this.flags.ignoreBaseGlyphs && glyph.isBase) ||\n           (this.flags.ignoreLigatures && glyph.isLigature) ||\n           (this.markAttachmentType && glyph.isMark && glyph.markAttachmentType !== this.markAttachmentType);\n  }\n\n  move(dir) {\n    this.index += dir;\n    while (0 <= this.index && this.index < this.glyphs.length && this.shouldIgnore(this.glyphs[this.index])) {\n      this.index += dir;\n    }\n\n    if (0 > this.index || this.index >= this.glyphs.length) {\n      return null;\n    }\n\n    return this.glyphs[this.index];\n  }\n\n  next() {\n    return this.move(+1);\n  }\n\n  prev() {\n    return this.move(-1);\n  }\n\n  peek(count = 1) {\n    let idx = this.index;\n    let res = this.increment(count);\n    this.index = idx;\n    return res;\n  }\n\n  peekIndex(count = 1) {\n    let idx = this.index;\n    this.increment(count);\n    let res = this.index;\n    this.index = idx;\n    return res;\n  }\n\n  increment(count = 1) {\n    let dir = count < 0 ? -1 : 1;\n    count = Math.abs(count);\n    while (count--) {\n      this.move(dir);\n    }\n\n    return this.glyphs[this.index];\n  }\n}\n","import GlyphIterator from './GlyphIterator';\nimport * as Script from '../layout/Script';\n\nconst DEFAULT_SCRIPTS = ['DFLT', 'dflt', 'latn'];\n\nexport default class OTProcessor {\n  constructor(font, table) {\n    this.font = font;\n    this.table = table;\n\n    this.script = null;\n    this.scriptTag = null;\n\n    this.language = null;\n    this.languageTag = null;\n\n    this.features = {};\n    this.lookups = {};\n\n    // Setup variation substitutions\n    this.variationsIndex = font._variationProcessor\n      ? this.findVariationsIndex(font._variationProcessor.normalizedCoords)\n      : -1;\n\n    // initialize to default script + language\n    this.selectScript();\n\n    // current context (set by applyFeatures)\n    this.glyphs = [];\n    this.positions = []; // only used by GPOS\n    this.ligatureID = 1;\n    this.currentFeature = null;\n  }\n\n  findScript(script) {\n    if (this.table.scriptList == null) {\n      return null;\n    }\n\n    if (!Array.isArray(script)) {\n      script = [ script ];\n    }\n\n    for (let s of script) {\n      for (let entry of this.table.scriptList) {\n        if (entry.tag === s) {\n          return entry;\n        }\n      }\n    }\n\n    return null;\n  }\n\n  selectScript(script, language, direction) {\n    let changed = false;\n    let entry;\n    if (!this.script || script !== this.scriptTag) {\n      entry = this.findScript(script);\n      if (!entry) {\n        entry = this.findScript(DEFAULT_SCRIPTS);\n      }\n\n      if (!entry) {\n        return this.scriptTag;\n      }\n\n      this.scriptTag = entry.tag;\n      this.script = entry.script;\n      this.language = null;\n      this.languageTag = null;\n      changed = true;\n    }\n\n    if (!direction || direction !== this.direction) {\n      this.direction = direction || Script.direction(script);\n    }\n\n    if (language && language.length < 4) {\n      language += ' '.repeat(4 - language.length);\n    }\n\n    if (!language || language !== this.languageTag) {\n      this.language = null;\n\n      for (let lang of this.script.langSysRecords) {\n        if (lang.tag === language) {\n          this.language = lang.langSys;\n          this.languageTag = lang.tag;\n          break;\n        }\n      }\n\n      if (!this.language) {\n        this.language = this.script.defaultLangSys;\n        this.languageTag = null;\n      }\n\n      changed = true;\n    }\n\n    // Build a feature lookup table\n    if (changed) {\n      this.features = {};\n      if (this.language) {\n        for (let featureIndex of this.language.featureIndexes) {\n          let record = this.table.featureList[featureIndex];\n          let substituteFeature = this.substituteFeatureForVariations(featureIndex);\n          this.features[record.tag] = substituteFeature || record.feature;\n        }\n      }\n    }\n\n    return this.scriptTag;\n  }\n\n  lookupsForFeatures(userFeatures = [], exclude) {\n    let lookups = [];\n    for (let tag of userFeatures) {\n      let feature = this.features[tag];\n      if (!feature) {\n        continue;\n      }\n\n      for (let lookupIndex of feature.lookupListIndexes) {\n        if (exclude && exclude.indexOf(lookupIndex) !== -1) {\n          continue;\n        }\n\n        lookups.push({\n          feature: tag,\n          index: lookupIndex,\n          lookup: this.table.lookupList.get(lookupIndex)\n        });\n      }\n    }\n\n    lookups.sort((a, b) => a.index - b.index);\n    return lookups;\n  }\n\n  substituteFeatureForVariations(featureIndex) {\n    if (this.variationsIndex === -1) {\n      return null;\n    }\n\n    let record = this.table.featureVariations.featureVariationRecords[this.variationsIndex];\n    let substitutions = record.featureTableSubstitution.substitutions;\n    for (let substitution of substitutions) {\n      if (substitution.featureIndex === featureIndex) {\n        return substitution.alternateFeatureTable;\n      }\n    }\n\n    return null;\n  }\n\n  findVariationsIndex(coords) {\n    let variations = this.table.featureVariations;\n    if (!variations) {\n      return -1;\n    }\n\n    let records = variations.featureVariationRecords;\n    for (let i = 0; i < records.length; i++) {\n      let conditions = records[i].conditionSet.conditionTable;\n      if (this.variationConditionsMatch(conditions, coords)) {\n        return i;\n      }\n    }\n\n    return -1;\n  }\n\n  variationConditionsMatch(conditions, coords) {\n    return conditions.every(condition => {\n      let coord = condition.axisIndex < coords.length ? coords[condition.axisIndex] : 0;\n      return condition.filterRangeMinValue <= coord && coord <= condition.filterRangeMaxValue;\n    });\n  }\n\n  applyFeatures(userFeatures, glyphs, advances) {\n    let lookups = this.lookupsForFeatures(userFeatures);\n    this.applyLookups(lookups, glyphs, advances);\n  }\n\n  applyLookups(lookups, glyphs, positions) {\n    this.glyphs = glyphs;\n    this.positions = positions;\n    this.glyphIterator = new GlyphIterator(glyphs);\n\n    for (let {feature, lookup} of lookups) {\n      this.currentFeature = feature;\n      this.glyphIterator.reset(lookup.flags);\n\n      while (this.glyphIterator.index < glyphs.length) {\n        if (!(feature in this.glyphIterator.cur.features)) {\n          this.glyphIterator.next();\n          continue;\n        }\n\n        for (let table of lookup.subTables) {\n          let res = this.applyLookup(lookup.lookupType, table);\n          if (res) {\n            break;\n          }\n        }\n\n        this.glyphIterator.next();\n      }\n    }\n  }\n\n  applyLookup(lookup, table) {\n    throw new Error(\"applyLookup must be implemented by subclasses\");\n  }\n\n  applyLookupList(lookupRecords) {\n    let options = this.glyphIterator.options;\n    let glyphIndex = this.glyphIterator.index;\n\n    for (let lookupRecord of lookupRecords) {\n      // Reset flags and find glyph index for this lookup record\n      this.glyphIterator.reset(options, glyphIndex);\n      this.glyphIterator.increment(lookupRecord.sequenceIndex);\n\n      // Get the lookup and setup flags for subtables\n      let lookup = this.table.lookupList.get(lookupRecord.lookupListIndex);\n      this.glyphIterator.reset(lookup.flags, this.glyphIterator.index);\n\n      // Apply lookup subtables until one matches\n      for (let table of lookup.subTables) {\n        if (this.applyLookup(lookup.lookupType, table)) {\n          break;\n        }\n      }\n    }\n\n    this.glyphIterator.reset(options, glyphIndex);\n    return true;\n  }\n\n  coverageIndex(coverage, glyph) {\n    if (glyph == null) {\n      glyph = this.glyphIterator.cur.id;\n    }\n\n    switch (coverage.version) {\n      case 1:\n        return coverage.glyphs.indexOf(glyph);\n\n      case 2:\n        for (let range of coverage.rangeRecords) {\n          if (range.start <= glyph && glyph <= range.end) {\n            return range.startCoverageIndex + glyph - range.start;\n          }\n        }\n\n        break;\n    }\n\n    return -1;\n  }\n\n  match(sequenceIndex, sequence, fn, matched) {\n    let pos = this.glyphIterator.index;\n    let glyph = this.glyphIterator.increment(sequenceIndex);\n    let idx = 0;\n\n    while (idx < sequence.length && glyph && fn(sequence[idx], glyph)) {\n      if (matched) {\n        matched.push(this.glyphIterator.index);\n      }\n\n      idx++;\n      glyph = this.glyphIterator.next();\n    }\n\n    this.glyphIterator.index = pos;\n    if (idx < sequence.length) {\n      return false;\n    }\n\n    return matched || true;\n  }\n\n  sequenceMatches(sequenceIndex, sequence) {\n    return this.match(sequenceIndex, sequence, (component, glyph) => component === glyph.id);\n  }\n\n  sequenceMatchIndices(sequenceIndex, sequence) {\n    return this.match(sequenceIndex, sequence, (component, glyph) => {\n      // If the current feature doesn't apply to this glyph,\n      if (!(this.currentFeature in glyph.features)) {\n        return false;\n      }\n\n      return component === glyph.id;\n    }, []);\n  }\n\n  coverageSequenceMatches(sequenceIndex, sequence) {\n    return this.match(sequenceIndex, sequence, (coverage, glyph) =>\n      this.coverageIndex(coverage, glyph.id) >= 0\n    );\n  }\n\n  getClassID(glyph, classDef) {\n    switch (classDef.version) {\n      case 1: // Class array\n        let i = glyph - classDef.startGlyph;\n        if (i >= 0 && i < classDef.classValueArray.length) {\n          return classDef.classValueArray[i];\n        }\n\n        break;\n\n      case 2:\n        for (let range of classDef.classRangeRecord) {\n          if (range.start <= glyph && glyph <= range.end) {\n            return range.class;\n          }\n        }\n\n        break;\n    }\n\n    return 0;\n  }\n\n  classSequenceMatches(sequenceIndex, sequence, classDef) {\n    return this.match(sequenceIndex, sequence, (classID, glyph) =>\n      classID === this.getClassID(glyph.id, classDef)\n    );\n  }\n\n  applyContext(table) {\n    switch (table.version) {\n      case 1:\n        let index = this.coverageIndex(table.coverage);\n        if (index === -1) {\n          return false;\n        }\n\n        let set = table.ruleSets[index];\n        for (let rule of set) {\n          if (this.sequenceMatches(1, rule.input)) {\n            return this.applyLookupList(rule.lookupRecords);\n          }\n        }\n\n        break;\n\n      case 2:\n        if (this.coverageIndex(table.coverage) === -1) {\n          return false;\n        }\n\n        index = this.getClassID(this.glyphIterator.cur.id, table.classDef);\n        if (index === -1) {\n          return false;\n        }\n\n        set = table.classSet[index];\n        for (let rule of set) {\n          if (this.classSequenceMatches(1, rule.classes, table.classDef)) {\n            return this.applyLookupList(rule.lookupRecords);\n          }\n        }\n\n        break;\n\n      case 3:\n        if (this.coverageSequenceMatches(0, table.coverages)) {\n          return this.applyLookupList(table.lookupRecords);\n        }\n\n        break;\n    }\n\n    return false;\n  }\n\n  applyChainingContext(table) {\n    switch (table.version) {\n      case 1:\n        let index = this.coverageIndex(table.coverage);\n        if (index === -1) {\n          return false;\n        }\n\n        let set = table.chainRuleSets[index];\n        for (let rule of set) {\n          if (this.sequenceMatches(-rule.backtrack.length, rule.backtrack)\n              && this.sequenceMatches(1, rule.input)\n              && this.sequenceMatches(1 + rule.input.length, rule.lookahead)) {\n            return this.applyLookupList(rule.lookupRecords);\n          }\n        }\n\n        break;\n\n      case 2:\n        if (this.coverageIndex(table.coverage) === -1) {\n          return false;\n        }\n\n        index = this.getClassID(this.glyphIterator.cur.id, table.inputClassDef);\n        let rules = table.chainClassSet[index];\n        if (!rules) {\n          return false;\n        }\n\n        for (let rule of rules) {\n          if (this.classSequenceMatches(-rule.backtrack.length, rule.backtrack, table.backtrackClassDef) &&\n              this.classSequenceMatches(1, rule.input, table.inputClassDef) &&\n              this.classSequenceMatches(1 + rule.input.length, rule.lookahead, table.lookaheadClassDef)) {\n            return this.applyLookupList(rule.lookupRecords);\n          }\n        }\n\n        break;\n\n      case 3:\n        if (this.coverageSequenceMatches(-table.backtrackGlyphCount, table.backtrackCoverage) &&\n            this.coverageSequenceMatches(0, table.inputCoverage) &&\n            this.coverageSequenceMatches(table.inputGlyphCount, table.lookaheadCoverage)) {\n          return this.applyLookupList(table.lookupRecords);\n        }\n\n        break;\n    }\n\n    return false;\n  }\n}\n","import unicode from 'unicode-properties';\nimport OTProcessor from './OTProcessor';\n\nexport default class GlyphInfo {\n  constructor(font, id, codePoints = [], features) {\n    this._font = font;\n    this.codePoints = codePoints;\n    this.id = id;\n\n    this.features = {};\n    if (Array.isArray(features)) {\n      for (let i = 0; i < features.length; i++) {\n        let feature = features[i];\n        this.features[feature] = true;\n      }\n    } else if (typeof features === 'object') {\n      Object.assign(this.features, features);\n    }\n\n    this.ligatureID = null;\n    this.ligatureComponent = null;\n    this.isLigated = false;\n    this.cursiveAttachment = null;\n    this.markAttachment = null;\n    this.shaperInfo = null;\n    this.substituted = false;\n    this.isMultiplied = false;\n  }\n\n  get id() {\n    return this._id;\n  }\n\n  set id(id) {\n    this._id = id;\n    this.substituted = true;\n\n    let GDEF = this._font.GDEF;\n    if (GDEF && GDEF.glyphClassDef) {\n      // TODO: clean this up\n      let classID = OTProcessor.prototype.getClassID(id, GDEF.glyphClassDef);\n      this.isBase = classID === 1;\n      this.isLigature = classID === 2;\n      this.isMark = classID === 3;\n      this.markAttachmentType = GDEF.markAttachClassDef ? OTProcessor.prototype.getClassID(id, GDEF.markAttachClassDef) : 0;\n    } else {\n      this.isMark = this.codePoints.length > 0 && this.codePoints.every(unicode.isMark);\n      this.isBase = !this.isMark;\n      this.isLigature = this.codePoints.length > 1;\n      this.markAttachmentType = 0;\n    }\n  }\n\n  copy() {\n    return new GlyphInfo(this._font, this.id, this.codePoints, this.features);\n  }\n}\n","import DefaultShaper from './DefaultShaper';\nimport GlyphInfo from '../GlyphInfo';\n\n/**\n * This is a shaper for the Hangul script, used by the Korean language.\n * It does the following:\n *   - decompose if unsupported by the font:\n *     <LV>   -> <L,V>\n *     <LVT>  -> <L,V,T>\n *     <LV,T> -> <L,V,T>\n *\n *   - compose if supported by the font:\n *     <L,V>   -> <LV>\n *     <L,V,T> -> <LVT>\n *     <LV,T>  -> <LVT>\n *\n *   - reorder tone marks (S is any valid syllable):\n *     <S, M> -> <M, S>\n *\n *   - apply ljmo, vjmo, and tjmo OpenType features to decomposed Jamo sequences.\n *\n * This logic is based on the following documents:\n *   - http://www.microsoft.com/typography/OpenTypeDev/hangul/intro.htm\n *   - http://ktug.org/~nomos/harfbuzz-hangul/hangulshaper.pdf\n */\nexport default class HangulShaper extends DefaultShaper {\n  static zeroMarkWidths = 'NONE';\n  static planFeatures(plan) {\n    plan.add(['ljmo', 'vjmo', 'tjmo'], false);\n  }\n\n  static assignFeatures(plan, glyphs) {\n    let state = 0;\n    let i = 0;\n    while (i < glyphs.length) {\n      let action;\n      let glyph = glyphs[i];\n      let code = glyph.codePoints[0];\n      let type = getType(code);\n\n      [ action, state ] = STATE_TABLE[state][type];\n\n      switch (action) {\n        case DECOMPOSE:\n          // Decompose the composed syllable if it is not supported by the font.\n          if (!plan.font.hasGlyphForCodePoint(code)) {\n            i = decompose(glyphs, i, plan.font);\n          }\n          break;\n\n        case COMPOSE:\n          // Found a decomposed syllable. Try to compose if supported by the font.\n          i = compose(glyphs, i, plan.font);\n          break;\n\n        case TONE_MARK:\n          // Got a valid syllable, followed by a tone mark. Move the tone mark to the beginning of the syllable.\n          reorderToneMark(glyphs, i, plan.font);\n          break;\n\n        case INVALID:\n          // Tone mark has no valid syllable to attach to, so insert a dotted circle\n          i = insertDottedCircle(glyphs, i, plan.font);\n          break;\n      }\n\n      i++;\n    }\n  }\n}\n\nconst HANGUL_BASE  = 0xac00;\nconst HANGUL_END   = 0xd7a4;\nconst HANGUL_COUNT = HANGUL_END - HANGUL_BASE + 1;\nconst L_BASE  = 0x1100; // lead\nconst V_BASE  = 0x1161; // vowel\nconst T_BASE  = 0x11a7; // trail\nconst L_COUNT = 19;\nconst V_COUNT = 21;\nconst T_COUNT = 28;\nconst L_END   = L_BASE + L_COUNT - 1;\nconst V_END   = V_BASE + V_COUNT - 1;\nconst T_END   = T_BASE + T_COUNT - 1;\nconst DOTTED_CIRCLE = 0x25cc;\n\nconst isL    = code => 0x1100 <= code && code <= 0x115f || 0xa960 <= code && code <= 0xa97c;\nconst isV    = code => 0x1160 <= code && code <= 0x11a7 || 0xd7b0 <= code && code <= 0xd7c6;\nconst isT    = code => 0x11a8 <= code && code <= 0x11ff || 0xd7cb <= code && code <= 0xd7fb;\nconst isTone = code => 0x302e <= code && code <= 0x302f;\nconst isLVT  = code => HANGUL_BASE <= code && code <= HANGUL_END;\nconst isLV   = code => (code - HANGUL_BASE) < HANGUL_COUNT && (code - HANGUL_BASE) % T_COUNT === 0;\nconst isCombiningL = code => L_BASE <= code && code <= L_END;\nconst isCombiningV = code => V_BASE <= code && code <= V_END;\nconst isCombiningT = code => T_BASE + 1 && 1 <= code && code <= T_END;\n\n// Character categories\nconst X   = 0; // Other character\nconst L   = 1; // Leading consonant\nconst V   = 2; // Medial vowel\nconst T   = 3; // Trailing consonant\nconst LV  = 4; // Composed <LV> syllable\nconst LVT = 5; // Composed <LVT> syllable\nconst M   = 6; // Tone mark\n\n// This function classifies a character using the above categories.\nfunction getType(code) {\n  if (isL(code))    { return L; }\n  if (isV(code))    { return V; }\n  if (isT(code))    { return T; }\n  if (isLV(code))   { return LV; }\n  if (isLVT(code))  { return LVT; }\n  if (isTone(code)) { return M; }\n  return X;\n}\n\n// State machine actions\nconst NO_ACTION = 0;\nconst DECOMPOSE = 1;\nconst COMPOSE   = 2;\nconst TONE_MARK = 4;\nconst INVALID   = 5;\n\n// Build a state machine that accepts valid syllables, and applies actions along the way.\n// The logic this is implementing is documented at the top of the file.\nconst STATE_TABLE = [\n  //       X                 L                 V                T                  LV                LVT               M\n  // State 0: start state\n  [ [ NO_ACTION, 0 ], [ NO_ACTION, 1 ], [ NO_ACTION, 0 ], [ NO_ACTION, 0 ], [ DECOMPOSE, 2 ], [ DECOMPOSE, 3 ], [  INVALID, 0  ] ],\n\n  // State 1: <L>\n  [ [ NO_ACTION, 0 ], [ NO_ACTION, 1 ], [  COMPOSE, 2  ], [ NO_ACTION, 0 ], [ DECOMPOSE, 2 ], [ DECOMPOSE, 3 ], [  INVALID, 0  ] ],\n\n  // State 2: <L,V> or <LV>\n  [ [ NO_ACTION, 0 ], [ NO_ACTION, 1 ], [ NO_ACTION, 0 ], [  COMPOSE, 3  ], [ DECOMPOSE, 2 ], [ DECOMPOSE, 3 ], [ TONE_MARK, 0 ] ],\n\n  // State 3: <L,V,T> or <LVT>\n  [ [ NO_ACTION, 0 ], [ NO_ACTION, 1 ], [ NO_ACTION, 0 ], [ NO_ACTION, 0 ], [ DECOMPOSE, 2 ], [ DECOMPOSE, 3 ], [ TONE_MARK, 0 ] ]\n];\n\nfunction getGlyph(font, code, features) {\n  return new GlyphInfo(font, font.glyphForCodePoint(code).id, [code], features);\n}\n\nfunction decompose(glyphs, i, font) {\n  let glyph = glyphs[i];\n  let code = glyph.codePoints[0];\n\n  let s = code - HANGUL_BASE;\n  let t = T_BASE + s % T_COUNT;\n  s = s / T_COUNT | 0;\n  let l = L_BASE + s / V_COUNT | 0;\n  let v = V_BASE + s % V_COUNT;\n\n  // Don't decompose if all of the components are not available\n  if (!font.hasGlyphForCodePoint(l) ||\n      !font.hasGlyphForCodePoint(v) ||\n      (t !== T_BASE && !font.hasGlyphForCodePoint(t))) {\n    return i;\n  }\n\n  // Replace the current glyph with decomposed L, V, and T glyphs,\n  // and apply the proper OpenType features to each component.\n  let ljmo = getGlyph(font, l, glyph.features);\n  ljmo.features.ljmo = true;\n\n  let vjmo = getGlyph(font, v, glyph.features);\n  vjmo.features.vjmo = true;\n\n  let insert = [ ljmo, vjmo ];\n\n  if (t > T_BASE) {\n    let tjmo = getGlyph(font, t, glyph.features);\n    tjmo.features.tjmo = true;\n    insert.push(tjmo);\n  }\n\n  glyphs.splice(i, 1, ...insert);\n  return i + insert.length - 1;\n}\n\nfunction compose(glyphs, i, font) {\n  let glyph = glyphs[i];\n  let code = glyphs[i].codePoints[0];\n  let type = getType(code);\n\n  let prev = glyphs[i - 1].codePoints[0];\n  let prevType = getType(prev);\n\n  // Figure out what type of syllable we're dealing with\n  let lv, ljmo, vjmo, tjmo;\n  if (prevType === LV && type === T) {\n    // <LV,T>\n    lv = prev;\n    tjmo = glyph;\n  } else {\n    if (type === V) {\n      // <L,V>\n      ljmo = glyphs[i - 1];\n      vjmo = glyph;\n    } else {\n      // <L,V,T>\n      ljmo = glyphs[i - 2];\n      vjmo = glyphs[i - 1];\n      tjmo = glyph;\n    }\n\n    let l = ljmo.codePoints[0];\n    let v = vjmo.codePoints[0];\n\n    // Make sure L and V are combining characters\n    if (isCombiningL(l) && isCombiningV(v)) {\n      lv = HANGUL_BASE + ((l - L_BASE) * V_COUNT + (v - V_BASE)) * T_COUNT;\n    }\n  }\n\n  let t = (tjmo && tjmo.codePoints[0]) || T_BASE;\n  if ((lv != null) && (t === T_BASE || isCombiningT(t))) {\n    let s = lv + (t - T_BASE);\n\n    // Replace with a composed glyph if supported by the font,\n    // otherwise apply the proper OpenType features to each component.\n    if (font.hasGlyphForCodePoint(s)) {\n      let del = prevType === V ? 3 : 2;\n      glyphs.splice(i - del + 1, del, getGlyph(font, s, glyph.features));\n      return i - del + 1;\n    }\n  }\n\n  // Didn't compose (either a non-combining component or unsupported by font).\n  if (ljmo) { ljmo.features.ljmo = true; }\n  if (vjmo) { vjmo.features.vjmo = true; }\n  if (tjmo) { tjmo.features.tjmo = true; }\n\n  if (prevType === LV) {\n    // Sequence was originally <L,V>, which got combined earlier.\n    // Either the T was non-combining, or the LVT glyph wasn't supported.\n    // Decompose the glyph again and apply OT features.\n    decompose(glyphs, i - 1, font);\n    return i + 1;\n  }\n\n  return i;\n}\n\nfunction getLength(code) {\n  switch (getType(code)) {\n    case LV:\n    case LVT:\n      return 1;\n    case V:\n      return 2;\n    case T:\n      return 3;\n  }\n}\n\nfunction reorderToneMark(glyphs, i, font) {\n  let glyph = glyphs[i];\n  let code = glyphs[i].codePoints[0];\n\n  // Move tone mark to the beginning of the previous syllable, unless it is zero width\n  if (font.glyphForCodePoint(code).advanceWidth === 0) { return; }\n\n  let prev = glyphs[i - 1].codePoints[0];\n  let len = getLength(prev);\n\n  glyphs.splice(i, 1);\n  return glyphs.splice(i - len, 0, glyph);\n}\n\nfunction insertDottedCircle(glyphs, i, font) {\n  let glyph = glyphs[i];\n  let code = glyphs[i].codePoints[0];\n\n  if (font.hasGlyphForCodePoint(DOTTED_CIRCLE)) {\n    let dottedCircle = getGlyph(font, DOTTED_CIRCLE, glyph.features);\n\n    // If the tone mark is zero width, insert the dotted circle before, otherwise after\n    let idx = font.glyphForCodePoint(code).advanceWidth === 0 ? i : i + 1;\n    glyphs.splice(idx, 0, dottedCircle);\n    i++;\n  }\n\n  return i;\n}\n","// Cateories used in the OpenType spec:\n// https://www.microsoft.com/typography/otfntdev/devanot/shaping.aspx\nexport const CATEGORIES = {\n  X: 1 << 0,\n  C: 1 << 1,\n  V: 1 << 2,\n  N: 1 << 3,\n  H: 1 << 4,\n  ZWNJ: 1 << 5,\n  ZWJ: 1 << 6,\n  M: 1 << 7,\n  SM: 1 << 8,\n  VD: 1 << 9,\n  A: 1 << 10,\n  Placeholder: 1 << 11,\n  Dotted_Circle: 1 << 12,\n  RS: 1 << 13,    // Register Shifter, used in Khmer OT spec.\n  Coeng: 1 << 14, // Khmer-style Virama.\n  Repha: 1 << 15, // Atomically-encoded logical or visual repha.\n  Ra: 1 << 16,\n  CM: 1 << 17,    // Consonant-Medial.\n  Symbol: 1 << 18 // Avagraha, etc that take marks (SM,A,VD).\n};\n\n// Visual positions in a syllable from left to right.\nexport const POSITIONS = {\n  Start: 1 << 0,\n\n  Ra_To_Become_Reph: 1 << 1,\n  Pre_M: 1 << 2,\n  Pre_C: 1 << 3,\n\n  Base_C: 1 << 4,\n  After_Main: 1 << 5,\n\n  Above_C: 1 << 6,\n\n  Before_Sub: 1 << 7,\n  Below_C: 1 << 8,\n  After_Sub: 1 << 9,\n\n  Before_Post: 1 << 10,\n  Post_C: 1 << 11,\n  After_Post: 1 << 12,\n\n  Final_C: 1 << 13,\n  SMVD: 1 << 14,\n\n  End: 1 << 15\n};\n\nexport const CONSONANT_FLAGS = CATEGORIES.C | CATEGORIES.Ra | CATEGORIES.CM | CATEGORIES.V | CATEGORIES.Placeholder | CATEGORIES.Dotted_Circle;\nexport const JOINER_FLAGS = CATEGORIES.ZWJ | CATEGORIES.ZWNJ;\nexport const HALANT_OR_COENG_FLAGS = CATEGORIES.H | CATEGORIES.Coeng;\n\nexport const INDIC_CONFIGS = {\n  Default: {\n    hasOldSpec: false,\n    virama: 0,\n    basePos: 'Last',\n    rephPos: POSITIONS.Before_Post,\n    rephMode: 'Implicit',\n    blwfMode: 'Pre_And_Post'\n  },\n\n  Devanagari: {\n    hasOldSpec: true,\n    virama: 0x094D,\n    basePos: 'Last',\n    rephPos: POSITIONS.Before_Post,\n    rephMode: 'Implicit',\n    blwfMode: 'Pre_And_Post'\n  },\n\n  Bengali: {\n    hasOldSpec: true,\n    virama: 0x09CD,\n    basePos: 'Last',\n    rephPos: POSITIONS.After_Sub,\n    rephMode: 'Implicit',\n    blwfMode: 'Pre_And_Post'\n  },\n\n  Gurmukhi: {\n    hasOldSpec: true,\n    virama: 0x0A4D,\n    basePos: 'Last',\n    rephPos: POSITIONS.Before_Sub,\n    rephMode: 'Implicit',\n    blwfMode: 'Pre_And_Post'\n  },\n\n  Gujarati: {\n    hasOldSpec: true,\n    virama: 0x0ACD,\n    basePos: 'Last',\n    rephPos: POSITIONS.Before_Post,\n    rephMode: 'Implicit',\n    blwfMode: 'Pre_And_Post'\n  },\n\n  Oriya: {\n    hasOldSpec: true,\n    virama: 0x0B4D,\n    basePos: 'Last',\n    rephPos: POSITIONS.After_Main,\n    rephMode: 'Implicit',\n    blwfMode: 'Pre_And_Post'\n  },\n\n  Tamil: {\n    hasOldSpec: true,\n    virama: 0x0BCD,\n    basePos: 'Last',\n    rephPos: POSITIONS.After_Post,\n    rephMode: 'Implicit',\n    blwfMode: 'Pre_And_Post'\n  },\n\n  Telugu: {\n    hasOldSpec: true,\n    virama: 0x0C4D,\n    basePos: 'Last',\n    rephPos: POSITIONS.After_Post,\n    rephMode: 'Explicit',\n    blwfMode: 'Post_Only'\n  },\n\n  Kannada: {\n    hasOldSpec: true,\n    virama: 0x0CCD,\n    basePos: 'Last',\n    rephPos: POSITIONS.After_Post,\n    rephMode: 'Implicit',\n    blwfMode: 'Post_Only'\n  },\n\n  Malayalam: {\n    hasOldSpec: true,\n    virama: 0x0D4D,\n    basePos: 'Last',\n    rephPos: POSITIONS.After_Main,\n    rephMode: 'Log_Repha',\n    blwfMode: 'Pre_And_Post'\n  },\n\n  // Handled by UniversalShaper\n  // Sinhala: {\n  //   hasOldSpec: false,\n  //   virama: 0x0DCA,\n  //   basePos: 'Last_Sinhala',\n  //   rephPos: POSITIONS.After_Main,\n  //   rephMode: 'Explicit',\n  //   blwfMode: 'Pre_And_Post'\n  // },\n\n  Khmer: {\n    hasOldSpec: false,\n    virama: 0x17D2,\n    basePos: 'First',\n    rephPos: POSITIONS.Ra_To_Become_Reph,\n    rephMode: 'Vis_Repha',\n    blwfMode: 'Pre_And_Post'\n  }\n};\n\n// Additional decompositions that aren't in Unicode\nexport const INDIC_DECOMPOSITIONS = {\n  // Khmer\n  0x17BE: [0x17C1, 0x17BE],\n  0x17BF: [0x17C1, 0x17BF],\n  0x17C0: [0x17C1, 0x17C0],\n  0x17C4: [0x17C1, 0x17C4],\n  0x17C5: [0x17C1, 0x17C5]\n};\n","import DefaultShaper from './DefaultShaper';\nimport StateMachine from 'dfa';\nimport UnicodeTrie from 'unicode-trie';\nimport unicode from 'unicode-properties';\nimport * as Script from '../../layout/Script';\nimport GlyphInfo from '../GlyphInfo';\nimport indicMachine from './indic.json';\nimport useData from './use.json';\nimport {\n  CATEGORIES,\n  POSITIONS,\n  CONSONANT_FLAGS,\n  JOINER_FLAGS,\n  HALANT_OR_COENG_FLAGS, INDIC_CONFIGS,\n  INDIC_DECOMPOSITIONS\n} from './indic-data';\n\nconst {decompositions} = useData;\nconst trie = new UnicodeTrie(require('fs').readFileSync(__dirname + '/indic.trie'));\nconst stateMachine = new StateMachine(indicMachine);\n\n/**\n * The IndicShaper supports indic scripts e.g. Devanagari, Kannada, etc.\n * Based on code from Harfbuzz: https://github.com/behdad/harfbuzz/blob/master/src/hb-ot-shape-complex-indic.cc\n */\nexport default class IndicShaper extends DefaultShaper {\n  static zeroMarkWidths = 'NONE';\n  static planFeatures(plan) {\n    plan.addStage(setupSyllables);\n\n    plan.addStage(['locl', 'ccmp']);\n\n    plan.addStage(initialReordering);\n\n    plan.addStage('nukt');\n    plan.addStage('akhn');\n    plan.addStage('rphf', false);\n    plan.addStage('rkrf');\n    plan.addStage('pref', false);\n    plan.addStage('blwf', false);\n    plan.addStage('abvf', false);\n    plan.addStage('half', false);\n    plan.addStage('pstf', false);\n    plan.addStage('vatu');\n    plan.addStage('cjct');\n    plan.addStage('cfar', false);\n\n    plan.addStage(finalReordering);\n\n    plan.addStage({\n      local: ['init'],\n      global: ['pres', 'abvs', 'blws', 'psts', 'haln', 'dist', 'abvm', 'blwm', 'calt', 'clig']\n    });\n\n    // Setup the indic config for the selected script\n    plan.unicodeScript = Script.fromOpenType(plan.script);\n    plan.indicConfig = INDIC_CONFIGS[plan.unicodeScript] || INDIC_CONFIGS.Default;\n    plan.isOldSpec = plan.indicConfig.hasOldSpec && plan.script[plan.script.length - 1] !== '2';\n\n    // TODO: turn off kern (Khmer) and liga features.\n  }\n\n  static assignFeatures(plan, glyphs) {\n    // Decompose split matras\n    // TODO: do this in a more general unicode normalizer\n    for (let i = glyphs.length - 1; i >= 0; i--) {\n      let codepoint = glyphs[i].codePoints[0];\n      let d = INDIC_DECOMPOSITIONS[codepoint] || decompositions[codepoint];\n      if (d) {\n        let decomposed = d.map(c => {\n          let g = plan.font.glyphForCodePoint(c);\n          return new GlyphInfo(plan.font, g.id, [c], glyphs[i].features);\n        });\n\n        glyphs.splice(i, 1, ...decomposed);\n      }\n    }\n  }\n}\n\nfunction indicCategory(glyph) {\n  return trie.get(glyph.codePoints[0]) >> 8;\n}\n\nfunction indicPosition(glyph) {\n  return 1 << (trie.get(glyph.codePoints[0]) & 0xff);\n}\n\nclass IndicInfo {\n  constructor(category, position, syllableType, syllable) {\n    this.category = category;\n    this.position = position;\n    this.syllableType = syllableType;\n    this.syllable = syllable;\n  }\n}\n\nfunction setupSyllables(font, glyphs) {\n  let syllable = 0;\n  let last = 0;\n  for (let [start, end, tags] of stateMachine.match(glyphs.map(indicCategory))) {\n    if (start > last) {\n      ++syllable;\n      for (let i = last; i < start; i++) {\n        glyphs[i].shaperInfo = new IndicInfo(CATEGORIES.X, POSITIONS.End, 'non_indic_cluster', syllable);\n      }\n    }\n\n    ++syllable;\n\n    // Create shaper info\n    for (let i = start; i <= end; i++) {\n      glyphs[i].shaperInfo = new IndicInfo(\n        1 << indicCategory(glyphs[i]),\n        indicPosition(glyphs[i]),\n        tags[0],\n        syllable\n      );\n    }\n\n    last = end + 1;\n  }\n\n  if (last < glyphs.length) {\n    ++syllable;\n    for (let i = last; i < glyphs.length; i++) {\n      glyphs[i].shaperInfo = new IndicInfo(CATEGORIES.X, POSITIONS.End, 'non_indic_cluster', syllable);\n    }\n  }\n}\n\nfunction isConsonant(glyph) {\n  return glyph.shaperInfo.category & CONSONANT_FLAGS;\n}\n\nfunction isJoiner(glyph) {\n  return glyph.shaperInfo.category & JOINER_FLAGS;\n}\n\nfunction isHalantOrCoeng(glyph) {\n  return glyph.shaperInfo.category & HALANT_OR_COENG_FLAGS;\n}\n\nfunction wouldSubstitute(glyphs, feature) {\n  for (let glyph of glyphs) {\n    glyph.features = {[feature]: true};\n  }\n\n  let GSUB = glyphs[0]._font._layoutEngine.engine.GSUBProcessor;\n  GSUB.applyFeatures([feature], glyphs);\n\n  return glyphs.length === 1;\n}\n\nfunction consonantPosition(font, consonant, virama) {\n  let glyphs = [virama, consonant, virama];\n  if (wouldSubstitute(glyphs.slice(0, 2), 'blwf') || wouldSubstitute(glyphs.slice(1, 3), 'blwf')) {\n    return POSITIONS.Below_C;\n  } else if (wouldSubstitute(glyphs.slice(0, 2), 'pstf') || wouldSubstitute(glyphs.slice(1, 3), 'pstf')) {\n    return POSITIONS.Post_C;\n  } else if (wouldSubstitute(glyphs.slice(0, 2), 'pref') || wouldSubstitute(glyphs.slice(1, 3), 'pref')) {\n    return POSITIONS.Post_C;\n  }\n\n  return POSITIONS.Base_C;\n}\n\nfunction initialReordering(font, glyphs, plan) {\n  let indicConfig = plan.indicConfig;\n  let features = font._layoutEngine.engine.GSUBProcessor.features;\n\n  let dottedCircle = font.glyphForCodePoint(0x25cc).id;\n  let virama = font.glyphForCodePoint(indicConfig.virama).id;\n  if (virama) {\n    let info = new GlyphInfo(font, virama, [indicConfig.virama]);\n    for (let i = 0; i < glyphs.length; i++) {\n      if (glyphs[i].shaperInfo.position === POSITIONS.Base_C) {\n        glyphs[i].shaperInfo.position = consonantPosition(font, glyphs[i].copy(), info);\n      }\n    }\n  }\n\n  for (let start = 0, end = nextSyllable(glyphs, 0); start < glyphs.length; start = end, end = nextSyllable(glyphs, start)) {\n    let {category, syllableType} = glyphs[start].shaperInfo;\n\n    if (syllableType === 'symbol_cluster' || syllableType === 'non_indic_cluster') {\n      continue;\n    }\n\n    if (syllableType === 'broken_cluster' && dottedCircle) {\n      let g = new GlyphInfo(font, dottedCircle, [0x25cc]);\n      g.shaperInfo = new IndicInfo(\n        1 << indicCategory(g),\n        indicPosition(g),\n        glyphs[start].shaperInfo.syllableType,\n        glyphs[start].shaperInfo.syllable\n      );\n\n      // Insert after possible Repha.\n      let i = start;\n      while (i < end && glyphs[i].shaperInfo.category === CATEGORIES.Repha) {\n        i++;\n      }\n\n      glyphs.splice(i++, 0, g);\n      end++;\n    }\n\n    // 1. Find base consonant:\n    //\n    // The shaping engine finds the base consonant of the syllable, using the\n    // following algorithm: starting from the end of the syllable, move backwards\n    // until a consonant is found that does not have a below-base or post-base\n    // form (post-base forms have to follow below-base forms), or that is not a\n    // pre-base reordering Ra, or arrive at the first consonant. The consonant\n    // stopped at will be the base.\n\n    let base = end;\n    let limit = start;\n    let hasReph = false;\n\n    // If the syllable starts with Ra + Halant (in a script that has Reph)\n    // and has more than one consonant, Ra is excluded from candidates for\n    // base consonants.\n    if (indicConfig.rephPos !== POSITIONS.Ra_To_Become_Reph &&\n      features.rphf &&\n      start + 3 <= end && (\n        (indicConfig.rephMode === 'Implicit' && !isJoiner(glyphs[start + 2])) ||\n        (indicConfig.rephMode === 'Explicit' && glyphs[start + 2].shaperInfo.category === CATEGORIES.ZWJ)\n      )\n    ) {\n      // See if it matches the 'rphf' feature.\n      let g = [glyphs[start].copy(), glyphs[start + 1].copy(), glyphs[start + 2].copy()];\n      if (wouldSubstitute(g.slice(0, 2), 'rphf') || (indicConfig.rephMode === 'Explicit' && wouldSubstitute(g, 'rphf'))) {\n        limit += 2;\n        while (limit < end && isJoiner(glyphs[limit])) {\n          limit++;\n        }\n        base = start;\n        hasReph = true;\n      }\n    } else if (indicConfig.rephMode === 'Log_Repha' && glyphs[start].shaperInfo.category === CATEGORIES.Repha) {\n      limit++;\n      while (limit < end && isJoiner(glyphs[limit])) {\n        limit++;\n      }\n      base = start;\n      hasReph = true;\n    }\n\n    switch (indicConfig.basePos) {\n      case 'Last': {\n        // starting from the end of the syllable, move backwards\n        let i = end;\n        let seenBelow = false;\n\n        do {\n          let info = glyphs[--i].shaperInfo;\n\n          // until a consonant is found\n          if (isConsonant(glyphs[i])) {\n            // that does not have a below-base or post-base form\n            // (post-base forms have to follow below-base forms),\n            if (info.position !== POSITIONS.Below_C && (info.position !== POSITIONS.Post_C || seenBelow)) {\n              base = i;\n              break;\n            }\n\n            // or that is not a pre-base reordering Ra,\n            //\n            // IMPLEMENTATION NOTES:\n            //\n            // Our pre-base reordering Ra's are marked POS_POST_C, so will be skipped\n            // by the logic above already.\n            //\n\n            // or arrive at the first consonant. The consonant stopped at will\n            // be the base.\n            if (info.position === POSITIONS.Below_C) {\n              seenBelow = true;\n            }\n\n            base = i;\n          } else if (start < i && info.category === CATEGORIES.ZWJ && glyphs[i - 1].shaperInfo.category === CATEGORIES.H) {\n            // A ZWJ after a Halant stops the base search, and requests an explicit\n            // half form.\n            // A ZWJ before a Halant, requests a subjoined form instead, and hence\n            // search continues.  This is particularly important for Bengali\n            // sequence Ra,H,Ya that should form Ya-Phalaa by subjoining Ya.\n            break;\n          }\n        } while (i > limit);\n        break;\n      }\n\n      case 'First': {\n        // The first consonant is always the base.\n        base = start;\n\n        // Mark all subsequent consonants as below.\n        for (let i = base + 1; i < end; i++) {\n          if (isConsonant(glyphs[i])) {\n            glyphs[i].shaperInfo.position = POSITIONS.Below_C;\n          }\n        }\n      }\n    }\n\n    // If the syllable starts with Ra + Halant (in a script that has Reph)\n    // and has more than one consonant, Ra is excluded from candidates for\n    // base consonants.\n    //\n    //  Only do this for unforced Reph. (ie. not for Ra,H,ZWJ)\n    if (hasReph && base === start && limit - base <= 2) {\n      hasReph = false;\n    }\n\n    // 2. Decompose and reorder Matras:\n    //\n    // Each matra and any syllable modifier sign in the cluster are moved to the\n    // appropriate position relative to the consonant(s) in the cluster. The\n    // shaping engine decomposes two- or three-part matras into their constituent\n    // parts before any repositioning. Matra characters are classified by which\n    // consonant in a conjunct they have affinity for and are reordered to the\n    // following positions:\n    //\n    //   o Before first half form in the syllable\n    //   o After subjoined consonants\n    //   o After post-form consonant\n    //   o After main consonant (for above marks)\n    //\n    // IMPLEMENTATION NOTES:\n    //\n    // The normalize() routine has already decomposed matras for us, so we don't\n    // need to worry about that.\n\n    // 3.  Reorder marks to canonical order:\n    //\n    // Adjacent nukta and halant or nukta and vedic sign are always repositioned\n    // if necessary, so that the nukta is first.\n    //\n    // IMPLEMENTATION NOTES:\n    //\n    // We don't need to do this: the normalize() routine already did this for us.\n\n    // Reorder characters\n\n    for (let i = start; i < base; i++) {\n      let info = glyphs[i].shaperInfo;\n      info.position = Math.min(POSITIONS.Pre_C, info.position);\n    }\n\n    if (base < end) {\n      glyphs[base].shaperInfo.position = POSITIONS.Base_C;\n    }\n\n    // Mark final consonants.  A final consonant is one appearing after a matra,\n    // like in Khmer.\n    for (let i = base + 1; i < end; i++) {\n      if (glyphs[i].shaperInfo.category === CATEGORIES.M) {\n        for (let j = i + 1; j < end; j++) {\n          if (isConsonant(glyphs[j])) {\n            glyphs[j].shaperInfo.position = POSITIONS.Final_C;\n            break;\n          }\n        }\n        break;\n      }\n    }\n\n    // Handle beginning Ra\n    if (hasReph) {\n      glyphs[start].shaperInfo.position = POSITIONS.Ra_To_Become_Reph;\n    }\n\n    // For old-style Indic script tags, move the first post-base Halant after\n    // last consonant.\n    //\n    // Reports suggest that in some scripts Uniscribe does this only if there\n    // is *not* a Halant after last consonant already (eg. Kannada), while it\n    // does it unconditionally in other scripts (eg. Malayalam).  We don't\n    // currently know about other scripts, so we single out Malayalam for now.\n    //\n    // Kannada test case:\n    // U+0C9A,U+0CCD,U+0C9A,U+0CCD\n    // With some versions of Lohit Kannada.\n    // https://bugs.freedesktop.org/show_bug.cgi?id=59118\n    //\n    // Malayalam test case:\n    // U+0D38,U+0D4D,U+0D31,U+0D4D,U+0D31,U+0D4D\n    // With lohit-ttf-20121122/Lohit-Malayalam.ttf\n    if (plan.isOldSpec) {\n      let disallowDoubleHalants = plan.unicodeScript !== 'Malayalam';\n      for (let i = base + 1; i < end; i++) {\n        if (glyphs[i].shaperInfo.category === CATEGORIES.H) {\n          let j;\n          for (j = end - 1; j > i; j--) {\n            if (isConsonant(glyphs[j]) || (disallowDoubleHalants && glyphs[j].shaperInfo.category === CATEGORIES.H)) {\n              break;\n            }\n          }\n\n          if (glyphs[j].shaperInfo.category !== CATEGORIES.H && j > i) {\n            // Move Halant to after last consonant.\n            let t = glyphs[i];\n            glyphs.splice(i, 0, ...glyphs.splice(i + 1, j - i));\n            glyphs[j] = t;\n          }\n\n          break;\n        }\n      }\n    }\n\n    // Attach misc marks to previous char to move with them.\n    let lastPos = POSITIONS.Start;\n    for (let i = start; i < end; i++) {\n      let info = glyphs[i].shaperInfo;\n      if (info.category & (JOINER_FLAGS | CATEGORIES.N | CATEGORIES.RS | CATEGORIES.CM | HALANT_OR_COENG_FLAGS & info.category)) {\n        info.position = lastPos;\n        if (info.category === CATEGORIES.H && info.position === POSITIONS.Pre_M) {\n          // Uniscribe doesn't move the Halant with Left Matra.\n          // TEST: U+092B,U+093F,U+094DE\n          // We follow.  This is important for the Sinhala\n          // U+0DDA split matra since it decomposes to U+0DD9,U+0DCA\n          // where U+0DD9 is a left matra and U+0DCA is the virama.\n          // We don't want to move the virama with the left matra.\n          // TEST: U+0D9A,U+0DDA\n          for (let j = i; j > start; j--) {\n            if (glyphs[j - 1].shaperInfo.position !== POSITIONS.Pre_M) {\n              info.position = glyphs[j - 1].shaperInfo.position;\n              break;\n            }\n          }\n        }\n      } else if (info.position !== POSITIONS.SMVD) {\n        lastPos = info.position;\n      }\n    }\n\n    // For post-base consonants let them own anything before them\n    // since the last consonant or matra.\n    let last = base;\n    for (let i = base + 1; i < end; i++) {\n      if (isConsonant(glyphs[i])) {\n        for (let j = last + 1; j < i; j++) {\n          if (glyphs[j].shaperInfo.position < POSITIONS.SMVD) {\n            glyphs[j].shaperInfo.position = glyphs[i].shaperInfo.position;\n          }\n        }\n        last = i;\n      } else if (glyphs[i].shaperInfo.category === CATEGORIES.M) {\n        last = i;\n      }\n    }\n\n    let arr = glyphs.slice(start, end);\n    arr.sort((a, b) => a.shaperInfo.position - b.shaperInfo.position);\n    glyphs.splice(start, arr.length, ...arr);\n\n    // Find base again\n    for (let i = start; i < end; i++) {\n      if (glyphs[i].shaperInfo.position === POSITIONS.Base_C) {\n        base = i;\n        break;\n      }\n    }\n\n    // Setup features now\n\n    // Reph\n    for (let i = start; i < end && glyphs[i].shaperInfo.position === POSITIONS.Ra_To_Become_Reph; i++) {\n      glyphs[i].features.rphf = true;\n    }\n\n    // Pre-base\n    let blwf = !plan.isOldSpec && indicConfig.blwfMode === 'Pre_And_Post';\n    for (let i = start; i < base; i++) {\n      glyphs[i].features.half = true;\n      if (blwf) {\n        glyphs[i].features.blwf = true;\n      }\n    }\n\n    // Post-base\n    for (let i = base + 1; i < end; i++) {\n      glyphs[i].features.abvf = true;\n      glyphs[i].features.pstf = true;\n      glyphs[i].features.blwf = true;\n    }\n\n    if (plan.isOldSpec && plan.unicodeScript === 'Devanagari') {\n      // Old-spec eye-lash Ra needs special handling.  From the\n      // spec:\n      //\n      // \"The feature 'below-base form' is applied to consonants\n      // having below-base forms and following the base consonant.\n      // The exception is vattu, which may appear below half forms\n      // as well as below the base glyph. The feature 'below-base\n      // form' will be applied to all such occurrences of Ra as well.\"\n      //\n      // Test case: U+0924,U+094D,U+0930,U+094d,U+0915\n      // with Sanskrit 2003 font.\n      //\n      // However, note that Ra,Halant,ZWJ is the correct way to\n      // request eyelash form of Ra, so we wouldbn't inhibit it\n      // in that sequence.\n      //\n      // Test case: U+0924,U+094D,U+0930,U+094d,U+200D,U+0915\n      for (let i = start; i + 1 < base; i++) {\n        if (glyphs[i].shaperInfo.category === CATEGORIES.Ra &&\n          glyphs[i + 1].shaperInfo.category === CATEGORIES.H &&\n          (i + 1 === base || glyphs[i + 2].shaperInfo.category === CATEGORIES.ZWJ)\n        ) {\n          glyphs[i].features.blwf = true;\n          glyphs[i + 1].features.blwf = true;\n        }\n      }\n    }\n\n    let prefLen = 2;\n    if (features.pref && base + prefLen < end) {\n      // Find a Halant,Ra sequence and mark it for pre-base reordering processing.\n      for (let i = base + 1; i + prefLen - 1 < end; i++) {\n        let g = [glyphs[i].copy(), glyphs[i + 1].copy()];\n        if (wouldSubstitute(g, 'pref')) {\n          for (let j = 0; j < prefLen; j++) {\n            glyphs[i++].features.pref = true;\n          }\n\n          // Mark the subsequent stuff with 'cfar'.  Used in Khmer.\n          // Read the feature spec.\n          // This allows distinguishing the following cases with MS Khmer fonts:\n          // U+1784,U+17D2,U+179A,U+17D2,U+1782\n          // U+1784,U+17D2,U+1782,U+17D2,U+179A\n          if (features.cfar) {\n            for (; i < end; i++) {\n              glyphs[i].features.cfar = true;\n            }\n          }\n\n          break;\n        }\n      }\n    }\n\n    // Apply ZWJ/ZWNJ effects\n    for (let i = start + 1; i < end; i++) {\n      if (isJoiner(glyphs[i])) {\n        let nonJoiner = glyphs[i].shaperInfo.category === CATEGORIES.ZWNJ;\n        let j = i;\n\n        do {\n          j--;\n\n          // ZWJ/ZWNJ should disable CJCT.  They do that by simply\n          // being there, since we don't skip them for the CJCT\n          // feature (ie. F_MANUAL_ZWJ)\n\n          // A ZWNJ disables HALF.\n          if (nonJoiner) {\n            delete glyphs[j].features.half;\n          }\n        } while (j > start && !isConsonant(glyphs[j]));\n      }\n    }\n  }\n}\n\nfunction finalReordering(font, glyphs, plan) {\n  let indicConfig = plan.indicConfig;\n  let features = font._layoutEngine.engine.GSUBProcessor.features;\n\n  for (let start = 0, end = nextSyllable(glyphs, 0); start < glyphs.length; start = end, end = nextSyllable(glyphs, start)) {\n    // 4. Final reordering:\n    //\n    // After the localized forms and basic shaping forms GSUB features have been\n    // applied (see below), the shaping engine performs some final glyph\n    // reordering before applying all the remaining font features to the entire\n    // cluster.\n\n    let tryPref = !!features.pref;\n\n    // Find base again\n    let base = start;\n    for (; base < end; base++) {\n      if (glyphs[base].shaperInfo.position >= POSITIONS.Base_C) {\n        if (tryPref && base + 1 < end) {\n          for (let i = base + 1; i < end; i++) {\n            if (glyphs[i].features.pref) {\n              if (!(glyphs[i].substituted && glyphs[i].isLigated && !glyphs[i].isMultiplied)) {\n                // Ok, this was a 'pref' candidate but didn't form any.\n                // Base is around here...\n                base = i;\n                while (base < end && isHalantOrCoeng(glyphs[base])) {\n                  base++;\n                }\n                glyphs[base].shaperInfo.position = POSITIONS.BASE_C;\n                tryPref = false;\n              }\n              break;\n            }\n          }\n        }\n\n        // For Malayalam, skip over unformed below- (but NOT post-) forms.\n        if (plan.unicodeScript === 'Malayalam') {\n          for (let i = base + 1; i < end; i++) {\n            while (i < end && isJoiner(glyphs[i])) {\n              i++;\n            }\n\n            if (i === end || !isHalantOrCoeng(glyphs[i])) {\n              break;\n            }\n\n            i++; // Skip halant.\n            while (i < end && isJoiner(glyphs[i])) {\n              i++;\n            }\n\n            if (i < end && isConsonant(glyphs[i]) && glyphs[i].shaperInfo.position === POSITIONS.Below_C) {\n              base = i;\n              glyphs[base].shaperInfo.position = POSITIONS.Base_C;\n            }\n          }\n        }\n\n        if (start < base && glyphs[base].shaperInfo.position > POSITIONS.Base_C) {\n          base--;\n        }\n        break;\n      }\n    }\n\n    if (base === end && start < base && glyphs[base - 1].shaperInfo.category === CATEGORIES.ZWJ) {\n      base--;\n    }\n\n    if (base < end) {\n      while (start < base && glyphs[base].shaperInfo.category & (CATEGORIES.N | HALANT_OR_COENG_FLAGS)) {\n        base--;\n      }\n    }\n\n    // o Reorder matras:\n    //\n    // If a pre-base matra character had been reordered before applying basic\n    // features, the glyph can be moved closer to the main consonant based on\n    // whether half-forms had been formed. Actual position for the matra is\n    // defined as “after last standalone halant glyph, after initial matra\n    // position and before the main consonant”. If ZWJ or ZWNJ follow this\n    // halant, position is moved after it.\n    //\n\n    if (start + 1 < end && start < base) { // Otherwise there can't be any pre-base matra characters.\n      // If we lost track of base, alas, position before last thingy.\n      let newPos = base === end ? base - 2 : base - 1;\n\n      // Malayalam / Tamil do not have \"half\" forms or explicit virama forms.\n      // The glyphs formed by 'half' are Chillus or ligated explicit viramas.\n      // We want to position matra after them.\n      if (plan.unicodeScript !== 'Malayalam' && plan.unicodeScript !== 'Tamil') {\n        while (newPos > start && !(glyphs[newPos].shaperInfo.category & (CATEGORIES.M | HALANT_OR_COENG_FLAGS))) {\n          newPos--;\n        }\n\n        // If we found no Halant we are done.\n        // Otherwise only proceed if the Halant does\n        // not belong to the Matra itself!\n        if (isHalantOrCoeng(glyphs[newPos]) && glyphs[newPos].shaperInfo.position !== POSITIONS.Pre_M) {\n          // If ZWJ or ZWNJ follow this halant, position is moved after it.\n          if (newPos + 1 < end && isJoiner(glyphs[newPos + 1])) {\n            newPos++;\n          }\n        } else {\n          newPos = start; // No move.\n        }\n      }\n\n      if (start < newPos && glyphs[newPos].shaperInfo.position !== POSITIONS.Pre_M) {\n        // Now go see if there's actually any matras...\n        for (let i = newPos; i > start; i--) {\n          if (glyphs[i - 1].shaperInfo.position === POSITIONS.Pre_M) {\n            let oldPos = i - 1;\n            if (oldPos < base && base <= newPos) { // Shouldn't actually happen.\n              base--;\n            }\n\n            let tmp = glyphs[oldPos];\n            glyphs.splice(oldPos, 0, ...glyphs.splice(oldPos + 1, newPos - oldPos));\n            glyphs[newPos] = tmp;\n\n            newPos--;\n          }\n        }\n      }\n    }\n\n    // o Reorder reph:\n    //\n    // Reph’s original position is always at the beginning of the syllable,\n    // (i.e. it is not reordered at the character reordering stage). However,\n    // it will be reordered according to the basic-forms shaping results.\n    // Possible positions for reph, depending on the script, are; after main,\n    // before post-base consonant forms, and after post-base consonant forms.\n\n    // Two cases:\n    //\n    // - If repha is encoded as a sequence of characters (Ra,H or Ra,H,ZWJ), then\n    //   we should only move it if the sequence ligated to the repha form.\n    //\n    // - If repha is encoded separately and in the logical position, we should only\n    //   move it if it did NOT ligate.  If it ligated, it's probably the font trying\n    //   to make it work without the reordering.\n    if (start + 1 < end &&\n      glyphs[start].shaperInfo.position === POSITIONS.Ra_To_Become_Reph &&\n      (glyphs[start].shaperInfo.category === CATEGORIES.Repha) !== (glyphs[start].isLigated && !glyphs[start].isMultiplied)\n    ) {\n      let newRephPos;\n      let rephPos = indicConfig.rephPos;\n      let found = false;\n\n      // 1. If reph should be positioned after post-base consonant forms,\n      //    proceed to step 5.\n      if (rephPos !== POSITIONS.After_Post) {\n        //  2. If the reph repositioning class is not after post-base: target\n        //     position is after the first explicit halant glyph between the\n        //     first post-reph consonant and last main consonant. If ZWJ or ZWNJ\n        //     are following this halant, position is moved after it. If such\n        //     position is found, this is the target position. Otherwise,\n        //     proceed to the next step.\n        //\n        //     Note: in old-implementation fonts, where classifications were\n        //     fixed in shaping engine, there was no case where reph position\n        //     will be found on this step.\n        newRephPos = start + 1;\n        while (newRephPos < base && !isHalantOrCoeng(glyphs[newRephPos])) {\n          newRephPos++;\n        }\n\n        if (newRephPos < base && isHalantOrCoeng(glyphs[newRephPos])) {\n          // ->If ZWJ or ZWNJ are following this halant, position is moved after it.\n          if (newRephPos + 1 < base && isJoiner(glyphs[newRephPos + 1])) {\n            newRephPos++;\n          }\n\n          found = true;\n        }\n\n        // 3. If reph should be repositioned after the main consonant: find the\n        //    first consonant not ligated with main, or find the first\n        //    consonant that is not a potential pre-base reordering Ra.\n        if (!found && rephPos === POSITIONS.After_Main) {\n          newRephPos = base;\n          while (newRephPos + 1 < end && glyphs[newRephPos + 1].shaperInfo.position <= POSITIONS.After_Main) {\n            newRephPos++;\n          }\n\n          found = newRephPos < end;\n        }\n\n        // 4. If reph should be positioned before post-base consonant, find\n        //    first post-base classified consonant not ligated with main. If no\n        //    consonant is found, the target position should be before the\n        //    first matra, syllable modifier sign or vedic sign.\n        //\n        // This is our take on what step 4 is trying to say (and failing, BADLY).\n        if (!found && rephPos === POSITIONS.After_Sub) {\n          newRephPos = base;\n          while (newRephPos + 1 < end && !(glyphs[newRephPos + 1].shaperInfo.position & (POSITIONS.Post_C | POSITIONS.After_Post | POSITIONS.SMVD))) {\n            newRephPos++;\n          }\n\n          found = newRephPos < end;\n        }\n      }\n\n      //  5. If no consonant is found in steps 3 or 4, move reph to a position\n      //     immediately before the first post-base matra, syllable modifier\n      //     sign or vedic sign that has a reordering class after the intended\n      //     reph position. For example, if the reordering position for reph\n      //     is post-main, it will skip above-base matras that also have a\n      //     post-main position.\n      if (!found) {\n        // Copied from step 2.\n        newRephPos = start + 1;\n        while (newRephPos < base && !isHalantOrCoeng(glyphs[newRephPos])) {\n          newRephPos++;\n        }\n\n        if (newRephPos < base && isHalantOrCoeng(glyphs[newRephPos])) {\n          // ->If ZWJ or ZWNJ are following this halant, position is moved after it.\n          if (newRephPos + 1 < base && isJoiner(glyphs[newRephPos + 1])) {\n            newRephPos++;\n          }\n\n          found = true;\n        }\n      }\n\n      // 6. Otherwise, reorder reph to the end of the syllable.\n      if (!found) {\n        newRephPos = end - 1;\n        while (newRephPos > start && glyphs[newRephPos].shaperInfo.position === POSITIONS.SMVD) {\n          newRephPos--;\n        }\n\n        // If the Reph is to be ending up after a Matra,Halant sequence,\n        // position it before that Halant so it can interact with the Matra.\n        // However, if it's a plain Consonant,Halant we shouldn't do that.\n        // Uniscribe doesn't do this.\n        // TEST: U+0930,U+094D,U+0915,U+094B,U+094D\n        if (isHalantOrCoeng(glyphs[newRephPos])) {\n          for (let i = base + 1; i < newRephPos; i++) {\n            if (glyphs[i].shaperInfo.category === CATEGORIES.M) {\n              newRephPos--;\n            }\n          }\n        }\n      }\n\n      let reph = glyphs[start];\n      glyphs.splice(start, 0, ...glyphs.splice(start + 1, newRephPos - start));\n      glyphs[newRephPos] = reph;\n\n      if (start < base && base <= newRephPos) {\n        base--;\n      }\n    }\n\n    // o Reorder pre-base reordering consonants:\n    //\n    // If a pre-base reordering consonant is found, reorder it according to\n    // the following rules:\n    if (tryPref && base + 1 < end) {\n      for (let i = base + 1; i < end; i++) {\n        if (glyphs[i].features.pref) {\n           // 1. Only reorder a glyph produced by substitution during application\n           //    of the <pref> feature. (Note that a font may shape a Ra consonant with\n           //    the feature generally but block it in certain contexts.)\n\n          // Note: We just check that something got substituted.  We don't check that\n          // the <pref> feature actually did it...\n          //\n          // Reorder pref only if it ligated.\n          if (glyphs[i].isLigated && !glyphs[i].isMultiplied) {\n            // 2. Try to find a target position the same way as for pre-base matra.\n            //    If it is found, reorder pre-base consonant glyph.\n            //\n            // 3. If position is not found, reorder immediately before main\n            //    consonant.\n            let newPos = base;\n\n            // Malayalam / Tamil do not have \"half\" forms or explicit virama forms.\n            // The glyphs formed by 'half' are Chillus or ligated explicit viramas.\n            // We want to position matra after them.\n            if (plan.unicodeScript !== 'Malayalam' && plan.unicodeScript !== 'Tamil') {\n              while (newPos > start && !(glyphs[newPos - 1].shaperInfo.category & (CATEGORIES.M | HALANT_OR_COENG_FLAGS))) {\n                newPos--;\n              }\n\n              // In Khmer coeng model, a H,Ra can go *after* matras.  If it goes after a\n              // split matra, it should be reordered to *before* the left part of such matra.\n              if (newPos > start && glyphs[newPos - 1].shaperInfo.category === CATEGORIES.M) {\n                let oldPos = i;\n                for (let j = base + 1; j < oldPos; j++) {\n                  if (glyphs[j].shaperInfo.category === CATEGORIES.M) {\n                    newPos--;\n                    break;\n                  }\n                }\n              }\n            }\n\n            if (newPos > start && isHalantOrCoeng(glyphs[newPos - 1])) {\n              // -> If ZWJ or ZWNJ follow this halant, position is moved after it.\n              if (newPos < end && isJoiner(glyphs[newPos])) {\n                newPos++;\n              }\n            }\n\n            let oldPos = i;\n            let tmp = glyphs[oldPos];\n            glyphs.splice(newPos + 1, 0, ...glyphs.splice(newPos, oldPos - newPos));\n            glyphs[newPos] = tmp;\n\n            if (newPos <= base && base < oldPos) {\n              base++;\n            }\n          }\n\n          break;\n        }\n      }\n    }\n\n    // Apply 'init' to the Left Matra if it's a word start.\n    if (glyphs[start].shaperInfo.position === POSITIONS.Pre_M && (!start || !/Cf|Mn/.test(unicode.getCategory(glyphs[start - 1].codePoints[0])))) {\n      glyphs[start].features.init = true;\n    }\n  }\n}\n\nfunction nextSyllable(glyphs, start) {\n  if (start >= glyphs.length) return start;\n  let syllable = glyphs[start].shaperInfo.syllable;\n  while (++start < glyphs.length && glyphs[start].shaperInfo.syllable === syllable);\n  return start;\n}\n","import DefaultShaper from './DefaultShaper';\nimport StateMachine from 'dfa';\nimport UnicodeTrie from 'unicode-trie';\nimport GlyphInfo from '../GlyphInfo';\nimport useData from './use.json';\n\nconst {categories, decompositions} = useData;\nconst trie = new UnicodeTrie(require('fs').readFileSync(__dirname + '/use.trie'));\nconst stateMachine = new StateMachine(useData);\n\n/**\n * This shaper is an implementation of the Universal Shaping Engine, which\n * uses Unicode data to shape a number of scripts without a dedicated shaping engine.\n * See https://www.microsoft.com/typography/OpenTypeDev/USE/intro.htm.\n */\nexport default class UniversalShaper extends DefaultShaper {\n  static zeroMarkWidths = 'BEFORE_GPOS';\n  static planFeatures(plan) {\n    plan.addStage(setupSyllables);\n\n    // Default glyph pre-processing group\n    plan.addStage(['locl', 'ccmp', 'nukt', 'akhn']);\n\n    // Reordering group\n    plan.addStage(clearSubstitutionFlags);\n    plan.addStage(['rphf'], false);\n    plan.addStage(recordRphf);\n    plan.addStage(clearSubstitutionFlags);\n    plan.addStage(['pref']);\n    plan.addStage(recordPref);\n\n    // Orthographic unit shaping group\n    plan.addStage(['rkrf', 'abvf', 'blwf', 'half', 'pstf', 'vatu', 'cjct']);\n    plan.addStage(reorder);\n\n    // Topographical features\n    // Scripts that need this are handled by the Arabic shaper, not implemented here for now.\n    // plan.addStage(['isol', 'init', 'medi', 'fina', 'med2', 'fin2', 'fin3'], false);\n\n    // Standard topographic presentation and positional feature application\n    plan.addStage(['abvs', 'blws', 'pres', 'psts', 'dist', 'abvm', 'blwm']);\n  }\n\n  static assignFeatures(plan, glyphs) {\n    // Decompose split vowels\n    // TODO: do this in a more general unicode normalizer\n    for (let i = glyphs.length - 1; i >= 0; i--) {\n      let codepoint = glyphs[i].codePoints[0];\n      if (decompositions[codepoint]) {\n        let decomposed = decompositions[codepoint].map(c => {\n          let g = plan.font.glyphForCodePoint(c);\n          return new GlyphInfo(plan.font, g.id, [c], glyphs[i].features);\n        });\n\n        glyphs.splice(i, 1, ...decomposed);\n      }\n    }\n  }\n}\n\nfunction useCategory(glyph) {\n  return trie.get(glyph.codePoints[0]);\n}\n\nclass USEInfo {\n  constructor(category, syllableType, syllable) {\n    this.category = category;\n    this.syllableType = syllableType;\n    this.syllable = syllable;\n  }\n}\n\nfunction setupSyllables(font, glyphs) {\n  let syllable = 0;\n  for (let [start, end, tags] of stateMachine.match(glyphs.map(useCategory))) {\n    ++syllable;\n\n    // Create shaper info\n    for (let i = start; i <= end; i++) {\n      glyphs[i].shaperInfo = new USEInfo(categories[useCategory(glyphs[i])], tags[0], syllable);\n    }\n\n    // Assign rphf feature\n    let limit = glyphs[start].shaperInfo.category === 'R' ? 1 : Math.min(3, end - start);\n    for (let i = start; i < start + limit; i++) {\n      glyphs[i].features.rphf = true;\n    }\n  }\n}\n\nfunction clearSubstitutionFlags(font, glyphs) {\n  for (let glyph of glyphs) {\n    glyph.substituted = false;\n  }\n}\n\nfunction recordRphf(font, glyphs) {\n  for (let glyph of glyphs) {\n    if (glyph.substituted && glyph.features.rphf) {\n      // Mark a substituted repha.\n      glyph.shaperInfo.category = 'R';\n    }\n  }\n}\n\nfunction recordPref(font, glyphs) {\n  for (let glyph of glyphs) {\n    if (glyph.substituted) {\n      // Mark a substituted pref as VPre, as they behave the same way.\n      glyph.shaperInfo.category = 'VPre';\n    }\n  }\n}\n\nfunction reorder(font, glyphs) {\n  let dottedCircle = font.glyphForCodePoint(0x25cc).id;\n\n  for (let start = 0, end = nextSyllable(glyphs, 0); start < glyphs.length; start = end, end = nextSyllable(glyphs, start)) {\n    let i, j;\n    let info = glyphs[start].shaperInfo;\n    let type = info.syllableType;\n\n    // Only a few syllable types need reordering.\n    if (type !== 'virama_terminated_cluster' && type !== 'standard_cluster' && type !== 'broken_cluster') {\n      continue;\n    }\n\n    // Insert a dotted circle glyph in broken clusters.\n    if (type === 'broken_cluster' && dottedCircle) {\n      let g = new GlyphInfo(font, dottedCircle, [0x25cc]);\n      g.shaperInfo = info;\n\n      // Insert after possible Repha.\n      for (i = start; i < end && glyphs[i].shaperInfo.category === 'R'; i++);\n      glyphs.splice(++i, 0, g);\n      end++;\n    }\n\n    // Move things forward.\n    if (info.category === 'R' && end - start > 1) {\n      // Got a repha. Reorder it to after first base, before first halant.\n      for (i = start + 1; i < end; i++) {\n        info = glyphs[i].shaperInfo;\n        if (isBase(info) || isHalant(glyphs[i])) {\n          // If we hit a halant, move before it; otherwise it's a base: move to it's\n          // place, and shift things in between backward.\n          if (isHalant(glyphs[i])) {\n            i--;\n          }\n\n          glyphs.splice(start, 0, ...glyphs.splice(start + 1, i - start), glyphs[i]);\n          break;\n        }\n      }\n    }\n\n    // Move things back.\n    for (i = start, j = end; i < end; i++) {\n      info = glyphs[i].shaperInfo;\n      if (isBase(info) || isHalant(glyphs[i])) {\n        // If we hit a halant, move after it; otherwise it's a base: move to it's\n        // place, and shift things in between backward.\n        j = isHalant(glyphs[i]) ? i + 1 : i;\n      } else if ((info.category === 'VPre' || info.category === 'VMPre') && j < i) {\n        glyphs.splice(j, 1, glyphs[i], ...glyphs.splice(j, i - j));\n      }\n    }\n  }\n}\n\nfunction nextSyllable(glyphs, start) {\n  if (start >= glyphs.length) return start;\n  let syllable = glyphs[start].shaperInfo.syllable;\n  while (++start < glyphs.length && glyphs[start].shaperInfo.syllable === syllable);\n  return start;\n}\n\nfunction isHalant(glyph) {\n  return glyph.shaperInfo.category === 'H' && !glyph.isLigated;\n}\n\nfunction isBase(info) {\n  return info.category === 'B' || info.category === 'GB';\n}\n","import DefaultShaper from './DefaultShaper';\nimport ArabicShaper from './ArabicShaper';\nimport HangulShaper from './HangulShaper';\nimport IndicShaper from './IndicShaper';\nimport UniversalShaper from './UniversalShaper';\n\nconst SHAPERS = {\n  arab: ArabicShaper,    // Arabic\n  mong: ArabicShaper,    // Mongolian\n  syrc: ArabicShaper,    // Syriac\n  'nko ': ArabicShaper,  // N'Ko\n  phag: ArabicShaper,    // Phags Pa\n  mand: ArabicShaper,    // Mandaic\n  mani: ArabicShaper,    // Manichaean\n  phlp: ArabicShaper,    // Psalter Pahlavi\n\n  hang: HangulShaper,    // Hangul\n\n  bng2: IndicShaper,     // Bengali\n  beng: IndicShaper,     // Bengali\n  dev2: IndicShaper,     // Devanagari\n  deva: IndicShaper,     // Devanagari\n  gjr2: IndicShaper,     // Gujarati\n  gujr: IndicShaper,     // Gujarati\n  guru: IndicShaper,     // Gurmukhi\n  gur2: IndicShaper,     // Gurmukhi\n  knda: IndicShaper,     // Kannada\n  knd2: IndicShaper,     // Kannada\n  mlm2: IndicShaper,     // Malayalam\n  mlym: IndicShaper,     // Malayalam\n  ory2: IndicShaper,     // Oriya\n  orya: IndicShaper,     // Oriya\n  taml: IndicShaper,     // Tamil\n  tml2: IndicShaper,     // Tamil\n  telu: IndicShaper,     // Telugu\n  tel2: IndicShaper,     // Telugu\n  khmr: IndicShaper,     // Khmer\n\n  bali: UniversalShaper, // Balinese\n  batk: UniversalShaper, // Batak\n  brah: UniversalShaper, // Brahmi\n  bugi: UniversalShaper, // Buginese\n  buhd: UniversalShaper, // Buhid\n  cakm: UniversalShaper, // Chakma\n  cham: UniversalShaper, // Cham\n  dupl: UniversalShaper, // Duployan\n  egyp: UniversalShaper, // Egyptian Hieroglyphs\n  gran: UniversalShaper, // Grantha\n  hano: UniversalShaper, // Hanunoo\n  java: UniversalShaper, // Javanese\n  kthi: UniversalShaper, // Kaithi\n  kali: UniversalShaper, // Kayah Li\n  khar: UniversalShaper, // Kharoshthi\n  khoj: UniversalShaper, // Khojki\n  sind: UniversalShaper, // Khudawadi\n  lepc: UniversalShaper, // Lepcha\n  limb: UniversalShaper, // Limbu\n  mahj: UniversalShaper, // Mahajani\n  // mand: UniversalShaper, // Mandaic\n  // mani: UniversalShaper, // Manichaean\n  mtei: UniversalShaper, // Meitei Mayek\n  modi: UniversalShaper, // Modi\n  // mong: UniversalShaper, // Mongolian\n  // 'nko ': UniversalShaper, // N’Ko\n  hmng: UniversalShaper, // Pahawh Hmong\n  // phag: UniversalShaper, // Phags-pa\n  // phlp: UniversalShaper, // Psalter Pahlavi\n  rjng: UniversalShaper, // Rejang\n  saur: UniversalShaper, // Saurashtra\n  shrd: UniversalShaper, // Sharada\n  sidd: UniversalShaper, // Siddham\n  sinh: UniversalShaper, // Sinhala\n  sund: UniversalShaper, // Sundanese\n  sylo: UniversalShaper, // Syloti Nagri\n  tglg: UniversalShaper, // Tagalog\n  tagb: UniversalShaper, // Tagbanwa\n  tale: UniversalShaper, // Tai Le\n  lana: UniversalShaper, // Tai Tham\n  tavt: UniversalShaper, // Tai Viet\n  takr: UniversalShaper, // Takri\n  tibt: UniversalShaper, // Tibetan\n  tfng: UniversalShaper, // Tifinagh\n  tirh: UniversalShaper, // Tirhuta\n\n  latn: DefaultShaper,   // Latin\n  DFLT: DefaultShaper    // Default\n};\n\nexport function choose(script) {\n  if (!Array.isArray(script)) {\n    script = [script];\n  }\n\n  for (let s of script) {\n    let shaper = SHAPERS[s];\n    if (shaper) {\n      return shaper;\n    }\n  }\n\n  return DefaultShaper;\n}\n","import OTProcessor from './OTProcessor';\nimport GlyphInfo from './GlyphInfo';\n\nexport default class GSUBProcessor extends OTProcessor {\n  applyLookup(lookupType, table) {\n    switch (lookupType) {\n      case 1: { // Single Substitution\n        let index = this.coverageIndex(table.coverage);\n        if (index === -1) {\n          return false;\n        }\n\n        let glyph = this.glyphIterator.cur;\n        switch (table.version) {\n          case 1:\n            glyph.id = (glyph.id + table.deltaGlyphID) & 0xffff;\n            break;\n\n          case 2:\n            glyph.id = table.substitute.get(index);\n            break;\n        }\n\n        return true;\n      }\n\n      case 2: { // Multiple Substitution\n        let index = this.coverageIndex(table.coverage);\n        if (index !== -1) {\n          let sequence = table.sequences.get(index);\n\n          if (sequence.length === 0) {\n            // If the sequence length is zero, delete the glyph.\n            // The OpenType spec disallows this, but seems like Harfbuzz and Uniscribe allow it.\n            this.glyphs.splice(this.glyphIterator.index, 1);\n            return true;\n          }\n\n          this.glyphIterator.cur.id = sequence[0];\n          this.glyphIterator.cur.ligatureComponent = 0;\n\n          let features = this.glyphIterator.cur.features;\n          let curGlyph = this.glyphIterator.cur;\n          let replacement = sequence.slice(1).map((gid, i) => {\n            let glyph = new GlyphInfo(this.font, gid, undefined, features);\n            glyph.shaperInfo = curGlyph.shaperInfo;\n            glyph.isLigated = curGlyph.isLigated;\n            glyph.ligatureComponent = i + 1;\n            glyph.substituted = true;\n            glyph.isMultiplied = true;\n            return glyph;\n          });\n\n          this.glyphs.splice(this.glyphIterator.index + 1, 0, ...replacement);\n          return true;\n        }\n\n        return false;\n      }\n\n      case 3: { // Alternate Substitution\n        let index = this.coverageIndex(table.coverage);\n        if (index !== -1) {\n          let USER_INDEX = 0; // TODO\n          this.glyphIterator.cur.id = table.alternateSet.get(index)[USER_INDEX];\n          return true;\n        }\n\n        return false;\n      }\n\n      case 4: { // Ligature Substitution\n        let index = this.coverageIndex(table.coverage);\n        if (index === -1) {\n          return false;\n        }\n\n        for (let ligature of table.ligatureSets.get(index)) {\n          let matched = this.sequenceMatchIndices(1, ligature.components);\n          if (!matched) {\n            continue;\n          }\n\n          let curGlyph = this.glyphIterator.cur;\n\n          // Concatenate all of the characters the new ligature will represent\n          let characters = curGlyph.codePoints.slice();\n          for (let index of matched) {\n            characters.push(...this.glyphs[index].codePoints);\n          }\n\n          // Create the replacement ligature glyph\n          let ligatureGlyph = new GlyphInfo(this.font, ligature.glyph, characters, curGlyph.features);\n          ligatureGlyph.shaperInfo = curGlyph.shaperInfo;\n          ligatureGlyph.isLigated = true;\n          ligatureGlyph.substituted = true;\n\n          // From Harfbuzz:\n          // - If it *is* a mark ligature, we don't allocate a new ligature id, and leave\n          //   the ligature to keep its old ligature id.  This will allow it to attach to\n          //   a base ligature in GPOS.  Eg. if the sequence is: LAM,LAM,SHADDA,FATHA,HEH,\n          //   and LAM,LAM,HEH for a ligature, they will leave SHADDA and FATHA with a\n          //   ligature id and component value of 2.  Then if SHADDA,FATHA form a ligature\n          //   later, we don't want them to lose their ligature id/component, otherwise\n          //   GPOS will fail to correctly position the mark ligature on top of the\n          //   LAM,LAM,HEH ligature. See https://bugzilla.gnome.org/show_bug.cgi?id=676343\n          //\n          // - If a ligature is formed of components that some of which are also ligatures\n          //   themselves, and those ligature components had marks attached to *their*\n          //   components, we have to attach the marks to the new ligature component\n          //   positions!  Now *that*'s tricky!  And these marks may be following the\n          //   last component of the whole sequence, so we should loop forward looking\n          //   for them and update them.\n          //\n          //   Eg. the sequence is LAM,LAM,SHADDA,FATHA,HEH, and the font first forms a\n          //   'calt' ligature of LAM,HEH, leaving the SHADDA and FATHA with a ligature\n          //   id and component == 1.  Now, during 'liga', the LAM and the LAM-HEH ligature\n          //   form a LAM-LAM-HEH ligature.  We need to reassign the SHADDA and FATHA to\n          //   the new ligature with a component value of 2.\n          //\n          //   This in fact happened to a font...  See https://bugzilla.gnome.org/show_bug.cgi?id=437633\n          let isMarkLigature = curGlyph.isMark;\n          for (let i = 0; i < matched.length && isMarkLigature; i++) {\n            isMarkLigature = this.glyphs[matched[i]].isMark;\n          }\n\n          ligatureGlyph.ligatureID = isMarkLigature ? null : this.ligatureID++;\n\n          let lastLigID = curGlyph.ligatureID;\n          let lastNumComps = curGlyph.codePoints.length;\n          let curComps = lastNumComps;\n          let idx = this.glyphIterator.index + 1;\n\n          // Set ligatureID and ligatureComponent on glyphs that were skipped in the matched sequence.\n          // This allows GPOS to attach marks to the correct ligature components.\n          for (let matchIndex of matched) {\n            // Don't assign new ligature components for mark ligatures (see above)\n            if (isMarkLigature) {\n              idx = matchIndex;\n            } else {\n              while (idx < matchIndex) {\n                var ligatureComponent = curComps - lastNumComps + Math.min(this.glyphs[idx].ligatureComponent || 1, lastNumComps);\n                this.glyphs[idx].ligatureID = ligatureGlyph.ligatureID;\n                this.glyphs[idx].ligatureComponent = ligatureComponent;\n                idx++;\n              }\n            }\n\n            lastLigID = this.glyphs[idx].ligatureID;\n            lastNumComps = this.glyphs[idx].codePoints.length;\n            curComps += lastNumComps;\n            idx++; // skip base glyph\n          }\n\n          // Adjust ligature components for any marks following\n          if (lastLigID && !isMarkLigature) {\n            for (let i = idx; i < this.glyphs.length; i++) {\n              if (this.glyphs[i].ligatureID === lastLigID) {\n                var ligatureComponent = curComps - lastNumComps + Math.min(this.glyphs[i].ligatureComponent || 1, lastNumComps);\n                this.glyphs[i].ligatureComponent = ligatureComponent;\n              } else {\n                break;\n              }\n            }\n          }\n\n          // Delete the matched glyphs, and replace the current glyph with the ligature glyph\n          for (let i = matched.length - 1; i >= 0; i--) {\n            this.glyphs.splice(matched[i], 1);\n          }\n\n          this.glyphs[this.glyphIterator.index] = ligatureGlyph;\n          return true;\n        }\n\n        return false;\n      }\n\n      case 5: // Contextual Substitution\n        return this.applyContext(table);\n\n      case 6: // Chaining Contextual Substitution\n        return this.applyChainingContext(table);\n\n      case 7: // Extension Substitution\n        return this.applyLookup(table.lookupType, table.extension);\n\n      default:\n        throw new Error(`GSUB lookupType ${lookupType} is not supported`);\n    }\n  }\n}\n","import OTProcessor from './OTProcessor';\n\nexport default class GPOSProcessor extends OTProcessor {\n  applyPositionValue(sequenceIndex, value) {\n    let position = this.positions[this.glyphIterator.peekIndex(sequenceIndex)];\n    if (value.xAdvance != null) {\n      position.xAdvance += value.xAdvance;\n    }\n\n    if (value.yAdvance != null) {\n      position.yAdvance += value.yAdvance;\n    }\n\n    if (value.xPlacement != null) {\n      position.xOffset += value.xPlacement;\n    }\n\n    if (value.yPlacement != null) {\n      position.yOffset += value.yPlacement;\n    }\n\n    // Adjustments for font variations\n    let variationProcessor = this.font._variationProcessor;\n    let variationStore = this.font.GDEF && this.font.GDEF.itemVariationStore;\n    if (variationProcessor && variationStore) {\n      if (value.xPlaDevice) {\n        position.xOffset += variationProcessor.getDelta(variationStore, value.xPlaDevice.a, value.xPlaDevice.b);\n      }\n\n      if (value.yPlaDevice) {\n        position.yOffset += variationProcessor.getDelta(variationStore, value.yPlaDevice.a, value.yPlaDevice.b);\n      }\n\n      if (value.xAdvDevice) {\n        position.xAdvance += variationProcessor.getDelta(variationStore, value.xAdvDevice.a, value.xAdvDevice.b);\n      }\n\n      if (value.yAdvDevice) {\n        position.yAdvance += variationProcessor.getDelta(variationStore, value.yAdvDevice.a, value.yAdvDevice.b);\n      }\n    }\n\n    // TODO: device tables\n  }\n\n  applyLookup(lookupType, table) {\n    switch (lookupType) {\n      case 1: { // Single positioning value\n        let index = this.coverageIndex(table.coverage);\n        if (index === -1) {\n          return false;\n        }\n\n        switch (table.version) {\n          case 1:\n            this.applyPositionValue(0, table.value);\n            break;\n\n          case 2:\n            this.applyPositionValue(0, table.values.get(index));\n            break;\n        }\n\n        return true;\n      }\n\n      case 2: { // Pair Adjustment Positioning\n        let nextGlyph = this.glyphIterator.peek();\n        if (!nextGlyph) {\n          return false;\n        }\n\n        let index = this.coverageIndex(table.coverage);\n        if (index === -1) {\n          return false;\n        }\n\n        switch (table.version) {\n          case 1: // Adjustments for glyph pairs\n            let set = table.pairSets.get(index);\n\n            for (let pair of set) {\n              if (pair.secondGlyph === nextGlyph.id) {\n                this.applyPositionValue(0, pair.value1);\n                this.applyPositionValue(1, pair.value2);\n                return true;\n              }\n            }\n\n            return false;\n\n          case 2: // Class pair adjustment\n            let class1 = this.getClassID(this.glyphIterator.cur.id, table.classDef1);\n            let class2 = this.getClassID(nextGlyph.id, table.classDef2);\n            if (class1 === -1 || class2 === -1) {\n              return false;\n            }\n\n            var pair = table.classRecords.get(class1).get(class2);\n            this.applyPositionValue(0, pair.value1);\n            this.applyPositionValue(1, pair.value2);\n            return true;\n        }\n      }\n\n      case 3: { // Cursive Attachment Positioning\n        let nextIndex = this.glyphIterator.peekIndex();\n        let nextGlyph = this.glyphs[nextIndex];\n        if (!nextGlyph) {\n          return false;\n        }\n\n        let curRecord = table.entryExitRecords[this.coverageIndex(table.coverage)];\n        if (!curRecord || !curRecord.exitAnchor) {\n          return false;\n        }\n\n        let nextRecord = table.entryExitRecords[this.coverageIndex(table.coverage, nextGlyph.id)];\n        if (!nextRecord || !nextRecord.entryAnchor) {\n          return false;\n        }\n\n        let entry = this.getAnchor(nextRecord.entryAnchor);\n        let exit = this.getAnchor(curRecord.exitAnchor);\n\n        let cur = this.positions[this.glyphIterator.index];\n        let next = this.positions[nextIndex];\n\n        switch (this.direction) {\n          case 'ltr':\n            cur.xAdvance = exit.x + cur.xOffset;\n\n            let d = entry.x + next.xOffset;\n            next.xAdvance -= d;\n            next.xOffset -= d;\n            break;\n\n          case 'rtl':\n            d = exit.x + cur.xOffset;\n            cur.xAdvance -= d;\n            cur.xOffset -= d;\n            next.xAdvance = entry.x + next.xOffset;\n            break;\n        }\n\n        if (this.glyphIterator.flags.rightToLeft) {\n          this.glyphIterator.cur.cursiveAttachment = nextIndex;\n          cur.yOffset = entry.y - exit.y;\n        } else {\n          nextGlyph.cursiveAttachment = this.glyphIterator.index;\n          cur.yOffset = exit.y - entry.y;\n        }\n\n        return true;\n      }\n\n      case 4: { // Mark to base positioning\n        let markIndex = this.coverageIndex(table.markCoverage);\n        if (markIndex === -1) {\n          return false;\n        }\n\n        // search backward for a base glyph\n        let baseGlyphIndex = this.glyphIterator.index;\n        while (--baseGlyphIndex >= 0 && (this.glyphs[baseGlyphIndex].isMark || this.glyphs[baseGlyphIndex].ligatureComponent > 0));\n\n        if (baseGlyphIndex < 0) {\n          return false;\n        }\n\n        let baseIndex = this.coverageIndex(table.baseCoverage, this.glyphs[baseGlyphIndex].id);\n        if (baseIndex === -1) {\n          return false;\n        }\n\n        let markRecord = table.markArray[markIndex];\n        let baseAnchor = table.baseArray[baseIndex][markRecord.class];\n        this.applyAnchor(markRecord, baseAnchor, baseGlyphIndex);\n        return true;\n      }\n\n      case 5: { // Mark to ligature positioning\n        let markIndex = this.coverageIndex(table.markCoverage);\n        if (markIndex === -1) {\n          return false;\n        }\n\n        // search backward for a base glyph\n        let baseGlyphIndex = this.glyphIterator.index;\n        while (--baseGlyphIndex >= 0 && this.glyphs[baseGlyphIndex].isMark);\n\n        if (baseGlyphIndex < 0) {\n          return false;\n        }\n\n        let ligIndex = this.coverageIndex(table.ligatureCoverage, this.glyphs[baseGlyphIndex].id);\n        if (ligIndex === -1) {\n          return false;\n        }\n\n        let ligAttach = table.ligatureArray[ligIndex];\n        let markGlyph = this.glyphIterator.cur;\n        let ligGlyph = this.glyphs[baseGlyphIndex];\n        let compIndex = ligGlyph.ligatureID && ligGlyph.ligatureID === markGlyph.ligatureID && (markGlyph.ligatureComponent > 0)\n          ? Math.min(markGlyph.ligatureComponent, ligGlyph.codePoints.length) - 1\n          : ligGlyph.codePoints.length - 1;\n\n        let markRecord = table.markArray[markIndex];\n        let baseAnchor = ligAttach[compIndex][markRecord.class];\n        this.applyAnchor(markRecord, baseAnchor, baseGlyphIndex);\n        return true;\n      }\n\n      case 6: { // Mark to mark positioning\n        let mark1Index = this.coverageIndex(table.mark1Coverage);\n        if (mark1Index === -1) {\n          return false;\n        }\n\n        // get the previous mark to attach to\n        let prevIndex = this.glyphIterator.peekIndex(-1);\n        let prev = this.glyphs[prevIndex];\n        if (!prev || !prev.isMark) {\n          return false;\n        }\n\n        let cur = this.glyphIterator.cur;\n\n        // The following logic was borrowed from Harfbuzz\n        let good = false;\n        if (cur.ligatureID === prev.ligatureID) {\n          if (!cur.ligatureID) { // Marks belonging to the same base\n            good = true;\n          } else if (cur.ligatureComponent === prev.ligatureComponent) { // Marks belonging to the same ligature component\n            good = true;\n          }\n        } else {\n          // If ligature ids don't match, it may be the case that one of the marks\n          // itself is a ligature, in which case match.\n          if ((cur.ligatureID && !cur.ligatureComponent) || (prev.ligatureID && !prev.ligatureComponent)) {\n            good = true;\n          }\n        }\n\n        if (!good) {\n          return false;\n        }\n\n        let mark2Index = this.coverageIndex(table.mark2Coverage, prev.id);\n        if (mark2Index === -1) {\n          return false;\n        }\n\n        let markRecord = table.mark1Array[mark1Index];\n        let baseAnchor = table.mark2Array[mark2Index][markRecord.class];\n        this.applyAnchor(markRecord, baseAnchor, prevIndex);\n        return true;\n      }\n\n      case 7: // Contextual positioning\n        return this.applyContext(table);\n\n      case 8: // Chaining contextual positioning\n        return this.applyChainingContext(table);\n\n      case 9: // Extension positioning\n        return this.applyLookup(table.lookupType, table.extension);\n\n      default:\n        throw new Error(`Unsupported GPOS table: ${lookupType}`);\n    }\n  }\n\n  applyAnchor(markRecord, baseAnchor, baseGlyphIndex) {\n    let baseCoords = this.getAnchor(baseAnchor);\n    let markCoords = this.getAnchor(markRecord.markAnchor);\n\n    let basePos = this.positions[baseGlyphIndex];\n    let markPos = this.positions[this.glyphIterator.index];\n\n    markPos.xOffset = baseCoords.x - markCoords.x;\n    markPos.yOffset = baseCoords.y - markCoords.y;\n    this.glyphIterator.cur.markAttachment = baseGlyphIndex;\n  }\n\n  getAnchor(anchor) {\n    // TODO: contour point, device tables\n    let x = anchor.xCoordinate;\n    let y = anchor.yCoordinate;\n\n    // Adjustments for font variations\n    let variationProcessor = this.font._variationProcessor;\n    let variationStore = this.font.GDEF && this.font.GDEF.itemVariationStore;\n    if (variationProcessor && variationStore) {\n      if (anchor.xDeviceTable) {\n        x += variationProcessor.getDelta(variationStore, anchor.xDeviceTable.a, anchor.xDeviceTable.b);\n      }\n\n      if (anchor.yDeviceTable) {\n        y += variationProcessor.getDelta(variationStore, anchor.yDeviceTable.a, anchor.yDeviceTable.b);\n      }\n    }\n\n    return {x, y};\n  }\n\n  applyFeatures(userFeatures, glyphs, advances) {\n    super.applyFeatures(userFeatures, glyphs, advances);\n\n    for (var i = 0; i < this.glyphs.length; i++) {\n      this.fixCursiveAttachment(i);\n    }\n\n    this.fixMarkAttachment();\n  }\n\n  fixCursiveAttachment(i) {\n    let glyph = this.glyphs[i];\n    if (glyph.cursiveAttachment != null) {\n      let j = glyph.cursiveAttachment;\n\n      glyph.cursiveAttachment = null;\n      this.fixCursiveAttachment(j);\n\n      this.positions[i].yOffset += this.positions[j].yOffset;\n    }\n  }\n\n  fixMarkAttachment() {\n    for (let i = 0; i < this.glyphs.length; i++) {\n      let glyph = this.glyphs[i];\n      if (glyph.markAttachment != null) {\n        let j = glyph.markAttachment;\n\n        this.positions[i].xOffset += this.positions[j].xOffset;\n        this.positions[i].yOffset += this.positions[j].yOffset;\n\n        if (this.direction === 'ltr') {\n          for (let k = j; k < i; k++) {\n            this.positions[i].xOffset -= this.positions[k].xAdvance;\n            this.positions[i].yOffset -= this.positions[k].yAdvance;\n          }\n        } else {\n          for (let k = j + 1; k < i + 1; k++) {\n            this.positions[i].xOffset += this.positions[k].xAdvance;\n            this.positions[i].yOffset += this.positions[k].yAdvance;\n          }\n        }\n      }\n    }\n  }\n}\n","import ShapingPlan from './ShapingPlan';\nimport * as Shapers from './shapers';\nimport GlyphInfo from './GlyphInfo';\nimport GSUBProcessor from './GSUBProcessor';\nimport GPOSProcessor from './GPOSProcessor';\n\nexport default class OTLayoutEngine {\n  constructor(font) {\n    this.font = font;\n    this.glyphInfos = null;\n    this.plan = null;\n    this.GSUBProcessor = null;\n    this.GPOSProcessor = null;\n    this.fallbackPosition = true;\n\n    if (font.GSUB) {\n      this.GSUBProcessor = new GSUBProcessor(font, font.GSUB);\n    }\n\n    if (font.GPOS) {\n      this.GPOSProcessor = new GPOSProcessor(font, font.GPOS);\n    }\n  }\n\n  setup(glyphRun) {\n    // Map glyphs to GlyphInfo objects so data can be passed between\n    // GSUB and GPOS without mutating the real (shared) Glyph objects.\n    this.glyphInfos = glyphRun.glyphs.map(glyph => new GlyphInfo(this.font, glyph.id, [...glyph.codePoints]));\n\n    // Select a script based on what is available in GSUB/GPOS.\n    let script = null;\n    if (this.GPOSProcessor) {\n      script = this.GPOSProcessor.selectScript(glyphRun.script, glyphRun.language, glyphRun.direction);\n    }\n\n    if (this.GSUBProcessor) {\n      script = this.GSUBProcessor.selectScript(glyphRun.script, glyphRun.language, glyphRun.direction);\n    }\n\n    // Choose a shaper based on the script, and setup a shaping plan.\n    // This determines which features to apply to which glyphs.\n    this.shaper = Shapers.choose(script);\n    this.plan = new ShapingPlan(this.font, script, glyphRun.direction);\n    this.shaper.plan(this.plan, this.glyphInfos, glyphRun.features);\n\n    // Assign chosen features to output glyph run\n    for (let key in this.plan.allFeatures) {\n      glyphRun.features[key] = true;\n    }\n  }\n\n  substitute(glyphRun) {\n    if (this.GSUBProcessor) {\n      this.plan.process(this.GSUBProcessor, this.glyphInfos);\n\n      // Map glyph infos back to normal Glyph objects\n      glyphRun.glyphs = this.glyphInfos.map(glyphInfo => this.font.getGlyph(glyphInfo.id, glyphInfo.codePoints));\n    }\n  }\n\n  position(glyphRun) {\n    if (this.shaper.zeroMarkWidths === 'BEFORE_GPOS') {\n      this.zeroMarkAdvances(glyphRun.positions);\n    }\n\n    if (this.GPOSProcessor) {\n      this.plan.process(this.GPOSProcessor, this.glyphInfos, glyphRun.positions);\n    }\n\n    if (this.shaper.zeroMarkWidths === 'AFTER_GPOS') {\n      this.zeroMarkAdvances(glyphRun.positions);\n    }\n\n    // Reverse the glyphs and positions if the script is right-to-left\n    if (glyphRun.direction === 'rtl') {\n      glyphRun.glyphs.reverse();\n      glyphRun.positions.reverse();\n    }\n\n    return this.GPOSProcessor && this.GPOSProcessor.features;\n  }\n\n  zeroMarkAdvances(positions) {\n    for (let i = 0; i < this.glyphInfos.length; i++) {\n      if (this.glyphInfos[i].isMark) {\n        positions[i].xAdvance = 0;\n        positions[i].yAdvance = 0;\n      }\n    }\n  }\n\n  cleanup() {\n    this.glyphInfos = null;\n    this.plan = null;\n    this.shaper = null;\n  }\n\n  getAvailableFeatures(script, language) {\n    let features = [];\n\n    if (this.GSUBProcessor) {\n      this.GSUBProcessor.selectScript(script, language);\n      features.push(...Object.keys(this.GSUBProcessor.features));\n    }\n\n    if (this.GPOSProcessor) {\n      this.GPOSProcessor.selectScript(script, language);\n      features.push(...Object.keys(this.GPOSProcessor.features));\n    }\n\n    return features;\n  }\n}\n","import KernProcessor from './KernProcessor';\nimport UnicodeLayoutEngine from './UnicodeLayoutEngine';\nimport GlyphRun from './GlyphRun';\nimport GlyphPosition from './GlyphPosition';\nimport * as Script from './Script';\nimport unicode from 'unicode-properties';\nimport AATLayoutEngine from '../aat/AATLayoutEngine';\nimport OTLayoutEngine from '../opentype/OTLayoutEngine';\n\nexport default class LayoutEngine {\n  constructor(font) {\n    this.font = font;\n    this.unicodeLayoutEngine = null;\n    this.kernProcessor = null;\n\n    // Choose an advanced layout engine. We try the AAT morx table first since more\n    // scripts are currently supported because the shaping logic is built into the font.\n    if (this.font.morx) {\n      this.engine = new AATLayoutEngine(this.font);\n\n    } else if (this.font.GSUB || this.font.GPOS) {\n      this.engine = new OTLayoutEngine(this.font);\n    }\n  }\n\n  layout(string, features, script, language, direction) {\n    // Make the features parameter optional\n    if (typeof features === 'string') {\n      direction = language;\n      language = script;\n      script = features;\n      features = [];\n    }\n\n    // Map string to glyphs if needed\n    if (typeof string === 'string') {\n      // Attempt to detect the script from the string if not provided.\n      if (script == null) {\n        script = Script.forString(string);\n      }\n\n      var glyphs = this.font.glyphsForString(string);\n    } else {\n      // Attempt to detect the script from the glyph code points if not provided.\n      if (script == null) {\n        let codePoints = [];\n        for (let glyph of string) {\n          codePoints.push(...glyph.codePoints);\n        }\n\n        script = Script.forCodePoints(codePoints);\n      }\n\n      var glyphs = string;\n    }\n\n    let glyphRun = new GlyphRun(glyphs, features, script, language, direction);\n\n    // Return early if there are no glyphs\n    if (glyphs.length === 0) {\n      glyphRun.positions = [];\n      return glyphRun;\n    }\n\n    // Setup the advanced layout engine\n    if (this.engine && this.engine.setup) {\n      this.engine.setup(glyphRun);\n    }\n\n    // Substitute and position the glyphs\n    this.substitute(glyphRun);\n    this.position(glyphRun);\n\n    this.hideDefaultIgnorables(glyphRun.glyphs, glyphRun.positions);\n\n    // Let the layout engine clean up any state it might have\n    if (this.engine && this.engine.cleanup) {\n      this.engine.cleanup();\n    }\n\n    return glyphRun;\n  }\n\n  substitute(glyphRun) {\n    // Call the advanced layout engine to make substitutions\n    if (this.engine && this.engine.substitute) {\n      this.engine.substitute(glyphRun);\n    }\n  }\n\n  position(glyphRun) {\n    // Get initial glyph positions\n    glyphRun.positions = glyphRun.glyphs.map(glyph => new GlyphPosition(glyph.advanceWidth));\n    let positioned = null;\n\n    // Call the advanced layout engine. Returns the features applied.\n    if (this.engine && this.engine.position) {\n      positioned = this.engine.position(glyphRun);\n    }\n\n    // if there is no GPOS table, use unicode properties to position marks.\n    if (!positioned && (!this.engine || this.engine.fallbackPosition)) {\n      if (!this.unicodeLayoutEngine) {\n        this.unicodeLayoutEngine = new UnicodeLayoutEngine(this.font);\n      }\n\n      this.unicodeLayoutEngine.positionGlyphs(glyphRun.glyphs, glyphRun.positions);\n    }\n\n    // if kerning is not supported by GPOS, do kerning with the TrueType/AAT kern table\n    if ((!positioned || !positioned.kern) && glyphRun.features.kern !== false && this.font.kern) {\n      if (!this.kernProcessor) {\n        this.kernProcessor = new KernProcessor(this.font);\n      }\n\n      this.kernProcessor.process(glyphRun.glyphs, glyphRun.positions);\n      glyphRun.features.kern = true;\n    }\n  }\n\n  hideDefaultIgnorables(glyphs, positions) {\n    let space = this.font.glyphForCodePoint(0x20);\n    for (let i = 0; i < glyphs.length; i++) {\n      if (this.isDefaultIgnorable(glyphs[i].codePoints[0])) {\n        glyphs[i] = space;\n        positions[i].xAdvance = 0;\n        positions[i].yAdvance = 0;\n      }\n    }\n  }\n\n  isDefaultIgnorable(ch) {\n    // From DerivedCoreProperties.txt in the Unicode database,\n    // minus U+115F, U+1160, U+3164 and U+FFA0, which is what\n    // Harfbuzz and Uniscribe do.\n    let plane = ch >> 16;\n    if (plane === 0) {\n      // BMP\n      switch (ch >> 8) {\n      \tcase 0x00: return ch === 0x00AD;\n      \tcase 0x03: return ch === 0x034F;\n      \tcase 0x06: return ch === 0x061C;\n      \tcase 0x17: return 0x17B4 <= ch && ch <= 0x17B5;\n      \tcase 0x18: return 0x180B <= ch && ch <= 0x180E;\n      \tcase 0x20: return (0x200B <= ch && ch <= 0x200F) || (0x202A <= ch && ch <= 0x202E) || (0x2060 <= ch && ch <= 0x206F);\n      \tcase 0xFE: return (0xFE00 <= ch && ch <= 0xFE0F) || ch === 0xFEFF;\n      \tcase 0xFF: return 0xFFF0 <= ch && ch <= 0xFFF8;\n      \tdefault:   return false;\n      }\n    } else {\n      // Other planes\n      switch (plane) {\n      \tcase 0x01: return (0x1BCA0 <= ch && ch <= 0x1BCA3) || (0x1D173 <= ch && ch <= 0x1D17A);\n      \tcase 0x0E: return 0xE0000 <= ch && ch <= 0xE0FFF;\n      \tdefault:   return false;\n      }\n    }\n  }\n\n  getAvailableFeatures(script, language) {\n    let features = [];\n\n    if (this.engine) {\n      features.push(...this.engine.getAvailableFeatures(script, language));\n    }\n\n    if (this.font.kern && features.indexOf('kern') === -1) {\n      features.push('kern');\n    }\n\n    return features;\n  }\n\n  stringsForGlyph(gid) {\n    let result = new Set;\n\n    let codePoints = this.font._cmapProcessor.codePointsForGlyph(gid);\n    for (let codePoint of codePoints) {\n      result.add(String.fromCodePoint(codePoint));\n    }\n\n    if (this.engine && this.engine.stringsForGlyph) {\n      for (let string of this.engine.stringsForGlyph(gid)) {\n        result.add(string);\n      }\n    }\n\n    return Array.from(result);\n  }\n}\n","import BBox from './BBox';\n\nconst SVG_COMMANDS = {\n  moveTo: 'M',\n  lineTo: 'L',\n  quadraticCurveTo: 'Q',\n  bezierCurveTo: 'C',\n  closePath: 'Z'\n};\n\n/**\n * Path objects are returned by glyphs and represent the actual\n * vector outlines for each glyph in the font. Paths can be converted\n * to SVG path data strings, or to functions that can be applied to\n * render the path to a graphics context.\n */\nexport default class Path {\n  constructor() {\n    this.commands = [];\n    this._bbox = null;\n    this._cbox = null;\n  }\n\n  /**\n   * Compiles the path to a JavaScript function that can be applied with\n   * a graphics context in order to render the path.\n   * @return {string}\n   */\n  toFunction() {\n    return ctx => {\n      this.commands.forEach(c => {\n        return ctx[c.command].apply(ctx, c.args)\n      })\n    };\n  }\n\n  /**\n   * Converts the path to an SVG path data string\n   * @return {string}\n   */\n  toSVG() {\n    let cmds = this.commands.map(c => {\n      let args = c.args.map(arg => Math.round(arg * 100) / 100);\n      return `${SVG_COMMANDS[c.command]}${args.join(' ')}`;\n    });\n\n    return cmds.join('');\n  }\n\n  /**\n   * Gets the \"control box\" of a path.\n   * This is like the bounding box, but it includes all points including\n   * control points of bezier segments and is much faster to compute than\n   * the real bounding box.\n   * @type {BBox}\n   */\n  get cbox() {\n    if (!this._cbox) {\n      let cbox = new BBox;\n      for (let command of this.commands) {\n        for (let i = 0; i < command.args.length; i += 2) {\n          cbox.addPoint(command.args[i], command.args[i + 1]);\n        }\n      }\n\n      this._cbox = Object.freeze(cbox);\n    }\n\n    return this._cbox;\n  }\n\n  /**\n   * Gets the exact bounding box of the path by evaluating curve segments.\n   * Slower to compute than the control box, but more accurate.\n   * @type {BBox}\n   */\n  get bbox() {\n    if (this._bbox) {\n      return this._bbox;\n    }\n\n    let bbox = new BBox;\n    let cx = 0, cy = 0;\n\n    let f = t => (\n      Math.pow(1 - t, 3) * p0[i]\n        + 3 * Math.pow(1 - t, 2) * t * p1[i]\n        + 3 * (1 - t) * Math.pow(t, 2) * p2[i]\n        + Math.pow(t, 3) * p3[i]\n    );\n\n    for (let c of this.commands) {\n      switch (c.command) {\n        case 'moveTo':\n        case 'lineTo':\n          let [x, y] = c.args;\n          bbox.addPoint(x, y);\n          cx = x;\n          cy = y;\n          break;\n\n        case 'quadraticCurveTo':\n        case 'bezierCurveTo':\n          if (c.command === 'quadraticCurveTo') {\n            // http://fontforge.org/bezier.html\n            var [qp1x, qp1y, p3x, p3y] = c.args;\n            var cp1x = cx + 2 / 3 * (qp1x - cx);    // CP1 = QP0 + 2/3 * (QP1-QP0)\n            var cp1y = cy + 2 / 3 * (qp1y - cy);\n            var cp2x = p3x + 2 / 3 * (qp1x - p3x);  // CP2 = QP2 + 2/3 * (QP1-QP2)\n            var cp2y = p3y + 2 / 3 * (qp1y - p3y);\n          } else {\n            var [cp1x, cp1y, cp2x, cp2y, p3x, p3y] = c.args;\n          }\n\n          // http://blog.hackers-cafe.net/2009/06/how-to-calculate-bezier-curves-bounding.html\n          bbox.addPoint(p3x, p3y);\n\n          var p0 = [cx, cy];\n          var p1 = [cp1x, cp1y];\n          var p2 = [cp2x, cp2y];\n          var p3 = [p3x, p3y];\n\n          for (var i = 0; i <= 1; i++) {\n            let b = 6 * p0[i] - 12 * p1[i] + 6 * p2[i];\n            let a = -3 * p0[i] + 9 * p1[i] - 9 * p2[i] + 3 * p3[i];\n            c = 3 * p1[i] - 3 * p0[i];\n\n            if (a === 0) {\n              if (b === 0) {\n                continue;\n              }\n\n              let t = -c / b;\n              if (0 < t && t < 1) {\n                if (i === 0) {\n                  bbox.addPoint(f(t), bbox.maxY);\n                } else if (i === 1) {\n                  bbox.addPoint(bbox.maxX, f(t));\n                }\n              }\n\n              continue;\n            }\n\n            let b2ac = Math.pow(b, 2) - 4 * c * a;\n            if (b2ac < 0) {\n              continue;\n            }\n\n            let t1 = (-b + Math.sqrt(b2ac)) / (2 * a);\n            if (0 < t1 && t1 < 1) {\n              if (i === 0) {\n                bbox.addPoint(f(t1), bbox.maxY);\n              } else if (i === 1) {\n                bbox.addPoint(bbox.maxX, f(t1));\n              }\n            }\n\n            let t2 = (-b - Math.sqrt(b2ac)) / (2 * a);\n            if (0 < t2 && t2 < 1) {\n              if (i === 0) {\n                bbox.addPoint(f(t2), bbox.maxY);\n              } else if (i === 1) {\n                bbox.addPoint(bbox.maxX, f(t2));\n              }\n            }\n          }\n\n          cx = p3x;\n          cy = p3y;\n          break;\n      }\n    }\n\n    return this._bbox = Object.freeze(bbox);\n  }\n\n  /**\n   * Applies a mapping function to each point in the path.\n   * @param {function} fn\n   * @return {Path}\n   */\n  mapPoints(fn) {\n    let path = new Path;\n\n    for (let c of this.commands) {\n      let args = [];\n      for (let i = 0; i < c.args.length; i += 2) {\n        let [x, y] = fn(c.args[i], c.args[i + 1]);\n        args.push(x, y);\n      }\n\n      path[c.command](...args);\n    }\n\n    return path;\n  }\n\n  /**\n   * Transforms the path by the given matrix.\n   */\n  transform(m0, m1, m2, m3, m4, m5) {\n    return this.mapPoints((x, y) => {\n      x = m0 * x + m2 * y + m4;\n      y = m1 * x + m3 * y + m5;\n      return [x, y];\n    });\n  }\n\n  /**\n   * Translates the path by the given offset.\n   */\n  translate(x, y) {\n    return this.transform(1, 0, 0, 1, x, y);\n  }\n\n  /**\n   * Rotates the path by the given angle (in radians).\n   */\n  rotate(angle) {\n    let cos = Math.cos(angle);\n    let sin = Math.sin(angle);\n    return this.transform(cos, sin, -sin, cos, 0, 0);\n  }\n\n  /**\n   * Scales the path.\n   */\n  scale(scaleX, scaleY = scaleX) {\n    return this.transform(scaleX, 0, 0, scaleY, 0, 0);\n  }\n}\n\nfor (let command of ['moveTo', 'lineTo', 'quadraticCurveTo', 'bezierCurveTo', 'closePath']) {\n  Path.prototype[command] = function(...args) {\n    this._bbox = this._cbox = null;\n    this.commands.push({\n      command,\n      args\n    });\n\n    return this;\n  };\n}\n","export default [\n  '.notdef', '.null', 'nonmarkingreturn', 'space', 'exclam', 'quotedbl', 'numbersign', 'dollar', 'percent',\n  'ampersand', 'quotesingle', 'parenleft', 'parenright', 'asterisk', 'plus', 'comma', 'hyphen', 'period', 'slash',\n  'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'colon', 'semicolon', 'less',\n  'equal', 'greater', 'question', 'at', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O',\n  'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'bracketleft', 'backslash', 'bracketright',\n  'asciicircum', 'underscore', 'grave', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o',\n  'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'braceleft', 'bar', 'braceright', 'asciitilde',\n  'Adieresis', 'Aring', 'Ccedilla', 'Eacute', 'Ntilde', 'Odieresis', 'Udieresis', 'aacute', 'agrave',\n  'acircumflex', 'adieresis', 'atilde', 'aring', 'ccedilla', 'eacute', 'egrave', 'ecircumflex', 'edieresis',\n  'iacute', 'igrave', 'icircumflex', 'idieresis', 'ntilde', 'oacute', 'ograve', 'ocircumflex', 'odieresis',\n  'otilde', 'uacute', 'ugrave', 'ucircumflex', 'udieresis', 'dagger', 'degree', 'cent', 'sterling', 'section',\n  'bullet', 'paragraph', 'germandbls', 'registered', 'copyright', 'trademark', 'acute', 'dieresis', 'notequal',\n  'AE', 'Oslash', 'infinity', 'plusminus', 'lessequal', 'greaterequal', 'yen', 'mu', 'partialdiff', 'summation',\n  'product', 'pi', 'integral', 'ordfeminine', 'ordmasculine', 'Omega', 'ae', 'oslash', 'questiondown',\n  'exclamdown', 'logicalnot', 'radical', 'florin', 'approxequal', 'Delta', 'guillemotleft', 'guillemotright',\n  'ellipsis', 'nonbreakingspace', 'Agrave', 'Atilde', 'Otilde', 'OE', 'oe', 'endash', 'emdash', 'quotedblleft',\n  'quotedblright', 'quoteleft', 'quoteright', 'divide', 'lozenge', 'ydieresis', 'Ydieresis', 'fraction',\n  'currency', 'guilsinglleft', 'guilsinglright', 'fi', 'fl', 'daggerdbl', 'periodcentered', 'quotesinglbase',\n  'quotedblbase', 'perthousand', 'Acircumflex', 'Ecircumflex', 'Aacute', 'Edieresis', 'Egrave', 'Iacute',\n  'Icircumflex', 'Idieresis', 'Igrave', 'Oacute', 'Ocircumflex', 'apple', 'Ograve', 'Uacute', 'Ucircumflex',\n  'Ugrave', 'dotlessi', 'circumflex', 'tilde', 'macron', 'breve', 'dotaccent', 'ring', 'cedilla', 'hungarumlaut',\n  'ogonek', 'caron', 'Lslash', 'lslash', 'Scaron', 'scaron', 'Zcaron', 'zcaron', 'brokenbar', 'Eth', 'eth',\n  'Yacute', 'yacute', 'Thorn', 'thorn', 'minus', 'multiply', 'onesuperior', 'twosuperior', 'threesuperior',\n  'onehalf', 'onequarter', 'threequarters', 'franc', 'Gbreve', 'gbreve', 'Idotaccent', 'Scedilla', 'scedilla',\n  'Cacute', 'cacute', 'Ccaron', 'ccaron', 'dcroat'\n];\n","import { cache } from '../decorators';\nimport Path from './Path';\nimport unicode from 'unicode-properties';\nimport StandardNames from './StandardNames';\n\n/**\n * Glyph objects represent a glyph in the font. They have various properties for accessing metrics and\n * the actual vector path the glyph represents, and methods for rendering the glyph to a graphics context.\n *\n * You do not create glyph objects directly. They are created by various methods on the font object.\n * There are several subclasses of the base Glyph class internally that may be returned depending\n * on the font format, but they all inherit from this class.\n */\nexport default class Glyph {\n  constructor(id, codePoints, font) {\n    /**\n     * The glyph id in the font\n     * @type {number}\n     */\n    this.id = id;\n\n    /**\n     * An array of unicode code points that are represented by this glyph.\n     * There can be multiple code points in the case of ligatures and other glyphs\n     * that represent multiple visual characters.\n     * @type {number[]}\n     */\n    this.codePoints = codePoints;\n    this._font = font;\n\n    // TODO: get this info from GDEF if available\n    this.isMark = this.codePoints.length > 0 && this.codePoints.every(unicode.isMark);\n    this.isLigature = this.codePoints.length > 1;\n  }\n\n  _getPath() {\n    return new Path();\n  }\n\n  _getCBox() {\n    return this.path.cbox;\n  }\n\n  _getBBox() {\n    return this.path.bbox;\n  }\n\n  _getTableMetrics(table) {\n    if (this.id < table.metrics.length) {\n      return table.metrics.get(this.id);\n    }\n\n    let metric = table.metrics.get(table.metrics.length - 1);\n    let res = {\n      advance: metric ? metric.advance : 0,\n      bearing: table.bearings.get(this.id - table.metrics.length) || 0\n    };\n\n    return res;\n  }\n\n  _getMetrics(cbox) {\n    if (this._metrics) { return this._metrics; }\n\n    let {advance:advanceWidth, bearing:leftBearing} = this._getTableMetrics(this._font.hmtx);\n\n    // For vertical metrics, use vmtx if available, or fall back to global data from OS/2 or hhea\n    if (this._font.vmtx) {\n      var {advance:advanceHeight, bearing:topBearing} = this._getTableMetrics(this._font.vmtx);\n\n    } else {\n      let os2;\n      if (typeof cbox === 'undefined' || cbox === null) { ({ cbox } = this); }\n\n      if ((os2 = this._font['OS/2']) && os2.version > 0) {\n        var advanceHeight = Math.abs(os2.typoAscender - os2.typoDescender);\n        var topBearing = os2.typoAscender - cbox.maxY;\n\n      } else {\n        let { hhea } = this._font;\n        var advanceHeight = Math.abs(hhea.ascent - hhea.descent);\n        var topBearing = hhea.ascent - cbox.maxY;\n      }\n    }\n\n    if (this._font._variationProcessor && this._font.HVAR) {\n      advanceWidth += this._font._variationProcessor.getAdvanceAdjustment(this.id, this._font.HVAR);\n    }\n\n    return this._metrics = { advanceWidth, advanceHeight, leftBearing, topBearing };\n  }\n\n  /**\n   * The glyph’s control box.\n   * This is often the same as the bounding box, but is faster to compute.\n   * Because of the way bezier curves are defined, some of the control points\n   * can be outside of the bounding box. Where `bbox` takes this into account,\n   * `cbox` does not. Thus, cbox is less accurate, but faster to compute.\n   * See [here](http://www.freetype.org/freetype2/docs/glyphs/glyphs-6.html#section-2)\n   * for a more detailed description.\n   *\n   * @type {BBox}\n   */\n  @cache\n  get cbox() {\n    return this._getCBox();\n  }\n\n  /**\n   * The glyph’s bounding box, i.e. the rectangle that encloses the\n   * glyph outline as tightly as possible.\n   * @type {BBox}\n   */\n  @cache\n  get bbox() {\n    return this._getBBox();\n  }\n\n  /**\n   * A vector Path object representing the glyph outline.\n   * @type {Path}\n   */\n  @cache\n  get path() {\n    // Cache the path so we only decode it once\n    // Decoding is actually performed by subclasses\n    return this._getPath();\n  }\n\n  /**\n   * Returns a path scaled to the given font size.\n   * @param {number} size\n   * @return {Path}\n   */\n  getScaledPath(size) {\n    let scale = 1 / this._font.unitsPerEm * size;\n    return this.path.scale(scale);\n  }\n\n  /**\n   * The glyph's advance width.\n   * @type {number}\n   */\n  @cache\n  get advanceWidth() {\n    return this._getMetrics().advanceWidth;\n  }\n\n  /**\n   * The glyph's advance height.\n   * @type {number}\n   */\n  @cache\n  get advanceHeight() {\n    return this._getMetrics().advanceHeight;\n  }\n\n  get ligatureCaretPositions() {}\n\n  _getName() {\n    let { post } = this._font;\n    if (!post) {\n      return null;\n    }\n\n    switch (post.version) {\n      case 1:\n        return StandardNames[this.id];\n\n      case 2:\n        let id = post.glyphNameIndex[this.id];\n        if (id < StandardNames.length) {\n          return StandardNames[id];\n        }\n\n        return post.names[id - StandardNames.length];\n\n      case 2.5:\n        return StandardNames[this.id + post.offsets[this.id]];\n\n      case 4:\n        return String.fromCharCode(post.map[this.id]);\n    }\n  }\n\n  /**\n   * The glyph's name\n   * @type {string}\n   */\n  @cache\n  get name() {\n    return this._getName();\n  }\n\n  /**\n   * Renders the glyph to the given graphics context, at the specified font size.\n   * @param {CanvasRenderingContext2d} ctx\n   * @param {number} size\n   */\n  render(ctx, size) {\n    ctx.save();\n\n    let scale = 1 / this._font.head.unitsPerEm * size;\n    ctx.scale(scale, scale);\n\n    let fn = this.path.toFunction();\n    fn(ctx);\n    ctx.fill();\n\n    ctx.restore();\n  }\n}\n","import Glyph from './Glyph';\nimport Path from './Path';\nimport BBox from './BBox';\nimport r from 'restructure';\n\n// The header for both simple and composite glyphs\nlet GlyfHeader = new r.Struct({\n  numberOfContours: r.int16, // if negative, this is a composite glyph\n  xMin:             r.int16,\n  yMin:             r.int16,\n  xMax:             r.int16,\n  yMax:             r.int16\n});\n\n// Flags for simple glyphs\nconst ON_CURVE        = 1 << 0;\nconst X_SHORT_VECTOR  = 1 << 1;\nconst Y_SHORT_VECTOR  = 1 << 2;\nconst REPEAT          = 1 << 3;\nconst SAME_X          = 1 << 4;\nconst SAME_Y          = 1 << 5;\n\n// Flags for composite glyphs\nconst ARG_1_AND_2_ARE_WORDS     = 1 << 0;\nconst ARGS_ARE_XY_VALUES        = 1 << 1;\nconst ROUND_XY_TO_GRID          = 1 << 2;\nconst WE_HAVE_A_SCALE           = 1 << 3;\nconst MORE_COMPONENTS           = 1 << 5;\nconst WE_HAVE_AN_X_AND_Y_SCALE  = 1 << 6;\nconst WE_HAVE_A_TWO_BY_TWO      = 1 << 7;\nconst WE_HAVE_INSTRUCTIONS      = 1 << 8;\nconst USE_MY_METRICS            = 1 << 9;\nconst OVERLAP_COMPOUND          = 1 << 10;\nconst SCALED_COMPONENT_OFFSET   = 1 << 11;\nconst UNSCALED_COMPONENT_OFFSET = 1 << 12;\n\n// Represents a point in a simple glyph\nexport class Point {\n  constructor(onCurve, endContour, x = 0, y = 0) {\n    this.onCurve = onCurve;\n    this.endContour = endContour;\n    this.x = x;\n    this.y = y;\n  }\n\n  copy() {\n    return new Point(this.onCurve, this.endContour, this.x, this.y);\n  }\n}\n\n// Represents a component in a composite glyph\nclass Component {\n  constructor(glyphID, dx, dy) {\n    this.glyphID = glyphID;\n    this.dx = dx;\n    this.dy = dy;\n    this.pos = 0;\n    this.scaleX = this.scaleY = 1;\n    this.scale01 = this.scale10 = 0;\n  }\n}\n\n/**\n * Represents a TrueType glyph.\n */\nexport default class TTFGlyph extends Glyph {\n  // Parses just the glyph header and returns the bounding box\n  _getCBox(internal) {\n    // We need to decode the glyph if variation processing is requested,\n    // so it's easier just to recompute the path's cbox after decoding.\n    if (this._font._variationProcessor && !internal) {\n      return this.path.cbox;\n    }\n\n    let stream = this._font._getTableStream('glyf');\n    stream.pos += this._font.loca.offsets[this.id];\n    let glyph = GlyfHeader.decode(stream);\n\n    let cbox = new BBox(glyph.xMin, glyph.yMin, glyph.xMax, glyph.yMax);\n    return Object.freeze(cbox);\n  }\n\n  // Parses a single glyph coordinate\n  _parseGlyphCoord(stream, prev, short, same) {\n    if (short) {\n      var val = stream.readUInt8();\n      if (!same) {\n        val = -val;\n      }\n\n      val += prev;\n    } else {\n      if (same) {\n        var val = prev;\n      } else {\n        var val = prev + stream.readInt16BE();\n      }\n    }\n\n    return val;\n  }\n\n  // Decodes the glyph data into points for simple glyphs,\n  // or components for composite glyphs\n  _decode() {\n    let glyfPos = this._font.loca.offsets[this.id];\n    let nextPos = this._font.loca.offsets[this.id + 1];\n\n    // Nothing to do if there is no data for this glyph\n    if (glyfPos === nextPos) { return null; }\n\n    let stream = this._font._getTableStream('glyf');\n    stream.pos += glyfPos;\n    let startPos = stream.pos;\n\n    let glyph = GlyfHeader.decode(stream);\n\n    if (glyph.numberOfContours > 0) {\n      this._decodeSimple(glyph, stream);\n\n    } else if (glyph.numberOfContours < 0) {\n      this._decodeComposite(glyph, stream, startPos);\n    }\n\n    return glyph;\n  }\n\n  _decodeSimple(glyph, stream) {\n    // this is a simple glyph\n    glyph.points = [];\n\n    let endPtsOfContours = new r.Array(r.uint16, glyph.numberOfContours).decode(stream);\n    glyph.instructions = new r.Array(r.uint8, r.uint16).decode(stream);\n\n    let flags = [];\n    let numCoords = endPtsOfContours[endPtsOfContours.length - 1] + 1;\n\n    while (flags.length < numCoords) {\n      var flag = stream.readUInt8();\n      flags.push(flag);\n\n      // check for repeat flag\n      if (flag & REPEAT) {\n        let count = stream.readUInt8();\n        for (let j = 0; j < count; j++) {\n          flags.push(flag);\n        }\n      }\n    }\n\n    for (var i = 0; i < flags.length; i++) {\n      var flag = flags[i];\n      let point = new Point(!!(flag & ON_CURVE), endPtsOfContours.indexOf(i) >= 0, 0, 0);\n      glyph.points.push(point);\n    }\n\n    let px = 0;\n    for (var i = 0; i < flags.length; i++) {\n      var flag = flags[i];\n      glyph.points[i].x = px = this._parseGlyphCoord(stream, px, flag & X_SHORT_VECTOR, flag & SAME_X);\n    }\n\n    let py = 0;\n    for (var i = 0; i < flags.length; i++) {\n      var flag = flags[i];\n      glyph.points[i].y = py = this._parseGlyphCoord(stream, py, flag & Y_SHORT_VECTOR, flag & SAME_Y);\n    }\n\n    if (this._font._variationProcessor) {\n      let points = glyph.points.slice();\n      points.push(...this._getPhantomPoints(glyph));\n\n      this._font._variationProcessor.transformPoints(this.id, points);\n      glyph.phantomPoints = points.slice(-4);\n    }\n\n    return;\n  }\n\n  _decodeComposite(glyph, stream, offset = 0) {\n    // this is a composite glyph\n    glyph.components = [];\n    let haveInstructions = false;\n    let flags = MORE_COMPONENTS;\n\n    while (flags & MORE_COMPONENTS) {\n      flags = stream.readUInt16BE();\n      let gPos = stream.pos - offset;\n      let glyphID = stream.readUInt16BE();\n      if (!haveInstructions) {\n        haveInstructions = (flags & WE_HAVE_INSTRUCTIONS) !== 0;\n      }\n\n      if (flags & ARG_1_AND_2_ARE_WORDS) {\n        var dx = stream.readInt16BE();\n        var dy = stream.readInt16BE();\n      } else {\n        var dx = stream.readInt8();\n        var dy = stream.readInt8();\n      }\n\n      var component = new Component(glyphID, dx, dy);\n      component.pos = gPos;\n\n      if (flags & WE_HAVE_A_SCALE) {\n        // fixed number with 14 bits of fraction\n        component.scaleX =\n        component.scaleY = ((stream.readUInt8() << 24) | (stream.readUInt8() << 16)) / 1073741824;\n\n      } else if (flags & WE_HAVE_AN_X_AND_Y_SCALE) {\n        component.scaleX = ((stream.readUInt8() << 24) | (stream.readUInt8() << 16)) / 1073741824;\n        component.scaleY = ((stream.readUInt8() << 24) | (stream.readUInt8() << 16)) / 1073741824;\n\n      } else if (flags & WE_HAVE_A_TWO_BY_TWO) {\n        component.scaleX  = ((stream.readUInt8() << 24) | (stream.readUInt8() << 16)) / 1073741824;\n        component.scale01 = ((stream.readUInt8() << 24) | (stream.readUInt8() << 16)) / 1073741824;\n        component.scale10 = ((stream.readUInt8() << 24) | (stream.readUInt8() << 16)) / 1073741824;\n        component.scaleY  = ((stream.readUInt8() << 24) | (stream.readUInt8() << 16)) / 1073741824;\n      }\n\n      glyph.components.push(component);\n    }\n\n    if (this._font._variationProcessor) {\n      let points = [];\n      for (let j = 0; j < glyph.components.length; j++) {\n        var component = glyph.components[j];\n        points.push(new Point(true, true, component.dx, component.dy));\n      }\n\n      points.push(...this._getPhantomPoints(glyph));\n\n      this._font._variationProcessor.transformPoints(this.id, points);\n      glyph.phantomPoints = points.splice(-4, 4);\n\n      for (let i = 0; i < points.length; i++) {\n        let point = points[i];\n        glyph.components[i].dx = point.x;\n        glyph.components[i].dy = point.y;\n      }\n    }\n\n    return haveInstructions;\n  }\n\n  _getPhantomPoints(glyph) {\n    let cbox = this._getCBox(true);\n    if (this._metrics == null) {\n      this._metrics = Glyph.prototype._getMetrics.call(this, cbox);\n    }\n\n    let { advanceWidth, advanceHeight, leftBearing, topBearing } = this._metrics;\n\n    return [\n      new Point(false, true, glyph.xMin - leftBearing, 0),\n      new Point(false, true, glyph.xMin - leftBearing + advanceWidth, 0),\n      new Point(false, true, 0, glyph.yMax + topBearing),\n      new Point(false, true, 0, glyph.yMax + topBearing + advanceHeight)\n    ];\n  }\n\n  // Decodes font data, resolves composite glyphs, and returns an array of contours\n  _getContours() {\n    let glyph = this._decode();\n    if (!glyph) {\n      return [];\n    }\n\n    let points = [];\n\n    if (glyph.numberOfContours < 0) {\n      // resolve composite glyphs\n      for (let component of glyph.components) {\n        let contours = this._font.getGlyph(component.glyphID)._getContours();\n        for (let i = 0; i < contours.length; i++) {\n          let contour = contours[i];\n          for (let j = 0; j < contour.length; j++) {\n            let point = contour[j];\n            let x = point.x * component.scaleX + point.y * component.scale01 + component.dx;\n            let y = point.y * component.scaleY + point.x * component.scale10 + component.dy;\n            points.push(new Point(point.onCurve, point.endContour, x, y));\n          }\n        }\n      }\n    } else {\n      points = glyph.points || [];\n    }\n\n    // Recompute and cache metrics if we performed variation processing, and don't have an HVAR table\n    if (glyph.phantomPoints && !this._font.directory.tables.HVAR) {\n      this._metrics.advanceWidth  = glyph.phantomPoints[1].x - glyph.phantomPoints[0].x;\n      this._metrics.advanceHeight = glyph.phantomPoints[3].y - glyph.phantomPoints[2].y;\n      this._metrics.leftBearing   = glyph.xMin - glyph.phantomPoints[0].x;\n      this._metrics.topBearing    = glyph.phantomPoints[2].y - glyph.yMax;\n    }\n\n    let contours = [];\n    let cur = [];\n    for (let k = 0; k < points.length; k++) {\n      var point = points[k];\n      cur.push(point);\n      if (point.endContour) {\n        contours.push(cur);\n        cur = [];\n      }\n    }\n\n    return contours;\n  }\n\n  _getMetrics() {\n    if (this._metrics) {\n      return this._metrics;\n    }\n\n    let cbox = this._getCBox(true);\n    super._getMetrics(cbox);\n\n    if (this._font._variationProcessor && !this._font.HVAR) {\n      // No HVAR table, decode the glyph. This triggers recomputation of metrics.\n      this.path;\n    }\n\n    return this._metrics;\n  }\n\n  // Converts contours to a Path object that can be rendered\n  _getPath() {\n    let contours = this._getContours();\n    let path = new Path;\n\n    for (let i = 0; i < contours.length; i++) {\n      let contour = contours[i];\n      let firstPt = contour[0];\n      let lastPt = contour[contour.length - 1];\n      let start = 0;\n\n      if (firstPt.onCurve) {\n        // The first point will be consumed by the moveTo command, so skip in the loop\n        var curvePt = null;\n        start = 1;\n      } else {\n        if (lastPt.onCurve) {\n          // Start at the last point if the first point is off curve and the last point is on curve\n          firstPt = lastPt;\n        } else {\n          // Start at the middle if both the first and last points are off curve\n          firstPt = new Point(false, false, (firstPt.x + lastPt.x) / 2, (firstPt.y + lastPt.y) / 2);\n        }\n\n        var curvePt = firstPt;\n      }\n\n      path.moveTo(firstPt.x, firstPt.y);\n\n      for (let j = start; j < contour.length; j++) {\n        let pt = contour[j];\n        let prevPt = j === 0 ? firstPt : contour[j - 1];\n\n        if (prevPt.onCurve && pt.onCurve) {\n          path.lineTo(pt.x, pt.y);\n\n        } else if (prevPt.onCurve && !pt.onCurve) {\n          var curvePt = pt;\n\n        } else if (!prevPt.onCurve && !pt.onCurve) {\n          let midX = (prevPt.x + pt.x) / 2;\n          let midY = (prevPt.y + pt.y) / 2;\n          path.quadraticCurveTo(prevPt.x, prevPt.y, midX, midY);\n          var curvePt = pt;\n\n        } else if (!prevPt.onCurve && pt.onCurve) {\n          path.quadraticCurveTo(curvePt.x, curvePt.y, pt.x, pt.y);\n          var curvePt = null;\n\n        } else {\n          throw new Error(\"Unknown TTF path state\");\n        }\n      }\n\n      // Connect the first and last points\n      if (curvePt) {\n        path.quadraticCurveTo(curvePt.x, curvePt.y, firstPt.x, firstPt.y);\n      }\n\n      path.closePath();\n    }\n\n    return path;\n  }\n}\n","import Glyph from './Glyph';\nimport Path from './Path';\n\n/**\n * Represents an OpenType PostScript glyph, in the Compact Font Format.\n */\nexport default class CFFGlyph extends Glyph {\n  _getName() {\n    if (this._font.CFF2) {\n      return super._getName();\n    }\n\n    return this._font['CFF '].getGlyphName(this.id);\n  }\n\n  bias(s) {\n    if (s.length < 1240) {\n      return 107;\n    } else if (s.length < 33900) {\n      return 1131;\n    } else {\n      return 32768;\n    }\n  }\n\n  _getPath() {\n    let cff = this._font.CFF2 || this._font['CFF '];\n    let { stream } = cff;\n    let str = cff.topDict.CharStrings[this.id];\n    let end = str.offset + str.length;\n    stream.pos = str.offset;\n\n    let path = new Path;\n    let stack = [];\n    let trans = [];\n\n    let width = null;\n    let nStems = 0;\n    let x = 0, y = 0;\n    let usedGsubrs;\n    let usedSubrs;\n    let open = false;\n\n    this._usedGsubrs = usedGsubrs = {};\n    this._usedSubrs = usedSubrs = {};\n\n    let gsubrs = cff.globalSubrIndex || [];\n    let gsubrsBias = this.bias(gsubrs);\n\n    let privateDict = cff.privateDictForGlyph(this.id) || {};\n    let subrs = privateDict.Subrs || [];\n    let subrsBias = this.bias(subrs);\n\n    let vstore = cff.topDict.vstore && cff.topDict.vstore.itemVariationStore;\n    let vsindex = privateDict.vsindex;\n    let variationProcessor = this._font._variationProcessor;\n\n    function checkWidth() {\n      if (width == null) {\n        width = stack.shift() + privateDict.nominalWidthX;\n      }\n    }\n\n    function parseStems() {\n      if (stack.length % 2 !== 0) {\n        checkWidth();\n      }\n\n      nStems += stack.length >> 1;\n      return stack.length = 0;\n    }\n\n    function moveTo(x, y) {\n      if (open) {\n        path.closePath();\n      }\n\n      path.moveTo(x, y);\n      open = true;\n    }\n\n    let parse = function() {\n      while (stream.pos < end) {\n        let op = stream.readUInt8();\n        if (op < 32) {\n          switch (op) {\n            case 1:  // hstem\n            case 3:  // vstem\n            case 18: // hstemhm\n            case 23: // vstemhm\n              parseStems();\n              break;\n\n            case 4: // vmoveto\n              if (stack.length > 1) {\n                checkWidth();\n              }\n\n              y += stack.shift();\n              moveTo(x, y);\n              break;\n\n            case 5: // rlineto\n              while (stack.length >= 2) {\n                x += stack.shift();\n                y += stack.shift();\n                path.lineTo(x, y);\n              }\n              break;\n\n            case 6: // hlineto\n            case 7: // vlineto\n              let phase = op === 6;\n              while (stack.length >= 1) {\n                if (phase) {\n                  x += stack.shift();\n                } else {\n                  y += stack.shift();\n                }\n\n                path.lineTo(x, y);\n                phase = !phase;\n              }\n              break;\n\n            case 8: // rrcurveto\n              while (stack.length > 0) {\n                var c1x = x + stack.shift();\n                var c1y = y + stack.shift();\n                var c2x = c1x + stack.shift();\n                var c2y = c1y + stack.shift();\n                x = c2x + stack.shift();\n                y = c2y + stack.shift();\n                path.bezierCurveTo(c1x, c1y, c2x, c2y, x, y);\n              }\n              break;\n\n            case 10: // callsubr\n              let index = stack.pop() + subrsBias;\n              let subr = subrs[index];\n              if (subr) {\n                usedSubrs[index] = true;\n                var p = stream.pos;\n                var e = end;\n                stream.pos = subr.offset;\n                end = subr.offset + subr.length;\n                parse();\n                stream.pos = p;\n                end = e;\n              }\n              break;\n\n            case 11: // return\n              if (cff.version >= 2) {\n                break;\n              }\n              return;\n\n            case 14: // endchar\n              if (cff.version >= 2) {\n                break;\n              }\n\n              if (stack.length > 0) {\n                checkWidth();\n              }\n\n              if (open) {\n                path.closePath();\n                open = false;\n              }\n              break;\n\n            case 15: { // vsindex\n              if (cff.version < 2) {\n                throw new Error('vsindex operator not supported in CFF v1');\n              }\n\n              vsindex = stack.pop();\n              break;\n            }\n\n            case 16: { // blend\n              if (cff.version < 2) {\n                throw new Error('blend operator not supported in CFF v1');\n              }\n\n              if (!variationProcessor) {\n                throw new Error('blend operator in non-variation font');\n              }\n\n              let blendVector = variationProcessor.getBlendVector(vstore, vsindex);\n              let numBlends = stack.pop();\n              let numOperands = numBlends * blendVector.length;\n              let delta = stack.length - numOperands;\n              let base = delta - numBlends;\n\n              for (let i = 0; i < numBlends; i++) {\n                let sum = stack[base + i];\n                for (let j = 0; j < blendVector.length; j++) {\n                  sum += blendVector[j] * stack[delta++];\n                }\n\n                stack[base + i] = sum;\n              }\n\n              while (numOperands--) {\n                stack.pop();\n              }\n\n              break;\n            }\n\n            case 19: // hintmask\n            case 20: // cntrmask\n              parseStems();\n              stream.pos += (nStems + 7) >> 3;\n              break;\n\n            case 21: // rmoveto\n              if (stack.length > 2) {\n                checkWidth();\n              }\n\n              x += stack.shift();\n              y += stack.shift();\n              moveTo(x, y);\n              break;\n\n            case 22: // hmoveto\n              if (stack.length > 1) {\n                checkWidth();\n              }\n\n              x += stack.shift();\n              moveTo(x, y);\n              break;\n\n            case 24: // rcurveline\n              while (stack.length >= 8) {\n                var c1x = x + stack.shift();\n                var c1y = y + stack.shift();\n                var c2x = c1x + stack.shift();\n                var c2y = c1y + stack.shift();\n                x = c2x + stack.shift();\n                y = c2y + stack.shift();\n                path.bezierCurveTo(c1x, c1y, c2x, c2y, x, y);\n              }\n\n              x += stack.shift();\n              y += stack.shift();\n              path.lineTo(x, y);\n              break;\n\n            case 25: // rlinecurve\n              while (stack.length >= 8) {\n                x += stack.shift();\n                y += stack.shift();\n                path.lineTo(x, y);\n              }\n\n              var c1x = x + stack.shift();\n              var c1y = y + stack.shift();\n              var c2x = c1x + stack.shift();\n              var c2y = c1y + stack.shift();\n              x = c2x + stack.shift();\n              y = c2y + stack.shift();\n              path.bezierCurveTo(c1x, c1y, c2x, c2y, x, y);\n              break;\n\n            case 26: // vvcurveto\n              if (stack.length % 2) {\n                x += stack.shift();\n              }\n\n              while (stack.length >= 4) {\n                c1x = x;\n                c1y = y + stack.shift();\n                c2x = c1x + stack.shift();\n                c2y = c1y + stack.shift();\n                x = c2x;\n                y = c2y + stack.shift();\n                path.bezierCurveTo(c1x, c1y, c2x, c2y, x, y);\n              }\n              break;\n\n            case 27: // hhcurveto\n              if (stack.length % 2) {\n                y += stack.shift();\n              }\n\n              while (stack.length >= 4) {\n                c1x = x + stack.shift();\n                c1y = y;\n                c2x = c1x + stack.shift();\n                c2y = c1y + stack.shift();\n                x = c2x + stack.shift();\n                y = c2y;\n                path.bezierCurveTo(c1x, c1y, c2x, c2y, x, y);\n              }\n              break;\n\n            case 28: // shortint\n              stack.push(stream.readInt16BE());\n              break;\n\n            case 29: // callgsubr\n              index = stack.pop() + gsubrsBias;\n              subr = gsubrs[index];\n              if (subr) {\n                usedGsubrs[index] = true;\n                var p = stream.pos;\n                var e = end;\n                stream.pos = subr.offset;\n                end = subr.offset + subr.length;\n                parse();\n                stream.pos = p;\n                end = e;\n              }\n              break;\n\n            case 30: // vhcurveto\n            case 31: // hvcurveto\n              phase = op === 31;\n              while (stack.length >= 4) {\n                if (phase) {\n                  c1x = x + stack.shift();\n                  c1y = y;\n                  c2x = c1x + stack.shift();\n                  c2y = c1y + stack.shift();\n                  y = c2y + stack.shift();\n                  x = c2x + (stack.length === 1 ? stack.shift() : 0);\n                } else {\n                  c1x = x;\n                  c1y = y + stack.shift();\n                  c2x = c1x + stack.shift();\n                  c2y = c1y + stack.shift();\n                  x = c2x + stack.shift();\n                  y = c2y + (stack.length === 1 ? stack.shift() : 0);\n                }\n\n                path.bezierCurveTo(c1x, c1y, c2x, c2y, x, y);\n                phase = !phase;\n              }\n              break;\n\n            case 12:\n              op = stream.readUInt8();\n              switch (op) {\n                case 3: // and\n                  let a = stack.pop();\n                  let b = stack.pop();\n                  stack.push(a && b ? 1 : 0);\n                  break;\n\n                case 4: // or\n                  a = stack.pop();\n                  b = stack.pop();\n                  stack.push(a || b ? 1 : 0);\n                  break;\n\n                case 5: // not\n                  a = stack.pop();\n                  stack.push(a ? 0 : 1);\n                  break;\n\n                case 9: // abs\n                  a = stack.pop();\n                  stack.push(Math.abs(a));\n                  break;\n\n                case 10: // add\n                  a = stack.pop();\n                  b = stack.pop();\n                  stack.push(a + b);\n                  break;\n\n                case 11: // sub\n                  a = stack.pop();\n                  b = stack.pop();\n                  stack.push(a - b);\n                  break;\n\n                case 12: // div\n                  a = stack.pop();\n                  b = stack.pop();\n                  stack.push(a / b);\n                  break;\n\n                case 14: // neg\n                  a = stack.pop();\n                  stack.push(-a);\n                  break;\n\n                case 15: // eq\n                  a = stack.pop();\n                  b = stack.pop();\n                  stack.push(a === b ? 1 : 0);\n                  break;\n\n                case 18: // drop\n                  stack.pop();\n                  break;\n\n                case 20: // put\n                  let val = stack.pop();\n                  let idx = stack.pop();\n                  trans[idx] = val;\n                  break;\n\n                case 21: // get\n                  idx = stack.pop();\n                  stack.push(trans[idx] || 0);\n                  break;\n\n                case 22: // ifelse\n                  let s1 = stack.pop();\n                  let s2 = stack.pop();\n                  let v1 = stack.pop();\n                  let v2 = stack.pop();\n                  stack.push(v1 <= v2 ? s1 : s2);\n                  break;\n\n                case 23: // random\n                  stack.push(Math.random());\n                  break;\n\n                case 24: // mul\n                  a = stack.pop();\n                  b = stack.pop();\n                  stack.push(a * b);\n                  break;\n\n                case 26: // sqrt\n                  a = stack.pop();\n                  stack.push(Math.sqrt(a));\n                  break;\n\n                case 27: // dup\n                  a = stack.pop();\n                  stack.push(a, a);\n                  break;\n\n                case 28: // exch\n                  a = stack.pop();\n                  b = stack.pop();\n                  stack.push(b, a);\n                  break;\n\n                case 29: // index\n                  idx = stack.pop();\n                  if (idx < 0) {\n                    idx = 0;\n                  } else if (idx > stack.length - 1) {\n                    idx = stack.length - 1;\n                  }\n\n                  stack.push(stack[idx]);\n                  break;\n\n                case 30: // roll\n                  let n = stack.pop();\n                  let j = stack.pop();\n\n                  if (j >= 0) {\n                    while (j > 0) {\n                      var t = stack[n - 1];\n                      for (let i = n - 2; i >= 0; i--) {\n                        stack[i + 1] = stack[i];\n                      }\n\n                      stack[0] = t;\n                      j--;\n                    }\n                  } else {\n                    while (j < 0) {\n                      var t = stack[0];\n                      for (let i = 0; i <= n; i++) {\n                        stack[i] = stack[i + 1];\n                      }\n\n                      stack[n - 1] = t;\n                      j++;\n                    }\n                  }\n                  break;\n\n                case 34: // hflex\n                  c1x = x + stack.shift();\n                  c1y = y;\n                  c2x = c1x + stack.shift();\n                  c2y = c1y + stack.shift();\n                  let c3x = c2x + stack.shift();\n                  let c3y = c2y;\n                  let c4x = c3x + stack.shift();\n                  let c4y = c3y;\n                  let c5x = c4x + stack.shift();\n                  let c5y = c4y;\n                  let c6x = c5x + stack.shift();\n                  let c6y = c5y;\n                  x = c6x;\n                  y = c6y;\n\n                  path.bezierCurveTo(c1x, c1y, c2x, c2y, c3x, c3y);\n                  path.bezierCurveTo(c4x, c4y, c5x, c5y, c6x, c6y);\n                  break;\n\n                case 35: // flex\n                  let pts = [];\n\n                  for (let i = 0; i <= 5; i++) {\n                    x += stack.shift();\n                    y += stack.shift();\n                    pts.push(x, y);\n                  }\n\n                  path.bezierCurveTo(...pts.slice(0, 6));\n                  path.bezierCurveTo(...pts.slice(6));\n                  stack.shift(); // fd\n                  break;\n\n                case 36: // hflex1\n                  c1x = x + stack.shift();\n                  c1y = y + stack.shift();\n                  c2x = c1x + stack.shift();\n                  c2y = c1y + stack.shift();\n                  c3x = c2x + stack.shift();\n                  c3y = c2y;\n                  c4x = c3x + stack.shift();\n                  c4y = c3y;\n                  c5x = c4x + stack.shift();\n                  c5y = c4y + stack.shift();\n                  c6x = c5x + stack.shift();\n                  c6y = c5y;\n                  x = c6x;\n                  y = c6y;\n\n                  path.bezierCurveTo(c1x, c1y, c2x, c2y, c3x, c3y);\n                  path.bezierCurveTo(c4x, c4y, c5x, c5y, c6x, c6y);\n                  break;\n\n                case 37: // flex1\n                  let startx = x;\n                  let starty = y;\n\n                  pts = [];\n                  for (let i = 0; i <= 4; i++) {\n                    x += stack.shift();\n                    y += stack.shift();\n                    pts.push(x, y);\n                  }\n\n                  if (Math.abs(x - startx) > Math.abs(y - starty)) { // horizontal\n                    x += stack.shift();\n                    y = starty;\n                  } else {\n                    x = startx;\n                    y += stack.shift();\n                  }\n\n                  pts.push(x, y);\n                  path.bezierCurveTo(...pts.slice(0, 6));\n                  path.bezierCurveTo(...pts.slice(6));\n                  break;\n\n                default:\n                  throw new Error(`Unknown op: 12 ${op}`);\n              }\n              break;\n\n            default:\n              throw new Error(`Unknown op: ${op}`);\n          }\n\n        } else if (op < 247) {\n          stack.push(op - 139);\n        } else if (op < 251) {\n          var b1 = stream.readUInt8();\n          stack.push((op - 247) * 256 + b1 + 108);\n        } else if (op < 255) {\n          var b1 = stream.readUInt8();\n          stack.push(-(op - 251) * 256 - b1 - 108);\n        } else {\n          stack.push(stream.readInt32BE() / 65536);\n        }\n      }\n    };\n\n    parse();\n\n    if (open) {\n      path.closePath();\n    }\n\n    return path;\n  }\n}\n","import TTFGlyph from './TTFGlyph';\nimport r from 'restructure';\n\nlet SBIXImage = new r.Struct({\n  originX: r.uint16,\n  originY: r.uint16,\n  type: new r.String(4),\n  data: new r.Buffer(t => t.parent.buflen - t._currentOffset)\n});\n\n/**\n * Represents a color (e.g. emoji) glyph in Apple's SBIX format.\n */\nexport default class SBIXGlyph extends TTFGlyph {\n  /**\n   * Returns an object representing a glyph image at the given point size.\n   * The object has a data property with a Buffer containing the actual image data,\n   * along with the image type, and origin.\n   *\n   * @param {number} size\n   * @return {object}\n   */\n  getImageForSize(size) {\n    for (let i = 0; i < this._font.sbix.imageTables.length; i++) {\n      var table = this._font.sbix.imageTables[i];\n      if (table.ppem >= size) { break; }\n    }\n\n    let offsets = table.imageOffsets;\n    let start = offsets[this.id];\n    let end = offsets[this.id + 1];\n\n    if (start === end) {\n      return null;\n    }\n\n    this._font.stream.pos = start;\n    return SBIXImage.decode(this._font.stream, {buflen: end - start});\n  }\n\n  render(ctx, size) {\n    let img = this.getImageForSize(size);\n    if (img != null) {\n      let scale = size / this._font.unitsPerEm;\n      ctx.image(img.data, {height: size, x: img.originX, y: (this.bbox.minY - img.originY) * scale});\n    }\n\n    if (this._font.sbix.flags.renderOutlines) {\n      super.render(ctx, size);\n    }\n  }\n}\n","import Glyph from './Glyph';\nimport BBox from './BBox';\n\nclass COLRLayer {\n  constructor(glyph, color) {\n    this.glyph = glyph;\n    this.color = color;\n  }\n}\n\n/**\n * Represents a color (e.g. emoji) glyph in Microsoft's COLR format.\n * Each glyph in this format contain a list of colored layers, each\n * of which  is another vector glyph.\n */\nexport default class COLRGlyph extends Glyph {\n  _getBBox() {\n    let bbox = new BBox;\n    for (let i = 0; i < this.layers.length; i++) {\n      let layer = this.layers[i];\n      let b = layer.glyph.bbox;\n      bbox.addPoint(b.minX, b.minY);\n      bbox.addPoint(b.maxX, b.maxY);\n    }\n\n    return bbox;\n  }\n\n  /**\n   * Returns an array of objects containing the glyph and color for\n   * each layer in the composite color glyph.\n   * @type {object[]}\n   */\n  get layers() {\n    let cpal = this._font.CPAL;\n    let colr = this._font.COLR;\n    let low = 0;\n    let high = colr.baseGlyphRecord.length - 1;\n\n    while (low <= high) {\n      let mid = (low + high) >> 1;\n      var rec = colr.baseGlyphRecord[mid];\n\n      if (this.id < rec.gid) {\n        high = mid - 1;\n      } else if (this.id > rec.gid) {\n        low = mid + 1;\n      } else {\n        var baseLayer = rec;\n        break;\n      }\n    }\n\n    // if base glyph not found in COLR table,\n    // default to normal glyph from glyf or CFF\n    if (baseLayer == null) {\n      var g = this._font._getBaseGlyph(this.id);\n      var color = {\n        red: 0,\n        green: 0,\n        blue: 0,\n        alpha: 255\n      };\n\n      return [new COLRLayer(g, color)];\n    }\n\n    // otherwise, return an array of all the layers\n    let layers = [];\n    for (let i = baseLayer.firstLayerIndex; i < baseLayer.firstLayerIndex + baseLayer.numLayers; i++) {\n      var rec = colr.layerRecords[i];\n      var color = cpal.colorRecords[rec.paletteIndex];\n      var g = this._font._getBaseGlyph(rec.gid);\n      layers.push(new COLRLayer(g, color));\n    }\n\n    return layers;\n  }\n\n  render(ctx, size) {\n    for (let {glyph, color} of this.layers) {\n      ctx.fillColor([color.red, color.green, color.blue], color.alpha / 255 * 100);\n      glyph.render(ctx, size);\n    }\n\n    return;\n  }\n}\n","const TUPLES_SHARE_POINT_NUMBERS = 0x8000;\nconst TUPLE_COUNT_MASK           = 0x0fff;\nconst EMBEDDED_TUPLE_COORD       = 0x8000;\nconst INTERMEDIATE_TUPLE         = 0x4000;\nconst PRIVATE_POINT_NUMBERS      = 0x2000;\nconst TUPLE_INDEX_MASK           = 0x0fff;\nconst POINTS_ARE_WORDS           = 0x80;\nconst POINT_RUN_COUNT_MASK       = 0x7f;\nconst DELTAS_ARE_ZERO            = 0x80;\nconst DELTAS_ARE_WORDS           = 0x40;\nconst DELTA_RUN_COUNT_MASK       = 0x3f;\n\n/**\n * This class is transforms TrueType glyphs according to the data from\n * the Apple Advanced Typography variation tables (fvar, gvar, and avar).\n * These tables allow infinite adjustments to glyph weight, width, slant,\n * and optical size without the designer needing to specify every exact style.\n *\n * Apple's documentation for these tables is not great, so thanks to the\n * Freetype project for figuring much of this out.\n *\n * @private\n */\nexport default class GlyphVariationProcessor {\n  constructor(font, coords) {\n    this.font = font;\n    this.normalizedCoords = this.normalizeCoords(coords);\n    this.blendVectors = new Map;\n  }\n\n  normalizeCoords(coords) {\n    // the default mapping is linear along each axis, in two segments:\n    // from the minValue to defaultValue, and from defaultValue to maxValue.\n    let normalized = [];\n    for (var i = 0; i < this.font.fvar.axis.length; i++) {\n      let axis = this.font.fvar.axis[i];\n      if (coords[i] < axis.defaultValue) {\n        normalized.push((coords[i] - axis.defaultValue + Number.EPSILON) / (axis.defaultValue - axis.minValue + Number.EPSILON));\n      } else {\n        normalized.push((coords[i] - axis.defaultValue + Number.EPSILON) / (axis.maxValue - axis.defaultValue + Number.EPSILON));\n      }\n    }\n\n    // if there is an avar table, the normalized value is calculated\n    // by interpolating between the two nearest mapped values.\n    if (this.font.avar) {\n      for (var i = 0; i < this.font.avar.segment.length; i++) {\n        let segment = this.font.avar.segment[i];\n        for (let j = 0; j < segment.correspondence.length; j++) {\n          let pair = segment.correspondence[j];\n          if (j >= 1 && normalized[i] < pair.fromCoord) {\n            let prev = segment.correspondence[j - 1];\n            normalized[i] = ((normalized[i] - prev.fromCoord) * (pair.toCoord - prev.toCoord) + Number.EPSILON) /\n              (pair.fromCoord - prev.fromCoord + Number.EPSILON) +\n              prev.toCoord;\n\n            break;\n          }\n        }\n      }\n    }\n\n    return normalized;\n  }\n\n  transformPoints(gid, glyphPoints) {\n    if (!this.font.fvar || !this.font.gvar) { return; }\n\n    let { gvar } = this.font;\n    if (gid >= gvar.glyphCount) { return; }\n\n    let offset = gvar.offsets[gid];\n    if (offset === gvar.offsets[gid + 1]) { return; }\n\n    // Read the gvar data for this glyph\n    let { stream } = this.font;\n    stream.pos = offset;\n    if (stream.pos >= stream.length) {\n      return;\n    }\n\n    let tupleCount = stream.readUInt16BE();\n    let offsetToData = offset + stream.readUInt16BE();\n\n    if (tupleCount & TUPLES_SHARE_POINT_NUMBERS) {\n      var here = stream.pos;\n      stream.pos = offsetToData;\n      var sharedPoints = this.decodePoints();\n      offsetToData = stream.pos;\n      stream.pos = here;\n    }\n\n    let origPoints = glyphPoints.map(pt => pt.copy());\n\n    tupleCount &= TUPLE_COUNT_MASK;\n    for (let i = 0; i < tupleCount; i++) {\n      let tupleDataSize = stream.readUInt16BE();\n      let tupleIndex = stream.readUInt16BE();\n\n      if (tupleIndex & EMBEDDED_TUPLE_COORD) {\n        var tupleCoords = [];\n        for (let a = 0; a < gvar.axisCount; a++) {\n          tupleCoords.push(stream.readInt16BE() / 16384);\n        }\n\n      } else {\n        if ((tupleIndex & TUPLE_INDEX_MASK) >= gvar.globalCoordCount) {\n          throw new Error('Invalid gvar table');\n        }\n\n        var tupleCoords = gvar.globalCoords[tupleIndex & TUPLE_INDEX_MASK];\n      }\n\n      if (tupleIndex & INTERMEDIATE_TUPLE) {\n        var startCoords = [];\n        for (let a = 0; a < gvar.axisCount; a++) {\n          startCoords.push(stream.readInt16BE() / 16384);\n        }\n\n        var endCoords = [];\n        for (let a = 0; a < gvar.axisCount; a++) {\n          endCoords.push(stream.readInt16BE() / 16384);\n        }\n      }\n\n      // Get the factor at which to apply this tuple\n      let factor = this.tupleFactor(tupleIndex, tupleCoords, startCoords, endCoords);\n      if (factor === 0) {\n        offsetToData += tupleDataSize;\n        continue;\n      }\n\n      var here = stream.pos;\n      stream.pos = offsetToData;\n\n      if (tupleIndex & PRIVATE_POINT_NUMBERS) {\n        var points = this.decodePoints();\n      } else {\n        var points = sharedPoints;\n      }\n\n      // points.length = 0 means there are deltas for all points\n      let nPoints = points.length === 0 ? glyphPoints.length : points.length;\n      let xDeltas = this.decodeDeltas(nPoints);\n      let yDeltas = this.decodeDeltas(nPoints);\n\n      if (points.length === 0) { // all points\n        for (let i = 0; i < glyphPoints.length; i++) {\n          var point = glyphPoints[i];\n          point.x += Math.round(xDeltas[i] * factor);\n          point.y += Math.round(yDeltas[i] * factor);\n        }\n      } else {\n        let outPoints = origPoints.map(pt => pt.copy());\n        let hasDelta = glyphPoints.map(() => false);\n\n        for (let i = 0; i < points.length; i++) {\n          let idx = points[i];\n          if (idx < glyphPoints.length) {\n            let point = outPoints[idx];\n            hasDelta[idx] = true;\n\n            point.x += Math.round(xDeltas[i] * factor);\n            point.y += Math.round(yDeltas[i] * factor);\n          }\n        }\n\n        this.interpolateMissingDeltas(outPoints, origPoints, hasDelta);\n\n        for (let i = 0; i < glyphPoints.length; i++) {\n          let deltaX = outPoints[i].x - origPoints[i].x;\n          let deltaY = outPoints[i].y - origPoints[i].y;\n\n          glyphPoints[i].x += deltaX;\n          glyphPoints[i].y += deltaY;\n        }\n      }\n\n      offsetToData += tupleDataSize;\n      stream.pos = here;\n    }\n  }\n\n  decodePoints() {\n    let stream = this.font.stream;\n    let count = stream.readUInt8();\n\n    if (count & POINTS_ARE_WORDS) {\n      count = (count & POINT_RUN_COUNT_MASK) << 8 | stream.readUInt8();\n    }\n\n    let points = new Uint16Array(count);\n    let i = 0;\n    let point = 0;\n    while (i < count) {\n      let run = stream.readUInt8();\n      let runCount = (run & POINT_RUN_COUNT_MASK) + 1;\n      let fn = run & POINTS_ARE_WORDS ? stream.readUInt16 : stream.readUInt8;\n\n      for (let j = 0; j < runCount && i < count; j++) {\n        point += fn.call(stream);\n        points[i++] = point;\n      }\n    }\n\n    return points;\n  }\n\n  decodeDeltas(count) {\n    let stream = this.font.stream;\n    let i = 0;\n    let deltas = new Int16Array(count);\n\n    while (i < count) {\n      let run = stream.readUInt8();\n      let runCount = (run & DELTA_RUN_COUNT_MASK) + 1;\n\n      if (run & DELTAS_ARE_ZERO) {\n        i += runCount;\n\n      } else {\n        let fn = run & DELTAS_ARE_WORDS ? stream.readInt16BE : stream.readInt8;\n        for (let j = 0; j < runCount && i < count; j++) {\n          deltas[i++] = fn.call(stream);\n        }\n      }\n    }\n\n    return deltas;\n  }\n\n  tupleFactor(tupleIndex, tupleCoords, startCoords, endCoords) {\n    let normalized = this.normalizedCoords;\n    let { gvar } = this.font;\n    let factor = 1;\n\n    for (let i = 0; i < gvar.axisCount; i++) {\n      if (tupleCoords[i] === 0) {\n        continue;\n      }\n\n      if (normalized[i] === 0) {\n        return 0;\n      }\n\n      if ((tupleIndex & INTERMEDIATE_TUPLE) === 0) {\n        if ((normalized[i] < Math.min(0, tupleCoords[i])) ||\n            (normalized[i] > Math.max(0, tupleCoords[i]))) {\n          return 0;\n        }\n\n        factor = (factor * normalized[i] + Number.EPSILON) / (tupleCoords[i] + Number.EPSILON);\n      } else {\n        if ((normalized[i] < startCoords[i]) ||\n            (normalized[i] > endCoords[i])) {\n          return 0;\n\n        } else if (normalized[i] < tupleCoords[i]) {\n          factor = factor * (normalized[i] - startCoords[i] + Number.EPSILON) / (tupleCoords[i] - startCoords[i] + Number.EPSILON);\n\n        } else {\n          factor = factor * (endCoords[i] - normalized[i] + Number.EPSILON) / (endCoords[i] - tupleCoords[i] + Number.EPSILON);\n        }\n      }\n    }\n\n    return factor;\n  }\n\n  // Interpolates points without delta values.\n  // Needed for the Ø and Q glyphs in Skia.\n  // Algorithm from Freetype.\n  interpolateMissingDeltas(points, inPoints, hasDelta) {\n    if (points.length === 0) {\n      return;\n    }\n\n    let point = 0;\n    while (point < points.length) {\n      let firstPoint = point;\n\n      // find the end point of the contour\n      let endPoint = point;\n      let pt = points[endPoint];\n      while (!pt.endContour) {\n        pt = points[++endPoint];\n      }\n\n      // find the first point that has a delta\n      while (point <= endPoint && !hasDelta[point]) {\n        point++;\n      }\n\n      if (point > endPoint) {\n        continue;\n      }\n\n      let firstDelta = point;\n      let curDelta = point;\n      point++;\n\n      while (point <= endPoint) {\n        // find the next point with a delta, and interpolate intermediate points\n        if (hasDelta[point]) {\n          this.deltaInterpolate(curDelta + 1, point - 1, curDelta, point, inPoints, points);\n          curDelta = point;\n        }\n\n        point++;\n      }\n\n      // shift contour if we only have a single delta\n      if (curDelta === firstDelta) {\n        this.deltaShift(firstPoint, endPoint, curDelta, inPoints, points);\n      } else {\n        // otherwise, handle the remaining points at the end and beginning of the contour\n        this.deltaInterpolate(curDelta + 1, endPoint, curDelta, firstDelta, inPoints, points);\n\n        if (firstDelta > 0) {\n          this.deltaInterpolate(firstPoint, firstDelta - 1, curDelta, firstDelta, inPoints, points);\n        }\n      }\n\n      point = endPoint + 1;\n    }\n  }\n\n  deltaInterpolate(p1, p2, ref1, ref2, inPoints, outPoints) {\n    if (p1 > p2) {\n      return;\n    }\n\n    let iterable = ['x', 'y'];\n    for (let i = 0; i < iterable.length; i++) {\n      let k = iterable[i];\n      if (inPoints[ref1][k] > inPoints[ref2][k]) {\n        var p = ref1;\n        ref1 = ref2;\n        ref2 = p;\n      }\n\n      let in1 = inPoints[ref1][k];\n      let in2 = inPoints[ref2][k];\n      let out1 = outPoints[ref1][k];\n      let out2 = outPoints[ref2][k];\n\n      // If the reference points have the same coordinate but different\n      // delta, inferred delta is zero.  Otherwise interpolate.\n      if (in1 !== in2 || out1 === out2) {\n        let scale = in1 === in2 ? 0 : (out2 - out1) / (in2 - in1);\n\n        for (let p = p1; p <= p2; p++) {\n          let out = inPoints[p][k];\n\n          if (out <= in1) {\n            out += out1 - in1;\n          } else if (out >= in2) {\n            out += out2 - in2;\n          } else {\n            out = out1 + (out - in1) * scale;\n          }\n\n          outPoints[p][k] = out;\n        }\n      }\n    }\n  }\n\n  deltaShift(p1, p2, ref, inPoints, outPoints) {\n    let deltaX = outPoints[ref].x - inPoints[ref].x;\n    let deltaY = outPoints[ref].y - inPoints[ref].y;\n\n    if (deltaX === 0 && deltaY === 0) {\n      return;\n    }\n\n    for (let p = p1; p <= p2; p++) {\n      if (p !== ref) {\n        outPoints[p].x += deltaX;\n        outPoints[p].y += deltaY;\n      }\n    }\n  }\n\n  getAdvanceAdjustment(gid, table) {\n    let outerIndex, innerIndex;\n\n    if (table.advanceWidthMapping) {\n      let idx = gid;\n      if (idx >= table.advanceWidthMapping.mapCount) {\n        idx = table.advanceWidthMapping.mapCount - 1;\n      }\n\n      let entryFormat = table.advanceWidthMapping.entryFormat;\n      ({outerIndex, innerIndex} = table.advanceWidthMapping.mapData[idx]);\n    } else {\n      outerIndex = 0;\n      innerIndex = gid;\n    }\n\n    return this.getDelta(table.itemVariationStore, outerIndex, innerIndex);\n  }\n\n  // See pseudo code from `Font Variations Overview'\n  // in the OpenType specification.\n  getDelta(itemStore, outerIndex, innerIndex) {\n    if (outerIndex >= itemStore.itemVariationData.length) {\n      return 0;\n    }\n\n    let varData = itemStore.itemVariationData[outerIndex];\n    if (innerIndex >= varData.deltaSets.length) {\n      return 0;\n    }\n\n    let deltaSet = varData.deltaSets[innerIndex];\n    let blendVector = this.getBlendVector(itemStore, outerIndex);\n    let netAdjustment = 0;\n\n    for (let master = 0; master < varData.regionIndexCount; master++) {\n      netAdjustment += deltaSet.deltas[master] * blendVector[master];\n    }\n\n    return netAdjustment;\n  }\n\n  getBlendVector(itemStore, outerIndex) {\n    let varData = itemStore.itemVariationData[outerIndex];\n    if (this.blendVectors.has(varData)) {\n      return this.blendVectors.get(varData);\n    }\n\n    let normalizedCoords = this.normalizedCoords;\n    let blendVector = [];\n\n    // outer loop steps through master designs to be blended\n    for (let master = 0; master < varData.regionIndexCount; master++) {\n      let scalar = 1;\n      let regionIndex = varData.regionIndexes[master];\n      let axes = itemStore.variationRegionList.variationRegions[regionIndex];\n\n      // inner loop steps through axes in this region\n      for (let j = 0; j < axes.length; j++) {\n        let axis = axes[j];\n        let axisScalar;\n\n        // compute the scalar contribution of this axis\n        // ignore invalid ranges\n        if (axis.startCoord > axis.peakCoord || axis.peakCoord > axis.endCoord) {\n          axisScalar = 1;\n\n        } else if (axis.startCoord < 0 && axis.endCoord > 0 && axis.peakCoord !== 0) {\n          axisScalar = 1;\n\n        // peak of 0 means ignore this axis\n        } else if (axis.peakCoord === 0) {\n          axisScalar = 1;\n\n        // ignore this region if coords are out of range\n        } else if (normalizedCoords[j] < axis.startCoord || normalizedCoords[j] > axis.endCoord) {\n          axisScalar = 0;\n\n        // calculate a proportional factor\n        } else {\n          if (normalizedCoords[j] === axis.peakCoord) {\n            axisScalar = 1;\n          } else if (normalizedCoords[j] < axis.peakCoord) {\n            axisScalar = (normalizedCoords[j] - axis.startCoord + Number.EPSILON) /\n              (axis.peakCoord - axis.startCoord + Number.EPSILON);\n          } else {\n            axisScalar = (axis.endCoord - normalizedCoords[j] + Number.EPSILON) /\n              (axis.endCoord - axis.peakCoord + Number.EPSILON);\n          }\n        }\n\n        // take product of all the axis scalars\n        scalar *= axisScalar;\n      }\n\n      blendVector[master] = scalar;\n    }\n\n    this.blendVectors.set(varData, blendVector);\n    return blendVector;\n  }\n}\n","import r from 'restructure';\n\nconst resolved = Promise.resolve();\n\nexport default class Subset {\n  constructor(font) {\n    this.font = font;\n    this.glyphs = [];\n    this.mapping = {};\n\n    // always include the missing glyph\n    this.includeGlyph(0);\n  }\n\n  includeGlyph(glyph) {\n    if (typeof glyph === 'object') {\n      glyph = glyph.id;\n    }\n\n    if (this.mapping[glyph] == null) {\n      this.glyphs.push(glyph);\n      this.mapping[glyph] = this.glyphs.length - 1;\n    }\n\n    return this.mapping[glyph];\n  }\n\n  encodeStream() {\n    let s = new r.EncodeStream();\n\n    resolved.then(() => {\n      this.encode(s);\n      return s.end();\n    });\n\n    return s;\n  }\n}\n","import r from 'restructure';\n\n// Flags for simple glyphs\nconst ON_CURVE        = 1 << 0;\nconst X_SHORT_VECTOR  = 1 << 1;\nconst Y_SHORT_VECTOR  = 1 << 2;\nconst REPEAT          = 1 << 3;\nconst SAME_X          = 1 << 4;\nconst SAME_Y          = 1 << 5;\n\nclass Point {\n  static size(val) {\n    return val >= 0 && val <= 255 ? 1 : 2;\n  }\n  \n  static encode(stream, value) {\n    if (value >= 0 && value <= 255) {\n      stream.writeUInt8(value);\n    } else {\n      stream.writeInt16BE(value);\n    }\n  }\n}\n\nlet Glyf = new r.Struct({\n  numberOfContours: r.int16, // if negative, this is a composite glyph\n  xMin: r.int16,\n  yMin: r.int16,\n  xMax: r.int16,\n  yMax: r.int16,\n  endPtsOfContours: new r.Array(r.uint16, 'numberOfContours'),\n  instructions: new r.Array(r.uint8, r.uint16),\n  flags: new r.Array(r.uint8, 0),\n  xPoints: new r.Array(Point, 0),\n  yPoints: new r.Array(Point, 0)\n});\n\n/**\n * Encodes TrueType glyph outlines\n */\nexport default class TTFGlyphEncoder {\n  encodeSimple(path, instructions = []) {\n    let endPtsOfContours = [];\n    let xPoints = [];\n    let yPoints = [];\n    let flags = [];\n    let same = 0;\n    let lastX = 0, lastY = 0, lastFlag = 0;\n    let pointCount = 0;\n    \n    for (let i = 0; i < path.commands.length; i++) {\n      let c = path.commands[i];\n      \n      for (let j = 0; j < c.args.length; j += 2) {\n        let x = c.args[j];\n        let y = c.args[j + 1];\n        let flag = 0;\n        \n        // If the ending point of a quadratic curve is the midpoint\n        // between the control point and the control point of the next\n        // quadratic curve, we can omit the ending point.\n        if (c.command === 'quadraticCurveTo' && j === 2) {\n          let next = path.commands[i + 1];\n          if (next && next.command === 'quadraticCurveTo') {\n            let midX = (lastX + next.args[0]) / 2;\n            let midY = (lastY + next.args[1]) / 2;\n            \n            if (x === midX && y === midY) {\n              continue;\n            }\n          }\n        }\n        \n        // All points except control points are on curve.\n        if (!(c.command === 'quadraticCurveTo' && j === 0)) {\n          flag |= ON_CURVE;\n        }\n        \n        flag = this._encodePoint(x, lastX, xPoints, flag, X_SHORT_VECTOR, SAME_X);\n        flag = this._encodePoint(y, lastY, yPoints, flag, Y_SHORT_VECTOR, SAME_Y);\n        \n        if (flag === lastFlag && same < 255) {\n          flags[flags.length - 1] |= REPEAT;\n          same++;\n        } else {\n          if (same > 0) {\n            flags.push(same);\n            same = 0;\n          }\n      \n          flags.push(flag);\n          lastFlag = flag;\n        }\n        \n        lastX = x;\n        lastY = y;\n        pointCount++;\n      }\n  \n      if (c.command === 'closePath') {\n        endPtsOfContours.push(pointCount - 1);\n      }\n    }\n\n    // Close the path if the last command didn't already\n    if (path.commands.length > 1 && path.commands[path.commands.length - 1].command !== 'closePath') {\n      endPtsOfContours.push(pointCount - 1);\n    }\n    \n    let bbox = path.bbox;\n    let glyf = {\n      numberOfContours: endPtsOfContours.length,\n      xMin: bbox.minX,\n      yMin: bbox.minY,\n      xMax: bbox.maxX,\n      yMax: bbox.maxY,\n      endPtsOfContours: endPtsOfContours,\n      instructions: instructions,\n      flags: flags,\n      xPoints: xPoints,\n      yPoints: yPoints\n    };\n    \n    let size = Glyf.size(glyf);\n    let tail = 4 - (size % 4);\n    \n    let stream = new r.EncodeStream(size + tail);\n    Glyf.encode(stream, glyf);\n    \n    // Align to 4-byte length\n    if (tail !== 0) {\n      stream.fill(0, tail);\n    }\n    \n    return stream.buffer;\n  }\n  \n  _encodePoint(value, last, points, flag, shortFlag, sameFlag) {\n    let diff = value - last;\n    \n    if (value === last) {\n      flag |= sameFlag;\n    } else {\n      if (-255 <= diff && diff <= 255) {\n        flag |= shortFlag;\n        if (diff < 0) {\n          diff = -diff;\n        } else {\n          flag |= sameFlag;\n        }\n      }\n      \n      points.push(diff);\n    }\n    \n    return flag;\n  }\n}\n","import cloneDeep from 'clone';\nimport Subset from './Subset';\nimport Directory from '../tables/directory';\nimport Tables from '../tables';\nimport TTFGlyphEncoder from '../glyph/TTFGlyphEncoder';\n\nexport default class TTFSubset extends Subset {\n  constructor(font) {\n    super(font);\n    this.glyphEncoder = new TTFGlyphEncoder;\n  }\n  \n  _addGlyph(gid) {\n    let glyph = this.font.getGlyph(gid);\n    let glyf = glyph._decode();\n\n    // get the offset to the glyph from the loca table\n    let curOffset = this.font.loca.offsets[gid];\n    let nextOffset = this.font.loca.offsets[gid + 1];\n\n    let stream = this.font._getTableStream('glyf');\n    stream.pos += curOffset;\n\n    let buffer = stream.readBuffer(nextOffset - curOffset);\n\n    // if it is a compound glyph, include its components\n    if (glyf && glyf.numberOfContours < 0) {\n      buffer = new Buffer(buffer);\n      for (let component of glyf.components) {\n        gid = this.includeGlyph(component.glyphID);\n        buffer.writeUInt16BE(gid, component.pos);\n      }\n    } else if (glyf && this.font._variationProcessor) {\n      // If this is a TrueType variation glyph, re-encode the path\n      buffer = this.glyphEncoder.encodeSimple(glyph.path, glyf.instructions);\n    }\n\n    this.glyf.push(buffer);\n    this.loca.offsets.push(this.offset);\n    \n    this.hmtx.metrics.push({\n      advance: glyph.advanceWidth,\n      bearing: glyph._getMetrics().leftBearing\n    });\n\n    this.offset += buffer.length;\n    return this.glyf.length - 1;\n  }\n\n  encode(stream) {\n    // tables required by PDF spec:\n    //   head, hhea, loca, maxp, cvt , prep, glyf, hmtx, fpgm\n    //\n    // additional tables required for standalone fonts:\n    //   name, cmap, OS/2, post\n\n    this.glyf = [];\n    this.offset = 0;\n    this.loca = {\n      offsets: [],\n      version: this.font.loca.version\n    };\n\n    this.hmtx = {\n      metrics: [],\n      bearings: []\n    };\n\n    // include all the glyphs\n    // not using a for loop because we need to support adding more\n    // glyphs to the array as we go, and CoffeeScript caches the length.\n    let i = 0;\n    while (i < this.glyphs.length) {\n      this._addGlyph(this.glyphs[i++]);\n    }\n\n    let maxp = cloneDeep(this.font.maxp);\n    maxp.numGlyphs = this.glyf.length;\n\n    this.loca.offsets.push(this.offset);\n\n    let head = cloneDeep(this.font.head);\n    head.indexToLocFormat = this.loca.version;\n\n    let hhea = cloneDeep(this.font.hhea);\n    hhea.numberOfMetrics = this.hmtx.metrics.length;\n\n    // map = []\n    // for index in [0...256]\n    //     if index < @numGlyphs\n    //         map[index] = index\n    //     else\n    //         map[index] = 0\n    //\n    // cmapTable =\n    //     version: 0\n    //     length: 262\n    //     language: 0\n    //     codeMap: map\n    //\n    // cmap =\n    //     version: 0\n    //     numSubtables: 1\n    //     tables: [\n    //         platformID: 1\n    //         encodingID: 0\n    //         table: cmapTable\n    //     ]\n\n    // TODO: subset prep, cvt, fpgm?\n    Directory.encode(stream, {\n      tables: {\n        head,\n        hhea,\n        loca: this.loca,\n        maxp,\n        'cvt ': this.font['cvt '],\n        prep: this.font.prep,\n        glyf: this.glyf,\n        hmtx: this.hmtx,\n        fpgm: this.font.fpgm\n\n        // name: clone @font.name\n        // 'OS/2': clone @font['OS/2']\n        // post: clone @font.post\n        // cmap: cmap\n      }\n    });\n  }\n}\n","import Subset from './Subset';\nimport CFFTop from '../cff/CFFTop';\nimport CFFPrivateDict from '../cff/CFFPrivateDict';\nimport standardStrings from '../cff/CFFStandardStrings';\n\nexport default class CFFSubset extends Subset {\n  constructor(font) {\n    super(font);\n\n    this.cff = this.font['CFF '];\n    if (!this.cff) {\n      throw new Error('Not a CFF Font');\n    }\n  }\n\n  subsetCharstrings() {\n    this.charstrings = [];\n    let gsubrs = {};\n\n    for (let gid of this.glyphs) {\n      this.charstrings.push(this.cff.getCharString(gid));\n\n      let glyph = this.font.getGlyph(gid);\n      let path = glyph.path; // this causes the glyph to be parsed\n\n      for (let subr in glyph._usedGsubrs) {\n        gsubrs[subr] = true;\n      }\n    }\n\n    this.gsubrs = this.subsetSubrs(this.cff.globalSubrIndex, gsubrs);\n  }\n\n  subsetSubrs(subrs, used) {\n    let res = [];\n    for (let i = 0; i < subrs.length; i++) {\n      let subr = subrs[i];\n      if (used[i]) {\n        this.cff.stream.pos = subr.offset;\n        res.push(this.cff.stream.readBuffer(subr.length));\n      } else {\n        res.push(new Buffer([11])); // return\n      }\n    }\n\n    return res;\n  }\n\n  subsetFontdict(topDict) {\n    topDict.FDArray = [];\n    topDict.FDSelect = {\n      version: 0,\n      fds: []\n    };\n\n    let used_fds = {};\n    let used_subrs = [];\n    for (let gid of this.glyphs) {\n      let fd = this.cff.fdForGlyph(gid);\n      if (fd == null) {\n        continue;\n      }\n\n      if (!used_fds[fd]) {\n        topDict.FDArray.push(Object.assign({}, this.cff.topDict.FDArray[fd]));\n        used_subrs.push({});\n      }\n\n      used_fds[fd] = true;\n      topDict.FDSelect.fds.push(topDict.FDArray.length - 1);\n\n      let glyph = this.font.getGlyph(gid);\n      let path = glyph.path; // this causes the glyph to be parsed\n      for (let subr in glyph._usedSubrs) {\n        used_subrs[used_subrs.length - 1][subr] = true;\n      }\n    }\n\n    for (let i = 0; i < topDict.FDArray.length; i++) {\n      let dict = topDict.FDArray[i];\n      delete dict.FontName;\n      if (dict.Private && dict.Private.Subrs) {\n        dict.Private = Object.assign({}, dict.Private);\n        dict.Private.Subrs = this.subsetSubrs(dict.Private.Subrs, used_subrs[i]);\n      }\n    }\n\n    return;\n  }\n\n  createCIDFontdict(topDict) {\n    let used_subrs = {};\n    for (let gid of this.glyphs) {\n      let glyph = this.font.getGlyph(gid);\n      let path = glyph.path; // this causes the glyph to be parsed\n\n      for (let subr in glyph._usedSubrs) {\n        used_subrs[subr] = true;\n      }\n    }\n\n    let privateDict = Object.assign({}, this.cff.topDict.Private);\n    if (this.cff.topDict.Private && this.cff.topDict.Private.Subrs) {\n      privateDict.Subrs = this.subsetSubrs(this.cff.topDict.Private.Subrs, used_subrs);\n    }\n\n    topDict.FDArray = [{ Private: privateDict }];\n    return topDict.FDSelect = {\n      version: 3,\n      nRanges: 1,\n      ranges: [{ first: 0, fd: 0 }],\n      sentinel: this.charstrings.length\n    };\n  }\n\n  addString(string) {\n    if (!string) {\n      return null;\n    }\n\n    if (!this.strings) {\n      this.strings = [];\n    }\n\n    this.strings.push(string);\n    return standardStrings.length + this.strings.length - 1;\n  }\n\n  encode(stream) {\n    this.subsetCharstrings();\n\n    let charset = {\n      version: this.charstrings.length > 255 ? 2 : 1,\n      ranges: [{ first: 1, nLeft: this.charstrings.length - 2 }]\n    };\n\n    let topDict = Object.assign({}, this.cff.topDict);\n    topDict.Private = null;\n    topDict.charset = charset;\n    topDict.Encoding = null;\n    topDict.CharStrings = this.charstrings;\n\n    for (let key of ['version', 'Notice', 'Copyright', 'FullName', 'FamilyName', 'Weight', 'PostScript', 'BaseFontName', 'FontName']) {\n      topDict[key] = this.addString(this.cff.string(topDict[key]));\n    }\n\n    topDict.ROS = [this.addString('Adobe'), this.addString('Identity'), 0];\n    topDict.CIDCount = this.charstrings.length;\n\n    if (this.cff.isCIDFont) {\n      this.subsetFontdict(topDict);\n    } else {\n      this.createCIDFontdict(topDict);\n    }\n\n    let top = {\n      version: 1,\n      hdrSize: this.cff.hdrSize,\n      offSize: 4,\n      header: this.cff.header,\n      nameIndex: [this.cff.postscriptName],\n      topDictIndex: [topDict],\n      stringIndex: this.strings,\n      globalSubrIndex: this.gsubrs\n    };\n\n    CFFTop.encode(stream, top);\n  }\n}\n","import r from 'restructure';\nimport { cache } from './decorators';\nimport fontkit from './base';\nimport Directory from './tables/directory';\nimport tables from './tables';\nimport CmapProcessor from './CmapProcessor';\nimport LayoutEngine from './layout/LayoutEngine';\nimport TTFGlyph from './glyph/TTFGlyph';\nimport CFFGlyph from './glyph/CFFGlyph';\nimport SBIXGlyph from './glyph/SBIXGlyph';\nimport COLRGlyph from './glyph/COLRGlyph';\nimport GlyphVariationProcessor from './glyph/GlyphVariationProcessor';\nimport TTFSubset from './subset/TTFSubset';\nimport CFFSubset from './subset/CFFSubset';\nimport BBox from './glyph/BBox';\n\n/**\n * This is the base class for all SFNT-based font formats in fontkit.\n * It supports TrueType, and PostScript glyphs, and several color glyph formats.\n */\nexport default class TTFFont {\n  static probe(buffer) {\n    let format = buffer.toString('ascii', 0, 4);\n    return format === 'true' || format === 'OTTO' || format === String.fromCharCode(0, 1, 0, 0);\n  }\n\n  constructor(stream, variationCoords = null) {\n    this.defaultLanguage = null;\n    this.stream = stream;\n    this.variationCoords = variationCoords;\n\n    this._directoryPos = this.stream.pos;\n    this._tables = {};\n    this._glyphs = {};\n    this._decodeDirectory();\n\n    // define properties for each table to lazily parse\n    for (let tag in this.directory.tables) {\n      let table = this.directory.tables[tag];\n      if (tables[tag] && table.length > 0) {\n        Object.defineProperty(this, tag, {\n          get: this._getTable.bind(this, table)\n        });\n      }\n    }\n  }\n\n  setDefaultLanguage(lang = null) {\n    this.defaultLanguage = lang;\n  }\n\n  _getTable(table) {\n    if (!(table.tag in this._tables)) {\n      try {\n        this._tables[table.tag] = this._decodeTable(table);\n      } catch (e) {\n        if (fontkit.logErrors) {\n          console.error(`Error decoding table ${table.tag}`);\n          console.error(e.stack);\n        }\n      }\n    }\n\n    return this._tables[table.tag];\n  }\n\n  _getTableStream(tag) {\n    let table = this.directory.tables[tag];\n    if (table) {\n      this.stream.pos = table.offset;\n      return this.stream;\n    }\n\n    return null;\n  }\n\n  _decodeDirectory() {\n    return this.directory = Directory.decode(this.stream, {_startOffset: 0});\n  }\n\n  _decodeTable(table) {\n    let pos = this.stream.pos;\n\n    let stream = this._getTableStream(table.tag);\n    let result = tables[table.tag].decode(stream, this, table.length);\n\n    this.stream.pos = pos;\n    return result;\n  }\n\n  /**\n   * Gets a string from the font's `name` table\n   * `lang` is a BCP-47 language code.\n   * @return {string}\n   */\n  getName(key, lang = this.defaultLanguage || fontkit.defaultLanguage) {\n    let record = this.name && this.name.records[key];\n    if (record) {\n      // Attempt to retrieve the entry, depending on which translation is available:\n      return (\n          record[lang]\n          || record[this.defaultLanguage]\n          || record[fontkit.defaultLanguage]\n          || record['en']\n          || record[Object.keys(record)[0]] // Seriously, ANY language would be fine\n          || null\n      );\n    }\n\n    return null;\n  }\n\n  /**\n   * The unique PostScript name for this font, e.g. \"Helvetica-Bold\"\n   * @type {string}\n   */\n  get postscriptName() {\n    return this.getName('postscriptName');\n  }\n\n  /**\n   * The font's full name, e.g. \"Helvetica Bold\"\n   * @type {string}\n   */\n  get fullName() {\n    return this.getName('fullName');\n  }\n\n  /**\n   * The font's family name, e.g. \"Helvetica\"\n   * @type {string}\n   */\n  get familyName() {\n    return this.getName('fontFamily');\n  }\n\n  /**\n   * The font's sub-family, e.g. \"Bold\".\n   * @type {string}\n   */\n  get subfamilyName() {\n    return this.getName('fontSubfamily');\n  }\n\n  /**\n   * The font's copyright information\n   * @type {string}\n   */\n  get copyright() {\n    return this.getName('copyright');\n  }\n\n  /**\n   * The font's version number\n   * @type {string}\n   */\n  get version() {\n    return this.getName('version');\n  }\n\n  /**\n   * The font’s [ascender](https://en.wikipedia.org/wiki/Ascender_(typography))\n   * @type {number}\n   */\n  get ascent() {\n    return this.hhea.ascent;\n  }\n\n  /**\n   * The font’s [descender](https://en.wikipedia.org/wiki/Descender)\n   * @type {number}\n   */\n  get descent() {\n    return this.hhea.descent;\n  }\n\n  /**\n   * The amount of space that should be included between lines\n   * @type {number}\n   */\n  get lineGap() {\n    return this.hhea.lineGap;\n  }\n\n  /**\n   * The offset from the normal underline position that should be used\n   * @type {number}\n   */\n  get underlinePosition() {\n    return this.post.underlinePosition;\n  }\n\n  /**\n   * The weight of the underline that should be used\n   * @type {number}\n   */\n  get underlineThickness() {\n    return this.post.underlineThickness;\n  }\n\n  /**\n   * If this is an italic font, the angle the cursor should be drawn at to match the font design\n   * @type {number}\n   */\n  get italicAngle() {\n    return this.post.italicAngle;\n  }\n\n  /**\n   * The height of capital letters above the baseline.\n   * See [here](https://en.wikipedia.org/wiki/Cap_height) for more details.\n   * @type {number}\n   */\n  get capHeight() {\n    let os2 = this['OS/2'];\n    return os2 ? os2.capHeight : this.ascent;\n  }\n\n  /**\n   * The height of lower case letters in the font.\n   * See [here](https://en.wikipedia.org/wiki/X-height) for more details.\n   * @type {number}\n   */\n  get xHeight() {\n    let os2 = this['OS/2'];\n    return os2 ? os2.xHeight : 0;\n  }\n\n  /**\n   * The number of glyphs in the font.\n   * @type {number}\n   */\n  get numGlyphs() {\n    return this.maxp.numGlyphs;\n  }\n\n  /**\n   * The size of the font’s internal coordinate grid\n   * @type {number}\n   */\n  get unitsPerEm() {\n    return this.head.unitsPerEm;\n  }\n\n  /**\n   * The font’s bounding box, i.e. the box that encloses all glyphs in the font.\n   * @type {BBox}\n   */\n  @cache\n  get bbox() {\n    return Object.freeze(new BBox(this.head.xMin, this.head.yMin, this.head.xMax, this.head.yMax));\n  }\n\n  @cache\n  get _cmapProcessor() {\n    return new CmapProcessor(this.cmap);\n  }\n\n  /**\n   * An array of all of the unicode code points supported by the font.\n   * @type {number[]}\n   */\n  @cache\n  get characterSet() {\n    return this._cmapProcessor.getCharacterSet();\n  }\n\n  /**\n   * Returns whether there is glyph in the font for the given unicode code point.\n   *\n   * @param {number} codePoint\n   * @return {boolean}\n   */\n  hasGlyphForCodePoint(codePoint) {\n    return !!this._cmapProcessor.lookup(codePoint);\n  }\n\n  /**\n   * Maps a single unicode code point to a Glyph object.\n   * Does not perform any advanced substitutions (there is no context to do so).\n   *\n   * @param {number} codePoint\n   * @return {Glyph}\n   */\n  glyphForCodePoint(codePoint) {\n    return this.getGlyph(this._cmapProcessor.lookup(codePoint), [codePoint]);\n  }\n\n  /**\n   * Returns an array of Glyph objects for the given string.\n   * This is only a one-to-one mapping from characters to glyphs.\n   * For most uses, you should use font.layout (described below), which\n   * provides a much more advanced mapping supporting AAT and OpenType shaping.\n   *\n   * @param {string} string\n   * @return {Glyph[]}\n   */\n  glyphsForString(string) {\n    let glyphs = [];\n    let len = string.length;\n    let idx = 0;\n    let last = -1;\n    let state = -1;\n\n    while (idx <= len) {\n      let code = 0;\n      let nextState = 0;\n\n      if (idx < len) {\n        // Decode the next codepoint from UTF 16\n        code = string.charCodeAt(idx++);\n        if (0xd800 <= code && code <= 0xdbff && idx < len) {\n          let next = string.charCodeAt(idx);\n          if (0xdc00 <= next && next <= 0xdfff) {\n            idx++;\n            code = ((code & 0x3ff) << 10) + (next & 0x3ff) + 0x10000;\n          }\n        }\n\n        // Compute the next state: 1 if the next codepoint is a variation selector, 0 otherwise.\n        nextState = ((0xfe00 <= code && code <= 0xfe0f) || (0xe0100 <= code && code <= 0xe01ef)) ? 1 : 0;\n      } else {\n        idx++;\n      }\n\n      if (state === 0 && nextState === 1) {\n        // Variation selector following normal codepoint.\n        glyphs.push(this.getGlyph(this._cmapProcessor.lookup(last, code), [last, code]));\n      } else if (state === 0 && nextState === 0) {\n        // Normal codepoint following normal codepoint.\n        glyphs.push(this.glyphForCodePoint(last));\n      }\n\n      last = code;\n      state = nextState;\n    }\n\n    return glyphs;\n  }\n\n  @cache\n  get _layoutEngine() {\n    return new LayoutEngine(this);\n  }\n\n  /**\n   * Returns a GlyphRun object, which includes an array of Glyphs and GlyphPositions for the given string.\n   *\n   * @param {string} string\n   * @param {string[]} [userFeatures]\n   * @param {string} [script]\n   * @param {string} [language]\n   * @param {string} [direction]\n   * @return {GlyphRun}\n   */\n  layout(string, userFeatures, script, language, direction) {\n    return this._layoutEngine.layout(string, userFeatures, script, language, direction);\n  }\n\n  /**\n   * Returns an array of strings that map to the given glyph id.\n   * @param {number} gid - glyph id\n   */\n  stringsForGlyph(gid) {\n    return this._layoutEngine.stringsForGlyph(gid);\n  }\n\n  /**\n   * An array of all [OpenType feature tags](https://www.microsoft.com/typography/otspec/featuretags.htm)\n   * (or mapped AAT tags) supported by the font.\n   * The features parameter is an array of OpenType feature tags to be applied in addition to the default set.\n   * If this is an AAT font, the OpenType feature tags are mapped to AAT features.\n   *\n   * @type {string[]}\n   */\n  get availableFeatures() {\n    return this._layoutEngine.getAvailableFeatures();\n  }\n\n  getAvailableFeatures(script, language) {\n    return this._layoutEngine.getAvailableFeatures(script, language);\n  }\n\n  _getBaseGlyph(glyph, characters = []) {\n    if (!this._glyphs[glyph]) {\n      if (this.directory.tables.glyf) {\n        this._glyphs[glyph] = new TTFGlyph(glyph, characters, this);\n\n      } else if (this.directory.tables['CFF '] || this.directory.tables.CFF2) {\n        this._glyphs[glyph] = new CFFGlyph(glyph, characters, this);\n      }\n    }\n\n    return this._glyphs[glyph] || null;\n  }\n\n  /**\n   * Returns a glyph object for the given glyph id.\n   * You can pass the array of code points this glyph represents for\n   * your use later, and it will be stored in the glyph object.\n   *\n   * @param {number} glyph\n   * @param {number[]} characters\n   * @return {Glyph}\n   */\n  getGlyph(glyph, characters = []) {\n    if (!this._glyphs[glyph]) {\n      if (this.directory.tables.sbix) {\n        this._glyphs[glyph] = new SBIXGlyph(glyph, characters, this);\n\n      } else if ((this.directory.tables.COLR) && (this.directory.tables.CPAL)) {\n        this._glyphs[glyph] = new COLRGlyph(glyph, characters, this);\n\n      } else {\n        this._getBaseGlyph(glyph, characters);\n      }\n    }\n\n    return this._glyphs[glyph] || null;\n  }\n\n  /**\n   * Returns a Subset for this font.\n   * @return {Subset}\n   */\n  createSubset() {\n    if (this.directory.tables['CFF ']) {\n      return new CFFSubset(this);\n    }\n\n    return new TTFSubset(this);\n  }\n\n  /**\n   * Returns an object describing the available variation axes\n   * that this font supports. Keys are setting tags, and values\n   * contain the axis name, range, and default value.\n   *\n   * @type {object}\n   */\n  @cache\n  get variationAxes() {\n    let res = {};\n    if (!this.fvar) {\n      return res;\n    }\n\n    for (let axis of this.fvar.axis) {\n      res[axis.axisTag.trim()] = {\n        name: axis.name.en,\n        min: axis.minValue,\n        default: axis.defaultValue,\n        max: axis.maxValue\n      };\n    }\n\n    return res;\n  }\n\n  /**\n   * Returns an object describing the named variation instances\n   * that the font designer has specified. Keys are variation names\n   * and values are the variation settings for this instance.\n   *\n   * @type {object}\n   */\n  @cache\n  get namedVariations() {\n    let res = {};\n    if (!this.fvar) {\n      return res;\n    }\n\n    for (let instance of this.fvar.instance) {\n      let settings = {};\n      for (let i = 0; i < this.fvar.axis.length; i++) {\n        let axis = this.fvar.axis[i];\n        settings[axis.axisTag.trim()] = instance.coord[i];\n      }\n\n      res[instance.name.en] = settings;\n    }\n\n    return res;\n  }\n\n  /**\n   * Returns a new font with the given variation settings applied.\n   * Settings can either be an instance name, or an object containing\n   * variation tags as specified by the `variationAxes` property.\n   *\n   * @param {object} settings\n   * @return {TTFFont}\n   */\n  getVariation(settings) {\n    if (!(this.directory.tables.fvar && ((this.directory.tables.gvar && this.directory.tables.glyf) || this.directory.tables.CFF2))) {\n      throw new Error('Variations require a font with the fvar, gvar and glyf, or CFF2 tables.');\n    }\n\n    if (typeof settings === 'string') {\n      settings = this.namedVariations[settings];\n    }\n\n    if (typeof settings !== 'object') {\n      throw new Error('Variation settings must be either a variation name or settings object.');\n    }\n\n    // normalize the coordinates\n    let coords = this.fvar.axis.map((axis, i) => {\n      let axisTag = axis.axisTag.trim();\n      if (axisTag in settings) {\n        return Math.max(axis.minValue, Math.min(axis.maxValue, settings[axisTag]));\n      } else {\n        return axis.defaultValue;\n      }\n    });\n\n    let stream = new r.DecodeStream(this.stream.buffer);\n    stream.pos = this._directoryPos;\n\n    let font = new TTFFont(stream, coords);\n    font._tables = this._tables;\n\n    return font;\n  }\n\n  @cache\n  get _variationProcessor() {\n    if (!this.fvar) {\n      return null;\n    }\n\n    let variationCoords = this.variationCoords;\n\n    // Ignore if no variation coords and not CFF2\n    if (!variationCoords && !this.CFF2) {\n      return null;\n    }\n\n    if (!variationCoords) {\n      variationCoords = this.fvar.axis.map(axis => axis.defaultValue);\n    }\n\n    return new GlyphVariationProcessor(this, variationCoords);\n  }\n\n  // Standardized format plugin API\n  getFont(name) {\n    return this.getVariation(name);\n  }\n}\n","import r from 'restructure';\nimport tables from './';\n\nlet WOFFDirectoryEntry = new r.Struct({\n  tag:          new r.String(4),\n  offset:       new r.Pointer(r.uint32, 'void', {type: 'global'}),\n  compLength:   r.uint32,\n  length:       r.uint32,\n  origChecksum: r.uint32\n});\n\nlet WOFFDirectory = new r.Struct({\n  tag:            new r.String(4), // should be 'wOFF'\n  flavor:         r.uint32,\n  length:         r.uint32,\n  numTables:      r.uint16,\n  reserved:       new r.Reserved(r.uint16),\n  totalSfntSize:  r.uint32,\n  majorVersion:   r.uint16,\n  minorVersion:   r.uint16,\n  metaOffset:     r.uint32,\n  metaLength:     r.uint32,\n  metaOrigLength: r.uint32,\n  privOffset:     r.uint32,\n  privLength:     r.uint32,\n  tables:         new r.Array(WOFFDirectoryEntry, 'numTables')\n});\n\nWOFFDirectory.process = function() {\n  let tables = {};\n  for (let table of this.tables) {\n    tables[table.tag] = table;\n  }\n\n  this.tables = tables;\n};\n\nexport default WOFFDirectory;\n","import TTFFont from './TTFFont';\nimport WOFFDirectory from './tables/WOFFDirectory';\nimport tables from './tables';\nimport inflate from 'tiny-inflate';\nimport r from 'restructure';\n\nexport default class WOFFFont extends TTFFont {\n  static probe(buffer) {\n    return buffer.toString('ascii', 0, 4) === 'wOFF';\n  }\n\n  _decodeDirectory() {\n    this.directory = WOFFDirectory.decode(this.stream, { _startOffset: 0 });\n  }\n\n  _getTableStream(tag) {\n    let table = this.directory.tables[tag];\n    if (table) {\n      this.stream.pos = table.offset;\n\n      if (table.compLength < table.length) {\n        this.stream.pos += 2; // skip deflate header\n        let outBuffer = new Buffer(table.length);\n        let buf = inflate(this.stream.readBuffer(table.compLength - 2), outBuffer);\n        return new r.DecodeStream(buf);\n      } else {\n        return this.stream;\n      }\n    }\n\n    return null;\n  }\n}\n","import TTFGlyph from './TTFGlyph';\n\n/**\n * Represents a TrueType glyph in the WOFF2 format, which compresses glyphs differently.\n */\nexport default class WOFF2Glyph extends TTFGlyph {\n  _decode() {\n    // We have to decode in advance (in WOFF2Font), so just return the pre-decoded data.\n    return this._font._transformedGlyphs[this.id];\n  }\n\n  _getCBox() {\n    return this.path.bbox;\n  }\n}\n","import r from 'restructure';\n\nconst Base128 = {\n  decode(stream) {\n    let result = 0;\n    let iterable = [0, 1, 2, 3, 4];\n    for (let j = 0; j < iterable.length; j++) {\n      let i = iterable[j];\n      let code = stream.readUInt8();\n\n      // If any of the top seven bits are set then we're about to overflow.\n      if (result & 0xe0000000) {\n        throw new Error('Overflow');\n      }\n\n      result = (result << 7) | (code & 0x7f);\n      if ((code & 0x80) === 0) {\n        return result;\n      }\n    }\n\n    throw new Error('Bad base 128 number');\n  }\n};\n\nlet knownTags = [\n  'cmap', 'head', 'hhea', 'hmtx', 'maxp', 'name', 'OS/2', 'post', 'cvt ',\n  'fpgm', 'glyf', 'loca', 'prep', 'CFF ', 'VORG', 'EBDT', 'EBLC', 'gasp',\n  'hdmx', 'kern', 'LTSH', 'PCLT', 'VDMX', 'vhea', 'vmtx', 'BASE', 'GDEF',\n  'GPOS', 'GSUB', 'EBSC', 'JSTF', 'MATH', 'CBDT', 'CBLC', 'COLR', 'CPAL',\n  'SVG ', 'sbix', 'acnt', 'avar', 'bdat', 'bloc', 'bsln', 'cvar', 'fdsc',\n  'feat', 'fmtx', 'fvar', 'gvar', 'hsty', 'just', 'lcar', 'mort', 'morx',\n  'opbd', 'prop', 'trak', 'Zapf', 'Silf', 'Glat', 'Gloc', 'Feat', 'Sill'\n];\n\nlet WOFF2DirectoryEntry = new r.Struct({\n  flags: r.uint8,\n  customTag: new r.Optional(new r.String(4), t => (t.flags & 0x3f) === 0x3f),\n  tag: t => t.customTag || knownTags[t.flags & 0x3f],// || (() => { throw new Error(`Bad tag: ${flags & 0x3f}`); })(); },\n  length: Base128,\n  transformVersion: t => (t.flags >>> 6) & 0x03,\n  transformed: t => (t.tag === 'glyf' || t.tag === 'loca') ? t.transformVersion === 0 : t.transformVersion !== 0,\n  transformLength: new r.Optional(Base128, t => t.transformed)\n});\n\nlet WOFF2Directory = new r.Struct({\n  tag: new r.String(4), // should be 'wOF2'\n  flavor: r.uint32,\n  length: r.uint32,\n  numTables: r.uint16,\n  reserved: new r.Reserved(r.uint16),\n  totalSfntSize: r.uint32,\n  totalCompressedSize: r.uint32,\n  majorVersion: r.uint16,\n  minorVersion: r.uint16,\n  metaOffset: r.uint32,\n  metaLength: r.uint32,\n  metaOrigLength: r.uint32,\n  privOffset: r.uint32,\n  privLength: r.uint32,\n  tables: new r.Array(WOFF2DirectoryEntry, 'numTables')\n});\n\nWOFF2Directory.process = function() {\n  let tables = {};\n  for (let i = 0; i < this.tables.length; i++) {\n    let table = this.tables[i];\n    tables[table.tag] = table;\n  }\n\n  return this.tables = tables;\n};\n\nexport default WOFF2Directory;\n","import r from 'restructure';\nimport brotli from 'brotli/decompress';\nimport TTFFont from './TTFFont';\nimport TTFGlyph, { Point } from './glyph/TTFGlyph';\nimport WOFF2Glyph from './glyph/WOFF2Glyph';\nimport WOFF2Directory from './tables/WOFF2Directory';\n\n/**\n * Subclass of TTFFont that represents a TTF/OTF font compressed by WOFF2\n * See spec here: http://www.w3.org/TR/WOFF2/\n */\nexport default class WOFF2Font extends TTFFont {\n  static probe(buffer) {\n    return buffer.toString('ascii', 0, 4) === 'wOF2';\n  }\n\n  _decodeDirectory() {\n    this.directory = WOFF2Directory.decode(this.stream);\n    this._dataPos = this.stream.pos;\n  }\n\n  _decompress() {\n    // decompress data and setup table offsets if we haven't already\n    if (!this._decompressed) {\n      this.stream.pos = this._dataPos;\n      let buffer = this.stream.readBuffer(this.directory.totalCompressedSize);\n\n      let decompressedSize = 0;\n      for (let tag in this.directory.tables) {\n        let entry = this.directory.tables[tag];\n        entry.offset = decompressedSize;\n        decompressedSize += (entry.transformLength != null) ? entry.transformLength : entry.length;\n      }\n\n      let decompressed = brotli(buffer, decompressedSize);\n      if (!decompressed) {\n        throw new Error('Error decoding compressed data in WOFF2');\n      }\n\n      this.stream = new r.DecodeStream(new Buffer(decompressed));\n      this._decompressed = true;\n    }\n  }\n\n  _decodeTable(table) {\n    this._decompress();\n    return super._decodeTable(table);\n  }\n\n  // Override this method to get a glyph and return our\n  // custom subclass if there is a glyf table.\n  _getBaseGlyph(glyph, characters = []) {\n    if (!this._glyphs[glyph]) {\n      if (this.directory.tables.glyf && this.directory.tables.glyf.transformed) {\n        if (!this._transformedGlyphs) { this._transformGlyfTable(); }\n        return this._glyphs[glyph] = new WOFF2Glyph(glyph, characters, this);\n\n      } else {\n        return super._getBaseGlyph(glyph, characters);\n      }\n    }\n  }\n\n  _transformGlyfTable() {\n    this._decompress();\n    this.stream.pos = this.directory.tables.glyf.offset;\n    let table = GlyfTable.decode(this.stream);\n    let glyphs = [];\n\n    for (let index = 0; index < table.numGlyphs; index++) {\n      let glyph = {};\n      let nContours = table.nContours.readInt16BE();\n      glyph.numberOfContours = nContours;\n\n      if (nContours > 0) { // simple glyph\n        let nPoints = [];\n        let totalPoints = 0;\n\n        for (let i = 0; i < nContours; i++) {\n          let r = read255UInt16(table.nPoints);\n          totalPoints += r;\n          nPoints.push(totalPoints);\n        }\n\n        glyph.points = decodeTriplet(table.flags, table.glyphs, totalPoints);\n        for (let i = 0; i < nContours; i++) {\n          glyph.points[nPoints[i] - 1].endContour = true;\n        }\n\n        var instructionSize = read255UInt16(table.glyphs);\n\n      } else if (nContours < 0) { // composite glyph\n        let haveInstructions = TTFGlyph.prototype._decodeComposite.call({ _font: this }, glyph, table.composites);\n        if (haveInstructions) {\n          var instructionSize = read255UInt16(table.glyphs);\n        }\n      }\n\n      glyphs.push(glyph);\n    }\n\n    this._transformedGlyphs = glyphs;\n  }\n}\n\n// Special class that accepts a length and returns a sub-stream for that data\nclass Substream {\n  constructor(length) {\n    this.length = length;\n    this._buf = new r.Buffer(length);\n  }\n\n  decode(stream, parent) {\n    return new r.DecodeStream(this._buf.decode(stream, parent));\n  }\n}\n\n// This struct represents the entire glyf table\nlet GlyfTable = new r.Struct({\n  version: r.uint32,\n  numGlyphs: r.uint16,\n  indexFormat: r.uint16,\n  nContourStreamSize: r.uint32,\n  nPointsStreamSize: r.uint32,\n  flagStreamSize: r.uint32,\n  glyphStreamSize: r.uint32,\n  compositeStreamSize: r.uint32,\n  bboxStreamSize: r.uint32,\n  instructionStreamSize: r.uint32,\n  nContours: new Substream('nContourStreamSize'),\n  nPoints: new Substream('nPointsStreamSize'),\n  flags: new Substream('flagStreamSize'),\n  glyphs: new Substream('glyphStreamSize'),\n  composites: new Substream('compositeStreamSize'),\n  bboxes: new Substream('bboxStreamSize'),\n  instructions: new Substream('instructionStreamSize')\n});\n\nconst WORD_CODE = 253;\nconst ONE_MORE_BYTE_CODE2 = 254;\nconst ONE_MORE_BYTE_CODE1 = 255;\nconst LOWEST_U_CODE = 253;\n\nfunction read255UInt16(stream) {\n  let code = stream.readUInt8();\n\n  if (code === WORD_CODE) {\n    return stream.readUInt16BE();\n  }\n\n  if (code === ONE_MORE_BYTE_CODE1) {\n    return stream.readUInt8() + LOWEST_U_CODE;\n  }\n\n  if (code === ONE_MORE_BYTE_CODE2) {\n    return stream.readUInt8() + LOWEST_U_CODE * 2;\n  }\n\n  return code;\n}\n\nfunction withSign(flag, baseval) {\n  return flag & 1 ? baseval : -baseval;\n}\n\nfunction decodeTriplet(flags, glyphs, nPoints) {\n  let y;\n  let x = y = 0;\n  let res = [];\n\n  for (let i = 0; i < nPoints; i++) {\n    let dx = 0, dy = 0;\n    let flag = flags.readUInt8();\n    let onCurve = !(flag >> 7);\n    flag &= 0x7f;\n\n    if (flag < 10) {\n      dx = 0;\n      dy = withSign(flag, ((flag & 14) << 7) + glyphs.readUInt8());\n\n    } else if (flag < 20) {\n      dx = withSign(flag, (((flag - 10) & 14) << 7) + glyphs.readUInt8());\n      dy = 0;\n\n    } else if (flag < 84) {\n      var b0 = flag - 20;\n      var b1 = glyphs.readUInt8();\n      dx = withSign(flag, 1 + (b0 & 0x30) + (b1 >> 4));\n      dy = withSign(flag >> 1, 1 + ((b0 & 0x0c) << 2) + (b1 & 0x0f));\n\n    } else if (flag < 120) {\n      var b0 = flag - 84;\n      dx = withSign(flag, 1 + ((b0 / 12) << 8) + glyphs.readUInt8());\n      dy = withSign(flag >> 1, 1 + (((b0 % 12) >> 2) << 8) + glyphs.readUInt8());\n\n    } else if (flag < 124) {\n      var b1 = glyphs.readUInt8();\n      let b2 = glyphs.readUInt8();\n      dx = withSign(flag, (b1 << 4) + (b2 >> 4));\n      dy = withSign(flag >> 1, ((b2 & 0x0f) << 8) + glyphs.readUInt8());\n\n    } else {\n      dx = withSign(flag, glyphs.readUInt16BE());\n      dy = withSign(flag >> 1, glyphs.readUInt16BE());\n    }\n\n    x += dx;\n    y += dy;\n    res.push(new Point(onCurve, false, x, y));\n  }\n\n  return res;\n}\n","import r from 'restructure';\nimport TTFFont from './TTFFont';\nimport Directory from './tables/directory';\nimport tables from './tables';\n\nlet TTCHeader = new r.VersionedStruct(r.uint32, {\n  0x00010000: {\n    numFonts:   r.uint32,\n    offsets:    new r.Array(r.uint32, 'numFonts')\n  },\n  0x00020000: {\n    numFonts:   r.uint32,\n    offsets:    new r.Array(r.uint32, 'numFonts'),\n    dsigTag:    r.uint32,\n    dsigLength: r.uint32,\n    dsigOffset: r.uint32\n  }\n});\n\nexport default class TrueTypeCollection {\n  static probe(buffer) {\n    return buffer.toString('ascii', 0, 4) === 'ttcf';\n  }\n\n  constructor(stream) {\n    this.stream = stream;\n    if (stream.readString(4) !== 'ttcf') {\n      throw new Error('Not a TrueType collection');\n    }\n\n    this.header = TTCHeader.decode(stream);\n  }\n\n  getFont(name) {\n    for (let offset of this.header.offsets) {\n      let stream = new r.DecodeStream(this.stream.buffer);\n      stream.pos = offset;\n      let font = new TTFFont(stream);\n      if (font.postscriptName === name) {\n        return font;\n      }\n    }\n\n    return null;\n  }\n\n  get fonts() {\n    let fonts = [];\n    for (let offset of this.header.offsets) {\n      let stream = new r.DecodeStream(this.stream.buffer);\n      stream.pos = offset;\n      fonts.push(new TTFFont(stream));\n    }\n\n    return fonts;\n  }\n}\n","import r from 'restructure';\nimport TTFFont from './TTFFont';\n\nlet DFontName = new r.String(r.uint8);\nlet DFontData = new r.Struct({\n  len: r.uint32,\n  buf: new r.Buffer('len')\n});\n\nlet Ref = new r.Struct({\n  id: r.uint16,\n  nameOffset: r.int16,\n  attr: r.uint8,\n  dataOffset: r.uint24,\n  handle: r.uint32\n});\n\nlet Type = new r.Struct({\n  name: new r.String(4),\n  maxTypeIndex: r.uint16,\n  refList: new r.Pointer(r.uint16, new r.Array(Ref, t => t.maxTypeIndex + 1), { type: 'parent' })\n});\n\nlet TypeList = new r.Struct({\n  length: r.uint16,\n  types: new r.Array(Type, t => t.length + 1)\n});\n\nlet DFontMap = new r.Struct({\n  reserved: new r.Reserved(r.uint8, 24),\n  typeList: new r.Pointer(r.uint16, TypeList),\n  nameListOffset: new r.Pointer(r.uint16, 'void')\n});\n\nlet DFontHeader = new r.Struct({\n  dataOffset: r.uint32,\n  map: new r.Pointer(r.uint32, DFontMap),\n  dataLength: r.uint32,\n  mapLength: r.uint32\n});\n\nexport default class DFont {\n  static probe(buffer) {\n    let stream = new r.DecodeStream(buffer);\n\n    try {\n      var header = DFontHeader.decode(stream);\n    } catch (e) {\n      return false;\n    }\n\n    for (let type of header.map.typeList.types) {\n      if (type.name === 'sfnt') {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  constructor(stream) {\n    this.stream = stream;\n    this.header = DFontHeader.decode(this.stream);\n\n    for (let type of this.header.map.typeList.types) {\n      for (let ref of type.refList) {\n        if (ref.nameOffset >= 0) {\n          this.stream.pos = ref.nameOffset + this.header.map.nameListOffset;\n          ref.name = DFontName.decode(this.stream);\n        } else {\n          ref.name = null;\n        }\n      }\n\n      if (type.name === 'sfnt') {\n        this.sfnt = type;\n      }\n    }\n  }\n\n  getFont(name) {\n    if (!this.sfnt) {\n      return null;\n    }\n\n    for (let ref of this.sfnt.refList) {\n      let pos = this.header.dataOffset + ref.dataOffset + 4;\n      let stream = new r.DecodeStream(this.stream.buffer.slice(pos));\n      let font = new TTFFont(stream);\n      if (font.postscriptName === name) {\n        return font;\n      }\n    }\n\n    return null;\n  }\n\n  get fonts() {\n    let fonts = [];\n    for (let ref of this.sfnt.refList) {\n      let pos = this.header.dataOffset + ref.dataOffset + 4;\n      let stream = new r.DecodeStream(this.stream.buffer.slice(pos));\n      fonts.push(new TTFFont(stream));\n    }\n\n    return fonts;\n  }\n}\n","import fontkit from './base';\nimport TTFFont from './TTFFont';\nimport WOFFFont from './WOFFFont';\nimport WOFF2Font from './WOFF2Font';\nimport TrueTypeCollection from './TrueTypeCollection';\nimport DFont from './DFont';\n\n// Register font formats\nfontkit.registerFormat(TTFFont);\nfontkit.registerFormat(WOFFFont);\nfontkit.registerFormat(WOFF2Font);\nfontkit.registerFormat(TrueTypeCollection);\nfontkit.registerFormat(DFont);\n\nexport default fontkit;\n"]},"metadata":{},"sourceType":"script"}