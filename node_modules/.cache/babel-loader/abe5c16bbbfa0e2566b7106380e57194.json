{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar SAFETY_HEIGHT = 15;\n\nvar splitPage = function splitPage(words, availableHeight, getHeight) {\n  var minIndex = 0;\n  var maxIndex = words.length;\n  var currentIndex = void 0;\n  var currentElement = void 0;\n  var result = void 0;\n\n  while (minIndex <= maxIndex) {\n    currentIndex = (minIndex + maxIndex) / 2 | 0;\n    currentElement = getHeight(words.slice(0, currentIndex).join(' '));\n\n    if (currentElement < availableHeight) {\n      result = currentIndex;\n      minIndex = currentIndex + 1;\n    } else if (currentElement >= availableHeight) {\n      maxIndex = currentIndex - 1;\n    }\n  }\n\n  return result || 1;\n};\n\nvar chunkString = exports.chunkString = function chunkString(string, availableHeight, getHeight) {\n  if (availableHeight > SAFETY_HEIGHT) {\n    var words = string.split(' ');\n    var pageIndex = splitPage(words, availableHeight, getHeight);\n    return [words.slice(0, pageIndex).join(' '), words.slice(pageIndex).join(' ')];\n  }\n\n  return ['', string];\n}; // Given an element and an availableHeight, returns a new element that fits\n// into it and edits the original one with the remaining content\n// TODO: split nested children\n\n\nvar splitElement = exports.splitElement = function splitElement(element, availableHeight, getHeight) {\n  var newElement = element.clone();\n  var margin = element.getMargin();\n  var padding = element.getPadding();\n  var lines = chunkString(element.getRawValue(), availableHeight - padding.top - padding.bottom - margin.top - margin.bottom, getHeight);\n  newElement.children = [lines[0]];\n  element.children = [lines[1]];\n  return newElement;\n};","map":{"version":3,"sources":["/Users/kaja/Code/mallar/node_modules/@react-pdf/core/lib/utils/wrapping.js"],"names":["Object","defineProperty","exports","value","SAFETY_HEIGHT","splitPage","words","availableHeight","getHeight","minIndex","maxIndex","length","currentIndex","currentElement","result","slice","join","chunkString","string","split","pageIndex","splitElement","element","newElement","clone","margin","getMargin","padding","getPadding","lines","getRawValue","top","bottom","children"],"mappings":"AAAA;;AAEAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAC3CC,EAAAA,KAAK,EAAE;AADoC,CAA7C;AAGA,IAAIC,aAAa,GAAG,EAApB;;AAEA,IAAIC,SAAS,GAAG,SAASA,SAAT,CAAmBC,KAAnB,EAA0BC,eAA1B,EAA2CC,SAA3C,EAAsD;AACpE,MAAIC,QAAQ,GAAG,CAAf;AACA,MAAIC,QAAQ,GAAGJ,KAAK,CAACK,MAArB;AACA,MAAIC,YAAY,GAAG,KAAK,CAAxB;AACA,MAAIC,cAAc,GAAG,KAAK,CAA1B;AACA,MAAIC,MAAM,GAAG,KAAK,CAAlB;;AAEA,SAAOL,QAAQ,IAAIC,QAAnB,EAA6B;AAC3BE,IAAAA,YAAY,GAAG,CAACH,QAAQ,GAAGC,QAAZ,IAAwB,CAAxB,GAA4B,CAA3C;AACAG,IAAAA,cAAc,GAAGL,SAAS,CAACF,KAAK,CAACS,KAAN,CAAY,CAAZ,EAAeH,YAAf,EAA6BI,IAA7B,CAAkC,GAAlC,CAAD,CAA1B;;AAEA,QAAIH,cAAc,GAAGN,eAArB,EAAsC;AACpCO,MAAAA,MAAM,GAAGF,YAAT;AACAH,MAAAA,QAAQ,GAAGG,YAAY,GAAG,CAA1B;AACD,KAHD,MAGO,IAAIC,cAAc,IAAIN,eAAtB,EAAuC;AAC5CG,MAAAA,QAAQ,GAAGE,YAAY,GAAG,CAA1B;AACD;AACF;;AAED,SAAOE,MAAM,IAAI,CAAjB;AACD,CApBD;;AAsBA,IAAIG,WAAW,GAAGf,OAAO,CAACe,WAAR,GAAsB,SAASA,WAAT,CAAqBC,MAArB,EAA6BX,eAA7B,EAA8CC,SAA9C,EAAyD;AAC/F,MAAID,eAAe,GAAGH,aAAtB,EAAqC;AACnC,QAAIE,KAAK,GAAGY,MAAM,CAACC,KAAP,CAAa,GAAb,CAAZ;AACA,QAAIC,SAAS,GAAGf,SAAS,CAACC,KAAD,EAAQC,eAAR,EAAyBC,SAAzB,CAAzB;AAEA,WAAO,CAACF,KAAK,CAACS,KAAN,CAAY,CAAZ,EAAeK,SAAf,EAA0BJ,IAA1B,CAA+B,GAA/B,CAAD,EAAsCV,KAAK,CAACS,KAAN,CAAYK,SAAZ,EAAuBJ,IAAvB,CAA4B,GAA5B,CAAtC,CAAP;AACD;;AAED,SAAO,CAAC,EAAD,EAAKE,MAAL,CAAP;AACD,CATD,C,CAWA;AACA;AACA;;;AACA,IAAIG,YAAY,GAAGnB,OAAO,CAACmB,YAAR,GAAuB,SAASA,YAAT,CAAsBC,OAAtB,EAA+Bf,eAA/B,EAAgDC,SAAhD,EAA2D;AACnG,MAAIe,UAAU,GAAGD,OAAO,CAACE,KAAR,EAAjB;AACA,MAAIC,MAAM,GAAGH,OAAO,CAACI,SAAR,EAAb;AACA,MAAIC,OAAO,GAAGL,OAAO,CAACM,UAAR,EAAd;AAEA,MAAIC,KAAK,GAAGZ,WAAW,CAACK,OAAO,CAACQ,WAAR,EAAD,EAAwBvB,eAAe,GAAGoB,OAAO,CAACI,GAA1B,GAAgCJ,OAAO,CAACK,MAAxC,GAAiDP,MAAM,CAACM,GAAxD,GAA8DN,MAAM,CAACO,MAA7F,EAAqGxB,SAArG,CAAvB;AAEAe,EAAAA,UAAU,CAACU,QAAX,GAAsB,CAACJ,KAAK,CAAC,CAAD,CAAN,CAAtB;AACAP,EAAAA,OAAO,CAACW,QAAR,GAAmB,CAACJ,KAAK,CAAC,CAAD,CAAN,CAAnB;AAEA,SAAON,UAAP;AACD,CAXD","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar SAFETY_HEIGHT = 15;\n\nvar splitPage = function splitPage(words, availableHeight, getHeight) {\n  var minIndex = 0;\n  var maxIndex = words.length;\n  var currentIndex = void 0;\n  var currentElement = void 0;\n  var result = void 0;\n\n  while (minIndex <= maxIndex) {\n    currentIndex = (minIndex + maxIndex) / 2 | 0;\n    currentElement = getHeight(words.slice(0, currentIndex).join(' '));\n\n    if (currentElement < availableHeight) {\n      result = currentIndex;\n      minIndex = currentIndex + 1;\n    } else if (currentElement >= availableHeight) {\n      maxIndex = currentIndex - 1;\n    }\n  }\n\n  return result || 1;\n};\n\nvar chunkString = exports.chunkString = function chunkString(string, availableHeight, getHeight) {\n  if (availableHeight > SAFETY_HEIGHT) {\n    var words = string.split(' ');\n    var pageIndex = splitPage(words, availableHeight, getHeight);\n\n    return [words.slice(0, pageIndex).join(' '), words.slice(pageIndex).join(' ')];\n  }\n\n  return ['', string];\n};\n\n// Given an element and an availableHeight, returns a new element that fits\n// into it and edits the original one with the remaining content\n// TODO: split nested children\nvar splitElement = exports.splitElement = function splitElement(element, availableHeight, getHeight) {\n  var newElement = element.clone();\n  var margin = element.getMargin();\n  var padding = element.getPadding();\n\n  var lines = chunkString(element.getRawValue(), availableHeight - padding.top - padding.bottom - margin.top - margin.bottom, getHeight);\n\n  newElement.children = [lines[0]];\n  element.children = [lines[1]];\n\n  return newElement;\n};"]},"metadata":{},"sourceType":"script"}