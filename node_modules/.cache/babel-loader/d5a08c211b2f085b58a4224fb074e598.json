{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nexports.__esModule = true;\nexports.default = exports.embedEmojis = exports.fetchEmojis = void 0;\n\nvar _emojiRegex = _interopRequireDefault(require(\"emoji-regex\"));\n\nvar _image = _interopRequireDefault(require(\"@react-pdf/image\"));\n/* eslint-disable no-cond-assign */\n// Caches emoji images data\n\n\nconst emojis = {};\nconst regex = (0, _emojiRegex.default)();\n\nconst reflect = promise => (...args) => promise(...args).then(v => v, e => e); // Returns a function to be able to mock resolveImage.\n\n\nconst makeFetchEmojiImage = () => reflect(_image.default);\n/**\n * When an emoji as no color, it might still have 2 parts,\n * the canonical emoji and an empty string.\n * ex.\n *   (no color) Array.from('❤️') => [\"❤\", \"️\"]\n *   (w/ color) Array.from('👍🏿') => [\"👍\", \"🏿\"]\n *\n * The empty string needs to be removed otherwise the generated\n * url will be incorect.\n */\n\n\nconst _removeNoColor = x => x !== '️';\n\nconst getCodePoints = string => Array.from(string).filter(_removeNoColor).map(char => char.codePointAt(0).toString(16)).join('-');\n\nconst buildEmojiUrl = (emoji, source) => {\n  const {\n    url,\n    format\n  } = source;\n  return `${url}${getCodePoints(emoji)}.${format}`;\n};\n\nconst fetchEmojis = (string, source) => {\n  if (!source || !source.url) return [];\n  const promises = [];\n  let match;\n\n  while (match = regex.exec(string)) {\n    const emoji = match[0];\n\n    if (!emojis[emoji] || emojis[emoji].loading) {\n      const emojiUrl = buildEmojiUrl(emoji, source);\n      emojis[emoji] = {\n        loading: true\n      };\n      const fetchEmojiImage = makeFetchEmojiImage();\n      promises.push(fetchEmojiImage({\n        uri: emojiUrl\n      }).then(image => {\n        emojis[emoji].loading = false;\n        emojis[emoji].data = image.data;\n      }));\n    }\n  }\n\n  return promises;\n};\n\nexports.fetchEmojis = fetchEmojis;\n\nconst embedEmojis = fragments => {\n  const result = [];\n\n  for (let i = 0; i < fragments.length; i += 1) {\n    const fragment = fragments[i];\n    let match;\n    let lastIndex = 0;\n\n    while (match = regex.exec(fragment.string)) {\n      const {\n        index\n      } = match;\n      const emoji = match[0];\n      const emojiSize = fragment.attributes.fontSize;\n      const chunk = fragment.string.slice(lastIndex, index + match[0].length); // If emoji image was found, we create a new fragment with the\n      // correct attachment and object substitution character;\n\n      if (emojis[emoji] && emojis[emoji].data) {\n        result.push({\n          string: chunk.replace(match, String.fromCharCode(0xfffc)),\n          attributes: { ...fragment.attributes,\n            attachment: {\n              width: emojiSize,\n              height: emojiSize,\n              yOffset: Math.floor(emojiSize * 0.1),\n              image: emojis[emoji].data\n            }\n          }\n        });\n      } else {\n        // If no emoji data, we just replace the emoji with a nodef char\n        result.push({\n          string: chunk.replace(match, String.fromCharCode(0)),\n          attributes: fragment.attributes\n        });\n      }\n\n      lastIndex = index + emoji.length;\n    }\n\n    if (lastIndex < fragment.string.length) {\n      result.push({\n        string: fragment.string.slice(lastIndex),\n        attributes: fragment.attributes\n      });\n    }\n  }\n\n  return result;\n};\n\nexports.embedEmojis = embedEmojis;\nvar _default = fetchEmojis;\nexports.default = _default;","map":{"version":3,"sources":["/Users/kaja/Code/mallar/app/node_modules/@react-pdf/layout/lib/text/emoji.js"],"names":["_interopRequireDefault","require","exports","__esModule","default","embedEmojis","fetchEmojis","_emojiRegex","_image","emojis","regex","reflect","promise","args","then","v","e","makeFetchEmojiImage","_removeNoColor","x","getCodePoints","string","Array","from","filter","map","char","codePointAt","toString","join","buildEmojiUrl","emoji","source","url","format","promises","match","exec","loading","emojiUrl","fetchEmojiImage","push","uri","image","data","fragments","result","i","length","fragment","lastIndex","index","emojiSize","attributes","fontSize","chunk","slice","replace","String","fromCharCode","attachment","width","height","yOffset","Math","floor","_default"],"mappings":"AAAA;;AAEA,IAAIA,sBAAsB,GAAGC,OAAO,CAAC,8CAAD,CAApC;;AAEAC,OAAO,CAACC,UAAR,GAAqB,IAArB;AACAD,OAAO,CAACE,OAAR,GAAkBF,OAAO,CAACG,WAAR,GAAsBH,OAAO,CAACI,WAAR,GAAsB,KAAK,CAAnE;;AAEA,IAAIC,WAAW,GAAGP,sBAAsB,CAACC,OAAO,CAAC,aAAD,CAAR,CAAxC;;AAEA,IAAIO,MAAM,GAAGR,sBAAsB,CAACC,OAAO,CAAC,kBAAD,CAAR,CAAnC;AAEA;AACA;;;AACA,MAAMQ,MAAM,GAAG,EAAf;AACA,MAAMC,KAAK,GAAG,CAAC,GAAGH,WAAW,CAACH,OAAhB,GAAd;;AAEA,MAAMO,OAAO,GAAGC,OAAO,IAAI,CAAC,GAAGC,IAAJ,KAAaD,OAAO,CAAC,GAAGC,IAAJ,CAAP,CAAiBC,IAAjB,CAAsBC,CAAC,IAAIA,CAA3B,EAA8BC,CAAC,IAAIA,CAAnC,CAAxC,C,CAA+E;;;AAG/E,MAAMC,mBAAmB,GAAG,MAAMN,OAAO,CAACH,MAAM,CAACJ,OAAR,CAAzC;AACA;;;;;;;;;;;;AAYA,MAAMc,cAAc,GAAGC,CAAC,IAAIA,CAAC,KAAK,GAAlC;;AAEA,MAAMC,aAAa,GAAGC,MAAM,IAAIC,KAAK,CAACC,IAAN,CAAWF,MAAX,EAAmBG,MAAnB,CAA0BN,cAA1B,EAA0CO,GAA1C,CAA8CC,IAAI,IAAIA,IAAI,CAACC,WAAL,CAAiB,CAAjB,EAAoBC,QAApB,CAA6B,EAA7B,CAAtD,EAAwFC,IAAxF,CAA6F,GAA7F,CAAhC;;AAEA,MAAMC,aAAa,GAAG,CAACC,KAAD,EAAQC,MAAR,KAAmB;AACvC,QAAM;AACJC,IAAAA,GADI;AAEJC,IAAAA;AAFI,MAGFF,MAHJ;AAIA,SAAQ,GAAEC,GAAI,GAAEb,aAAa,CAACW,KAAD,CAAQ,IAAGG,MAAO,EAA/C;AACD,CAND;;AAQA,MAAM5B,WAAW,GAAG,CAACe,MAAD,EAASW,MAAT,KAAoB;AACtC,MAAI,CAACA,MAAD,IAAW,CAACA,MAAM,CAACC,GAAvB,EAA4B,OAAO,EAAP;AAC5B,QAAME,QAAQ,GAAG,EAAjB;AACA,MAAIC,KAAJ;;AAEA,SAAOA,KAAK,GAAG1B,KAAK,CAAC2B,IAAN,CAAWhB,MAAX,CAAf,EAAmC;AACjC,UAAMU,KAAK,GAAGK,KAAK,CAAC,CAAD,CAAnB;;AAEA,QAAI,CAAC3B,MAAM,CAACsB,KAAD,CAAP,IAAkBtB,MAAM,CAACsB,KAAD,CAAN,CAAcO,OAApC,EAA6C;AAC3C,YAAMC,QAAQ,GAAGT,aAAa,CAACC,KAAD,EAAQC,MAAR,CAA9B;AACAvB,MAAAA,MAAM,CAACsB,KAAD,CAAN,GAAgB;AACdO,QAAAA,OAAO,EAAE;AADK,OAAhB;AAGA,YAAME,eAAe,GAAGvB,mBAAmB,EAA3C;AACAkB,MAAAA,QAAQ,CAACM,IAAT,CAAcD,eAAe,CAAC;AAC5BE,QAAAA,GAAG,EAAEH;AADuB,OAAD,CAAf,CAEXzB,IAFW,CAEN6B,KAAK,IAAI;AACflC,QAAAA,MAAM,CAACsB,KAAD,CAAN,CAAcO,OAAd,GAAwB,KAAxB;AACA7B,QAAAA,MAAM,CAACsB,KAAD,CAAN,CAAca,IAAd,GAAqBD,KAAK,CAACC,IAA3B;AACD,OALa,CAAd;AAMD;AACF;;AAED,SAAOT,QAAP;AACD,CAxBD;;AA0BAjC,OAAO,CAACI,WAAR,GAAsBA,WAAtB;;AAEA,MAAMD,WAAW,GAAGwC,SAAS,IAAI;AAC/B,QAAMC,MAAM,GAAG,EAAf;;AAEA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,SAAS,CAACG,MAA9B,EAAsCD,CAAC,IAAI,CAA3C,EAA8C;AAC5C,UAAME,QAAQ,GAAGJ,SAAS,CAACE,CAAD,CAA1B;AACA,QAAIX,KAAJ;AACA,QAAIc,SAAS,GAAG,CAAhB;;AAEA,WAAOd,KAAK,GAAG1B,KAAK,CAAC2B,IAAN,CAAWY,QAAQ,CAAC5B,MAApB,CAAf,EAA4C;AAC1C,YAAM;AACJ8B,QAAAA;AADI,UAEFf,KAFJ;AAGA,YAAML,KAAK,GAAGK,KAAK,CAAC,CAAD,CAAnB;AACA,YAAMgB,SAAS,GAAGH,QAAQ,CAACI,UAAT,CAAoBC,QAAtC;AACA,YAAMC,KAAK,GAAGN,QAAQ,CAAC5B,MAAT,CAAgBmC,KAAhB,CAAsBN,SAAtB,EAAiCC,KAAK,GAAGf,KAAK,CAAC,CAAD,CAAL,CAASY,MAAlD,CAAd,CAN0C,CAM+B;AACzE;;AAEA,UAAIvC,MAAM,CAACsB,KAAD,CAAN,IAAiBtB,MAAM,CAACsB,KAAD,CAAN,CAAca,IAAnC,EAAyC;AACvCE,QAAAA,MAAM,CAACL,IAAP,CAAY;AACVpB,UAAAA,MAAM,EAAEkC,KAAK,CAACE,OAAN,CAAcrB,KAAd,EAAqBsB,MAAM,CAACC,YAAP,CAAoB,MAApB,CAArB,CADE;AAEVN,UAAAA,UAAU,EAAE,EAAE,GAAGJ,QAAQ,CAACI,UAAd;AACVO,YAAAA,UAAU,EAAE;AACVC,cAAAA,KAAK,EAAET,SADG;AAEVU,cAAAA,MAAM,EAAEV,SAFE;AAGVW,cAAAA,OAAO,EAAEC,IAAI,CAACC,KAAL,CAAWb,SAAS,GAAG,GAAvB,CAHC;AAIVT,cAAAA,KAAK,EAAElC,MAAM,CAACsB,KAAD,CAAN,CAAca;AAJX;AADF;AAFF,SAAZ;AAWD,OAZD,MAYO;AACL;AACAE,QAAAA,MAAM,CAACL,IAAP,CAAY;AACVpB,UAAAA,MAAM,EAAEkC,KAAK,CAACE,OAAN,CAAcrB,KAAd,EAAqBsB,MAAM,CAACC,YAAP,CAAoB,CAApB,CAArB,CADE;AAEVN,UAAAA,UAAU,EAAEJ,QAAQ,CAACI;AAFX,SAAZ;AAID;;AAEDH,MAAAA,SAAS,GAAGC,KAAK,GAAGpB,KAAK,CAACiB,MAA1B;AACD;;AAED,QAAIE,SAAS,GAAGD,QAAQ,CAAC5B,MAAT,CAAgB2B,MAAhC,EAAwC;AACtCF,MAAAA,MAAM,CAACL,IAAP,CAAY;AACVpB,QAAAA,MAAM,EAAE4B,QAAQ,CAAC5B,MAAT,CAAgBmC,KAAhB,CAAsBN,SAAtB,CADE;AAEVG,QAAAA,UAAU,EAAEJ,QAAQ,CAACI;AAFX,OAAZ;AAID;AACF;;AAED,SAAOP,MAAP;AACD,CAjDD;;AAmDA5C,OAAO,CAACG,WAAR,GAAsBA,WAAtB;AACA,IAAI6D,QAAQ,GAAG5D,WAAf;AACAJ,OAAO,CAACE,OAAR,GAAkB8D,QAAlB","sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nexports.__esModule = true;\nexports.default = exports.embedEmojis = exports.fetchEmojis = void 0;\n\nvar _emojiRegex = _interopRequireDefault(require(\"emoji-regex\"));\n\nvar _image = _interopRequireDefault(require(\"@react-pdf/image\"));\n\n/* eslint-disable no-cond-assign */\n// Caches emoji images data\nconst emojis = {};\nconst regex = (0, _emojiRegex.default)();\n\nconst reflect = promise => (...args) => promise(...args).then(v => v, e => e); // Returns a function to be able to mock resolveImage.\n\n\nconst makeFetchEmojiImage = () => reflect(_image.default);\n/**\n * When an emoji as no color, it might still have 2 parts,\n * the canonical emoji and an empty string.\n * ex.\n *   (no color) Array.from('❤️') => [\"❤\", \"️\"]\n *   (w/ color) Array.from('👍🏿') => [\"👍\", \"🏿\"]\n *\n * The empty string needs to be removed otherwise the generated\n * url will be incorect.\n */\n\n\nconst _removeNoColor = x => x !== '️';\n\nconst getCodePoints = string => Array.from(string).filter(_removeNoColor).map(char => char.codePointAt(0).toString(16)).join('-');\n\nconst buildEmojiUrl = (emoji, source) => {\n  const {\n    url,\n    format\n  } = source;\n  return `${url}${getCodePoints(emoji)}.${format}`;\n};\n\nconst fetchEmojis = (string, source) => {\n  if (!source || !source.url) return [];\n  const promises = [];\n  let match;\n\n  while (match = regex.exec(string)) {\n    const emoji = match[0];\n\n    if (!emojis[emoji] || emojis[emoji].loading) {\n      const emojiUrl = buildEmojiUrl(emoji, source);\n      emojis[emoji] = {\n        loading: true\n      };\n      const fetchEmojiImage = makeFetchEmojiImage();\n      promises.push(fetchEmojiImage({\n        uri: emojiUrl\n      }).then(image => {\n        emojis[emoji].loading = false;\n        emojis[emoji].data = image.data;\n      }));\n    }\n  }\n\n  return promises;\n};\n\nexports.fetchEmojis = fetchEmojis;\n\nconst embedEmojis = fragments => {\n  const result = [];\n\n  for (let i = 0; i < fragments.length; i += 1) {\n    const fragment = fragments[i];\n    let match;\n    let lastIndex = 0;\n\n    while (match = regex.exec(fragment.string)) {\n      const {\n        index\n      } = match;\n      const emoji = match[0];\n      const emojiSize = fragment.attributes.fontSize;\n      const chunk = fragment.string.slice(lastIndex, index + match[0].length); // If emoji image was found, we create a new fragment with the\n      // correct attachment and object substitution character;\n\n      if (emojis[emoji] && emojis[emoji].data) {\n        result.push({\n          string: chunk.replace(match, String.fromCharCode(0xfffc)),\n          attributes: { ...fragment.attributes,\n            attachment: {\n              width: emojiSize,\n              height: emojiSize,\n              yOffset: Math.floor(emojiSize * 0.1),\n              image: emojis[emoji].data\n            }\n          }\n        });\n      } else {\n        // If no emoji data, we just replace the emoji with a nodef char\n        result.push({\n          string: chunk.replace(match, String.fromCharCode(0)),\n          attributes: fragment.attributes\n        });\n      }\n\n      lastIndex = index + emoji.length;\n    }\n\n    if (lastIndex < fragment.string.length) {\n      result.push({\n        string: fragment.string.slice(lastIndex),\n        attributes: fragment.attributes\n      });\n    }\n  }\n\n  return result;\n};\n\nexports.embedEmojis = embedEmojis;\nvar _default = fetchEmojis;\nexports.default = _default;"]},"metadata":{},"sourceType":"script"}