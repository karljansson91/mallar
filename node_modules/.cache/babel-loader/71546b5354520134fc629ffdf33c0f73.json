{"ast":null,"code":"/** @license React v16.2.0\n * react-reconciler.development.js\n *\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nif (process.env.NODE_ENV !== \"production\") {\n  // This is a hacky way to ensure third party renderers don't share\n  // top-level module state inside the reconciler. Ideally we should\n  // remove this hack by putting all top-level state into the closures\n  // and then forbidding adding more of it in the reconciler.\n  var $$$reconciler;\n\n  module.exports = function (config) {\n    'use strict';\n\n    var _assign = require('object-assign');\n\n    var invariant = require('fbjs/lib/invariant');\n\n    var warning = require('fbjs/lib/warning');\n\n    var React = require('react');\n\n    var emptyObject = require('fbjs/lib/emptyObject');\n\n    var checkPropTypes = require('prop-types/checkPropTypes');\n\n    var shallowEqual = require('fbjs/lib/shallowEqual');\n    /**\n     * WARNING: DO NOT manually require this module.\n     * This is a replacement for `invariant(...)` used by the error code system\n     * and will _only_ be required by the corresponding babel pass.\n     * It always throws.\n     */\n\n\n    var enableAsyncSubtreeAPI = true; // Exports ReactDOM.createRoot\n\n    var enableUserTimingAPI = true; // Mutating mode (React DOM, React ART, React Native):\n\n    var enableMutatingReconciler = true; // Experimental noop mode (currently unused):\n\n    var enableNoopReconciler = false; // Experimental persistent mode (CS):\n\n    var enablePersistentReconciler = false; // Helps identify side effects in begin-phase lifecycle hooks and setState reducers:\n\n    var debugRenderPhaseSideEffects = false; // Only used in www builds.\n\n    /**\n     * `ReactInstanceMap` maintains a mapping from a public facing stateful\n     * instance (key) and the internal representation (value). This allows public\n     * methods to accept the user facing instance as an argument and map them back\n     * to internal methods.\n     *\n     * Note that this module is currently shared and assumed to be stateless.\n     * If this becomes an actual Map, that will break.\n     */\n\n    /**\n     * This API should be called `delete` but we'd have to make sure to always\n     * transform these to strings for IE support. When this transform is fully\n     * supported we can rename it.\n     */\n\n    function get(key) {\n      return key._reactInternalFiber;\n    }\n\n    function set(key, value) {\n      key._reactInternalFiber = value;\n    }\n\n    var ReactInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n    var ReactCurrentOwner = ReactInternals.ReactCurrentOwner;\n    var ReactDebugCurrentFrame = ReactInternals.ReactDebugCurrentFrame;\n\n    function getComponentName(fiber) {\n      var type = fiber.type;\n\n      if (typeof type === 'string') {\n        return type;\n      }\n\n      if (typeof type === 'function') {\n        return type.displayName || type.name;\n      }\n\n      return null;\n    }\n\n    var IndeterminateComponent = 0; // Before we know whether it is functional or class\n\n    var FunctionalComponent = 1;\n    var ClassComponent = 2;\n    var HostRoot = 3; // Root of a host tree. Could be nested inside another node.\n\n    var HostPortal = 4; // A subtree. Could be an entry point to a different renderer.\n\n    var HostComponent = 5;\n    var HostText = 6;\n    var CallComponent = 7;\n    var CallHandlerPhase = 8;\n    var ReturnComponent = 9;\n    var Fragment = 10; // Don't change these two values:\n\n    var NoEffect = 0; //           0b00000000\n\n    var PerformedWork = 1; //      0b00000001\n    // You can change the rest (and add more).\n\n    var Placement = 2; //          0b00000010\n\n    var Update = 4; //             0b00000100\n\n    var PlacementAndUpdate = 6; // 0b00000110\n\n    var Deletion = 8; //           0b00001000\n\n    var ContentReset = 16; //      0b00010000\n\n    var Callback = 32; //          0b00100000\n\n    var Err = 64; //               0b01000000\n\n    var Ref = 128; //              0b10000000\n\n    var MOUNTING = 1;\n    var MOUNTED = 2;\n    var UNMOUNTED = 3;\n\n    function isFiberMountedImpl(fiber) {\n      var node = fiber;\n\n      if (!fiber.alternate) {\n        // If there is no alternate, this might be a new tree that isn't inserted\n        // yet. If it is, then it will have a pending insertion effect on it.\n        if ((node.effectTag & Placement) !== NoEffect) {\n          return MOUNTING;\n        }\n\n        while (node['return']) {\n          node = node['return'];\n\n          if ((node.effectTag & Placement) !== NoEffect) {\n            return MOUNTING;\n          }\n        }\n      } else {\n        while (node['return']) {\n          node = node['return'];\n        }\n      }\n\n      if (node.tag === HostRoot) {\n        // TODO: Check if this was a nested HostRoot when used with\n        // renderContainerIntoSubtree.\n        return MOUNTED;\n      } // If we didn't hit the root, that means that we're in an disconnected tree\n      // that has been unmounted.\n\n\n      return UNMOUNTED;\n    }\n\n    function isFiberMounted(fiber) {\n      return isFiberMountedImpl(fiber) === MOUNTED;\n    }\n\n    function isMounted(component) {\n      {\n        var owner = ReactCurrentOwner.current;\n\n        if (owner !== null && owner.tag === ClassComponent) {\n          var ownerFiber = owner;\n          var instance = ownerFiber.stateNode;\n          warning(instance._warnedAboutRefsInRender, '%s is accessing isMounted inside its render() function. ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', getComponentName(ownerFiber) || 'A component');\n          instance._warnedAboutRefsInRender = true;\n        }\n      }\n      var fiber = get(component);\n\n      if (!fiber) {\n        return false;\n      }\n\n      return isFiberMountedImpl(fiber) === MOUNTED;\n    }\n\n    function assertIsMounted(fiber) {\n      !(isFiberMountedImpl(fiber) === MOUNTED) ? invariant(false, 'Unable to find node on an unmounted component.') : void 0;\n    }\n\n    function findCurrentFiberUsingSlowPath(fiber) {\n      var alternate = fiber.alternate;\n\n      if (!alternate) {\n        // If there is no alternate, then we only need to check if it is mounted.\n        var state = isFiberMountedImpl(fiber);\n        !(state !== UNMOUNTED) ? invariant(false, 'Unable to find node on an unmounted component.') : void 0;\n\n        if (state === MOUNTING) {\n          return null;\n        }\n\n        return fiber;\n      } // If we have two possible branches, we'll walk backwards up to the root\n      // to see what path the root points to. On the way we may hit one of the\n      // special cases and we'll deal with them.\n\n\n      var a = fiber;\n      var b = alternate;\n\n      while (true) {\n        var parentA = a['return'];\n        var parentB = parentA ? parentA.alternate : null;\n\n        if (!parentA || !parentB) {\n          // We're at the root.\n          break;\n        } // If both copies of the parent fiber point to the same child, we can\n        // assume that the child is current. This happens when we bailout on low\n        // priority: the bailed out fiber's child reuses the current child.\n\n\n        if (parentA.child === parentB.child) {\n          var child = parentA.child;\n\n          while (child) {\n            if (child === a) {\n              // We've determined that A is the current branch.\n              assertIsMounted(parentA);\n              return fiber;\n            }\n\n            if (child === b) {\n              // We've determined that B is the current branch.\n              assertIsMounted(parentA);\n              return alternate;\n            }\n\n            child = child.sibling;\n          } // We should never have an alternate for any mounting node. So the only\n          // way this could possibly happen is if this was unmounted, if at all.\n\n\n          invariant(false, 'Unable to find node on an unmounted component.');\n        }\n\n        if (a['return'] !== b['return']) {\n          // The return pointer of A and the return pointer of B point to different\n          // fibers. We assume that return pointers never criss-cross, so A must\n          // belong to the child set of A.return, and B must belong to the child\n          // set of B.return.\n          a = parentA;\n          b = parentB;\n        } else {\n          // The return pointers point to the same fiber. We'll have to use the\n          // default, slow path: scan the child sets of each parent alternate to see\n          // which child belongs to which set.\n          //\n          // Search parent A's child set\n          var didFindChild = false;\n          var _child = parentA.child;\n\n          while (_child) {\n            if (_child === a) {\n              didFindChild = true;\n              a = parentA;\n              b = parentB;\n              break;\n            }\n\n            if (_child === b) {\n              didFindChild = true;\n              b = parentA;\n              a = parentB;\n              break;\n            }\n\n            _child = _child.sibling;\n          }\n\n          if (!didFindChild) {\n            // Search parent B's child set\n            _child = parentB.child;\n\n            while (_child) {\n              if (_child === a) {\n                didFindChild = true;\n                a = parentB;\n                b = parentA;\n                break;\n              }\n\n              if (_child === b) {\n                didFindChild = true;\n                b = parentB;\n                a = parentA;\n                break;\n              }\n\n              _child = _child.sibling;\n            }\n\n            !didFindChild ? invariant(false, 'Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue.') : void 0;\n          }\n        }\n\n        !(a.alternate === b) ? invariant(false, 'Return fibers should always be each others\\' alternates. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n      } // If the root is not a host container, we're in a disconnected tree. I.e.\n      // unmounted.\n\n\n      !(a.tag === HostRoot) ? invariant(false, 'Unable to find node on an unmounted component.') : void 0;\n\n      if (a.stateNode.current === a) {\n        // We've determined that A is the current branch.\n        return fiber;\n      } // Otherwise B has to be current branch.\n\n\n      return alternate;\n    }\n\n    function findCurrentHostFiber(parent) {\n      var currentParent = findCurrentFiberUsingSlowPath(parent);\n\n      if (!currentParent) {\n        return null;\n      } // Next we'll drill down this component to find the first HostComponent/Text.\n\n\n      var node = currentParent;\n\n      while (true) {\n        if (node.tag === HostComponent || node.tag === HostText) {\n          return node;\n        } else if (node.child) {\n          node.child['return'] = node;\n          node = node.child;\n          continue;\n        }\n\n        if (node === currentParent) {\n          return null;\n        }\n\n        while (!node.sibling) {\n          if (!node['return'] || node['return'] === currentParent) {\n            return null;\n          }\n\n          node = node['return'];\n        }\n\n        node.sibling['return'] = node['return'];\n        node = node.sibling;\n      } // Flow needs the return null here, but ESLint complains about it.\n      // eslint-disable-next-line no-unreachable\n\n\n      return null;\n    }\n\n    function findCurrentHostFiberWithNoPortals(parent) {\n      var currentParent = findCurrentFiberUsingSlowPath(parent);\n\n      if (!currentParent) {\n        return null;\n      } // Next we'll drill down this component to find the first HostComponent/Text.\n\n\n      var node = currentParent;\n\n      while (true) {\n        if (node.tag === HostComponent || node.tag === HostText) {\n          return node;\n        } else if (node.child && node.tag !== HostPortal) {\n          node.child['return'] = node;\n          node = node.child;\n          continue;\n        }\n\n        if (node === currentParent) {\n          return null;\n        }\n\n        while (!node.sibling) {\n          if (!node['return'] || node['return'] === currentParent) {\n            return null;\n          }\n\n          node = node['return'];\n        }\n\n        node.sibling['return'] = node['return'];\n        node = node.sibling;\n      } // Flow needs the return null here, but ESLint complains about it.\n      // eslint-disable-next-line no-unreachable\n\n\n      return null;\n    }\n\n    var valueStack = [];\n    {\n      var fiberStack = [];\n    }\n    var index = -1;\n\n    function createCursor(defaultValue) {\n      return {\n        current: defaultValue\n      };\n    }\n\n    function pop(cursor, fiber) {\n      if (index < 0) {\n        {\n          warning(false, 'Unexpected pop.');\n        }\n        return;\n      }\n\n      {\n        if (fiber !== fiberStack[index]) {\n          warning(false, 'Unexpected Fiber popped.');\n        }\n      }\n      cursor.current = valueStack[index];\n      valueStack[index] = null;\n      {\n        fiberStack[index] = null;\n      }\n      index--;\n    }\n\n    function push(cursor, value, fiber) {\n      index++;\n      valueStack[index] = cursor.current;\n      {\n        fiberStack[index] = fiber;\n      }\n      cursor.current = value;\n    }\n\n    function reset() {\n      while (index > -1) {\n        valueStack[index] = null;\n        {\n          fiberStack[index] = null;\n        }\n        index--;\n      }\n    }\n\n    var describeComponentFrame = function (name, source, ownerName) {\n      return '\\n    in ' + (name || 'Unknown') + (source ? ' (at ' + source.fileName.replace(/^.*[\\\\\\/]/, '') + ':' + source.lineNumber + ')' : ownerName ? ' (created by ' + ownerName + ')' : '');\n    };\n\n    function describeFiber(fiber) {\n      switch (fiber.tag) {\n        case IndeterminateComponent:\n        case FunctionalComponent:\n        case ClassComponent:\n        case HostComponent:\n          var owner = fiber._debugOwner;\n          var source = fiber._debugSource;\n          var name = getComponentName(fiber);\n          var ownerName = null;\n\n          if (owner) {\n            ownerName = getComponentName(owner);\n          }\n\n          return describeComponentFrame(name, source, ownerName);\n\n        default:\n          return '';\n      }\n    } // This function can only be called with a work-in-progress fiber and\n    // only during begin or complete phase. Do not call it under any other\n    // circumstances.\n\n\n    function getStackAddendumByWorkInProgressFiber(workInProgress) {\n      var info = '';\n      var node = workInProgress;\n\n      do {\n        info += describeFiber(node); // Otherwise this return pointer might point to the wrong tree:\n\n        node = node['return'];\n      } while (node);\n\n      return info;\n    }\n\n    function getCurrentFiberOwnerName() {\n      {\n        var fiber = ReactDebugCurrentFiber.current;\n\n        if (fiber === null) {\n          return null;\n        }\n\n        var owner = fiber._debugOwner;\n\n        if (owner !== null && typeof owner !== 'undefined') {\n          return getComponentName(owner);\n        }\n      }\n      return null;\n    }\n\n    function getCurrentFiberStackAddendum() {\n      {\n        var fiber = ReactDebugCurrentFiber.current;\n\n        if (fiber === null) {\n          return null;\n        } // Safe because if current fiber exists, we are reconciling,\n        // and it is guaranteed to be the work-in-progress version.\n\n\n        return getStackAddendumByWorkInProgressFiber(fiber);\n      }\n      return null;\n    }\n\n    function resetCurrentFiber() {\n      ReactDebugCurrentFrame.getCurrentStack = null;\n      ReactDebugCurrentFiber.current = null;\n      ReactDebugCurrentFiber.phase = null;\n    }\n\n    function setCurrentFiber(fiber) {\n      ReactDebugCurrentFrame.getCurrentStack = getCurrentFiberStackAddendum;\n      ReactDebugCurrentFiber.current = fiber;\n      ReactDebugCurrentFiber.phase = null;\n    }\n\n    function setCurrentPhase(phase) {\n      ReactDebugCurrentFiber.phase = phase;\n    }\n\n    var ReactDebugCurrentFiber = {\n      current: null,\n      phase: null,\n      resetCurrentFiber: resetCurrentFiber,\n      setCurrentFiber: setCurrentFiber,\n      setCurrentPhase: setCurrentPhase,\n      getCurrentFiberOwnerName: getCurrentFiberOwnerName,\n      getCurrentFiberStackAddendum: getCurrentFiberStackAddendum\n    }; // Prefix measurements so that it's possible to filter them.\n    // Longer prefixes are hard to read in DevTools.\n\n    var reactEmoji = '\\u269B';\n    var warningEmoji = '\\u26D4';\n    var supportsUserTiming = typeof performance !== 'undefined' && typeof performance.mark === 'function' && typeof performance.clearMarks === 'function' && typeof performance.measure === 'function' && typeof performance.clearMeasures === 'function'; // Keep track of current fiber so that we know the path to unwind on pause.\n    // TODO: this looks the same as nextUnitOfWork in scheduler. Can we unify them?\n\n    var currentFiber = null; // If we're in the middle of user code, which fiber and method is it?\n    // Reusing `currentFiber` would be confusing for this because user code fiber\n    // can change during commit phase too, but we don't need to unwind it (since\n    // lifecycles in the commit phase don't resemble a tree).\n\n    var currentPhase = null;\n    var currentPhaseFiber = null; // Did lifecycle hook schedule an update? This is often a performance problem,\n    // so we will keep track of it, and include it in the report.\n    // Track commits caused by cascading updates.\n\n    var isCommitting = false;\n    var hasScheduledUpdateInCurrentCommit = false;\n    var hasScheduledUpdateInCurrentPhase = false;\n    var commitCountInCurrentWorkLoop = 0;\n    var effectCountInCurrentCommit = 0;\n    var isWaitingForCallback = false; // During commits, we only show a measurement once per method name\n    // to avoid stretch the commit phase with measurement overhead.\n\n    var labelsInCurrentCommit = new Set();\n\n    var formatMarkName = function (markName) {\n      return reactEmoji + ' ' + markName;\n    };\n\n    var formatLabel = function (label, warning$$1) {\n      var prefix = warning$$1 ? warningEmoji + ' ' : reactEmoji + ' ';\n      var suffix = warning$$1 ? ' Warning: ' + warning$$1 : '';\n      return '' + prefix + label + suffix;\n    };\n\n    var beginMark = function (markName) {\n      performance.mark(formatMarkName(markName));\n    };\n\n    var clearMark = function (markName) {\n      performance.clearMarks(formatMarkName(markName));\n    };\n\n    var endMark = function (label, markName, warning$$1) {\n      var formattedMarkName = formatMarkName(markName);\n      var formattedLabel = formatLabel(label, warning$$1);\n\n      try {\n        performance.measure(formattedLabel, formattedMarkName);\n      } catch (err) {} // If previous mark was missing for some reason, this will throw.\n      // This could only happen if React crashed in an unexpected place earlier.\n      // Don't pile on with more errors.\n      // Clear marks immediately to avoid growing buffer.\n\n\n      performance.clearMarks(formattedMarkName);\n      performance.clearMeasures(formattedLabel);\n    };\n\n    var getFiberMarkName = function (label, debugID) {\n      return label + ' (#' + debugID + ')';\n    };\n\n    var getFiberLabel = function (componentName, isMounted, phase) {\n      if (phase === null) {\n        // These are composite component total time measurements.\n        return componentName + ' [' + (isMounted ? 'update' : 'mount') + ']';\n      } else {\n        // Composite component methods.\n        return componentName + '.' + phase;\n      }\n    };\n\n    var beginFiberMark = function (fiber, phase) {\n      var componentName = getComponentName(fiber) || 'Unknown';\n      var debugID = fiber._debugID;\n      var isMounted = fiber.alternate !== null;\n      var label = getFiberLabel(componentName, isMounted, phase);\n\n      if (isCommitting && labelsInCurrentCommit.has(label)) {\n        // During the commit phase, we don't show duplicate labels because\n        // there is a fixed overhead for every measurement, and we don't\n        // want to stretch the commit phase beyond necessary.\n        return false;\n      }\n\n      labelsInCurrentCommit.add(label);\n      var markName = getFiberMarkName(label, debugID);\n      beginMark(markName);\n      return true;\n    };\n\n    var clearFiberMark = function (fiber, phase) {\n      var componentName = getComponentName(fiber) || 'Unknown';\n      var debugID = fiber._debugID;\n      var isMounted = fiber.alternate !== null;\n      var label = getFiberLabel(componentName, isMounted, phase);\n      var markName = getFiberMarkName(label, debugID);\n      clearMark(markName);\n    };\n\n    var endFiberMark = function (fiber, phase, warning$$1) {\n      var componentName = getComponentName(fiber) || 'Unknown';\n      var debugID = fiber._debugID;\n      var isMounted = fiber.alternate !== null;\n      var label = getFiberLabel(componentName, isMounted, phase);\n      var markName = getFiberMarkName(label, debugID);\n      endMark(label, markName, warning$$1);\n    };\n\n    var shouldIgnoreFiber = function (fiber) {\n      // Host components should be skipped in the timeline.\n      // We could check typeof fiber.type, but does this work with RN?\n      switch (fiber.tag) {\n        case HostRoot:\n        case HostComponent:\n        case HostText:\n        case HostPortal:\n        case ReturnComponent:\n        case Fragment:\n          return true;\n\n        default:\n          return false;\n      }\n    };\n\n    var clearPendingPhaseMeasurement = function () {\n      if (currentPhase !== null && currentPhaseFiber !== null) {\n        clearFiberMark(currentPhaseFiber, currentPhase);\n      }\n\n      currentPhaseFiber = null;\n      currentPhase = null;\n      hasScheduledUpdateInCurrentPhase = false;\n    };\n\n    var pauseTimers = function () {\n      // Stops all currently active measurements so that they can be resumed\n      // if we continue in a later deferred loop from the same unit of work.\n      var fiber = currentFiber;\n\n      while (fiber) {\n        if (fiber._debugIsCurrentlyTiming) {\n          endFiberMark(fiber, null, null);\n        }\n\n        fiber = fiber['return'];\n      }\n    };\n\n    var resumeTimersRecursively = function (fiber) {\n      if (fiber['return'] !== null) {\n        resumeTimersRecursively(fiber['return']);\n      }\n\n      if (fiber._debugIsCurrentlyTiming) {\n        beginFiberMark(fiber, null);\n      }\n    };\n\n    var resumeTimers = function () {\n      // Resumes all measurements that were active during the last deferred loop.\n      if (currentFiber !== null) {\n        resumeTimersRecursively(currentFiber);\n      }\n    };\n\n    function recordEffect() {\n      if (enableUserTimingAPI) {\n        effectCountInCurrentCommit++;\n      }\n    }\n\n    function recordScheduleUpdate() {\n      if (enableUserTimingAPI) {\n        if (isCommitting) {\n          hasScheduledUpdateInCurrentCommit = true;\n        }\n\n        if (currentPhase !== null && currentPhase !== 'componentWillMount' && currentPhase !== 'componentWillReceiveProps') {\n          hasScheduledUpdateInCurrentPhase = true;\n        }\n      }\n    }\n\n    function startRequestCallbackTimer() {\n      if (enableUserTimingAPI) {\n        if (supportsUserTiming && !isWaitingForCallback) {\n          isWaitingForCallback = true;\n          beginMark('(Waiting for async callback...)');\n        }\n      }\n    }\n\n    function stopRequestCallbackTimer(didExpire) {\n      if (enableUserTimingAPI) {\n        if (supportsUserTiming) {\n          isWaitingForCallback = false;\n          var warning$$1 = didExpire ? 'React was blocked by main thread' : null;\n          endMark('(Waiting for async callback...)', '(Waiting for async callback...)', warning$$1);\n        }\n      }\n    }\n\n    function startWorkTimer(fiber) {\n      if (enableUserTimingAPI) {\n        if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {\n          return;\n        } // If we pause, this is the fiber to unwind from.\n\n\n        currentFiber = fiber;\n\n        if (!beginFiberMark(fiber, null)) {\n          return;\n        }\n\n        fiber._debugIsCurrentlyTiming = true;\n      }\n    }\n\n    function cancelWorkTimer(fiber) {\n      if (enableUserTimingAPI) {\n        if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {\n          return;\n        } // Remember we shouldn't complete measurement for this fiber.\n        // Otherwise flamechart will be deep even for small updates.\n\n\n        fiber._debugIsCurrentlyTiming = false;\n        clearFiberMark(fiber, null);\n      }\n    }\n\n    function stopWorkTimer(fiber) {\n      if (enableUserTimingAPI) {\n        if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {\n          return;\n        } // If we pause, its parent is the fiber to unwind from.\n\n\n        currentFiber = fiber['return'];\n\n        if (!fiber._debugIsCurrentlyTiming) {\n          return;\n        }\n\n        fiber._debugIsCurrentlyTiming = false;\n        endFiberMark(fiber, null, null);\n      }\n    }\n\n    function stopFailedWorkTimer(fiber) {\n      if (enableUserTimingAPI) {\n        if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {\n          return;\n        } // If we pause, its parent is the fiber to unwind from.\n\n\n        currentFiber = fiber['return'];\n\n        if (!fiber._debugIsCurrentlyTiming) {\n          return;\n        }\n\n        fiber._debugIsCurrentlyTiming = false;\n        var warning$$1 = 'An error was thrown inside this error boundary';\n        endFiberMark(fiber, null, warning$$1);\n      }\n    }\n\n    function startPhaseTimer(fiber, phase) {\n      if (enableUserTimingAPI) {\n        if (!supportsUserTiming) {\n          return;\n        }\n\n        clearPendingPhaseMeasurement();\n\n        if (!beginFiberMark(fiber, phase)) {\n          return;\n        }\n\n        currentPhaseFiber = fiber;\n        currentPhase = phase;\n      }\n    }\n\n    function stopPhaseTimer() {\n      if (enableUserTimingAPI) {\n        if (!supportsUserTiming) {\n          return;\n        }\n\n        if (currentPhase !== null && currentPhaseFiber !== null) {\n          var warning$$1 = hasScheduledUpdateInCurrentPhase ? 'Scheduled a cascading update' : null;\n          endFiberMark(currentPhaseFiber, currentPhase, warning$$1);\n        }\n\n        currentPhase = null;\n        currentPhaseFiber = null;\n      }\n    }\n\n    function startWorkLoopTimer(nextUnitOfWork) {\n      if (enableUserTimingAPI) {\n        currentFiber = nextUnitOfWork;\n\n        if (!supportsUserTiming) {\n          return;\n        }\n\n        commitCountInCurrentWorkLoop = 0; // This is top level call.\n        // Any other measurements are performed within.\n\n        beginMark('(React Tree Reconciliation)'); // Resume any measurements that were in progress during the last loop.\n\n        resumeTimers();\n      }\n    }\n\n    function stopWorkLoopTimer(interruptedBy) {\n      if (enableUserTimingAPI) {\n        if (!supportsUserTiming) {\n          return;\n        }\n\n        var warning$$1 = null;\n\n        if (interruptedBy !== null) {\n          if (interruptedBy.tag === HostRoot) {\n            warning$$1 = 'A top-level update interrupted the previous render';\n          } else {\n            var componentName = getComponentName(interruptedBy) || 'Unknown';\n            warning$$1 = 'An update to ' + componentName + ' interrupted the previous render';\n          }\n        } else if (commitCountInCurrentWorkLoop > 1) {\n          warning$$1 = 'There were cascading updates';\n        }\n\n        commitCountInCurrentWorkLoop = 0; // Pause any measurements until the next loop.\n\n        pauseTimers();\n        endMark('(React Tree Reconciliation)', '(React Tree Reconciliation)', warning$$1);\n      }\n    }\n\n    function startCommitTimer() {\n      if (enableUserTimingAPI) {\n        if (!supportsUserTiming) {\n          return;\n        }\n\n        isCommitting = true;\n        hasScheduledUpdateInCurrentCommit = false;\n        labelsInCurrentCommit.clear();\n        beginMark('(Committing Changes)');\n      }\n    }\n\n    function stopCommitTimer() {\n      if (enableUserTimingAPI) {\n        if (!supportsUserTiming) {\n          return;\n        }\n\n        var warning$$1 = null;\n\n        if (hasScheduledUpdateInCurrentCommit) {\n          warning$$1 = 'Lifecycle hook scheduled a cascading update';\n        } else if (commitCountInCurrentWorkLoop > 0) {\n          warning$$1 = 'Caused by a cascading update in earlier commit';\n        }\n\n        hasScheduledUpdateInCurrentCommit = false;\n        commitCountInCurrentWorkLoop++;\n        isCommitting = false;\n        labelsInCurrentCommit.clear();\n        endMark('(Committing Changes)', '(Committing Changes)', warning$$1);\n      }\n    }\n\n    function startCommitHostEffectsTimer() {\n      if (enableUserTimingAPI) {\n        if (!supportsUserTiming) {\n          return;\n        }\n\n        effectCountInCurrentCommit = 0;\n        beginMark('(Committing Host Effects)');\n      }\n    }\n\n    function stopCommitHostEffectsTimer() {\n      if (enableUserTimingAPI) {\n        if (!supportsUserTiming) {\n          return;\n        }\n\n        var count = effectCountInCurrentCommit;\n        effectCountInCurrentCommit = 0;\n        endMark('(Committing Host Effects: ' + count + ' Total)', '(Committing Host Effects)', null);\n      }\n    }\n\n    function startCommitLifeCyclesTimer() {\n      if (enableUserTimingAPI) {\n        if (!supportsUserTiming) {\n          return;\n        }\n\n        effectCountInCurrentCommit = 0;\n        beginMark('(Calling Lifecycle Methods)');\n      }\n    }\n\n    function stopCommitLifeCyclesTimer() {\n      if (enableUserTimingAPI) {\n        if (!supportsUserTiming) {\n          return;\n        }\n\n        var count = effectCountInCurrentCommit;\n        effectCountInCurrentCommit = 0;\n        endMark('(Calling Lifecycle Methods: ' + count + ' Total)', '(Calling Lifecycle Methods)', null);\n      }\n    }\n\n    {\n      var warnedAboutMissingGetChildContext = {};\n    } // A cursor to the current merged context object on the stack.\n\n    var contextStackCursor = createCursor(emptyObject); // A cursor to a boolean indicating whether the context has changed.\n\n    var didPerformWorkStackCursor = createCursor(false); // Keep track of the previous context object that was on the stack.\n    // We use this to get access to the parent context after we have already\n    // pushed the next context provider, and now need to merge their contexts.\n\n    var previousContext = emptyObject;\n\n    function getUnmaskedContext(workInProgress) {\n      var hasOwnContext = isContextProvider(workInProgress);\n\n      if (hasOwnContext) {\n        // If the fiber is a context provider itself, when we read its context\n        // we have already pushed its own child context on the stack. A context\n        // provider should not \"see\" its own child context. Therefore we read the\n        // previous (parent) context instead for a context provider.\n        return previousContext;\n      }\n\n      return contextStackCursor.current;\n    }\n\n    function cacheContext(workInProgress, unmaskedContext, maskedContext) {\n      var instance = workInProgress.stateNode;\n      instance.__reactInternalMemoizedUnmaskedChildContext = unmaskedContext;\n      instance.__reactInternalMemoizedMaskedChildContext = maskedContext;\n    }\n\n    function getMaskedContext(workInProgress, unmaskedContext) {\n      var type = workInProgress.type;\n      var contextTypes = type.contextTypes;\n\n      if (!contextTypes) {\n        return emptyObject;\n      } // Avoid recreating masked context unless unmasked context has changed.\n      // Failing to do this will result in unnecessary calls to componentWillReceiveProps.\n      // This may trigger infinite loops if componentWillReceiveProps calls setState.\n\n\n      var instance = workInProgress.stateNode;\n\n      if (instance && instance.__reactInternalMemoizedUnmaskedChildContext === unmaskedContext) {\n        return instance.__reactInternalMemoizedMaskedChildContext;\n      }\n\n      var context = {};\n\n      for (var key in contextTypes) {\n        context[key] = unmaskedContext[key];\n      }\n\n      {\n        var name = getComponentName(workInProgress) || 'Unknown';\n        checkPropTypes(contextTypes, context, 'context', name, ReactDebugCurrentFiber.getCurrentFiberStackAddendum);\n      } // Cache unmasked context so we can avoid recreating masked context unless necessary.\n      // Context is created before the class component is instantiated so check for instance.\n\n      if (instance) {\n        cacheContext(workInProgress, unmaskedContext, context);\n      }\n\n      return context;\n    }\n\n    function hasContextChanged() {\n      return didPerformWorkStackCursor.current;\n    }\n\n    function isContextConsumer(fiber) {\n      return fiber.tag === ClassComponent && fiber.type.contextTypes != null;\n    }\n\n    function isContextProvider(fiber) {\n      return fiber.tag === ClassComponent && fiber.type.childContextTypes != null;\n    }\n\n    function popContextProvider(fiber) {\n      if (!isContextProvider(fiber)) {\n        return;\n      }\n\n      pop(didPerformWorkStackCursor, fiber);\n      pop(contextStackCursor, fiber);\n    }\n\n    function popTopLevelContextObject(fiber) {\n      pop(didPerformWorkStackCursor, fiber);\n      pop(contextStackCursor, fiber);\n    }\n\n    function pushTopLevelContextObject(fiber, context, didChange) {\n      !(contextStackCursor.cursor == null) ? invariant(false, 'Unexpected context found on stack. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n      push(contextStackCursor, context, fiber);\n      push(didPerformWorkStackCursor, didChange, fiber);\n    }\n\n    function processChildContext(fiber, parentContext) {\n      var instance = fiber.stateNode;\n      var childContextTypes = fiber.type.childContextTypes; // TODO (bvaughn) Replace this behavior with an invariant() in the future.\n      // It has only been added in Fiber to match the (unintentional) behavior in Stack.\n\n      if (typeof instance.getChildContext !== 'function') {\n        {\n          var componentName = getComponentName(fiber) || 'Unknown';\n\n          if (!warnedAboutMissingGetChildContext[componentName]) {\n            warnedAboutMissingGetChildContext[componentName] = true;\n            warning(false, '%s.childContextTypes is specified but there is no getChildContext() method ' + 'on the instance. You can either define getChildContext() on %s or remove ' + 'childContextTypes from it.', componentName, componentName);\n          }\n        }\n        return parentContext;\n      }\n\n      var childContext = void 0;\n      {\n        ReactDebugCurrentFiber.setCurrentPhase('getChildContext');\n      }\n      startPhaseTimer(fiber, 'getChildContext');\n      childContext = instance.getChildContext();\n      stopPhaseTimer();\n      {\n        ReactDebugCurrentFiber.setCurrentPhase(null);\n      }\n\n      for (var contextKey in childContext) {\n        !(contextKey in childContextTypes) ? invariant(false, '%s.getChildContext(): key \"%s\" is not defined in childContextTypes.', getComponentName(fiber) || 'Unknown', contextKey) : void 0;\n      }\n\n      {\n        var name = getComponentName(fiber) || 'Unknown';\n        checkPropTypes(childContextTypes, childContext, 'child context', name, // In practice, there is one case in which we won't get a stack. It's when\n        // somebody calls unstable_renderSubtreeIntoContainer() and we process\n        // context from the parent component instance. The stack will be missing\n        // because it's outside of the reconciliation, and so the pointer has not\n        // been set. This is rare and doesn't matter. We'll also remove that API.\n        ReactDebugCurrentFiber.getCurrentFiberStackAddendum);\n      }\n      return _assign({}, parentContext, childContext);\n    }\n\n    function pushContextProvider(workInProgress) {\n      if (!isContextProvider(workInProgress)) {\n        return false;\n      }\n\n      var instance = workInProgress.stateNode; // We push the context as early as possible to ensure stack integrity.\n      // If the instance does not exist yet, we will push null at first,\n      // and replace it on the stack later when invalidating the context.\n\n      var memoizedMergedChildContext = instance && instance.__reactInternalMemoizedMergedChildContext || emptyObject; // Remember the parent context so we can merge with it later.\n      // Inherit the parent's did-perform-work value to avoid inadvertently blocking updates.\n\n      previousContext = contextStackCursor.current;\n      push(contextStackCursor, memoizedMergedChildContext, workInProgress);\n      push(didPerformWorkStackCursor, didPerformWorkStackCursor.current, workInProgress);\n      return true;\n    }\n\n    function invalidateContextProvider(workInProgress, didChange) {\n      var instance = workInProgress.stateNode;\n      !instance ? invariant(false, 'Expected to have an instance by this point. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n\n      if (didChange) {\n        // Merge parent and own context.\n        // Skip this if we're not updating due to sCU.\n        // This avoids unnecessarily recomputing memoized values.\n        var mergedContext = processChildContext(workInProgress, previousContext);\n        instance.__reactInternalMemoizedMergedChildContext = mergedContext; // Replace the old (or empty) context with the new one.\n        // It is important to unwind the context in the reverse order.\n\n        pop(didPerformWorkStackCursor, workInProgress);\n        pop(contextStackCursor, workInProgress); // Now push the new context and mark that it has changed.\n\n        push(contextStackCursor, mergedContext, workInProgress);\n        push(didPerformWorkStackCursor, didChange, workInProgress);\n      } else {\n        pop(didPerformWorkStackCursor, workInProgress);\n        push(didPerformWorkStackCursor, didChange, workInProgress);\n      }\n    }\n\n    function resetContext() {\n      previousContext = emptyObject;\n      contextStackCursor.current = emptyObject;\n      didPerformWorkStackCursor.current = false;\n    }\n\n    function findCurrentUnmaskedContext(fiber) {\n      // Currently this is only used with renderSubtreeIntoContainer; not sure if it\n      // makes sense elsewhere\n      !(isFiberMounted(fiber) && fiber.tag === ClassComponent) ? invariant(false, 'Expected subtree parent to be a mounted class component. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n      var node = fiber;\n\n      while (node.tag !== HostRoot) {\n        if (isContextProvider(node)) {\n          return node.stateNode.__reactInternalMemoizedMergedChildContext;\n        }\n\n        var parent = node['return'];\n        !parent ? invariant(false, 'Found unexpected detached subtree parent. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n        node = parent;\n      }\n\n      return node.stateNode.context;\n    }\n\n    var NoWork = 0; // TODO: Use an opaque type once ESLint et al support the syntax\n\n    var Sync = 1;\n    var Never = 2147483647; // Max int32: Math.pow(2, 31) - 1\n\n    var UNIT_SIZE = 10;\n    var MAGIC_NUMBER_OFFSET = 2; // 1 unit of expiration time represents 10ms.\n\n    function msToExpirationTime(ms) {\n      // Always add an offset so that we don't clash with the magic number for NoWork.\n      return (ms / UNIT_SIZE | 0) + MAGIC_NUMBER_OFFSET;\n    }\n\n    function expirationTimeToMs(expirationTime) {\n      return (expirationTime - MAGIC_NUMBER_OFFSET) * UNIT_SIZE;\n    }\n\n    function ceiling(num, precision) {\n      return ((num / precision | 0) + 1) * precision;\n    }\n\n    function computeExpirationBucket(currentTime, expirationInMs, bucketSizeMs) {\n      return ceiling(currentTime + expirationInMs / UNIT_SIZE, bucketSizeMs / UNIT_SIZE);\n    }\n\n    var NoContext = 0;\n    var AsyncUpdates = 1;\n    {\n      var hasBadMapPolyfill = false;\n\n      try {\n        var nonExtensibleObject = Object.preventExtensions({});\n        /* eslint-disable no-new */\n\n        /* eslint-enable no-new */\n      } catch (e) {\n        // TODO: Consider warning about bad polyfills\n        hasBadMapPolyfill = true;\n      }\n    } // A Fiber is work on a Component that needs to be done or was done. There can\n    // be more than one per component.\n\n    {\n      var debugCounter = 1;\n    }\n\n    function FiberNode(tag, key, internalContextTag) {\n      // Instance\n      this.tag = tag;\n      this.key = key;\n      this.type = null;\n      this.stateNode = null; // Fiber\n\n      this['return'] = null;\n      this.child = null;\n      this.sibling = null;\n      this.index = 0;\n      this.ref = null;\n      this.pendingProps = null;\n      this.memoizedProps = null;\n      this.updateQueue = null;\n      this.memoizedState = null;\n      this.internalContextTag = internalContextTag; // Effects\n\n      this.effectTag = NoEffect;\n      this.nextEffect = null;\n      this.firstEffect = null;\n      this.lastEffect = null;\n      this.expirationTime = NoWork;\n      this.alternate = null;\n      {\n        this._debugID = debugCounter++;\n        this._debugSource = null;\n        this._debugOwner = null;\n        this._debugIsCurrentlyTiming = false;\n\n        if (!hasBadMapPolyfill && typeof Object.preventExtensions === 'function') {\n          Object.preventExtensions(this);\n        }\n      }\n    } // This is a constructor function, rather than a POJO constructor, still\n    // please ensure we do the following:\n    // 1) Nobody should add any instance methods on this. Instance methods can be\n    //    more difficult to predict when they get optimized and they are almost\n    //    never inlined properly in static compilers.\n    // 2) Nobody should rely on `instanceof Fiber` for type testing. We should\n    //    always know when it is a fiber.\n    // 3) We might want to experiment with using numeric keys since they are easier\n    //    to optimize in a non-JIT environment.\n    // 4) We can easily go from a constructor to a createFiber object literal if that\n    //    is faster.\n    // 5) It should be easy to port this to a C struct and keep a C implementation\n    //    compatible.\n\n\n    var createFiber = function (tag, key, internalContextTag) {\n      // $FlowFixMe: the shapes are exact here but Flow doesn't like constructors\n      return new FiberNode(tag, key, internalContextTag);\n    };\n\n    function shouldConstruct(Component) {\n      return !!(Component.prototype && Component.prototype.isReactComponent);\n    } // This is used to create an alternate fiber to do work on.\n\n\n    function createWorkInProgress(current, pendingProps, expirationTime) {\n      var workInProgress = current.alternate;\n\n      if (workInProgress === null) {\n        // We use a double buffering pooling technique because we know that we'll\n        // only ever need at most two versions of a tree. We pool the \"other\" unused\n        // node that we're free to reuse. This is lazily created to avoid allocating\n        // extra objects for things that are never updated. It also allow us to\n        // reclaim the extra memory if needed.\n        workInProgress = createFiber(current.tag, current.key, current.internalContextTag);\n        workInProgress.type = current.type;\n        workInProgress.stateNode = current.stateNode;\n        {\n          // DEV-only fields\n          workInProgress._debugID = current._debugID;\n          workInProgress._debugSource = current._debugSource;\n          workInProgress._debugOwner = current._debugOwner;\n        }\n        workInProgress.alternate = current;\n        current.alternate = workInProgress;\n      } else {\n        // We already have an alternate.\n        // Reset the effect tag.\n        workInProgress.effectTag = NoEffect; // The effect list is no longer valid.\n\n        workInProgress.nextEffect = null;\n        workInProgress.firstEffect = null;\n        workInProgress.lastEffect = null;\n      }\n\n      workInProgress.expirationTime = expirationTime;\n      workInProgress.pendingProps = pendingProps;\n      workInProgress.child = current.child;\n      workInProgress.memoizedProps = current.memoizedProps;\n      workInProgress.memoizedState = current.memoizedState;\n      workInProgress.updateQueue = current.updateQueue; // These will be overridden during the parent's reconciliation\n\n      workInProgress.sibling = current.sibling;\n      workInProgress.index = current.index;\n      workInProgress.ref = current.ref;\n      return workInProgress;\n    }\n\n    function createHostRootFiber() {\n      var fiber = createFiber(HostRoot, null, NoContext);\n      return fiber;\n    }\n\n    function createFiberFromElement(element, internalContextTag, expirationTime) {\n      var owner = null;\n      {\n        owner = element._owner;\n      }\n      var fiber = void 0;\n      var type = element.type,\n          key = element.key;\n\n      if (typeof type === 'function') {\n        fiber = shouldConstruct(type) ? createFiber(ClassComponent, key, internalContextTag) : createFiber(IndeterminateComponent, key, internalContextTag);\n        fiber.type = type;\n        fiber.pendingProps = element.props;\n      } else if (typeof type === 'string') {\n        fiber = createFiber(HostComponent, key, internalContextTag);\n        fiber.type = type;\n        fiber.pendingProps = element.props;\n      } else if (typeof type === 'object' && type !== null && typeof type.tag === 'number') {\n        // Currently assumed to be a continuation and therefore is a fiber already.\n        // TODO: The yield system is currently broken for updates in some cases.\n        // The reified yield stores a fiber, but we don't know which fiber that is;\n        // the current or a workInProgress? When the continuation gets rendered here\n        // we don't know if we can reuse that fiber or if we need to clone it.\n        // There is probably a clever way to restructure this.\n        fiber = type;\n        fiber.pendingProps = element.props;\n      } else {\n        var info = '';\n        {\n          if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {\n            info += ' You likely forgot to export your component from the file ' + \"it's defined in, or you might have mixed up default and named imports.\";\n          }\n\n          var ownerName = owner ? getComponentName(owner) : null;\n\n          if (ownerName) {\n            info += '\\n\\nCheck the render method of `' + ownerName + '`.';\n          }\n        }\n        invariant(false, 'Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s', type == null ? type : typeof type, info);\n      }\n\n      {\n        fiber._debugSource = element._source;\n        fiber._debugOwner = element._owner;\n      }\n      fiber.expirationTime = expirationTime;\n      return fiber;\n    }\n\n    function createFiberFromFragment(elements, internalContextTag, expirationTime, key) {\n      var fiber = createFiber(Fragment, key, internalContextTag);\n      fiber.pendingProps = elements;\n      fiber.expirationTime = expirationTime;\n      return fiber;\n    }\n\n    function createFiberFromText(content, internalContextTag, expirationTime) {\n      var fiber = createFiber(HostText, null, internalContextTag);\n      fiber.pendingProps = content;\n      fiber.expirationTime = expirationTime;\n      return fiber;\n    }\n\n    function createFiberFromHostInstanceForDeletion() {\n      var fiber = createFiber(HostComponent, null, NoContext);\n      fiber.type = 'DELETED';\n      return fiber;\n    }\n\n    function createFiberFromCall(call, internalContextTag, expirationTime) {\n      var fiber = createFiber(CallComponent, call.key, internalContextTag);\n      fiber.type = call.handler;\n      fiber.pendingProps = call;\n      fiber.expirationTime = expirationTime;\n      return fiber;\n    }\n\n    function createFiberFromReturn(returnNode, internalContextTag, expirationTime) {\n      var fiber = createFiber(ReturnComponent, null, internalContextTag);\n      fiber.expirationTime = expirationTime;\n      return fiber;\n    }\n\n    function createFiberFromPortal(portal, internalContextTag, expirationTime) {\n      var fiber = createFiber(HostPortal, portal.key, internalContextTag);\n      fiber.pendingProps = portal.children || [];\n      fiber.expirationTime = expirationTime;\n      fiber.stateNode = {\n        containerInfo: portal.containerInfo,\n        pendingChildren: null,\n        // Used by persistent updates\n        implementation: portal.implementation\n      };\n      return fiber;\n    }\n\n    function createFiberRoot(containerInfo, hydrate) {\n      // Cyclic construction. This cheats the type system right now because\n      // stateNode is any.\n      var uninitializedFiber = createHostRootFiber();\n      var root = {\n        current: uninitializedFiber,\n        containerInfo: containerInfo,\n        pendingChildren: null,\n        remainingExpirationTime: NoWork,\n        isReadyForCommit: false,\n        finishedWork: null,\n        context: null,\n        pendingContext: null,\n        hydrate: hydrate,\n        nextScheduledRoot: null\n      };\n      uninitializedFiber.stateNode = root;\n      return root;\n    }\n\n    var onCommitFiberRoot = null;\n    var onCommitFiberUnmount = null;\n    var hasLoggedError = false;\n\n    function catchErrors(fn) {\n      return function (arg) {\n        try {\n          return fn(arg);\n        } catch (err) {\n          if (true && !hasLoggedError) {\n            hasLoggedError = true;\n            warning(false, 'React DevTools encountered an error: %s', err);\n          }\n        }\n      };\n    }\n\n    function injectInternals(internals) {\n      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined') {\n        // No DevTools\n        return false;\n      }\n\n      var hook = __REACT_DEVTOOLS_GLOBAL_HOOK__;\n\n      if (hook.isDisabled) {\n        // This isn't a real property on the hook, but it can be set to opt out\n        // of DevTools integration and associated warnings and logs.\n        // https://github.com/facebook/react/issues/3877\n        return true;\n      }\n\n      if (!hook.supportsFiber) {\n        {\n          warning(false, 'The installed version of React DevTools is too old and will not work ' + 'with the current version of React. Please update React DevTools. ' + 'https://fb.me/react-devtools');\n        } // DevTools exists, even though it doesn't support Fiber.\n\n        return true;\n      }\n\n      try {\n        var rendererID = hook.inject(internals); // We have successfully injected, so now it is safe to set up hooks.\n\n        onCommitFiberRoot = catchErrors(function (root) {\n          return hook.onCommitFiberRoot(rendererID, root);\n        });\n        onCommitFiberUnmount = catchErrors(function (fiber) {\n          return hook.onCommitFiberUnmount(rendererID, fiber);\n        });\n      } catch (err) {\n        // Catch all errors because it is unsafe to throw during initialization.\n        {\n          warning(false, 'React DevTools encountered an error: %s.', err);\n        }\n      } // DevTools exists\n\n\n      return true;\n    }\n\n    function onCommitRoot(root) {\n      if (typeof onCommitFiberRoot === 'function') {\n        onCommitFiberRoot(root);\n      }\n    }\n\n    function onCommitUnmount(fiber) {\n      if (typeof onCommitFiberUnmount === 'function') {\n        onCommitFiberUnmount(fiber);\n      }\n    }\n\n    var ReactErrorUtils = {\n      // Used by Fiber to simulate a try-catch.\n      _caughtError: null,\n      _hasCaughtError: false,\n      // Used by event system to capture/rethrow the first error.\n      _rethrowError: null,\n      _hasRethrowError: false,\n      injection: {\n        injectErrorUtils: function (injectedErrorUtils) {\n          !(typeof injectedErrorUtils.invokeGuardedCallback === 'function') ? invariant(false, 'Injected invokeGuardedCallback() must be a function.') : void 0;\n          invokeGuardedCallback$1 = injectedErrorUtils.invokeGuardedCallback;\n        }\n      },\n\n      /**\n       * Call a function while guarding against errors that happens within it.\n       * Returns an error if it throws, otherwise null.\n       *\n       * In production, this is implemented using a try-catch. The reason we don't\n       * use a try-catch directly is so that we can swap out a different\n       * implementation in DEV mode.\n       *\n       * @param {String} name of the guard to use for logging or debugging\n       * @param {Function} func The function to invoke\n       * @param {*} context The context to use when calling the function\n       * @param {...*} args Arguments for function\n       */\n      invokeGuardedCallback: function (name, func, context, a, b, c, d, e, f) {\n        invokeGuardedCallback$1.apply(ReactErrorUtils, arguments);\n      },\n\n      /**\n       * Same as invokeGuardedCallback, but instead of returning an error, it stores\n       * it in a global so it can be rethrown by `rethrowCaughtError` later.\n       * TODO: See if _caughtError and _rethrowError can be unified.\n       *\n       * @param {String} name of the guard to use for logging or debugging\n       * @param {Function} func The function to invoke\n       * @param {*} context The context to use when calling the function\n       * @param {...*} args Arguments for function\n       */\n      invokeGuardedCallbackAndCatchFirstError: function (name, func, context, a, b, c, d, e, f) {\n        ReactErrorUtils.invokeGuardedCallback.apply(this, arguments);\n\n        if (ReactErrorUtils.hasCaughtError()) {\n          var error = ReactErrorUtils.clearCaughtError();\n\n          if (!ReactErrorUtils._hasRethrowError) {\n            ReactErrorUtils._hasRethrowError = true;\n            ReactErrorUtils._rethrowError = error;\n          }\n        }\n      },\n\n      /**\n       * During execution of guarded functions we will capture the first error which\n       * we will rethrow to be handled by the top level error handler.\n       */\n      rethrowCaughtError: function () {\n        return rethrowCaughtError.apply(ReactErrorUtils, arguments);\n      },\n      hasCaughtError: function () {\n        return ReactErrorUtils._hasCaughtError;\n      },\n      clearCaughtError: function () {\n        if (ReactErrorUtils._hasCaughtError) {\n          var error = ReactErrorUtils._caughtError;\n          ReactErrorUtils._caughtError = null;\n          ReactErrorUtils._hasCaughtError = false;\n          return error;\n        } else {\n          invariant(false, 'clearCaughtError was called but no error was captured. This error is likely caused by a bug in React. Please file an issue.');\n        }\n      }\n    };\n\n    var invokeGuardedCallback$1 = function (name, func, context, a, b, c, d, e, f) {\n      ReactErrorUtils._hasCaughtError = false;\n      ReactErrorUtils._caughtError = null;\n      var funcArgs = Array.prototype.slice.call(arguments, 3);\n\n      try {\n        func.apply(context, funcArgs);\n      } catch (error) {\n        ReactErrorUtils._caughtError = error;\n        ReactErrorUtils._hasCaughtError = true;\n      }\n    };\n\n    {\n      // In DEV mode, we swap out invokeGuardedCallback for a special version\n      // that plays more nicely with the browser's DevTools. The idea is to preserve\n      // \"Pause on exceptions\" behavior. Because React wraps all user-provided\n      // functions in invokeGuardedCallback, and the production version of\n      // invokeGuardedCallback uses a try-catch, all user exceptions are treated\n      // like caught exceptions, and the DevTools won't pause unless the developer\n      // takes the extra step of enabling pause on caught exceptions. This is\n      // untintuitive, though, because even though React has caught the error, from\n      // the developer's perspective, the error is uncaught.\n      //\n      // To preserve the expected \"Pause on exceptions\" behavior, we don't use a\n      // try-catch in DEV. Instead, we synchronously dispatch a fake event to a fake\n      // DOM node, and call the user-provided callback from inside an event handler\n      // for that fake event. If the callback throws, the error is \"captured\" using\n      // a global event handler. But because the error happens in a different\n      // event loop context, it does not interrupt the normal program flow.\n      // Effectively, this gives us try-catch behavior without actually using\n      // try-catch. Neat!\n      // Check that the browser supports the APIs we need to implement our special\n      // DEV version of invokeGuardedCallback\n      if (typeof window !== 'undefined' && typeof window.dispatchEvent === 'function' && typeof document !== 'undefined' && typeof document.createEvent === 'function') {\n        var fakeNode = document.createElement('react');\n\n        var invokeGuardedCallbackDev = function (name, func, context, a, b, c, d, e, f) {\n          // Keeps track of whether the user-provided callback threw an error. We\n          // set this to true at the beginning, then set it to false right after\n          // calling the function. If the function errors, `didError` will never be\n          // set to false. This strategy works even if the browser is flaky and\n          // fails to call our global error handler, because it doesn't rely on\n          // the error event at all.\n          var didError = true; // Create an event handler for our fake event. We will synchronously\n          // dispatch our fake event using `dispatchEvent`. Inside the handler, we\n          // call the user-provided callback.\n\n          var funcArgs = Array.prototype.slice.call(arguments, 3);\n\n          function callCallback() {\n            // We immediately remove the callback from event listeners so that\n            // nested `invokeGuardedCallback` calls do not clash. Otherwise, a\n            // nested call would trigger the fake event handlers of any call higher\n            // in the stack.\n            fakeNode.removeEventListener(evtType, callCallback, false);\n            func.apply(context, funcArgs);\n            didError = false;\n          } // Create a global error event handler. We use this to capture the value\n          // that was thrown. It's possible that this error handler will fire more\n          // than once; for example, if non-React code also calls `dispatchEvent`\n          // and a handler for that event throws. We should be resilient to most of\n          // those cases. Even if our error event handler fires more than once, the\n          // last error event is always used. If the callback actually does error,\n          // we know that the last error event is the correct one, because it's not\n          // possible for anything else to have happened in between our callback\n          // erroring and the code that follows the `dispatchEvent` call below. If\n          // the callback doesn't error, but the error event was fired, we know to\n          // ignore it because `didError` will be false, as described above.\n\n\n          var error = void 0; // Use this to track whether the error event is ever called.\n\n          var didSetError = false;\n          var isCrossOriginError = false;\n\n          function onError(event) {\n            error = event.error;\n            didSetError = true;\n\n            if (error === null && event.colno === 0 && event.lineno === 0) {\n              isCrossOriginError = true;\n            }\n          } // Create a fake event type.\n\n\n          var evtType = 'react-' + (name ? name : 'invokeguardedcallback'); // Attach our event handlers\n\n          window.addEventListener('error', onError);\n          fakeNode.addEventListener(evtType, callCallback, false); // Synchronously dispatch our fake event. If the user-provided function\n          // errors, it will trigger our global error handler.\n\n          var evt = document.createEvent('Event');\n          evt.initEvent(evtType, false, false);\n          fakeNode.dispatchEvent(evt);\n\n          if (didError) {\n            if (!didSetError) {\n              // The callback errored, but the error event never fired.\n              error = new Error('An error was thrown inside one of your components, but React ' + \"doesn't know what it was. This is likely due to browser \" + 'flakiness. React does its best to preserve the \"Pause on ' + 'exceptions\" behavior of the DevTools, which requires some ' + \"DEV-mode only tricks. It's possible that these don't work in \" + 'your browser. Try triggering the error in production mode, ' + 'or switching to a modern browser. If you suspect that this is ' + 'actually an issue with React, please file an issue.');\n            } else if (isCrossOriginError) {\n              error = new Error(\"A cross-origin error was thrown. React doesn't have access to \" + 'the actual error object in development. ' + 'See https://fb.me/react-crossorigin-error for more information.');\n            }\n\n            ReactErrorUtils._hasCaughtError = true;\n            ReactErrorUtils._caughtError = error;\n          } else {\n            ReactErrorUtils._hasCaughtError = false;\n            ReactErrorUtils._caughtError = null;\n          } // Remove our event listeners\n\n\n          window.removeEventListener('error', onError);\n        };\n\n        invokeGuardedCallback$1 = invokeGuardedCallbackDev;\n      }\n    }\n\n    var rethrowCaughtError = function () {\n      if (ReactErrorUtils._hasRethrowError) {\n        var error = ReactErrorUtils._rethrowError;\n        ReactErrorUtils._rethrowError = null;\n        ReactErrorUtils._hasRethrowError = false;\n        throw error;\n      }\n    };\n\n    {\n      var didWarnUpdateInsideUpdate = false;\n    } // Callbacks are not validated until invocation\n    // Singly linked-list of updates. When an update is scheduled, it is added to\n    // the queue of the current fiber and the work-in-progress fiber. The two queues\n    // are separate but they share a persistent structure.\n    //\n    // During reconciliation, updates are removed from the work-in-progress fiber,\n    // but they remain on the current fiber. That ensures that if a work-in-progress\n    // is aborted, the aborted updates are recovered by cloning from current.\n    //\n    // The work-in-progress queue is always a subset of the current queue.\n    //\n    // When the tree is committed, the work-in-progress becomes the current.\n\n    function createUpdateQueue(baseState) {\n      var queue = {\n        baseState: baseState,\n        expirationTime: NoWork,\n        first: null,\n        last: null,\n        callbackList: null,\n        hasForceUpdate: false,\n        isInitialized: false\n      };\n      {\n        queue.isProcessing = false;\n      }\n      return queue;\n    }\n\n    function insertUpdateIntoQueue(queue, update) {\n      // Append the update to the end of the list.\n      if (queue.last === null) {\n        // Queue is empty\n        queue.first = queue.last = update;\n      } else {\n        queue.last.next = update;\n        queue.last = update;\n      }\n\n      if (queue.expirationTime === NoWork || queue.expirationTime > update.expirationTime) {\n        queue.expirationTime = update.expirationTime;\n      }\n    }\n\n    function insertUpdateIntoFiber(fiber, update) {\n      // We'll have at least one and at most two distinct update queues.\n      var alternateFiber = fiber.alternate;\n      var queue1 = fiber.updateQueue;\n\n      if (queue1 === null) {\n        // TODO: We don't know what the base state will be until we begin work.\n        // It depends on which fiber is the next current. Initialize with an empty\n        // base state, then set to the memoizedState when rendering. Not super\n        // happy with this approach.\n        queue1 = fiber.updateQueue = createUpdateQueue(null);\n      }\n\n      var queue2 = void 0;\n\n      if (alternateFiber !== null) {\n        queue2 = alternateFiber.updateQueue;\n\n        if (queue2 === null) {\n          queue2 = alternateFiber.updateQueue = createUpdateQueue(null);\n        }\n      } else {\n        queue2 = null;\n      }\n\n      queue2 = queue2 !== queue1 ? queue2 : null; // Warn if an update is scheduled from inside an updater function.\n\n      {\n        if ((queue1.isProcessing || queue2 !== null && queue2.isProcessing) && !didWarnUpdateInsideUpdate) {\n          warning(false, 'An update (setState, replaceState, or forceUpdate) was scheduled ' + 'from inside an update function. Update functions should be pure, ' + 'with zero side-effects. Consider using componentDidUpdate or a ' + 'callback.');\n          didWarnUpdateInsideUpdate = true;\n        }\n      } // If there's only one queue, add the update to that queue and exit.\n\n      if (queue2 === null) {\n        insertUpdateIntoQueue(queue1, update);\n        return;\n      } // If either queue is empty, we need to add to both queues.\n\n\n      if (queue1.last === null || queue2.last === null) {\n        insertUpdateIntoQueue(queue1, update);\n        insertUpdateIntoQueue(queue2, update);\n        return;\n      } // If both lists are not empty, the last update is the same for both lists\n      // because of structural sharing. So, we should only append to one of\n      // the lists.\n\n\n      insertUpdateIntoQueue(queue1, update); // But we still need to update the `last` pointer of queue2.\n\n      queue2.last = update;\n    }\n\n    function getUpdateExpirationTime(fiber) {\n      if (fiber.tag !== ClassComponent && fiber.tag !== HostRoot) {\n        return NoWork;\n      }\n\n      var updateQueue = fiber.updateQueue;\n\n      if (updateQueue === null) {\n        return NoWork;\n      }\n\n      return updateQueue.expirationTime;\n    }\n\n    function getStateFromUpdate(update, instance, prevState, props) {\n      var partialState = update.partialState;\n\n      if (typeof partialState === 'function') {\n        var updateFn = partialState; // Invoke setState callback an extra time to help detect side-effects.\n\n        if (debugRenderPhaseSideEffects) {\n          updateFn.call(instance, prevState, props);\n        }\n\n        return updateFn.call(instance, prevState, props);\n      } else {\n        return partialState;\n      }\n    }\n\n    function processUpdateQueue(current, workInProgress, queue, instance, props, renderExpirationTime) {\n      if (current !== null && current.updateQueue === queue) {\n        // We need to create a work-in-progress queue, by cloning the current queue.\n        var currentQueue = queue;\n        queue = workInProgress.updateQueue = {\n          baseState: currentQueue.baseState,\n          expirationTime: currentQueue.expirationTime,\n          first: currentQueue.first,\n          last: currentQueue.last,\n          isInitialized: currentQueue.isInitialized,\n          // These fields are no longer valid because they were already committed.\n          // Reset them.\n          callbackList: null,\n          hasForceUpdate: false\n        };\n      }\n\n      {\n        // Set this flag so we can warn if setState is called inside the update\n        // function of another setState.\n        queue.isProcessing = true;\n      } // Reset the remaining expiration time. If we skip over any updates, we'll\n      // increase this accordingly.\n\n      queue.expirationTime = NoWork; // TODO: We don't know what the base state will be until we begin work.\n      // It depends on which fiber is the next current. Initialize with an empty\n      // base state, then set to the memoizedState when rendering. Not super\n      // happy with this approach.\n\n      var state = void 0;\n\n      if (queue.isInitialized) {\n        state = queue.baseState;\n      } else {\n        state = queue.baseState = workInProgress.memoizedState;\n        queue.isInitialized = true;\n      }\n\n      var dontMutatePrevState = true;\n      var update = queue.first;\n      var didSkip = false;\n\n      while (update !== null) {\n        var updateExpirationTime = update.expirationTime;\n\n        if (updateExpirationTime > renderExpirationTime) {\n          // This update does not have sufficient priority. Skip it.\n          var remainingExpirationTime = queue.expirationTime;\n\n          if (remainingExpirationTime === NoWork || remainingExpirationTime > updateExpirationTime) {\n            // Update the remaining expiration time.\n            queue.expirationTime = updateExpirationTime;\n          }\n\n          if (!didSkip) {\n            didSkip = true;\n            queue.baseState = state;\n          } // Continue to the next update.\n\n\n          update = update.next;\n          continue;\n        } // This update does have sufficient priority.\n        // If no previous updates were skipped, drop this update from the queue by\n        // advancing the head of the list.\n\n\n        if (!didSkip) {\n          queue.first = update.next;\n\n          if (queue.first === null) {\n            queue.last = null;\n          }\n        } // Process the update\n\n\n        var _partialState = void 0;\n\n        if (update.isReplace) {\n          state = getStateFromUpdate(update, instance, state, props);\n          dontMutatePrevState = true;\n        } else {\n          _partialState = getStateFromUpdate(update, instance, state, props);\n\n          if (_partialState) {\n            if (dontMutatePrevState) {\n              // $FlowFixMe: Idk how to type this properly.\n              state = _assign({}, state, _partialState);\n            } else {\n              state = _assign(state, _partialState);\n            }\n\n            dontMutatePrevState = false;\n          }\n        }\n\n        if (update.isForced) {\n          queue.hasForceUpdate = true;\n        }\n\n        if (update.callback !== null) {\n          // Append to list of callbacks.\n          var _callbackList = queue.callbackList;\n\n          if (_callbackList === null) {\n            _callbackList = queue.callbackList = [];\n          }\n\n          _callbackList.push(update);\n        }\n\n        update = update.next;\n      }\n\n      if (queue.callbackList !== null) {\n        workInProgress.effectTag |= Callback;\n      } else if (queue.first === null && !queue.hasForceUpdate) {\n        // The queue is empty. We can reset it.\n        workInProgress.updateQueue = null;\n      }\n\n      if (!didSkip) {\n        didSkip = true;\n        queue.baseState = state;\n      }\n\n      {\n        // No longer processing.\n        queue.isProcessing = false;\n      }\n      return state;\n    }\n\n    function commitCallbacks(queue, context) {\n      var callbackList = queue.callbackList;\n\n      if (callbackList === null) {\n        return;\n      } // Set the list to null to make sure they don't get called more than once.\n\n\n      queue.callbackList = null;\n\n      for (var i = 0; i < callbackList.length; i++) {\n        var update = callbackList[i];\n        var _callback = update.callback; // This update might be processed again. Clear the callback so it's only\n        // called once.\n\n        update.callback = null;\n        !(typeof _callback === 'function') ? invariant(false, 'Invalid argument passed as callback. Expected a function. Instead received: %s', _callback) : void 0;\n\n        _callback.call(context);\n      }\n    }\n\n    var fakeInternalInstance = {};\n    var isArray = Array.isArray;\n    {\n      var didWarnAboutStateAssignmentForComponent = {};\n\n      var warnOnInvalidCallback = function (callback, callerName) {\n        warning(callback === null || typeof callback === 'function', '%s(...): Expected the last optional `callback` argument to be a ' + 'function. Instead received: %s.', callerName, callback);\n      }; // This is so gross but it's at least non-critical and can be removed if\n      // it causes problems. This is meant to give a nicer error message for\n      // ReactDOM15.unstable_renderSubtreeIntoContainer(reactDOM16Component,\n      // ...)) which otherwise throws a \"_processChildContext is not a function\"\n      // exception.\n\n\n      Object.defineProperty(fakeInternalInstance, '_processChildContext', {\n        enumerable: false,\n        value: function () {\n          invariant(false, '_processChildContext is not available in React 16+. This likely means you have multiple copies of React and are attempting to nest a React 15 tree inside a React 16 tree using unstable_renderSubtreeIntoContainer, which isn\\'t supported. Try to make sure you have only one copy of React (and ideally, switch to ReactDOM.createPortal).');\n        }\n      });\n      Object.freeze(fakeInternalInstance);\n    }\n\n    var ReactFiberClassComponent = function (scheduleWork, computeExpirationForFiber, memoizeProps, memoizeState) {\n      // Class component state updater\n      var updater = {\n        isMounted: isMounted,\n        enqueueSetState: function (instance, partialState, callback) {\n          var fiber = get(instance);\n          callback = callback === undefined ? null : callback;\n          {\n            warnOnInvalidCallback(callback, 'setState');\n          }\n          var expirationTime = computeExpirationForFiber(fiber);\n          var update = {\n            expirationTime: expirationTime,\n            partialState: partialState,\n            callback: callback,\n            isReplace: false,\n            isForced: false,\n            nextCallback: null,\n            next: null\n          };\n          insertUpdateIntoFiber(fiber, update);\n          scheduleWork(fiber, expirationTime);\n        },\n        enqueueReplaceState: function (instance, state, callback) {\n          var fiber = get(instance);\n          callback = callback === undefined ? null : callback;\n          {\n            warnOnInvalidCallback(callback, 'replaceState');\n          }\n          var expirationTime = computeExpirationForFiber(fiber);\n          var update = {\n            expirationTime: expirationTime,\n            partialState: state,\n            callback: callback,\n            isReplace: true,\n            isForced: false,\n            nextCallback: null,\n            next: null\n          };\n          insertUpdateIntoFiber(fiber, update);\n          scheduleWork(fiber, expirationTime);\n        },\n        enqueueForceUpdate: function (instance, callback) {\n          var fiber = get(instance);\n          callback = callback === undefined ? null : callback;\n          {\n            warnOnInvalidCallback(callback, 'forceUpdate');\n          }\n          var expirationTime = computeExpirationForFiber(fiber);\n          var update = {\n            expirationTime: expirationTime,\n            partialState: null,\n            callback: callback,\n            isReplace: false,\n            isForced: true,\n            nextCallback: null,\n            next: null\n          };\n          insertUpdateIntoFiber(fiber, update);\n          scheduleWork(fiber, expirationTime);\n        }\n      };\n\n      function checkShouldComponentUpdate(workInProgress, oldProps, newProps, oldState, newState, newContext) {\n        if (oldProps === null || workInProgress.updateQueue !== null && workInProgress.updateQueue.hasForceUpdate) {\n          // If the workInProgress already has an Update effect, return true\n          return true;\n        }\n\n        var instance = workInProgress.stateNode;\n        var type = workInProgress.type;\n\n        if (typeof instance.shouldComponentUpdate === 'function') {\n          startPhaseTimer(workInProgress, 'shouldComponentUpdate');\n          var shouldUpdate = instance.shouldComponentUpdate(newProps, newState, newContext);\n          stopPhaseTimer(); // Simulate an async bailout/interruption by invoking lifecycle twice.\n\n          if (debugRenderPhaseSideEffects) {\n            instance.shouldComponentUpdate(newProps, newState, newContext);\n          }\n\n          {\n            warning(shouldUpdate !== undefined, '%s.shouldComponentUpdate(): Returned undefined instead of a ' + 'boolean value. Make sure to return true or false.', getComponentName(workInProgress) || 'Unknown');\n          }\n          return shouldUpdate;\n        }\n\n        if (type.prototype && type.prototype.isPureReactComponent) {\n          return !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState);\n        }\n\n        return true;\n      }\n\n      function checkClassInstance(workInProgress) {\n        var instance = workInProgress.stateNode;\n        var type = workInProgress.type;\n        {\n          var name = getComponentName(workInProgress);\n          var renderPresent = instance.render;\n\n          if (!renderPresent) {\n            if (type.prototype && typeof type.prototype.render === 'function') {\n              warning(false, '%s(...): No `render` method found on the returned component ' + 'instance: did you accidentally return an object from the constructor?', name);\n            } else {\n              warning(false, '%s(...): No `render` method found on the returned component ' + 'instance: you may have forgotten to define `render`.', name);\n            }\n          }\n\n          var noGetInitialStateOnES6 = !instance.getInitialState || instance.getInitialState.isReactClassApproved || instance.state;\n          warning(noGetInitialStateOnES6, 'getInitialState was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Did you mean to define a state property instead?', name);\n          var noGetDefaultPropsOnES6 = !instance.getDefaultProps || instance.getDefaultProps.isReactClassApproved;\n          warning(noGetDefaultPropsOnES6, 'getDefaultProps was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Use a static property to define defaultProps instead.', name);\n          var noInstancePropTypes = !instance.propTypes;\n          warning(noInstancePropTypes, 'propTypes was defined as an instance property on %s. Use a static ' + 'property to define propTypes instead.', name);\n          var noInstanceContextTypes = !instance.contextTypes;\n          warning(noInstanceContextTypes, 'contextTypes was defined as an instance property on %s. Use a static ' + 'property to define contextTypes instead.', name);\n          var noComponentShouldUpdate = typeof instance.componentShouldUpdate !== 'function';\n          warning(noComponentShouldUpdate, '%s has a method called ' + 'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' + 'The name is phrased as a question because the function is ' + 'expected to return a value.', name);\n\n          if (type.prototype && type.prototype.isPureReactComponent && typeof instance.shouldComponentUpdate !== 'undefined') {\n            warning(false, '%s has a method called shouldComponentUpdate(). ' + 'shouldComponentUpdate should not be used when extending React.PureComponent. ' + 'Please extend React.Component if shouldComponentUpdate is used.', getComponentName(workInProgress) || 'A pure component');\n          }\n\n          var noComponentDidUnmount = typeof instance.componentDidUnmount !== 'function';\n          warning(noComponentDidUnmount, '%s has a method called ' + 'componentDidUnmount(). But there is no such lifecycle method. ' + 'Did you mean componentWillUnmount()?', name);\n          var noComponentDidReceiveProps = typeof instance.componentDidReceiveProps !== 'function';\n          warning(noComponentDidReceiveProps, '%s has a method called ' + 'componentDidReceiveProps(). But there is no such lifecycle method. ' + 'If you meant to update the state in response to changing props, ' + 'use componentWillReceiveProps(). If you meant to fetch data or ' + 'run side-effects or mutations after React has updated the UI, use componentDidUpdate().', name);\n          var noComponentWillRecieveProps = typeof instance.componentWillRecieveProps !== 'function';\n          warning(noComponentWillRecieveProps, '%s has a method called ' + 'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?', name);\n          var hasMutatedProps = instance.props !== workInProgress.pendingProps;\n          warning(instance.props === undefined || !hasMutatedProps, '%s(...): When calling super() in `%s`, make sure to pass ' + \"up the same props that your component's constructor was passed.\", name, name);\n          var noInstanceDefaultProps = !instance.defaultProps;\n          warning(noInstanceDefaultProps, 'Setting defaultProps as an instance property on %s is not supported and will be ignored.' + ' Instead, define defaultProps as a static property on %s.', name, name);\n        }\n        var state = instance.state;\n\n        if (state && (typeof state !== 'object' || isArray(state))) {\n          warning(false, '%s.state: must be set to an object or null', getComponentName(workInProgress));\n        }\n\n        if (typeof instance.getChildContext === 'function') {\n          warning(typeof workInProgress.type.childContextTypes === 'object', '%s.getChildContext(): childContextTypes must be defined in order to ' + 'use getChildContext().', getComponentName(workInProgress));\n        }\n      }\n\n      function resetInputPointers(workInProgress, instance) {\n        instance.props = workInProgress.memoizedProps;\n        instance.state = workInProgress.memoizedState;\n      }\n\n      function adoptClassInstance(workInProgress, instance) {\n        instance.updater = updater;\n        workInProgress.stateNode = instance; // The instance needs access to the fiber so that it can schedule updates\n\n        set(instance, workInProgress);\n        {\n          instance._reactInternalInstance = fakeInternalInstance;\n        }\n      }\n\n      function constructClassInstance(workInProgress, props) {\n        var ctor = workInProgress.type;\n        var unmaskedContext = getUnmaskedContext(workInProgress);\n        var needsContext = isContextConsumer(workInProgress);\n        var context = needsContext ? getMaskedContext(workInProgress, unmaskedContext) : emptyObject;\n        var instance = new ctor(props, context);\n        adoptClassInstance(workInProgress, instance); // Cache unmasked context so we can avoid recreating masked context unless necessary.\n        // ReactFiberContext usually updates this cache but can't for newly-created instances.\n\n        if (needsContext) {\n          cacheContext(workInProgress, unmaskedContext, context);\n        }\n\n        return instance;\n      }\n\n      function callComponentWillMount(workInProgress, instance) {\n        startPhaseTimer(workInProgress, 'componentWillMount');\n        var oldState = instance.state;\n        instance.componentWillMount();\n        stopPhaseTimer(); // Simulate an async bailout/interruption by invoking lifecycle twice.\n\n        if (debugRenderPhaseSideEffects) {\n          instance.componentWillMount();\n        }\n\n        if (oldState !== instance.state) {\n          {\n            warning(false, '%s.componentWillMount(): Assigning directly to this.state is ' + \"deprecated (except inside a component's \" + 'constructor). Use setState instead.', getComponentName(workInProgress));\n          }\n          updater.enqueueReplaceState(instance, instance.state, null);\n        }\n      }\n\n      function callComponentWillReceiveProps(workInProgress, instance, newProps, newContext) {\n        startPhaseTimer(workInProgress, 'componentWillReceiveProps');\n        var oldState = instance.state;\n        instance.componentWillReceiveProps(newProps, newContext);\n        stopPhaseTimer(); // Simulate an async bailout/interruption by invoking lifecycle twice.\n\n        if (debugRenderPhaseSideEffects) {\n          instance.componentWillReceiveProps(newProps, newContext);\n        }\n\n        if (instance.state !== oldState) {\n          {\n            var componentName = getComponentName(workInProgress) || 'Component';\n\n            if (!didWarnAboutStateAssignmentForComponent[componentName]) {\n              warning(false, '%s.componentWillReceiveProps(): Assigning directly to ' + \"this.state is deprecated (except inside a component's \" + 'constructor). Use setState instead.', componentName);\n              didWarnAboutStateAssignmentForComponent[componentName] = true;\n            }\n          }\n          updater.enqueueReplaceState(instance, instance.state, null);\n        }\n      } // Invokes the mount life-cycles on a previously never rendered instance.\n\n\n      function mountClassInstance(workInProgress, renderExpirationTime) {\n        var current = workInProgress.alternate;\n        {\n          checkClassInstance(workInProgress);\n        }\n        var instance = workInProgress.stateNode;\n        var state = instance.state || null;\n        var props = workInProgress.pendingProps;\n        !props ? invariant(false, 'There must be pending props for an initial mount. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n        var unmaskedContext = getUnmaskedContext(workInProgress);\n        instance.props = props;\n        instance.state = workInProgress.memoizedState = state;\n        instance.refs = emptyObject;\n        instance.context = getMaskedContext(workInProgress, unmaskedContext);\n\n        if (enableAsyncSubtreeAPI && workInProgress.type != null && workInProgress.type.prototype != null && workInProgress.type.prototype.unstable_isAsyncReactComponent === true) {\n          workInProgress.internalContextTag |= AsyncUpdates;\n        }\n\n        if (typeof instance.componentWillMount === 'function') {\n          callComponentWillMount(workInProgress, instance); // If we had additional state updates during this life-cycle, let's\n          // process them now.\n\n          var updateQueue = workInProgress.updateQueue;\n\n          if (updateQueue !== null) {\n            instance.state = processUpdateQueue(current, workInProgress, updateQueue, instance, props, renderExpirationTime);\n          }\n        }\n\n        if (typeof instance.componentDidMount === 'function') {\n          workInProgress.effectTag |= Update;\n        }\n      } // Called on a preexisting class instance. Returns false if a resumed render\n      // could be reused.\n      // function resumeMountClassInstance(\n      //   workInProgress: Fiber,\n      //   priorityLevel: PriorityLevel,\n      // ): boolean {\n      //   const instance = workInProgress.stateNode;\n      //   resetInputPointers(workInProgress, instance);\n      //   let newState = workInProgress.memoizedState;\n      //   let newProps = workInProgress.pendingProps;\n      //   if (!newProps) {\n      //     // If there isn't any new props, then we'll reuse the memoized props.\n      //     // This could be from already completed work.\n      //     newProps = workInProgress.memoizedProps;\n      //     invariant(\n      //       newProps != null,\n      //       'There should always be pending or memoized props. This error is ' +\n      //         'likely caused by a bug in React. Please file an issue.',\n      //     );\n      //   }\n      //   const newUnmaskedContext = getUnmaskedContext(workInProgress);\n      //   const newContext = getMaskedContext(workInProgress, newUnmaskedContext);\n      //   const oldContext = instance.context;\n      //   const oldProps = workInProgress.memoizedProps;\n      //   if (\n      //     typeof instance.componentWillReceiveProps === 'function' &&\n      //     (oldProps !== newProps || oldContext !== newContext)\n      //   ) {\n      //     callComponentWillReceiveProps(\n      //       workInProgress,\n      //       instance,\n      //       newProps,\n      //       newContext,\n      //     );\n      //   }\n      //   // Process the update queue before calling shouldComponentUpdate\n      //   const updateQueue = workInProgress.updateQueue;\n      //   if (updateQueue !== null) {\n      //     newState = processUpdateQueue(\n      //       workInProgress,\n      //       updateQueue,\n      //       instance,\n      //       newState,\n      //       newProps,\n      //       priorityLevel,\n      //     );\n      //   }\n      //   // TODO: Should we deal with a setState that happened after the last\n      //   // componentWillMount and before this componentWillMount? Probably\n      //   // unsupported anyway.\n      //   if (\n      //     !checkShouldComponentUpdate(\n      //       workInProgress,\n      //       workInProgress.memoizedProps,\n      //       newProps,\n      //       workInProgress.memoizedState,\n      //       newState,\n      //       newContext,\n      //     )\n      //   ) {\n      //     // Update the existing instance's state, props, and context pointers even\n      //     // though we're bailing out.\n      //     instance.props = newProps;\n      //     instance.state = newState;\n      //     instance.context = newContext;\n      //     return false;\n      //   }\n      //   // Update the input pointers now so that they are correct when we call\n      //   // componentWillMount\n      //   instance.props = newProps;\n      //   instance.state = newState;\n      //   instance.context = newContext;\n      //   if (typeof instance.componentWillMount === 'function') {\n      //     callComponentWillMount(workInProgress, instance);\n      //     // componentWillMount may have called setState. Process the update queue.\n      //     const newUpdateQueue = workInProgress.updateQueue;\n      //     if (newUpdateQueue !== null) {\n      //       newState = processUpdateQueue(\n      //         workInProgress,\n      //         newUpdateQueue,\n      //         instance,\n      //         newState,\n      //         newProps,\n      //         priorityLevel,\n      //       );\n      //     }\n      //   }\n      //   if (typeof instance.componentDidMount === 'function') {\n      //     workInProgress.effectTag |= Update;\n      //   }\n      //   instance.state = newState;\n      //   return true;\n      // }\n      // Invokes the update life-cycles and returns false if it shouldn't rerender.\n\n\n      function updateClassInstance(current, workInProgress, renderExpirationTime) {\n        var instance = workInProgress.stateNode;\n        resetInputPointers(workInProgress, instance);\n        var oldProps = workInProgress.memoizedProps;\n        var newProps = workInProgress.pendingProps;\n\n        if (!newProps) {\n          // If there aren't any new props, then we'll reuse the memoized props.\n          // This could be from already completed work.\n          newProps = oldProps;\n          !(newProps != null) ? invariant(false, 'There should always be pending or memoized props. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n        }\n\n        var oldContext = instance.context;\n        var newUnmaskedContext = getUnmaskedContext(workInProgress);\n        var newContext = getMaskedContext(workInProgress, newUnmaskedContext); // Note: During these life-cycles, instance.props/instance.state are what\n        // ever the previously attempted to render - not the \"current\". However,\n        // during componentDidUpdate we pass the \"current\" props.\n\n        if (typeof instance.componentWillReceiveProps === 'function' && (oldProps !== newProps || oldContext !== newContext)) {\n          callComponentWillReceiveProps(workInProgress, instance, newProps, newContext);\n        } // Compute the next state using the memoized state and the update queue.\n\n\n        var oldState = workInProgress.memoizedState; // TODO: Previous state can be null.\n\n        var newState = void 0;\n\n        if (workInProgress.updateQueue !== null) {\n          newState = processUpdateQueue(current, workInProgress, workInProgress.updateQueue, instance, newProps, renderExpirationTime);\n        } else {\n          newState = oldState;\n        }\n\n        if (oldProps === newProps && oldState === newState && !hasContextChanged() && !(workInProgress.updateQueue !== null && workInProgress.updateQueue.hasForceUpdate)) {\n          // If an update was already in progress, we should schedule an Update\n          // effect even though we're bailing out, so that cWU/cDU are called.\n          if (typeof instance.componentDidUpdate === 'function') {\n            if (oldProps !== current.memoizedProps || oldState !== current.memoizedState) {\n              workInProgress.effectTag |= Update;\n            }\n          }\n\n          return false;\n        }\n\n        var shouldUpdate = checkShouldComponentUpdate(workInProgress, oldProps, newProps, oldState, newState, newContext);\n\n        if (shouldUpdate) {\n          if (typeof instance.componentWillUpdate === 'function') {\n            startPhaseTimer(workInProgress, 'componentWillUpdate');\n            instance.componentWillUpdate(newProps, newState, newContext);\n            stopPhaseTimer(); // Simulate an async bailout/interruption by invoking lifecycle twice.\n\n            if (debugRenderPhaseSideEffects) {\n              instance.componentWillUpdate(newProps, newState, newContext);\n            }\n          }\n\n          if (typeof instance.componentDidUpdate === 'function') {\n            workInProgress.effectTag |= Update;\n          }\n        } else {\n          // If an update was already in progress, we should schedule an Update\n          // effect even though we're bailing out, so that cWU/cDU are called.\n          if (typeof instance.componentDidUpdate === 'function') {\n            if (oldProps !== current.memoizedProps || oldState !== current.memoizedState) {\n              workInProgress.effectTag |= Update;\n            }\n          } // If shouldComponentUpdate returned false, we should still update the\n          // memoized props/state to indicate that this work can be reused.\n\n\n          memoizeProps(workInProgress, newProps);\n          memoizeState(workInProgress, newState);\n        } // Update the existing instance's state, props, and context pointers even\n        // if shouldComponentUpdate returns false.\n\n\n        instance.props = newProps;\n        instance.state = newState;\n        instance.context = newContext;\n        return shouldUpdate;\n      }\n\n      return {\n        adoptClassInstance: adoptClassInstance,\n        constructClassInstance: constructClassInstance,\n        mountClassInstance: mountClassInstance,\n        // resumeMountClassInstance,\n        updateClassInstance: updateClassInstance\n      };\n    }; // The Symbol used to tag the ReactElement-like types. If there is no native Symbol\n    // nor polyfill, then a plain number is used for performance.\n\n\n    var hasSymbol = typeof Symbol === 'function' && Symbol['for'];\n    var REACT_ELEMENT_TYPE = hasSymbol ? Symbol['for']('react.element') : 0xeac7;\n    var REACT_CALL_TYPE = hasSymbol ? Symbol['for']('react.call') : 0xeac8;\n    var REACT_RETURN_TYPE = hasSymbol ? Symbol['for']('react.return') : 0xeac9;\n    var REACT_PORTAL_TYPE = hasSymbol ? Symbol['for']('react.portal') : 0xeaca;\n    var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol['for']('react.fragment') : 0xeacb;\n    var MAYBE_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;\n    var FAUX_ITERATOR_SYMBOL = '@@iterator';\n\n    function getIteratorFn(maybeIterable) {\n      if (maybeIterable === null || typeof maybeIterable === 'undefined') {\n        return null;\n      }\n\n      var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n\n      if (typeof maybeIterator === 'function') {\n        return maybeIterator;\n      }\n\n      return null;\n    }\n\n    var getCurrentFiberStackAddendum$1 = ReactDebugCurrentFiber.getCurrentFiberStackAddendum;\n    {\n      var didWarnAboutMaps = false;\n      /**\n       * Warn if there's no key explicitly set on dynamic arrays of children or\n       * object keys are not valid. This allows us to keep track of children between\n       * updates.\n       */\n\n      var ownerHasKeyUseWarning = {};\n      var ownerHasFunctionTypeWarning = {};\n\n      var warnForMissingKey = function (child) {\n        if (child === null || typeof child !== 'object') {\n          return;\n        }\n\n        if (!child._store || child._store.validated || child.key != null) {\n          return;\n        }\n\n        !(typeof child._store === 'object') ? invariant(false, 'React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n        child._store.validated = true;\n        var currentComponentErrorInfo = 'Each child in an array or iterator should have a unique ' + '\"key\" prop. See https://fb.me/react-warning-keys for ' + 'more information.' + (getCurrentFiberStackAddendum$1() || '');\n\n        if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n          return;\n        }\n\n        ownerHasKeyUseWarning[currentComponentErrorInfo] = true;\n        warning(false, 'Each child in an array or iterator should have a unique ' + '\"key\" prop. See https://fb.me/react-warning-keys for ' + 'more information.%s', getCurrentFiberStackAddendum$1());\n      };\n    }\n    var isArray$1 = Array.isArray;\n\n    function coerceRef(current, element) {\n      var mixedRef = element.ref;\n\n      if (mixedRef !== null && typeof mixedRef !== 'function') {\n        if (element._owner) {\n          var owner = element._owner;\n          var inst = void 0;\n\n          if (owner) {\n            var ownerFiber = owner;\n            !(ownerFiber.tag === ClassComponent) ? invariant(false, 'Stateless function components cannot have refs.') : void 0;\n            inst = ownerFiber.stateNode;\n          }\n\n          !inst ? invariant(false, 'Missing owner for string ref %s. This error is likely caused by a bug in React. Please file an issue.', mixedRef) : void 0;\n          var stringRef = '' + mixedRef; // Check if previous string ref matches new string ref\n\n          if (current !== null && current.ref !== null && current.ref._stringRef === stringRef) {\n            return current.ref;\n          }\n\n          var ref = function (value) {\n            var refs = inst.refs === emptyObject ? inst.refs = {} : inst.refs;\n\n            if (value === null) {\n              delete refs[stringRef];\n            } else {\n              refs[stringRef] = value;\n            }\n          };\n\n          ref._stringRef = stringRef;\n          return ref;\n        } else {\n          !(typeof mixedRef === 'string') ? invariant(false, 'Expected ref to be a function or a string.') : void 0;\n          !element._owner ? invariant(false, 'Element ref was specified as a string (%s) but no owner was set. You may have multiple copies of React loaded. (details: https://fb.me/react-refs-must-have-owner).', mixedRef) : void 0;\n        }\n      }\n\n      return mixedRef;\n    }\n\n    function throwOnInvalidObjectType(returnFiber, newChild) {\n      if (returnFiber.type !== 'textarea') {\n        var addendum = '';\n        {\n          addendum = ' If you meant to render a collection of children, use an array ' + 'instead.' + (getCurrentFiberStackAddendum$1() || '');\n        }\n        invariant(false, 'Objects are not valid as a React child (found: %s).%s', Object.prototype.toString.call(newChild) === '[object Object]' ? 'object with keys {' + Object.keys(newChild).join(', ') + '}' : newChild, addendum);\n      }\n    }\n\n    function warnOnFunctionType() {\n      var currentComponentErrorInfo = 'Functions are not valid as a React child. This may happen if ' + 'you return a Component instead of <Component /> from render. ' + 'Or maybe you meant to call this function rather than return it.' + (getCurrentFiberStackAddendum$1() || '');\n\n      if (ownerHasFunctionTypeWarning[currentComponentErrorInfo]) {\n        return;\n      }\n\n      ownerHasFunctionTypeWarning[currentComponentErrorInfo] = true;\n      warning(false, 'Functions are not valid as a React child. This may happen if ' + 'you return a Component instead of <Component /> from render. ' + 'Or maybe you meant to call this function rather than return it.%s', getCurrentFiberStackAddendum$1() || '');\n    } // This wrapper function exists because I expect to clone the code in each path\n    // to be able to optimize each path individually by branching early. This needs\n    // a compiler or we can do it manually. Helpers that don't need this branching\n    // live outside of this function.\n\n\n    function ChildReconciler(shouldTrackSideEffects) {\n      function deleteChild(returnFiber, childToDelete) {\n        if (!shouldTrackSideEffects) {\n          // Noop.\n          return;\n        } // Deletions are added in reversed order so we add it to the front.\n        // At this point, the return fiber's effect list is empty except for\n        // deletions, so we can just append the deletion to the list. The remaining\n        // effects aren't added until the complete phase. Once we implement\n        // resuming, this may not be true.\n\n\n        var last = returnFiber.lastEffect;\n\n        if (last !== null) {\n          last.nextEffect = childToDelete;\n          returnFiber.lastEffect = childToDelete;\n        } else {\n          returnFiber.firstEffect = returnFiber.lastEffect = childToDelete;\n        }\n\n        childToDelete.nextEffect = null;\n        childToDelete.effectTag = Deletion;\n      }\n\n      function deleteRemainingChildren(returnFiber, currentFirstChild) {\n        if (!shouldTrackSideEffects) {\n          // Noop.\n          return null;\n        } // TODO: For the shouldClone case, this could be micro-optimized a bit by\n        // assuming that after the first child we've already added everything.\n\n\n        var childToDelete = currentFirstChild;\n\n        while (childToDelete !== null) {\n          deleteChild(returnFiber, childToDelete);\n          childToDelete = childToDelete.sibling;\n        }\n\n        return null;\n      }\n\n      function mapRemainingChildren(returnFiber, currentFirstChild) {\n        // Add the remaining children to a temporary map so that we can find them by\n        // keys quickly. Implicit (null) keys get added to this set with their index\n        var existingChildren = new Map();\n        var existingChild = currentFirstChild;\n\n        while (existingChild !== null) {\n          if (existingChild.key !== null) {\n            existingChildren.set(existingChild.key, existingChild);\n          } else {\n            existingChildren.set(existingChild.index, existingChild);\n          }\n\n          existingChild = existingChild.sibling;\n        }\n\n        return existingChildren;\n      }\n\n      function useFiber(fiber, pendingProps, expirationTime) {\n        // We currently set sibling to null and index to 0 here because it is easy\n        // to forget to do before returning it. E.g. for the single child case.\n        var clone = createWorkInProgress(fiber, pendingProps, expirationTime);\n        clone.index = 0;\n        clone.sibling = null;\n        return clone;\n      }\n\n      function placeChild(newFiber, lastPlacedIndex, newIndex) {\n        newFiber.index = newIndex;\n\n        if (!shouldTrackSideEffects) {\n          // Noop.\n          return lastPlacedIndex;\n        }\n\n        var current = newFiber.alternate;\n\n        if (current !== null) {\n          var oldIndex = current.index;\n\n          if (oldIndex < lastPlacedIndex) {\n            // This is a move.\n            newFiber.effectTag = Placement;\n            return lastPlacedIndex;\n          } else {\n            // This item can stay in place.\n            return oldIndex;\n          }\n        } else {\n          // This is an insertion.\n          newFiber.effectTag = Placement;\n          return lastPlacedIndex;\n        }\n      }\n\n      function placeSingleChild(newFiber) {\n        // This is simpler for the single child case. We only need to do a\n        // placement for inserting new children.\n        if (shouldTrackSideEffects && newFiber.alternate === null) {\n          newFiber.effectTag = Placement;\n        }\n\n        return newFiber;\n      }\n\n      function updateTextNode(returnFiber, current, textContent, expirationTime) {\n        if (current === null || current.tag !== HostText) {\n          // Insert\n          var created = createFiberFromText(textContent, returnFiber.internalContextTag, expirationTime);\n          created['return'] = returnFiber;\n          return created;\n        } else {\n          // Update\n          var existing = useFiber(current, textContent, expirationTime);\n          existing['return'] = returnFiber;\n          return existing;\n        }\n      }\n\n      function updateElement(returnFiber, current, element, expirationTime) {\n        if (current !== null && current.type === element.type) {\n          // Move based on index\n          var existing = useFiber(current, element.props, expirationTime);\n          existing.ref = coerceRef(current, element);\n          existing['return'] = returnFiber;\n          {\n            existing._debugSource = element._source;\n            existing._debugOwner = element._owner;\n          }\n          return existing;\n        } else {\n          // Insert\n          var created = createFiberFromElement(element, returnFiber.internalContextTag, expirationTime);\n          created.ref = coerceRef(current, element);\n          created['return'] = returnFiber;\n          return created;\n        }\n      }\n\n      function updateCall(returnFiber, current, call, expirationTime) {\n        // TODO: Should this also compare handler to determine whether to reuse?\n        if (current === null || current.tag !== CallComponent) {\n          // Insert\n          var created = createFiberFromCall(call, returnFiber.internalContextTag, expirationTime);\n          created['return'] = returnFiber;\n          return created;\n        } else {\n          // Move based on index\n          var existing = useFiber(current, call, expirationTime);\n          existing['return'] = returnFiber;\n          return existing;\n        }\n      }\n\n      function updateReturn(returnFiber, current, returnNode, expirationTime) {\n        if (current === null || current.tag !== ReturnComponent) {\n          // Insert\n          var created = createFiberFromReturn(returnNode, returnFiber.internalContextTag, expirationTime);\n          created.type = returnNode.value;\n          created['return'] = returnFiber;\n          return created;\n        } else {\n          // Move based on index\n          var existing = useFiber(current, null, expirationTime);\n          existing.type = returnNode.value;\n          existing['return'] = returnFiber;\n          return existing;\n        }\n      }\n\n      function updatePortal(returnFiber, current, portal, expirationTime) {\n        if (current === null || current.tag !== HostPortal || current.stateNode.containerInfo !== portal.containerInfo || current.stateNode.implementation !== portal.implementation) {\n          // Insert\n          var created = createFiberFromPortal(portal, returnFiber.internalContextTag, expirationTime);\n          created['return'] = returnFiber;\n          return created;\n        } else {\n          // Update\n          var existing = useFiber(current, portal.children || [], expirationTime);\n          existing['return'] = returnFiber;\n          return existing;\n        }\n      }\n\n      function updateFragment(returnFiber, current, fragment, expirationTime, key) {\n        if (current === null || current.tag !== Fragment) {\n          // Insert\n          var created = createFiberFromFragment(fragment, returnFiber.internalContextTag, expirationTime, key);\n          created['return'] = returnFiber;\n          return created;\n        } else {\n          // Update\n          var existing = useFiber(current, fragment, expirationTime);\n          existing['return'] = returnFiber;\n          return existing;\n        }\n      }\n\n      function createChild(returnFiber, newChild, expirationTime) {\n        if (typeof newChild === 'string' || typeof newChild === 'number') {\n          // Text nodes don't have keys. If the previous node is implicitly keyed\n          // we can continue to replace it without aborting even if it is not a text\n          // node.\n          var created = createFiberFromText('' + newChild, returnFiber.internalContextTag, expirationTime);\n          created['return'] = returnFiber;\n          return created;\n        }\n\n        if (typeof newChild === 'object' && newChild !== null) {\n          switch (newChild.$$typeof) {\n            case REACT_ELEMENT_TYPE:\n              {\n                if (newChild.type === REACT_FRAGMENT_TYPE) {\n                  var _created = createFiberFromFragment(newChild.props.children, returnFiber.internalContextTag, expirationTime, newChild.key);\n\n                  _created['return'] = returnFiber;\n                  return _created;\n                } else {\n                  var _created2 = createFiberFromElement(newChild, returnFiber.internalContextTag, expirationTime);\n\n                  _created2.ref = coerceRef(null, newChild);\n                  _created2['return'] = returnFiber;\n                  return _created2;\n                }\n              }\n\n            case REACT_CALL_TYPE:\n              {\n                var _created3 = createFiberFromCall(newChild, returnFiber.internalContextTag, expirationTime);\n\n                _created3['return'] = returnFiber;\n                return _created3;\n              }\n\n            case REACT_RETURN_TYPE:\n              {\n                var _created4 = createFiberFromReturn(newChild, returnFiber.internalContextTag, expirationTime);\n\n                _created4.type = newChild.value;\n                _created4['return'] = returnFiber;\n                return _created4;\n              }\n\n            case REACT_PORTAL_TYPE:\n              {\n                var _created5 = createFiberFromPortal(newChild, returnFiber.internalContextTag, expirationTime);\n\n                _created5['return'] = returnFiber;\n                return _created5;\n              }\n          }\n\n          if (isArray$1(newChild) || getIteratorFn(newChild)) {\n            var _created6 = createFiberFromFragment(newChild, returnFiber.internalContextTag, expirationTime, null);\n\n            _created6['return'] = returnFiber;\n            return _created6;\n          }\n\n          throwOnInvalidObjectType(returnFiber, newChild);\n        }\n\n        {\n          if (typeof newChild === 'function') {\n            warnOnFunctionType();\n          }\n        }\n        return null;\n      }\n\n      function updateSlot(returnFiber, oldFiber, newChild, expirationTime) {\n        // Update the fiber if the keys match, otherwise return null.\n        var key = oldFiber !== null ? oldFiber.key : null;\n\n        if (typeof newChild === 'string' || typeof newChild === 'number') {\n          // Text nodes don't have keys. If the previous node is implicitly keyed\n          // we can continue to replace it without aborting even if it is not a text\n          // node.\n          if (key !== null) {\n            return null;\n          }\n\n          return updateTextNode(returnFiber, oldFiber, '' + newChild, expirationTime);\n        }\n\n        if (typeof newChild === 'object' && newChild !== null) {\n          switch (newChild.$$typeof) {\n            case REACT_ELEMENT_TYPE:\n              {\n                if (newChild.key === key) {\n                  if (newChild.type === REACT_FRAGMENT_TYPE) {\n                    return updateFragment(returnFiber, oldFiber, newChild.props.children, expirationTime, key);\n                  }\n\n                  return updateElement(returnFiber, oldFiber, newChild, expirationTime);\n                } else {\n                  return null;\n                }\n              }\n\n            case REACT_CALL_TYPE:\n              {\n                if (newChild.key === key) {\n                  return updateCall(returnFiber, oldFiber, newChild, expirationTime);\n                } else {\n                  return null;\n                }\n              }\n\n            case REACT_RETURN_TYPE:\n              {\n                // Returns don't have keys. If the previous node is implicitly keyed\n                // we can continue to replace it without aborting even if it is not a\n                // yield.\n                if (key === null) {\n                  return updateReturn(returnFiber, oldFiber, newChild, expirationTime);\n                } else {\n                  return null;\n                }\n              }\n\n            case REACT_PORTAL_TYPE:\n              {\n                if (newChild.key === key) {\n                  return updatePortal(returnFiber, oldFiber, newChild, expirationTime);\n                } else {\n                  return null;\n                }\n              }\n          }\n\n          if (isArray$1(newChild) || getIteratorFn(newChild)) {\n            if (key !== null) {\n              return null;\n            }\n\n            return updateFragment(returnFiber, oldFiber, newChild, expirationTime, null);\n          }\n\n          throwOnInvalidObjectType(returnFiber, newChild);\n        }\n\n        {\n          if (typeof newChild === 'function') {\n            warnOnFunctionType();\n          }\n        }\n        return null;\n      }\n\n      function updateFromMap(existingChildren, returnFiber, newIdx, newChild, expirationTime) {\n        if (typeof newChild === 'string' || typeof newChild === 'number') {\n          // Text nodes don't have keys, so we neither have to check the old nor\n          // new node for the key. If both are text nodes, they match.\n          var matchedFiber = existingChildren.get(newIdx) || null;\n          return updateTextNode(returnFiber, matchedFiber, '' + newChild, expirationTime);\n        }\n\n        if (typeof newChild === 'object' && newChild !== null) {\n          switch (newChild.$$typeof) {\n            case REACT_ELEMENT_TYPE:\n              {\n                var _matchedFiber = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;\n\n                if (newChild.type === REACT_FRAGMENT_TYPE) {\n                  return updateFragment(returnFiber, _matchedFiber, newChild.props.children, expirationTime, newChild.key);\n                }\n\n                return updateElement(returnFiber, _matchedFiber, newChild, expirationTime);\n              }\n\n            case REACT_CALL_TYPE:\n              {\n                var _matchedFiber2 = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;\n\n                return updateCall(returnFiber, _matchedFiber2, newChild, expirationTime);\n              }\n\n            case REACT_RETURN_TYPE:\n              {\n                // Returns don't have keys, so we neither have to check the old nor\n                // new node for the key. If both are returns, they match.\n                var _matchedFiber3 = existingChildren.get(newIdx) || null;\n\n                return updateReturn(returnFiber, _matchedFiber3, newChild, expirationTime);\n              }\n\n            case REACT_PORTAL_TYPE:\n              {\n                var _matchedFiber4 = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;\n\n                return updatePortal(returnFiber, _matchedFiber4, newChild, expirationTime);\n              }\n          }\n\n          if (isArray$1(newChild) || getIteratorFn(newChild)) {\n            var _matchedFiber5 = existingChildren.get(newIdx) || null;\n\n            return updateFragment(returnFiber, _matchedFiber5, newChild, expirationTime, null);\n          }\n\n          throwOnInvalidObjectType(returnFiber, newChild);\n        }\n\n        {\n          if (typeof newChild === 'function') {\n            warnOnFunctionType();\n          }\n        }\n        return null;\n      }\n      /**\n       * Warns if there is a duplicate or missing key\n       */\n\n\n      function warnOnInvalidKey(child, knownKeys) {\n        {\n          if (typeof child !== 'object' || child === null) {\n            return knownKeys;\n          }\n\n          switch (child.$$typeof) {\n            case REACT_ELEMENT_TYPE:\n            case REACT_CALL_TYPE:\n            case REACT_PORTAL_TYPE:\n              warnForMissingKey(child);\n              var key = child.key;\n\n              if (typeof key !== 'string') {\n                break;\n              }\n\n              if (knownKeys === null) {\n                knownKeys = new Set();\n                knownKeys.add(key);\n                break;\n              }\n\n              if (!knownKeys.has(key)) {\n                knownKeys.add(key);\n                break;\n              }\n\n              warning(false, 'Encountered two children with the same key, `%s`. ' + 'Keys should be unique so that components maintain their identity ' + 'across updates. Non-unique keys may cause children to be ' + 'duplicated and/or omitted  the behavior is unsupported and ' + 'could change in a future version.%s', key, getCurrentFiberStackAddendum$1());\n              break;\n\n            default:\n              break;\n          }\n        }\n        return knownKeys;\n      }\n\n      function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren, expirationTime) {\n        // This algorithm can't optimize by searching from boths ends since we\n        // don't have backpointers on fibers. I'm trying to see how far we can get\n        // with that model. If it ends up not being worth the tradeoffs, we can\n        // add it later.\n        // Even with a two ended optimization, we'd want to optimize for the case\n        // where there are few changes and brute force the comparison instead of\n        // going for the Map. It'd like to explore hitting that path first in\n        // forward-only mode and only go for the Map once we notice that we need\n        // lots of look ahead. This doesn't handle reversal as well as two ended\n        // search but that's unusual. Besides, for the two ended optimization to\n        // work on Iterables, we'd need to copy the whole set.\n        // In this first iteration, we'll just live with hitting the bad case\n        // (adding everything to a Map) in for every insert/move.\n        // If you change this code, also update reconcileChildrenIterator() which\n        // uses the same algorithm.\n        {\n          // First, validate keys.\n          var knownKeys = null;\n\n          for (var i = 0; i < newChildren.length; i++) {\n            var child = newChildren[i];\n            knownKeys = warnOnInvalidKey(child, knownKeys);\n          }\n        }\n        var resultingFirstChild = null;\n        var previousNewFiber = null;\n        var oldFiber = currentFirstChild;\n        var lastPlacedIndex = 0;\n        var newIdx = 0;\n        var nextOldFiber = null;\n\n        for (; oldFiber !== null && newIdx < newChildren.length; newIdx++) {\n          if (oldFiber.index > newIdx) {\n            nextOldFiber = oldFiber;\n            oldFiber = null;\n          } else {\n            nextOldFiber = oldFiber.sibling;\n          }\n\n          var newFiber = updateSlot(returnFiber, oldFiber, newChildren[newIdx], expirationTime);\n\n          if (newFiber === null) {\n            // TODO: This breaks on empty slots like null children. That's\n            // unfortunate because it triggers the slow path all the time. We need\n            // a better way to communicate whether this was a miss or null,\n            // boolean, undefined, etc.\n            if (oldFiber === null) {\n              oldFiber = nextOldFiber;\n            }\n\n            break;\n          }\n\n          if (shouldTrackSideEffects) {\n            if (oldFiber && newFiber.alternate === null) {\n              // We matched the slot, but we didn't reuse the existing fiber, so we\n              // need to delete the existing child.\n              deleteChild(returnFiber, oldFiber);\n            }\n          }\n\n          lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);\n\n          if (previousNewFiber === null) {\n            // TODO: Move out of the loop. This only happens for the first run.\n            resultingFirstChild = newFiber;\n          } else {\n            // TODO: Defer siblings if we're not at the right index for this slot.\n            // I.e. if we had null values before, then we want to defer this\n            // for each null value. However, we also don't want to call updateSlot\n            // with the previous one.\n            previousNewFiber.sibling = newFiber;\n          }\n\n          previousNewFiber = newFiber;\n          oldFiber = nextOldFiber;\n        }\n\n        if (newIdx === newChildren.length) {\n          // We've reached the end of the new children. We can delete the rest.\n          deleteRemainingChildren(returnFiber, oldFiber);\n          return resultingFirstChild;\n        }\n\n        if (oldFiber === null) {\n          // If we don't have any more existing children we can choose a fast path\n          // since the rest will all be insertions.\n          for (; newIdx < newChildren.length; newIdx++) {\n            var _newFiber = createChild(returnFiber, newChildren[newIdx], expirationTime);\n\n            if (!_newFiber) {\n              continue;\n            }\n\n            lastPlacedIndex = placeChild(_newFiber, lastPlacedIndex, newIdx);\n\n            if (previousNewFiber === null) {\n              // TODO: Move out of the loop. This only happens for the first run.\n              resultingFirstChild = _newFiber;\n            } else {\n              previousNewFiber.sibling = _newFiber;\n            }\n\n            previousNewFiber = _newFiber;\n          }\n\n          return resultingFirstChild;\n        } // Add all children to a key map for quick lookups.\n\n\n        var existingChildren = mapRemainingChildren(returnFiber, oldFiber); // Keep scanning and use the map to restore deleted items as moves.\n\n        for (; newIdx < newChildren.length; newIdx++) {\n          var _newFiber2 = updateFromMap(existingChildren, returnFiber, newIdx, newChildren[newIdx], expirationTime);\n\n          if (_newFiber2) {\n            if (shouldTrackSideEffects) {\n              if (_newFiber2.alternate !== null) {\n                // The new fiber is a work in progress, but if there exists a\n                // current, that means that we reused the fiber. We need to delete\n                // it from the child list so that we don't add it to the deletion\n                // list.\n                existingChildren['delete'](_newFiber2.key === null ? newIdx : _newFiber2.key);\n              }\n            }\n\n            lastPlacedIndex = placeChild(_newFiber2, lastPlacedIndex, newIdx);\n\n            if (previousNewFiber === null) {\n              resultingFirstChild = _newFiber2;\n            } else {\n              previousNewFiber.sibling = _newFiber2;\n            }\n\n            previousNewFiber = _newFiber2;\n          }\n        }\n\n        if (shouldTrackSideEffects) {\n          // Any existing children that weren't consumed above were deleted. We need\n          // to add them to the deletion list.\n          existingChildren.forEach(function (child) {\n            return deleteChild(returnFiber, child);\n          });\n        }\n\n        return resultingFirstChild;\n      }\n\n      function reconcileChildrenIterator(returnFiber, currentFirstChild, newChildrenIterable, expirationTime) {\n        // This is the same implementation as reconcileChildrenArray(),\n        // but using the iterator instead.\n        var iteratorFn = getIteratorFn(newChildrenIterable);\n        !(typeof iteratorFn === 'function') ? invariant(false, 'An object is not an iterable. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n        {\n          // Warn about using Maps as children\n          if (typeof newChildrenIterable.entries === 'function') {\n            var possibleMap = newChildrenIterable;\n\n            if (possibleMap.entries === iteratorFn) {\n              warning(didWarnAboutMaps, 'Using Maps as children is unsupported and will likely yield ' + 'unexpected results. Convert it to a sequence/iterable of keyed ' + 'ReactElements instead.%s', getCurrentFiberStackAddendum$1());\n              didWarnAboutMaps = true;\n            }\n          } // First, validate keys.\n          // We'll get a different iterator later for the main pass.\n\n\n          var _newChildren = iteratorFn.call(newChildrenIterable);\n\n          if (_newChildren) {\n            var knownKeys = null;\n\n            var _step = _newChildren.next();\n\n            for (; !_step.done; _step = _newChildren.next()) {\n              var child = _step.value;\n              knownKeys = warnOnInvalidKey(child, knownKeys);\n            }\n          }\n        }\n        var newChildren = iteratorFn.call(newChildrenIterable);\n        !(newChildren != null) ? invariant(false, 'An iterable object provided no iterator.') : void 0;\n        var resultingFirstChild = null;\n        var previousNewFiber = null;\n        var oldFiber = currentFirstChild;\n        var lastPlacedIndex = 0;\n        var newIdx = 0;\n        var nextOldFiber = null;\n        var step = newChildren.next();\n\n        for (; oldFiber !== null && !step.done; newIdx++, step = newChildren.next()) {\n          if (oldFiber.index > newIdx) {\n            nextOldFiber = oldFiber;\n            oldFiber = null;\n          } else {\n            nextOldFiber = oldFiber.sibling;\n          }\n\n          var newFiber = updateSlot(returnFiber, oldFiber, step.value, expirationTime);\n\n          if (newFiber === null) {\n            // TODO: This breaks on empty slots like null children. That's\n            // unfortunate because it triggers the slow path all the time. We need\n            // a better way to communicate whether this was a miss or null,\n            // boolean, undefined, etc.\n            if (!oldFiber) {\n              oldFiber = nextOldFiber;\n            }\n\n            break;\n          }\n\n          if (shouldTrackSideEffects) {\n            if (oldFiber && newFiber.alternate === null) {\n              // We matched the slot, but we didn't reuse the existing fiber, so we\n              // need to delete the existing child.\n              deleteChild(returnFiber, oldFiber);\n            }\n          }\n\n          lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);\n\n          if (previousNewFiber === null) {\n            // TODO: Move out of the loop. This only happens for the first run.\n            resultingFirstChild = newFiber;\n          } else {\n            // TODO: Defer siblings if we're not at the right index for this slot.\n            // I.e. if we had null values before, then we want to defer this\n            // for each null value. However, we also don't want to call updateSlot\n            // with the previous one.\n            previousNewFiber.sibling = newFiber;\n          }\n\n          previousNewFiber = newFiber;\n          oldFiber = nextOldFiber;\n        }\n\n        if (step.done) {\n          // We've reached the end of the new children. We can delete the rest.\n          deleteRemainingChildren(returnFiber, oldFiber);\n          return resultingFirstChild;\n        }\n\n        if (oldFiber === null) {\n          // If we don't have any more existing children we can choose a fast path\n          // since the rest will all be insertions.\n          for (; !step.done; newIdx++, step = newChildren.next()) {\n            var _newFiber3 = createChild(returnFiber, step.value, expirationTime);\n\n            if (_newFiber3 === null) {\n              continue;\n            }\n\n            lastPlacedIndex = placeChild(_newFiber3, lastPlacedIndex, newIdx);\n\n            if (previousNewFiber === null) {\n              // TODO: Move out of the loop. This only happens for the first run.\n              resultingFirstChild = _newFiber3;\n            } else {\n              previousNewFiber.sibling = _newFiber3;\n            }\n\n            previousNewFiber = _newFiber3;\n          }\n\n          return resultingFirstChild;\n        } // Add all children to a key map for quick lookups.\n\n\n        var existingChildren = mapRemainingChildren(returnFiber, oldFiber); // Keep scanning and use the map to restore deleted items as moves.\n\n        for (; !step.done; newIdx++, step = newChildren.next()) {\n          var _newFiber4 = updateFromMap(existingChildren, returnFiber, newIdx, step.value, expirationTime);\n\n          if (_newFiber4 !== null) {\n            if (shouldTrackSideEffects) {\n              if (_newFiber4.alternate !== null) {\n                // The new fiber is a work in progress, but if there exists a\n                // current, that means that we reused the fiber. We need to delete\n                // it from the child list so that we don't add it to the deletion\n                // list.\n                existingChildren['delete'](_newFiber4.key === null ? newIdx : _newFiber4.key);\n              }\n            }\n\n            lastPlacedIndex = placeChild(_newFiber4, lastPlacedIndex, newIdx);\n\n            if (previousNewFiber === null) {\n              resultingFirstChild = _newFiber4;\n            } else {\n              previousNewFiber.sibling = _newFiber4;\n            }\n\n            previousNewFiber = _newFiber4;\n          }\n        }\n\n        if (shouldTrackSideEffects) {\n          // Any existing children that weren't consumed above were deleted. We need\n          // to add them to the deletion list.\n          existingChildren.forEach(function (child) {\n            return deleteChild(returnFiber, child);\n          });\n        }\n\n        return resultingFirstChild;\n      }\n\n      function reconcileSingleTextNode(returnFiber, currentFirstChild, textContent, expirationTime) {\n        // There's no need to check for keys on text nodes since we don't have a\n        // way to define them.\n        if (currentFirstChild !== null && currentFirstChild.tag === HostText) {\n          // We already have an existing node so let's just update it and delete\n          // the rest.\n          deleteRemainingChildren(returnFiber, currentFirstChild.sibling);\n          var existing = useFiber(currentFirstChild, textContent, expirationTime);\n          existing['return'] = returnFiber;\n          return existing;\n        } // The existing first child is not a text node so we need to create one\n        // and delete the existing ones.\n\n\n        deleteRemainingChildren(returnFiber, currentFirstChild);\n        var created = createFiberFromText(textContent, returnFiber.internalContextTag, expirationTime);\n        created['return'] = returnFiber;\n        return created;\n      }\n\n      function reconcileSingleElement(returnFiber, currentFirstChild, element, expirationTime) {\n        var key = element.key;\n        var child = currentFirstChild;\n\n        while (child !== null) {\n          // TODO: If key === null and child.key === null, then this only applies to\n          // the first item in the list.\n          if (child.key === key) {\n            if (child.tag === Fragment ? element.type === REACT_FRAGMENT_TYPE : child.type === element.type) {\n              deleteRemainingChildren(returnFiber, child.sibling);\n              var existing = useFiber(child, element.type === REACT_FRAGMENT_TYPE ? element.props.children : element.props, expirationTime);\n              existing.ref = coerceRef(child, element);\n              existing['return'] = returnFiber;\n              {\n                existing._debugSource = element._source;\n                existing._debugOwner = element._owner;\n              }\n              return existing;\n            } else {\n              deleteRemainingChildren(returnFiber, child);\n              break;\n            }\n          } else {\n            deleteChild(returnFiber, child);\n          }\n\n          child = child.sibling;\n        }\n\n        if (element.type === REACT_FRAGMENT_TYPE) {\n          var created = createFiberFromFragment(element.props.children, returnFiber.internalContextTag, expirationTime, element.key);\n          created['return'] = returnFiber;\n          return created;\n        } else {\n          var _created7 = createFiberFromElement(element, returnFiber.internalContextTag, expirationTime);\n\n          _created7.ref = coerceRef(currentFirstChild, element);\n          _created7['return'] = returnFiber;\n          return _created7;\n        }\n      }\n\n      function reconcileSingleCall(returnFiber, currentFirstChild, call, expirationTime) {\n        var key = call.key;\n        var child = currentFirstChild;\n\n        while (child !== null) {\n          // TODO: If key === null and child.key === null, then this only applies to\n          // the first item in the list.\n          if (child.key === key) {\n            if (child.tag === CallComponent) {\n              deleteRemainingChildren(returnFiber, child.sibling);\n              var existing = useFiber(child, call, expirationTime);\n              existing['return'] = returnFiber;\n              return existing;\n            } else {\n              deleteRemainingChildren(returnFiber, child);\n              break;\n            }\n          } else {\n            deleteChild(returnFiber, child);\n          }\n\n          child = child.sibling;\n        }\n\n        var created = createFiberFromCall(call, returnFiber.internalContextTag, expirationTime);\n        created['return'] = returnFiber;\n        return created;\n      }\n\n      function reconcileSingleReturn(returnFiber, currentFirstChild, returnNode, expirationTime) {\n        // There's no need to check for keys on yields since they're stateless.\n        var child = currentFirstChild;\n\n        if (child !== null) {\n          if (child.tag === ReturnComponent) {\n            deleteRemainingChildren(returnFiber, child.sibling);\n            var existing = useFiber(child, null, expirationTime);\n            existing.type = returnNode.value;\n            existing['return'] = returnFiber;\n            return existing;\n          } else {\n            deleteRemainingChildren(returnFiber, child);\n          }\n        }\n\n        var created = createFiberFromReturn(returnNode, returnFiber.internalContextTag, expirationTime);\n        created.type = returnNode.value;\n        created['return'] = returnFiber;\n        return created;\n      }\n\n      function reconcileSinglePortal(returnFiber, currentFirstChild, portal, expirationTime) {\n        var key = portal.key;\n        var child = currentFirstChild;\n\n        while (child !== null) {\n          // TODO: If key === null and child.key === null, then this only applies to\n          // the first item in the list.\n          if (child.key === key) {\n            if (child.tag === HostPortal && child.stateNode.containerInfo === portal.containerInfo && child.stateNode.implementation === portal.implementation) {\n              deleteRemainingChildren(returnFiber, child.sibling);\n              var existing = useFiber(child, portal.children || [], expirationTime);\n              existing['return'] = returnFiber;\n              return existing;\n            } else {\n              deleteRemainingChildren(returnFiber, child);\n              break;\n            }\n          } else {\n            deleteChild(returnFiber, child);\n          }\n\n          child = child.sibling;\n        }\n\n        var created = createFiberFromPortal(portal, returnFiber.internalContextTag, expirationTime);\n        created['return'] = returnFiber;\n        return created;\n      } // This API will tag the children with the side-effect of the reconciliation\n      // itself. They will be added to the side-effect list as we pass through the\n      // children and the parent.\n\n\n      function reconcileChildFibers(returnFiber, currentFirstChild, newChild, expirationTime) {\n        // This function is not recursive.\n        // If the top level item is an array, we treat it as a set of children,\n        // not as a fragment. Nested arrays on the other hand will be treated as\n        // fragment nodes. Recursion happens at the normal flow.\n        // Handle top level unkeyed fragments as if they were arrays.\n        // This leads to an ambiguity between <>{[...]}</> and <>...</>.\n        // We treat the ambiguous cases above the same.\n        if (typeof newChild === 'object' && newChild !== null && newChild.type === REACT_FRAGMENT_TYPE && newChild.key === null) {\n          newChild = newChild.props.children;\n        } // Handle object types\n\n\n        var isObject = typeof newChild === 'object' && newChild !== null;\n\n        if (isObject) {\n          switch (newChild.$$typeof) {\n            case REACT_ELEMENT_TYPE:\n              return placeSingleChild(reconcileSingleElement(returnFiber, currentFirstChild, newChild, expirationTime));\n\n            case REACT_CALL_TYPE:\n              return placeSingleChild(reconcileSingleCall(returnFiber, currentFirstChild, newChild, expirationTime));\n\n            case REACT_RETURN_TYPE:\n              return placeSingleChild(reconcileSingleReturn(returnFiber, currentFirstChild, newChild, expirationTime));\n\n            case REACT_PORTAL_TYPE:\n              return placeSingleChild(reconcileSinglePortal(returnFiber, currentFirstChild, newChild, expirationTime));\n          }\n        }\n\n        if (typeof newChild === 'string' || typeof newChild === 'number') {\n          return placeSingleChild(reconcileSingleTextNode(returnFiber, currentFirstChild, '' + newChild, expirationTime));\n        }\n\n        if (isArray$1(newChild)) {\n          return reconcileChildrenArray(returnFiber, currentFirstChild, newChild, expirationTime);\n        }\n\n        if (getIteratorFn(newChild)) {\n          return reconcileChildrenIterator(returnFiber, currentFirstChild, newChild, expirationTime);\n        }\n\n        if (isObject) {\n          throwOnInvalidObjectType(returnFiber, newChild);\n        }\n\n        {\n          if (typeof newChild === 'function') {\n            warnOnFunctionType();\n          }\n        }\n\n        if (typeof newChild === 'undefined') {\n          // If the new child is undefined, and the return fiber is a composite\n          // component, throw an error. If Fiber return types are disabled,\n          // we already threw above.\n          switch (returnFiber.tag) {\n            case ClassComponent:\n              {\n                {\n                  var instance = returnFiber.stateNode;\n\n                  if (instance.render._isMockFunction) {\n                    // We allow auto-mocks to proceed as if they're returning null.\n                    break;\n                  }\n                }\n              }\n            // Intentionally fall through to the next case, which handles both\n            // functions and classes\n            // eslint-disable-next-lined no-fallthrough\n\n            case FunctionalComponent:\n              {\n                var Component = returnFiber.type;\n                invariant(false, '%s(...): Nothing was returned from render. This usually means a return statement is missing. Or, to render nothing, return null.', Component.displayName || Component.name || 'Component');\n              }\n          }\n        } // Remaining cases are all treated as empty.\n\n\n        return deleteRemainingChildren(returnFiber, currentFirstChild);\n      }\n\n      return reconcileChildFibers;\n    }\n\n    var reconcileChildFibers = ChildReconciler(true);\n    var mountChildFibers = ChildReconciler(false);\n\n    function cloneChildFibers(current, workInProgress) {\n      !(current === null || workInProgress.child === current.child) ? invariant(false, 'Resuming work not yet implemented.') : void 0;\n\n      if (workInProgress.child === null) {\n        return;\n      }\n\n      var currentChild = workInProgress.child;\n      var newChild = createWorkInProgress(currentChild, currentChild.pendingProps, currentChild.expirationTime);\n      workInProgress.child = newChild;\n      newChild['return'] = workInProgress;\n\n      while (currentChild.sibling !== null) {\n        currentChild = currentChild.sibling;\n        newChild = newChild.sibling = createWorkInProgress(currentChild, currentChild.pendingProps, currentChild.expirationTime);\n        newChild['return'] = workInProgress;\n      }\n\n      newChild.sibling = null;\n    }\n\n    {\n      var warnedAboutStatelessRefs = {};\n    }\n\n    var ReactFiberBeginWork = function (config, hostContext, hydrationContext, scheduleWork, computeExpirationForFiber) {\n      var shouldSetTextContent = config.shouldSetTextContent,\n          useSyncScheduling = config.useSyncScheduling,\n          shouldDeprioritizeSubtree = config.shouldDeprioritizeSubtree;\n      var pushHostContext = hostContext.pushHostContext,\n          pushHostContainer = hostContext.pushHostContainer;\n      var enterHydrationState = hydrationContext.enterHydrationState,\n          resetHydrationState = hydrationContext.resetHydrationState,\n          tryToClaimNextHydratableInstance = hydrationContext.tryToClaimNextHydratableInstance;\n\n      var _ReactFiberClassCompo = ReactFiberClassComponent(scheduleWork, computeExpirationForFiber, memoizeProps, memoizeState),\n          adoptClassInstance = _ReactFiberClassCompo.adoptClassInstance,\n          constructClassInstance = _ReactFiberClassCompo.constructClassInstance,\n          mountClassInstance = _ReactFiberClassCompo.mountClassInstance,\n          updateClassInstance = _ReactFiberClassCompo.updateClassInstance; // TODO: Remove this and use reconcileChildrenAtExpirationTime directly.\n\n\n      function reconcileChildren(current, workInProgress, nextChildren) {\n        reconcileChildrenAtExpirationTime(current, workInProgress, nextChildren, workInProgress.expirationTime);\n      }\n\n      function reconcileChildrenAtExpirationTime(current, workInProgress, nextChildren, renderExpirationTime) {\n        if (current === null) {\n          // If this is a fresh new component that hasn't been rendered yet, we\n          // won't update its child set by applying minimal side-effects. Instead,\n          // we will add them all to the child before it gets rendered. That means\n          // we can optimize this reconciliation pass by not tracking side-effects.\n          workInProgress.child = mountChildFibers(workInProgress, null, nextChildren, renderExpirationTime);\n        } else {\n          // If the current child is the same as the work in progress, it means that\n          // we haven't yet started any work on these children. Therefore, we use\n          // the clone algorithm to create a copy of all the current children.\n          // If we had any progressed work already, that is invalid at this point so\n          // let's throw it out.\n          workInProgress.child = reconcileChildFibers(workInProgress, current.child, nextChildren, renderExpirationTime);\n        }\n      }\n\n      function updateFragment(current, workInProgress) {\n        var nextChildren = workInProgress.pendingProps;\n\n        if (hasContextChanged()) {\n          // Normally we can bail out on props equality but if context has changed\n          // we don't do the bailout and we have to reuse existing props instead.\n          if (nextChildren === null) {\n            nextChildren = workInProgress.memoizedProps;\n          }\n        } else if (nextChildren === null || workInProgress.memoizedProps === nextChildren) {\n          return bailoutOnAlreadyFinishedWork(current, workInProgress);\n        }\n\n        reconcileChildren(current, workInProgress, nextChildren);\n        memoizeProps(workInProgress, nextChildren);\n        return workInProgress.child;\n      }\n\n      function markRef(current, workInProgress) {\n        var ref = workInProgress.ref;\n\n        if (ref !== null && (!current || current.ref !== ref)) {\n          // Schedule a Ref effect\n          workInProgress.effectTag |= Ref;\n        }\n      }\n\n      function updateFunctionalComponent(current, workInProgress) {\n        var fn = workInProgress.type;\n        var nextProps = workInProgress.pendingProps;\n        var memoizedProps = workInProgress.memoizedProps;\n\n        if (hasContextChanged()) {\n          // Normally we can bail out on props equality but if context has changed\n          // we don't do the bailout and we have to reuse existing props instead.\n          if (nextProps === null) {\n            nextProps = memoizedProps;\n          }\n        } else {\n          if (nextProps === null || memoizedProps === nextProps) {\n            return bailoutOnAlreadyFinishedWork(current, workInProgress);\n          } // TODO: consider bringing fn.shouldComponentUpdate() back.\n          // It used to be here.\n\n        }\n\n        var unmaskedContext = getUnmaskedContext(workInProgress);\n        var context = getMaskedContext(workInProgress, unmaskedContext);\n        var nextChildren;\n        {\n          ReactCurrentOwner.current = workInProgress;\n          ReactDebugCurrentFiber.setCurrentPhase('render');\n          nextChildren = fn(nextProps, context);\n          ReactDebugCurrentFiber.setCurrentPhase(null);\n        } // React DevTools reads this flag.\n\n        workInProgress.effectTag |= PerformedWork;\n        reconcileChildren(current, workInProgress, nextChildren);\n        memoizeProps(workInProgress, nextProps);\n        return workInProgress.child;\n      }\n\n      function updateClassComponent(current, workInProgress, renderExpirationTime) {\n        // Push context providers early to prevent context stack mismatches.\n        // During mounting we don't know the child context yet as the instance doesn't exist.\n        // We will invalidate the child context in finishClassComponent() right after rendering.\n        var hasContext = pushContextProvider(workInProgress);\n        var shouldUpdate = void 0;\n\n        if (current === null) {\n          if (!workInProgress.stateNode) {\n            // In the initial pass we might need to construct the instance.\n            constructClassInstance(workInProgress, workInProgress.pendingProps);\n            mountClassInstance(workInProgress, renderExpirationTime);\n            shouldUpdate = true;\n          } else {\n            invariant(false, 'Resuming work not yet implemented.'); // In a resume, we'll already have an instance we can reuse.\n            // shouldUpdate = resumeMountClassInstance(workInProgress, renderExpirationTime);\n          }\n        } else {\n          shouldUpdate = updateClassInstance(current, workInProgress, renderExpirationTime);\n        }\n\n        return finishClassComponent(current, workInProgress, shouldUpdate, hasContext);\n      }\n\n      function finishClassComponent(current, workInProgress, shouldUpdate, hasContext) {\n        // Refs should update even if shouldComponentUpdate returns false\n        markRef(current, workInProgress);\n\n        if (!shouldUpdate) {\n          // Context providers should defer to sCU for rendering\n          if (hasContext) {\n            invalidateContextProvider(workInProgress, false);\n          }\n\n          return bailoutOnAlreadyFinishedWork(current, workInProgress);\n        }\n\n        var instance = workInProgress.stateNode; // Rerender\n\n        ReactCurrentOwner.current = workInProgress;\n        var nextChildren = void 0;\n        {\n          ReactDebugCurrentFiber.setCurrentPhase('render');\n          nextChildren = instance.render();\n\n          if (debugRenderPhaseSideEffects) {\n            instance.render();\n          }\n\n          ReactDebugCurrentFiber.setCurrentPhase(null);\n        } // React DevTools reads this flag.\n\n        workInProgress.effectTag |= PerformedWork;\n        reconcileChildren(current, workInProgress, nextChildren); // Memoize props and state using the values we just used to render.\n        // TODO: Restructure so we never read values from the instance.\n\n        memoizeState(workInProgress, instance.state);\n        memoizeProps(workInProgress, instance.props); // The context might have changed so we need to recalculate it.\n\n        if (hasContext) {\n          invalidateContextProvider(workInProgress, true);\n        }\n\n        return workInProgress.child;\n      }\n\n      function pushHostRootContext(workInProgress) {\n        var root = workInProgress.stateNode;\n\n        if (root.pendingContext) {\n          pushTopLevelContextObject(workInProgress, root.pendingContext, root.pendingContext !== root.context);\n        } else if (root.context) {\n          // Should always be set\n          pushTopLevelContextObject(workInProgress, root.context, false);\n        }\n\n        pushHostContainer(workInProgress, root.containerInfo);\n      }\n\n      function updateHostRoot(current, workInProgress, renderExpirationTime) {\n        pushHostRootContext(workInProgress);\n        var updateQueue = workInProgress.updateQueue;\n\n        if (updateQueue !== null) {\n          var prevState = workInProgress.memoizedState;\n          var state = processUpdateQueue(current, workInProgress, updateQueue, null, null, renderExpirationTime);\n\n          if (prevState === state) {\n            // If the state is the same as before, that's a bailout because we had\n            // no work that expires at this time.\n            resetHydrationState();\n            return bailoutOnAlreadyFinishedWork(current, workInProgress);\n          }\n\n          var element = state.element;\n          var root = workInProgress.stateNode;\n\n          if ((current === null || current.child === null) && root.hydrate && enterHydrationState(workInProgress)) {\n            // If we don't have any current children this might be the first pass.\n            // We always try to hydrate. If this isn't a hydration pass there won't\n            // be any children to hydrate which is effectively the same thing as\n            // not hydrating.\n            // This is a bit of a hack. We track the host root as a placement to\n            // know that we're currently in a mounting state. That way isMounted\n            // works as expected. We must reset this before committing.\n            // TODO: Delete this when we delete isMounted and findDOMNode.\n            workInProgress.effectTag |= Placement; // Ensure that children mount into this root without tracking\n            // side-effects. This ensures that we don't store Placement effects on\n            // nodes that will be hydrated.\n\n            workInProgress.child = mountChildFibers(workInProgress, null, element, renderExpirationTime);\n          } else {\n            // Otherwise reset hydration state in case we aborted and resumed another\n            // root.\n            resetHydrationState();\n            reconcileChildren(current, workInProgress, element);\n          }\n\n          memoizeState(workInProgress, state);\n          return workInProgress.child;\n        }\n\n        resetHydrationState(); // If there is no update queue, that's a bailout because the root has no props.\n\n        return bailoutOnAlreadyFinishedWork(current, workInProgress);\n      }\n\n      function updateHostComponent(current, workInProgress, renderExpirationTime) {\n        pushHostContext(workInProgress);\n\n        if (current === null) {\n          tryToClaimNextHydratableInstance(workInProgress);\n        }\n\n        var type = workInProgress.type;\n        var memoizedProps = workInProgress.memoizedProps;\n        var nextProps = workInProgress.pendingProps;\n\n        if (nextProps === null) {\n          nextProps = memoizedProps;\n          !(nextProps !== null) ? invariant(false, 'We should always have pending or current props. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n        }\n\n        var prevProps = current !== null ? current.memoizedProps : null;\n\n        if (hasContextChanged()) {// Normally we can bail out on props equality but if context has changed\n          // we don't do the bailout and we have to reuse existing props instead.\n        } else if (nextProps === null || memoizedProps === nextProps) {\n          return bailoutOnAlreadyFinishedWork(current, workInProgress);\n        }\n\n        var nextChildren = nextProps.children;\n        var isDirectTextChild = shouldSetTextContent(type, nextProps);\n\n        if (isDirectTextChild) {\n          // We special case a direct text child of a host node. This is a common\n          // case. We won't handle it as a reified child. We will instead handle\n          // this in the host environment that also have access to this prop. That\n          // avoids allocating another HostText fiber and traversing it.\n          nextChildren = null;\n        } else if (prevProps && shouldSetTextContent(type, prevProps)) {\n          // If we're switching from a direct text child to a normal child, or to\n          // empty, we need to schedule the text content to be reset.\n          workInProgress.effectTag |= ContentReset;\n        }\n\n        markRef(current, workInProgress); // Check the host config to see if the children are offscreen/hidden.\n\n        if (renderExpirationTime !== Never && !useSyncScheduling && shouldDeprioritizeSubtree(type, nextProps)) {\n          // Down-prioritize the children.\n          workInProgress.expirationTime = Never; // Bailout and come back to this fiber later.\n\n          return null;\n        }\n\n        reconcileChildren(current, workInProgress, nextChildren);\n        memoizeProps(workInProgress, nextProps);\n        return workInProgress.child;\n      }\n\n      function updateHostText(current, workInProgress) {\n        if (current === null) {\n          tryToClaimNextHydratableInstance(workInProgress);\n        }\n\n        var nextProps = workInProgress.pendingProps;\n\n        if (nextProps === null) {\n          nextProps = workInProgress.memoizedProps;\n        }\n\n        memoizeProps(workInProgress, nextProps); // Nothing to do here. This is terminal. We'll do the completion step\n        // immediately after.\n\n        return null;\n      }\n\n      function mountIndeterminateComponent(current, workInProgress, renderExpirationTime) {\n        !(current === null) ? invariant(false, 'An indeterminate component should never have mounted. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n        var fn = workInProgress.type;\n        var props = workInProgress.pendingProps;\n        var unmaskedContext = getUnmaskedContext(workInProgress);\n        var context = getMaskedContext(workInProgress, unmaskedContext);\n        var value;\n        {\n          if (fn.prototype && typeof fn.prototype.render === 'function') {\n            var componentName = getComponentName(workInProgress);\n            warning(false, \"The <%s /> component appears to have a render method, but doesn't extend React.Component. \" + 'This is likely to cause errors. Change %s to extend React.Component instead.', componentName, componentName);\n          }\n\n          ReactCurrentOwner.current = workInProgress;\n          value = fn(props, context);\n        } // React DevTools reads this flag.\n\n        workInProgress.effectTag |= PerformedWork;\n\n        if (typeof value === 'object' && value !== null && typeof value.render === 'function') {\n          // Proceed under the assumption that this is a class instance\n          workInProgress.tag = ClassComponent; // Push context providers early to prevent context stack mismatches.\n          // During mounting we don't know the child context yet as the instance doesn't exist.\n          // We will invalidate the child context in finishClassComponent() right after rendering.\n\n          var hasContext = pushContextProvider(workInProgress);\n          adoptClassInstance(workInProgress, value);\n          mountClassInstance(workInProgress, renderExpirationTime);\n          return finishClassComponent(current, workInProgress, true, hasContext);\n        } else {\n          // Proceed under the assumption that this is a functional component\n          workInProgress.tag = FunctionalComponent;\n          {\n            var Component = workInProgress.type;\n\n            if (Component) {\n              warning(!Component.childContextTypes, '%s(...): childContextTypes cannot be defined on a functional component.', Component.displayName || Component.name || 'Component');\n            }\n\n            if (workInProgress.ref !== null) {\n              var info = '';\n              var ownerName = ReactDebugCurrentFiber.getCurrentFiberOwnerName();\n\n              if (ownerName) {\n                info += '\\n\\nCheck the render method of `' + ownerName + '`.';\n              }\n\n              var warningKey = ownerName || workInProgress._debugID || '';\n              var debugSource = workInProgress._debugSource;\n\n              if (debugSource) {\n                warningKey = debugSource.fileName + ':' + debugSource.lineNumber;\n              }\n\n              if (!warnedAboutStatelessRefs[warningKey]) {\n                warnedAboutStatelessRefs[warningKey] = true;\n                warning(false, 'Stateless function components cannot be given refs. ' + 'Attempts to access this ref will fail.%s%s', info, ReactDebugCurrentFiber.getCurrentFiberStackAddendum());\n              }\n            }\n          }\n          reconcileChildren(current, workInProgress, value);\n          memoizeProps(workInProgress, props);\n          return workInProgress.child;\n        }\n      }\n\n      function updateCallComponent(current, workInProgress, renderExpirationTime) {\n        var nextCall = workInProgress.pendingProps;\n\n        if (hasContextChanged()) {\n          // Normally we can bail out on props equality but if context has changed\n          // we don't do the bailout and we have to reuse existing props instead.\n          if (nextCall === null) {\n            nextCall = current && current.memoizedProps;\n            !(nextCall !== null) ? invariant(false, 'We should always have pending or current props. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n          }\n        } else if (nextCall === null || workInProgress.memoizedProps === nextCall) {\n          nextCall = workInProgress.memoizedProps; // TODO: When bailing out, we might need to return the stateNode instead\n          // of the child. To check it for work.\n          // return bailoutOnAlreadyFinishedWork(current, workInProgress);\n        }\n\n        var nextChildren = nextCall.children; // The following is a fork of reconcileChildrenAtExpirationTime but using\n        // stateNode to store the child.\n\n        if (current === null) {\n          workInProgress.stateNode = mountChildFibers(workInProgress, workInProgress.stateNode, nextChildren, renderExpirationTime);\n        } else {\n          workInProgress.stateNode = reconcileChildFibers(workInProgress, workInProgress.stateNode, nextChildren, renderExpirationTime);\n        }\n\n        memoizeProps(workInProgress, nextCall); // This doesn't take arbitrary time so we could synchronously just begin\n        // eagerly do the work of workInProgress.child as an optimization.\n\n        return workInProgress.stateNode;\n      }\n\n      function updatePortalComponent(current, workInProgress, renderExpirationTime) {\n        pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);\n        var nextChildren = workInProgress.pendingProps;\n\n        if (hasContextChanged()) {\n          // Normally we can bail out on props equality but if context has changed\n          // we don't do the bailout and we have to reuse existing props instead.\n          if (nextChildren === null) {\n            nextChildren = current && current.memoizedProps;\n            !(nextChildren != null) ? invariant(false, 'We should always have pending or current props. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n          }\n        } else if (nextChildren === null || workInProgress.memoizedProps === nextChildren) {\n          return bailoutOnAlreadyFinishedWork(current, workInProgress);\n        }\n\n        if (current === null) {\n          // Portals are special because we don't append the children during mount\n          // but at commit. Therefore we need to track insertions which the normal\n          // flow doesn't do during mount. This doesn't happen at the root because\n          // the root always starts with a \"current\" with a null child.\n          // TODO: Consider unifying this with how the root works.\n          workInProgress.child = reconcileChildFibers(workInProgress, null, nextChildren, renderExpirationTime);\n          memoizeProps(workInProgress, nextChildren);\n        } else {\n          reconcileChildren(current, workInProgress, nextChildren);\n          memoizeProps(workInProgress, nextChildren);\n        }\n\n        return workInProgress.child;\n      }\n      /*\n      function reuseChildrenEffects(returnFiber : Fiber, firstChild : Fiber) {\n        let child = firstChild;\n        do {\n          // Ensure that the first and last effect of the parent corresponds\n          // to the children's first and last effect.\n          if (!returnFiber.firstEffect) {\n            returnFiber.firstEffect = child.firstEffect;\n          }\n          if (child.lastEffect) {\n            if (returnFiber.lastEffect) {\n              returnFiber.lastEffect.nextEffect = child.firstEffect;\n            }\n            returnFiber.lastEffect = child.lastEffect;\n          }\n        } while (child = child.sibling);\n      }\n      */\n\n\n      function bailoutOnAlreadyFinishedWork(current, workInProgress) {\n        cancelWorkTimer(workInProgress); // TODO: We should ideally be able to bail out early if the children have no\n        // more work to do. However, since we don't have a separation of this\n        // Fiber's priority and its children yet - we don't know without doing lots\n        // of the same work we do anyway. Once we have that separation we can just\n        // bail out here if the children has no more work at this priority level.\n        // if (workInProgress.priorityOfChildren <= priorityLevel) {\n        //   // If there are side-effects in these children that have not yet been\n        //   // committed we need to ensure that they get properly transferred up.\n        //   if (current && current.child !== workInProgress.child) {\n        //     reuseChildrenEffects(workInProgress, child);\n        //   }\n        //   return null;\n        // }\n\n        cloneChildFibers(current, workInProgress);\n        return workInProgress.child;\n      }\n\n      function bailoutOnLowPriority(current, workInProgress) {\n        cancelWorkTimer(workInProgress); // TODO: Handle HostComponent tags here as well and call pushHostContext()?\n        // See PR 8590 discussion for context\n\n        switch (workInProgress.tag) {\n          case HostRoot:\n            pushHostRootContext(workInProgress);\n            break;\n\n          case ClassComponent:\n            pushContextProvider(workInProgress);\n            break;\n\n          case HostPortal:\n            pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);\n            break;\n        } // TODO: What if this is currently in progress?\n        // How can that happen? How is this not being cloned?\n\n\n        return null;\n      } // TODO: Delete memoizeProps/State and move to reconcile/bailout instead\n\n\n      function memoizeProps(workInProgress, nextProps) {\n        workInProgress.memoizedProps = nextProps;\n      }\n\n      function memoizeState(workInProgress, nextState) {\n        workInProgress.memoizedState = nextState; // Don't reset the updateQueue, in case there are pending updates. Resetting\n        // is handled by processUpdateQueue.\n      }\n\n      function beginWork(current, workInProgress, renderExpirationTime) {\n        if (workInProgress.expirationTime === NoWork || workInProgress.expirationTime > renderExpirationTime) {\n          return bailoutOnLowPriority(current, workInProgress);\n        }\n\n        switch (workInProgress.tag) {\n          case IndeterminateComponent:\n            return mountIndeterminateComponent(current, workInProgress, renderExpirationTime);\n\n          case FunctionalComponent:\n            return updateFunctionalComponent(current, workInProgress);\n\n          case ClassComponent:\n            return updateClassComponent(current, workInProgress, renderExpirationTime);\n\n          case HostRoot:\n            return updateHostRoot(current, workInProgress, renderExpirationTime);\n\n          case HostComponent:\n            return updateHostComponent(current, workInProgress, renderExpirationTime);\n\n          case HostText:\n            return updateHostText(current, workInProgress);\n\n          case CallHandlerPhase:\n            // This is a restart. Reset the tag to the initial phase.\n            workInProgress.tag = CallComponent;\n          // Intentionally fall through since this is now the same.\n\n          case CallComponent:\n            return updateCallComponent(current, workInProgress, renderExpirationTime);\n\n          case ReturnComponent:\n            // A return component is just a placeholder, we can just run through the\n            // next one immediately.\n            return null;\n\n          case HostPortal:\n            return updatePortalComponent(current, workInProgress, renderExpirationTime);\n\n          case Fragment:\n            return updateFragment(current, workInProgress);\n\n          default:\n            invariant(false, 'Unknown unit of work tag. This error is likely caused by a bug in React. Please file an issue.');\n        }\n      }\n\n      function beginFailedWork(current, workInProgress, renderExpirationTime) {\n        // Push context providers here to avoid a push/pop context mismatch.\n        switch (workInProgress.tag) {\n          case ClassComponent:\n            pushContextProvider(workInProgress);\n            break;\n\n          case HostRoot:\n            pushHostRootContext(workInProgress);\n            break;\n\n          default:\n            invariant(false, 'Invalid type of work. This error is likely caused by a bug in React. Please file an issue.');\n        } // Add an error effect so we can handle the error during the commit phase\n\n\n        workInProgress.effectTag |= Err; // This is a weird case where we do \"resume\" work  work that failed on\n        // our first attempt. Because we no longer have a notion of \"progressed\n        // deletions,\" reset the child to the current child to make sure we delete\n        // it again. TODO: Find a better way to handle this, perhaps during a more\n        // general overhaul of error handling.\n\n        if (current === null) {\n          workInProgress.child = null;\n        } else if (workInProgress.child !== current.child) {\n          workInProgress.child = current.child;\n        }\n\n        if (workInProgress.expirationTime === NoWork || workInProgress.expirationTime > renderExpirationTime) {\n          return bailoutOnLowPriority(current, workInProgress);\n        } // If we don't bail out, we're going be recomputing our children so we need\n        // to drop our effect list.\n\n\n        workInProgress.firstEffect = null;\n        workInProgress.lastEffect = null; // Unmount the current children as if the component rendered null\n\n        var nextChildren = null;\n        reconcileChildrenAtExpirationTime(current, workInProgress, nextChildren, renderExpirationTime);\n\n        if (workInProgress.tag === ClassComponent) {\n          var instance = workInProgress.stateNode;\n          workInProgress.memoizedProps = instance.props;\n          workInProgress.memoizedState = instance.state;\n        }\n\n        return workInProgress.child;\n      }\n\n      return {\n        beginWork: beginWork,\n        beginFailedWork: beginFailedWork\n      };\n    };\n\n    var ReactFiberCompleteWork = function (config, hostContext, hydrationContext) {\n      var createInstance = config.createInstance,\n          createTextInstance = config.createTextInstance,\n          appendInitialChild = config.appendInitialChild,\n          finalizeInitialChildren = config.finalizeInitialChildren,\n          prepareUpdate = config.prepareUpdate,\n          mutation = config.mutation,\n          persistence = config.persistence;\n      var getRootHostContainer = hostContext.getRootHostContainer,\n          popHostContext = hostContext.popHostContext,\n          getHostContext = hostContext.getHostContext,\n          popHostContainer = hostContext.popHostContainer;\n      var prepareToHydrateHostInstance = hydrationContext.prepareToHydrateHostInstance,\n          prepareToHydrateHostTextInstance = hydrationContext.prepareToHydrateHostTextInstance,\n          popHydrationState = hydrationContext.popHydrationState;\n\n      function markUpdate(workInProgress) {\n        // Tag the fiber with an update effect. This turns a Placement into\n        // an UpdateAndPlacement.\n        workInProgress.effectTag |= Update;\n      }\n\n      function markRef(workInProgress) {\n        workInProgress.effectTag |= Ref;\n      }\n\n      function appendAllReturns(returns, workInProgress) {\n        var node = workInProgress.stateNode;\n\n        if (node) {\n          node['return'] = workInProgress;\n        }\n\n        while (node !== null) {\n          if (node.tag === HostComponent || node.tag === HostText || node.tag === HostPortal) {\n            invariant(false, 'A call cannot have host component children.');\n          } else if (node.tag === ReturnComponent) {\n            returns.push(node.type);\n          } else if (node.child !== null) {\n            node.child['return'] = node;\n            node = node.child;\n            continue;\n          }\n\n          while (node.sibling === null) {\n            if (node['return'] === null || node['return'] === workInProgress) {\n              return;\n            }\n\n            node = node['return'];\n          }\n\n          node.sibling['return'] = node['return'];\n          node = node.sibling;\n        }\n      }\n\n      function moveCallToHandlerPhase(current, workInProgress, renderExpirationTime) {\n        var call = workInProgress.memoizedProps;\n        !call ? invariant(false, 'Should be resolved by now. This error is likely caused by a bug in React. Please file an issue.') : void 0; // First step of the call has completed. Now we need to do the second.\n        // TODO: It would be nice to have a multi stage call represented by a\n        // single component, or at least tail call optimize nested ones. Currently\n        // that requires additional fields that we don't want to add to the fiber.\n        // So this requires nested handlers.\n        // Note: This doesn't mutate the alternate node. I don't think it needs to\n        // since this stage is reset for every pass.\n\n        workInProgress.tag = CallHandlerPhase; // Build up the returns.\n        // TODO: Compare this to a generator or opaque helpers like Children.\n\n        var returns = [];\n        appendAllReturns(returns, workInProgress);\n        var fn = call.handler;\n        var props = call.props;\n        var nextChildren = fn(props, returns);\n        var currentFirstChild = current !== null ? current.child : null;\n        workInProgress.child = reconcileChildFibers(workInProgress, currentFirstChild, nextChildren, renderExpirationTime);\n        return workInProgress.child;\n      }\n\n      function appendAllChildren(parent, workInProgress) {\n        // We only have the top Fiber that was created but we need recurse down its\n        // children to find all the terminal nodes.\n        var node = workInProgress.child;\n\n        while (node !== null) {\n          if (node.tag === HostComponent || node.tag === HostText) {\n            appendInitialChild(parent, node.stateNode);\n          } else if (node.tag === HostPortal) {// If we have a portal child, then we don't want to traverse\n            // down its children. Instead, we'll get insertions from each child in\n            // the portal directly.\n          } else if (node.child !== null) {\n            node.child['return'] = node;\n            node = node.child;\n            continue;\n          }\n\n          if (node === workInProgress) {\n            return;\n          }\n\n          while (node.sibling === null) {\n            if (node['return'] === null || node['return'] === workInProgress) {\n              return;\n            }\n\n            node = node['return'];\n          }\n\n          node.sibling['return'] = node['return'];\n          node = node.sibling;\n        }\n      }\n\n      var updateHostContainer = void 0;\n      var updateHostComponent = void 0;\n      var updateHostText = void 0;\n\n      if (mutation) {\n        if (enableMutatingReconciler) {\n          // Mutation mode\n          updateHostContainer = function (workInProgress) {// Noop\n          };\n\n          updateHostComponent = function (current, workInProgress, updatePayload, type, oldProps, newProps, rootContainerInstance) {\n            // TODO: Type this specific to this type of component.\n            workInProgress.updateQueue = updatePayload; // If the update payload indicates that there is a change or if there\n            // is a new ref we mark this as an update. All the work is done in commitWork.\n\n            if (updatePayload) {\n              markUpdate(workInProgress);\n            }\n          };\n\n          updateHostText = function (current, workInProgress, oldText, newText) {\n            // If the text differs, mark it as an update. All the work in done in commitWork.\n            if (oldText !== newText) {\n              markUpdate(workInProgress);\n            }\n          };\n        } else {\n          invariant(false, 'Mutating reconciler is disabled.');\n        }\n      } else if (persistence) {\n        if (enablePersistentReconciler) {\n          // Persistent host tree mode\n          var cloneInstance = persistence.cloneInstance,\n              createContainerChildSet = persistence.createContainerChildSet,\n              appendChildToContainerChildSet = persistence.appendChildToContainerChildSet,\n              finalizeContainerChildren = persistence.finalizeContainerChildren; // An unfortunate fork of appendAllChildren because we have two different parent types.\n\n          var appendAllChildrenToContainer = function (containerChildSet, workInProgress) {\n            // We only have the top Fiber that was created but we need recurse down its\n            // children to find all the terminal nodes.\n            var node = workInProgress.child;\n\n            while (node !== null) {\n              if (node.tag === HostComponent || node.tag === HostText) {\n                appendChildToContainerChildSet(containerChildSet, node.stateNode);\n              } else if (node.tag === HostPortal) {// If we have a portal child, then we don't want to traverse\n                // down its children. Instead, we'll get insertions from each child in\n                // the portal directly.\n              } else if (node.child !== null) {\n                node.child['return'] = node;\n                node = node.child;\n                continue;\n              }\n\n              if (node === workInProgress) {\n                return;\n              }\n\n              while (node.sibling === null) {\n                if (node['return'] === null || node['return'] === workInProgress) {\n                  return;\n                }\n\n                node = node['return'];\n              }\n\n              node.sibling['return'] = node['return'];\n              node = node.sibling;\n            }\n          };\n\n          updateHostContainer = function (workInProgress) {\n            var portalOrRoot = workInProgress.stateNode;\n            var childrenUnchanged = workInProgress.firstEffect === null;\n\n            if (childrenUnchanged) {// No changes, just reuse the existing instance.\n            } else {\n              var container = portalOrRoot.containerInfo;\n              var newChildSet = createContainerChildSet(container);\n\n              if (finalizeContainerChildren(container, newChildSet)) {\n                markUpdate(workInProgress);\n              }\n\n              portalOrRoot.pendingChildren = newChildSet; // If children might have changed, we have to add them all to the set.\n\n              appendAllChildrenToContainer(newChildSet, workInProgress); // Schedule an update on the container to swap out the container.\n\n              markUpdate(workInProgress);\n            }\n          };\n\n          updateHostComponent = function (current, workInProgress, updatePayload, type, oldProps, newProps, rootContainerInstance) {\n            // If there are no effects associated with this node, then none of our children had any updates.\n            // This guarantees that we can reuse all of them.\n            var childrenUnchanged = workInProgress.firstEffect === null;\n            var currentInstance = current.stateNode;\n\n            if (childrenUnchanged && updatePayload === null) {\n              // No changes, just reuse the existing instance.\n              // Note that this might release a previous clone.\n              workInProgress.stateNode = currentInstance;\n            } else {\n              var recyclableInstance = workInProgress.stateNode;\n              var newInstance = cloneInstance(currentInstance, updatePayload, type, oldProps, newProps, workInProgress, childrenUnchanged, recyclableInstance);\n\n              if (finalizeInitialChildren(newInstance, type, newProps, rootContainerInstance)) {\n                markUpdate(workInProgress);\n              }\n\n              workInProgress.stateNode = newInstance;\n\n              if (childrenUnchanged) {\n                // If there are no other effects in this tree, we need to flag this node as having one.\n                // Even though we're not going to use it for anything.\n                // Otherwise parents won't know that there are new children to propagate upwards.\n                markUpdate(workInProgress);\n              } else {\n                // If children might have changed, we have to add them all to the set.\n                appendAllChildren(newInstance, workInProgress);\n              }\n            }\n          };\n\n          updateHostText = function (current, workInProgress, oldText, newText) {\n            if (oldText !== newText) {\n              // If the text content differs, we'll create a new text instance for it.\n              var rootContainerInstance = getRootHostContainer();\n              var currentHostContext = getHostContext();\n              workInProgress.stateNode = createTextInstance(newText, rootContainerInstance, currentHostContext, workInProgress); // We'll have to mark it as having an effect, even though we won't use the effect for anything.\n              // This lets the parents know that at least one of their children has changed.\n\n              markUpdate(workInProgress);\n            }\n          };\n        } else {\n          invariant(false, 'Persistent reconciler is disabled.');\n        }\n      } else {\n        if (enableNoopReconciler) {\n          // No host operations\n          updateHostContainer = function (workInProgress) {// Noop\n          };\n\n          updateHostComponent = function (current, workInProgress, updatePayload, type, oldProps, newProps, rootContainerInstance) {// Noop\n          };\n\n          updateHostText = function (current, workInProgress, oldText, newText) {// Noop\n          };\n        } else {\n          invariant(false, 'Noop reconciler is disabled.');\n        }\n      }\n\n      function completeWork(current, workInProgress, renderExpirationTime) {\n        // Get the latest props.\n        var newProps = workInProgress.pendingProps;\n\n        if (newProps === null) {\n          newProps = workInProgress.memoizedProps;\n        } else if (workInProgress.expirationTime !== Never || renderExpirationTime === Never) {\n          // Reset the pending props, unless this was a down-prioritization.\n          workInProgress.pendingProps = null;\n        }\n\n        switch (workInProgress.tag) {\n          case FunctionalComponent:\n            return null;\n\n          case ClassComponent:\n            {\n              // We are leaving this subtree, so pop context if any.\n              popContextProvider(workInProgress);\n              return null;\n            }\n\n          case HostRoot:\n            {\n              popHostContainer(workInProgress);\n              popTopLevelContextObject(workInProgress);\n              var fiberRoot = workInProgress.stateNode;\n\n              if (fiberRoot.pendingContext) {\n                fiberRoot.context = fiberRoot.pendingContext;\n                fiberRoot.pendingContext = null;\n              }\n\n              if (current === null || current.child === null) {\n                // If we hydrated, pop so that we can delete any remaining children\n                // that weren't hydrated.\n                popHydrationState(workInProgress); // This resets the hacky state to fix isMounted before committing.\n                // TODO: Delete this when we delete isMounted and findDOMNode.\n\n                workInProgress.effectTag &= ~Placement;\n              }\n\n              updateHostContainer(workInProgress);\n              return null;\n            }\n\n          case HostComponent:\n            {\n              popHostContext(workInProgress);\n              var rootContainerInstance = getRootHostContainer();\n              var type = workInProgress.type;\n\n              if (current !== null && workInProgress.stateNode != null) {\n                // If we have an alternate, that means this is an update and we need to\n                // schedule a side-effect to do the updates.\n                var oldProps = current.memoizedProps; // If we get updated because one of our children updated, we don't\n                // have newProps so we'll have to reuse them.\n                // TODO: Split the update API as separate for the props vs. children.\n                // Even better would be if children weren't special cased at all tho.\n\n                var instance = workInProgress.stateNode;\n                var currentHostContext = getHostContext();\n                var updatePayload = prepareUpdate(instance, type, oldProps, newProps, rootContainerInstance, currentHostContext);\n                updateHostComponent(current, workInProgress, updatePayload, type, oldProps, newProps, rootContainerInstance);\n\n                if (current.ref !== workInProgress.ref) {\n                  markRef(workInProgress);\n                }\n              } else {\n                if (!newProps) {\n                  !(workInProgress.stateNode !== null) ? invariant(false, 'We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.') : void 0; // This can happen when we abort work.\n\n                  return null;\n                }\n\n                var _currentHostContext = getHostContext(); // TODO: Move createInstance to beginWork and keep it on a context\n                // \"stack\" as the parent. Then append children as we go in beginWork\n                // or completeWork depending on we want to add then top->down or\n                // bottom->up. Top->down is faster in IE11.\n\n\n                var wasHydrated = popHydrationState(workInProgress);\n\n                if (wasHydrated) {\n                  // TODO: Move this and createInstance step into the beginPhase\n                  // to consolidate.\n                  if (prepareToHydrateHostInstance(workInProgress, rootContainerInstance, _currentHostContext)) {\n                    // If changes to the hydrated node needs to be applied at the\n                    // commit-phase we mark this as such.\n                    markUpdate(workInProgress);\n                  }\n                } else {\n                  var _instance = createInstance(type, newProps, rootContainerInstance, _currentHostContext, workInProgress);\n\n                  appendAllChildren(_instance, workInProgress); // Certain renderers require commit-time effects for initial mount.\n                  // (eg DOM renderer supports auto-focus for certain elements).\n                  // Make sure such renderers get scheduled for later work.\n\n                  if (finalizeInitialChildren(_instance, type, newProps, rootContainerInstance)) {\n                    markUpdate(workInProgress);\n                  }\n\n                  workInProgress.stateNode = _instance;\n                }\n\n                if (workInProgress.ref !== null) {\n                  // If there is a ref on a host node we need to schedule a callback\n                  markRef(workInProgress);\n                }\n              }\n\n              return null;\n            }\n\n          case HostText:\n            {\n              var newText = newProps;\n\n              if (current && workInProgress.stateNode != null) {\n                var oldText = current.memoizedProps; // If we have an alternate, that means this is an update and we need\n                // to schedule a side-effect to do the updates.\n\n                updateHostText(current, workInProgress, oldText, newText);\n              } else {\n                if (typeof newText !== 'string') {\n                  !(workInProgress.stateNode !== null) ? invariant(false, 'We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.') : void 0; // This can happen when we abort work.\n\n                  return null;\n                }\n\n                var _rootContainerInstance = getRootHostContainer();\n\n                var _currentHostContext2 = getHostContext();\n\n                var _wasHydrated = popHydrationState(workInProgress);\n\n                if (_wasHydrated) {\n                  if (prepareToHydrateHostTextInstance(workInProgress)) {\n                    markUpdate(workInProgress);\n                  }\n                } else {\n                  workInProgress.stateNode = createTextInstance(newText, _rootContainerInstance, _currentHostContext2, workInProgress);\n                }\n              }\n\n              return null;\n            }\n\n          case CallComponent:\n            return moveCallToHandlerPhase(current, workInProgress, renderExpirationTime);\n\n          case CallHandlerPhase:\n            // Reset the tag to now be a first phase call.\n            workInProgress.tag = CallComponent;\n            return null;\n\n          case ReturnComponent:\n            // Does nothing.\n            return null;\n\n          case Fragment:\n            return null;\n\n          case HostPortal:\n            popHostContainer(workInProgress);\n            updateHostContainer(workInProgress);\n            return null;\n          // Error cases\n\n          case IndeterminateComponent:\n            invariant(false, 'An indeterminate component should have become determinate before completing. This error is likely caused by a bug in React. Please file an issue.');\n          // eslint-disable-next-line no-fallthrough\n\n          default:\n            invariant(false, 'Unknown unit of work tag. This error is likely caused by a bug in React. Please file an issue.');\n        }\n      }\n\n      return {\n        completeWork: completeWork\n      };\n    };\n\n    var invokeGuardedCallback$2 = ReactErrorUtils.invokeGuardedCallback;\n    var hasCaughtError$1 = ReactErrorUtils.hasCaughtError;\n    var clearCaughtError$1 = ReactErrorUtils.clearCaughtError;\n\n    var ReactFiberCommitWork = function (config, captureError) {\n      var getPublicInstance = config.getPublicInstance,\n          mutation = config.mutation,\n          persistence = config.persistence;\n\n      var callComponentWillUnmountWithTimer = function (current, instance) {\n        startPhaseTimer(current, 'componentWillUnmount');\n        instance.props = current.memoizedProps;\n        instance.state = current.memoizedState;\n        instance.componentWillUnmount();\n        stopPhaseTimer();\n      }; // Capture errors so they don't interrupt unmounting.\n\n\n      function safelyCallComponentWillUnmount(current, instance) {\n        {\n          invokeGuardedCallback$2(null, callComponentWillUnmountWithTimer, null, current, instance);\n\n          if (hasCaughtError$1()) {\n            var unmountError = clearCaughtError$1();\n            captureError(current, unmountError);\n          }\n        }\n      }\n\n      function safelyDetachRef(current) {\n        var ref = current.ref;\n\n        if (ref !== null) {\n          {\n            invokeGuardedCallback$2(null, ref, null, null);\n\n            if (hasCaughtError$1()) {\n              var refError = clearCaughtError$1();\n              captureError(current, refError);\n            }\n          }\n        }\n      }\n\n      function commitLifeCycles(current, finishedWork) {\n        switch (finishedWork.tag) {\n          case ClassComponent:\n            {\n              var instance = finishedWork.stateNode;\n\n              if (finishedWork.effectTag & Update) {\n                if (current === null) {\n                  startPhaseTimer(finishedWork, 'componentDidMount');\n                  instance.props = finishedWork.memoizedProps;\n                  instance.state = finishedWork.memoizedState;\n                  instance.componentDidMount();\n                  stopPhaseTimer();\n                } else {\n                  var prevProps = current.memoizedProps;\n                  var prevState = current.memoizedState;\n                  startPhaseTimer(finishedWork, 'componentDidUpdate');\n                  instance.props = finishedWork.memoizedProps;\n                  instance.state = finishedWork.memoizedState;\n                  instance.componentDidUpdate(prevProps, prevState);\n                  stopPhaseTimer();\n                }\n              }\n\n              var updateQueue = finishedWork.updateQueue;\n\n              if (updateQueue !== null) {\n                commitCallbacks(updateQueue, instance);\n              }\n\n              return;\n            }\n\n          case HostRoot:\n            {\n              var _updateQueue = finishedWork.updateQueue;\n\n              if (_updateQueue !== null) {\n                var _instance = finishedWork.child !== null ? finishedWork.child.stateNode : null;\n\n                commitCallbacks(_updateQueue, _instance);\n              }\n\n              return;\n            }\n\n          case HostComponent:\n            {\n              var _instance2 = finishedWork.stateNode; // Renderers may schedule work to be done after host components are mounted\n              // (eg DOM renderer may schedule auto-focus for inputs and form controls).\n              // These effects should only be committed when components are first mounted,\n              // aka when there is no current/alternate.\n\n              if (current === null && finishedWork.effectTag & Update) {\n                var type = finishedWork.type;\n                var props = finishedWork.memoizedProps;\n                commitMount(_instance2, type, props, finishedWork);\n              }\n\n              return;\n            }\n\n          case HostText:\n            {\n              // We have no life-cycles associated with text.\n              return;\n            }\n\n          case HostPortal:\n            {\n              // We have no life-cycles associated with portals.\n              return;\n            }\n\n          default:\n            {\n              invariant(false, 'This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.');\n            }\n        }\n      }\n\n      function commitAttachRef(finishedWork) {\n        var ref = finishedWork.ref;\n\n        if (ref !== null) {\n          var instance = finishedWork.stateNode;\n\n          switch (finishedWork.tag) {\n            case HostComponent:\n              ref(getPublicInstance(instance));\n              break;\n\n            default:\n              ref(instance);\n          }\n        }\n      }\n\n      function commitDetachRef(current) {\n        var currentRef = current.ref;\n\n        if (currentRef !== null) {\n          currentRef(null);\n        }\n      } // User-originating errors (lifecycles and refs) should not interrupt\n      // deletion, so don't let them throw. Host-originating errors should\n      // interrupt deletion, so it's okay\n\n\n      function commitUnmount(current) {\n        if (typeof onCommitUnmount === 'function') {\n          onCommitUnmount(current);\n        }\n\n        switch (current.tag) {\n          case ClassComponent:\n            {\n              safelyDetachRef(current);\n              var instance = current.stateNode;\n\n              if (typeof instance.componentWillUnmount === 'function') {\n                safelyCallComponentWillUnmount(current, instance);\n              }\n\n              return;\n            }\n\n          case HostComponent:\n            {\n              safelyDetachRef(current);\n              return;\n            }\n\n          case CallComponent:\n            {\n              commitNestedUnmounts(current.stateNode);\n              return;\n            }\n\n          case HostPortal:\n            {\n              // TODO: this is recursive.\n              // We are also not using this parent because\n              // the portal will get pushed immediately.\n              if (enableMutatingReconciler && mutation) {\n                unmountHostComponents(current);\n              } else if (enablePersistentReconciler && persistence) {\n                emptyPortalContainer(current);\n              }\n\n              return;\n            }\n        }\n      }\n\n      function commitNestedUnmounts(root) {\n        // While we're inside a removed host node we don't want to call\n        // removeChild on the inner nodes because they're removed by the top\n        // call anyway. We also want to call componentWillUnmount on all\n        // composites before this host node is removed from the tree. Therefore\n        var node = root;\n\n        while (true) {\n          commitUnmount(node); // Visit children because they may contain more composite or host nodes.\n          // Skip portals because commitUnmount() currently visits them recursively.\n\n          if (node.child !== null && ( // If we use mutation we drill down into portals using commitUnmount above.\n          // If we don't use mutation we drill down into portals here instead.\n          !mutation || node.tag !== HostPortal)) {\n            node.child['return'] = node;\n            node = node.child;\n            continue;\n          }\n\n          if (node === root) {\n            return;\n          }\n\n          while (node.sibling === null) {\n            if (node['return'] === null || node['return'] === root) {\n              return;\n            }\n\n            node = node['return'];\n          }\n\n          node.sibling['return'] = node['return'];\n          node = node.sibling;\n        }\n      }\n\n      function detachFiber(current) {\n        // Cut off the return pointers to disconnect it from the tree. Ideally, we\n        // should clear the child pointer of the parent alternate to let this\n        // get GC:ed but we don't know which for sure which parent is the current\n        // one so we'll settle for GC:ing the subtree of this child. This child\n        // itself will be GC:ed when the parent updates the next time.\n        current['return'] = null;\n        current.child = null;\n\n        if (current.alternate) {\n          current.alternate.child = null;\n          current.alternate['return'] = null;\n        }\n      }\n\n      if (!mutation) {\n        var commitContainer = void 0;\n\n        if (persistence) {\n          var replaceContainerChildren = persistence.replaceContainerChildren,\n              createContainerChildSet = persistence.createContainerChildSet;\n\n          var emptyPortalContainer = function (current) {\n            var portal = current.stateNode;\n            var containerInfo = portal.containerInfo;\n            var emptyChildSet = createContainerChildSet(containerInfo);\n            replaceContainerChildren(containerInfo, emptyChildSet);\n          };\n\n          commitContainer = function (finishedWork) {\n            switch (finishedWork.tag) {\n              case ClassComponent:\n                {\n                  return;\n                }\n\n              case HostComponent:\n                {\n                  return;\n                }\n\n              case HostText:\n                {\n                  return;\n                }\n\n              case HostRoot:\n              case HostPortal:\n                {\n                  var portalOrRoot = finishedWork.stateNode;\n                  var containerInfo = portalOrRoot.containerInfo,\n                      _pendingChildren = portalOrRoot.pendingChildren;\n                  replaceContainerChildren(containerInfo, _pendingChildren);\n                  return;\n                }\n\n              default:\n                {\n                  invariant(false, 'This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.');\n                }\n            }\n          };\n        } else {\n          commitContainer = function (finishedWork) {// Noop\n          };\n        }\n\n        if (enablePersistentReconciler || enableNoopReconciler) {\n          return {\n            commitResetTextContent: function (finishedWork) {},\n            commitPlacement: function (finishedWork) {},\n            commitDeletion: function (current) {\n              // Detach refs and call componentWillUnmount() on the whole subtree.\n              commitNestedUnmounts(current);\n              detachFiber(current);\n            },\n            commitWork: function (current, finishedWork) {\n              commitContainer(finishedWork);\n            },\n            commitLifeCycles: commitLifeCycles,\n            commitAttachRef: commitAttachRef,\n            commitDetachRef: commitDetachRef\n          };\n        } else if (persistence) {\n          invariant(false, 'Persistent reconciler is disabled.');\n        } else {\n          invariant(false, 'Noop reconciler is disabled.');\n        }\n      }\n\n      var commitMount = mutation.commitMount,\n          commitUpdate = mutation.commitUpdate,\n          resetTextContent = mutation.resetTextContent,\n          commitTextUpdate = mutation.commitTextUpdate,\n          appendChild = mutation.appendChild,\n          appendChildToContainer = mutation.appendChildToContainer,\n          insertBefore = mutation.insertBefore,\n          insertInContainerBefore = mutation.insertInContainerBefore,\n          removeChild = mutation.removeChild,\n          removeChildFromContainer = mutation.removeChildFromContainer;\n\n      function getHostParentFiber(fiber) {\n        var parent = fiber['return'];\n\n        while (parent !== null) {\n          if (isHostParent(parent)) {\n            return parent;\n          }\n\n          parent = parent['return'];\n        }\n\n        invariant(false, 'Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.');\n      }\n\n      function isHostParent(fiber) {\n        return fiber.tag === HostComponent || fiber.tag === HostRoot || fiber.tag === HostPortal;\n      }\n\n      function getHostSibling(fiber) {\n        // We're going to search forward into the tree until we find a sibling host\n        // node. Unfortunately, if multiple insertions are done in a row we have to\n        // search past them. This leads to exponential search for the next sibling.\n        var node = fiber;\n\n        siblings: while (true) {\n          // If we didn't find anything, let's try the next sibling.\n          while (node.sibling === null) {\n            if (node['return'] === null || isHostParent(node['return'])) {\n              // If we pop out of the root or hit the parent the fiber we are the\n              // last sibling.\n              return null;\n            }\n\n            node = node['return'];\n          }\n\n          node.sibling['return'] = node['return'];\n          node = node.sibling;\n\n          while (node.tag !== HostComponent && node.tag !== HostText) {\n            // If it is not host node and, we might have a host node inside it.\n            // Try to search down until we find one.\n            if (node.effectTag & Placement) {\n              // If we don't have a child, try the siblings instead.\n              continue siblings;\n            } // If we don't have a child, try the siblings instead.\n            // We also skip portals because they are not part of this host tree.\n\n\n            if (node.child === null || node.tag === HostPortal) {\n              continue siblings;\n            } else {\n              node.child['return'] = node;\n              node = node.child;\n            }\n          } // Check if this host node is stable or about to be placed.\n\n\n          if (!(node.effectTag & Placement)) {\n            // Found it!\n            return node.stateNode;\n          }\n        }\n      }\n\n      function commitPlacement(finishedWork) {\n        // Recursively insert all host nodes into the parent.\n        var parentFiber = getHostParentFiber(finishedWork);\n        var parent = void 0;\n        var isContainer = void 0;\n\n        switch (parentFiber.tag) {\n          case HostComponent:\n            parent = parentFiber.stateNode;\n            isContainer = false;\n            break;\n\n          case HostRoot:\n            parent = parentFiber.stateNode.containerInfo;\n            isContainer = true;\n            break;\n\n          case HostPortal:\n            parent = parentFiber.stateNode.containerInfo;\n            isContainer = true;\n            break;\n\n          default:\n            invariant(false, 'Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue.');\n        }\n\n        if (parentFiber.effectTag & ContentReset) {\n          // Reset the text content of the parent before doing any insertions\n          resetTextContent(parent); // Clear ContentReset from the effect tag\n\n          parentFiber.effectTag &= ~ContentReset;\n        }\n\n        var before = getHostSibling(finishedWork); // We only have the top Fiber that was inserted but we need recurse down its\n        // children to find all the terminal nodes.\n\n        var node = finishedWork;\n\n        while (true) {\n          if (node.tag === HostComponent || node.tag === HostText) {\n            if (before) {\n              if (isContainer) {\n                insertInContainerBefore(parent, node.stateNode, before);\n              } else {\n                insertBefore(parent, node.stateNode, before);\n              }\n            } else {\n              if (isContainer) {\n                appendChildToContainer(parent, node.stateNode);\n              } else {\n                appendChild(parent, node.stateNode);\n              }\n            }\n          } else if (node.tag === HostPortal) {// If the insertion itself is a portal, then we don't want to traverse\n            // down its children. Instead, we'll get insertions from each child in\n            // the portal directly.\n          } else if (node.child !== null) {\n            node.child['return'] = node;\n            node = node.child;\n            continue;\n          }\n\n          if (node === finishedWork) {\n            return;\n          }\n\n          while (node.sibling === null) {\n            if (node['return'] === null || node['return'] === finishedWork) {\n              return;\n            }\n\n            node = node['return'];\n          }\n\n          node.sibling['return'] = node['return'];\n          node = node.sibling;\n        }\n      }\n\n      function unmountHostComponents(current) {\n        // We only have the top Fiber that was inserted but we need recurse down its\n        var node = current; // Each iteration, currentParent is populated with node's host parent if not\n        // currentParentIsValid.\n\n        var currentParentIsValid = false;\n        var currentParent = void 0;\n        var currentParentIsContainer = void 0;\n\n        while (true) {\n          if (!currentParentIsValid) {\n            var parent = node['return'];\n\n            findParent: while (true) {\n              !(parent !== null) ? invariant(false, 'Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n\n              switch (parent.tag) {\n                case HostComponent:\n                  currentParent = parent.stateNode;\n                  currentParentIsContainer = false;\n                  break findParent;\n\n                case HostRoot:\n                  currentParent = parent.stateNode.containerInfo;\n                  currentParentIsContainer = true;\n                  break findParent;\n\n                case HostPortal:\n                  currentParent = parent.stateNode.containerInfo;\n                  currentParentIsContainer = true;\n                  break findParent;\n              }\n\n              parent = parent['return'];\n            }\n\n            currentParentIsValid = true;\n          }\n\n          if (node.tag === HostComponent || node.tag === HostText) {\n            commitNestedUnmounts(node); // After all the children have unmounted, it is now safe to remove the\n            // node from the tree.\n\n            if (currentParentIsContainer) {\n              removeChildFromContainer(currentParent, node.stateNode);\n            } else {\n              removeChild(currentParent, node.stateNode);\n            } // Don't visit children because we already visited them.\n\n          } else if (node.tag === HostPortal) {\n            // When we go into a portal, it becomes the parent to remove from.\n            // We will reassign it back when we pop the portal on the way up.\n            currentParent = node.stateNode.containerInfo; // Visit children because portals might contain host components.\n\n            if (node.child !== null) {\n              node.child['return'] = node;\n              node = node.child;\n              continue;\n            }\n          } else {\n            commitUnmount(node); // Visit children because we may find more host components below.\n\n            if (node.child !== null) {\n              node.child['return'] = node;\n              node = node.child;\n              continue;\n            }\n          }\n\n          if (node === current) {\n            return;\n          }\n\n          while (node.sibling === null) {\n            if (node['return'] === null || node['return'] === current) {\n              return;\n            }\n\n            node = node['return'];\n\n            if (node.tag === HostPortal) {\n              // When we go out of the portal, we need to restore the parent.\n              // Since we don't keep a stack of them, we will search for it.\n              currentParentIsValid = false;\n            }\n          }\n\n          node.sibling['return'] = node['return'];\n          node = node.sibling;\n        }\n      }\n\n      function commitDeletion(current) {\n        // Recursively delete all host nodes from the parent.\n        // Detach refs and call componentWillUnmount() on the whole subtree.\n        unmountHostComponents(current);\n        detachFiber(current);\n      }\n\n      function commitWork(current, finishedWork) {\n        switch (finishedWork.tag) {\n          case ClassComponent:\n            {\n              return;\n            }\n\n          case HostComponent:\n            {\n              var instance = finishedWork.stateNode;\n\n              if (instance != null) {\n                // Commit the work prepared earlier.\n                var newProps = finishedWork.memoizedProps; // For hydration we reuse the update path but we treat the oldProps\n                // as the newProps. The updatePayload will contain the real change in\n                // this case.\n\n                var oldProps = current !== null ? current.memoizedProps : newProps;\n                var type = finishedWork.type; // TODO: Type the updateQueue to be specific to host components.\n\n                var updatePayload = finishedWork.updateQueue;\n                finishedWork.updateQueue = null;\n\n                if (updatePayload !== null) {\n                  commitUpdate(instance, updatePayload, type, oldProps, newProps, finishedWork);\n                }\n              }\n\n              return;\n            }\n\n          case HostText:\n            {\n              !(finishedWork.stateNode !== null) ? invariant(false, 'This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n              var textInstance = finishedWork.stateNode;\n              var newText = finishedWork.memoizedProps; // For hydration we reuse the update path but we treat the oldProps\n              // as the newProps. The updatePayload will contain the real change in\n              // this case.\n\n              var oldText = current !== null ? current.memoizedProps : newText;\n              commitTextUpdate(textInstance, oldText, newText);\n              return;\n            }\n\n          case HostRoot:\n            {\n              return;\n            }\n\n          default:\n            {\n              invariant(false, 'This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.');\n            }\n        }\n      }\n\n      function commitResetTextContent(current) {\n        resetTextContent(current.stateNode);\n      }\n\n      if (enableMutatingReconciler) {\n        return {\n          commitResetTextContent: commitResetTextContent,\n          commitPlacement: commitPlacement,\n          commitDeletion: commitDeletion,\n          commitWork: commitWork,\n          commitLifeCycles: commitLifeCycles,\n          commitAttachRef: commitAttachRef,\n          commitDetachRef: commitDetachRef\n        };\n      } else {\n        invariant(false, 'Mutating reconciler is disabled.');\n      }\n    };\n\n    var NO_CONTEXT = {};\n\n    var ReactFiberHostContext = function (config) {\n      var getChildHostContext = config.getChildHostContext,\n          getRootHostContext = config.getRootHostContext;\n      var contextStackCursor = createCursor(NO_CONTEXT);\n      var contextFiberStackCursor = createCursor(NO_CONTEXT);\n      var rootInstanceStackCursor = createCursor(NO_CONTEXT);\n\n      function requiredContext(c) {\n        !(c !== NO_CONTEXT) ? invariant(false, 'Expected host context to exist. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n        return c;\n      }\n\n      function getRootHostContainer() {\n        var rootInstance = requiredContext(rootInstanceStackCursor.current);\n        return rootInstance;\n      }\n\n      function pushHostContainer(fiber, nextRootInstance) {\n        // Push current root instance onto the stack;\n        // This allows us to reset root when portals are popped.\n        push(rootInstanceStackCursor, nextRootInstance, fiber);\n        var nextRootContext = getRootHostContext(nextRootInstance); // Track the context and the Fiber that provided it.\n        // This enables us to pop only Fibers that provide unique contexts.\n\n        push(contextFiberStackCursor, fiber, fiber);\n        push(contextStackCursor, nextRootContext, fiber);\n      }\n\n      function popHostContainer(fiber) {\n        pop(contextStackCursor, fiber);\n        pop(contextFiberStackCursor, fiber);\n        pop(rootInstanceStackCursor, fiber);\n      }\n\n      function getHostContext() {\n        var context = requiredContext(contextStackCursor.current);\n        return context;\n      }\n\n      function pushHostContext(fiber) {\n        var rootInstance = requiredContext(rootInstanceStackCursor.current);\n        var context = requiredContext(contextStackCursor.current);\n        var nextContext = getChildHostContext(context, fiber.type, rootInstance); // Don't push this Fiber's context unless it's unique.\n\n        if (context === nextContext) {\n          return;\n        } // Track the context and the Fiber that provided it.\n        // This enables us to pop only Fibers that provide unique contexts.\n\n\n        push(contextFiberStackCursor, fiber, fiber);\n        push(contextStackCursor, nextContext, fiber);\n      }\n\n      function popHostContext(fiber) {\n        // Do not pop unless this Fiber provided the current context.\n        // pushHostContext() only pushes Fibers that provide unique contexts.\n        if (contextFiberStackCursor.current !== fiber) {\n          return;\n        }\n\n        pop(contextStackCursor, fiber);\n        pop(contextFiberStackCursor, fiber);\n      }\n\n      function resetHostContainer() {\n        contextStackCursor.current = NO_CONTEXT;\n        rootInstanceStackCursor.current = NO_CONTEXT;\n      }\n\n      return {\n        getHostContext: getHostContext,\n        getRootHostContainer: getRootHostContainer,\n        popHostContainer: popHostContainer,\n        popHostContext: popHostContext,\n        pushHostContainer: pushHostContainer,\n        pushHostContext: pushHostContext,\n        resetHostContainer: resetHostContainer\n      };\n    };\n\n    var ReactFiberHydrationContext = function (config) {\n      var shouldSetTextContent = config.shouldSetTextContent,\n          hydration = config.hydration; // If this doesn't have hydration mode.\n\n      if (!hydration) {\n        return {\n          enterHydrationState: function () {\n            return false;\n          },\n          resetHydrationState: function () {},\n          tryToClaimNextHydratableInstance: function () {},\n          prepareToHydrateHostInstance: function () {\n            invariant(false, 'Expected prepareToHydrateHostInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.');\n          },\n          prepareToHydrateHostTextInstance: function () {\n            invariant(false, 'Expected prepareToHydrateHostTextInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.');\n          },\n          popHydrationState: function (fiber) {\n            return false;\n          }\n        };\n      }\n\n      var canHydrateInstance = hydration.canHydrateInstance,\n          canHydrateTextInstance = hydration.canHydrateTextInstance,\n          getNextHydratableSibling = hydration.getNextHydratableSibling,\n          getFirstHydratableChild = hydration.getFirstHydratableChild,\n          hydrateInstance = hydration.hydrateInstance,\n          hydrateTextInstance = hydration.hydrateTextInstance,\n          didNotMatchHydratedContainerTextInstance = hydration.didNotMatchHydratedContainerTextInstance,\n          didNotMatchHydratedTextInstance = hydration.didNotMatchHydratedTextInstance,\n          didNotHydrateContainerInstance = hydration.didNotHydrateContainerInstance,\n          didNotHydrateInstance = hydration.didNotHydrateInstance,\n          didNotFindHydratableContainerInstance = hydration.didNotFindHydratableContainerInstance,\n          didNotFindHydratableContainerTextInstance = hydration.didNotFindHydratableContainerTextInstance,\n          didNotFindHydratableInstance = hydration.didNotFindHydratableInstance,\n          didNotFindHydratableTextInstance = hydration.didNotFindHydratableTextInstance; // The deepest Fiber on the stack involved in a hydration context.\n      // This may have been an insertion or a hydration.\n\n      var hydrationParentFiber = null;\n      var nextHydratableInstance = null;\n      var isHydrating = false;\n\n      function enterHydrationState(fiber) {\n        var parentInstance = fiber.stateNode.containerInfo;\n        nextHydratableInstance = getFirstHydratableChild(parentInstance);\n        hydrationParentFiber = fiber;\n        isHydrating = true;\n        return true;\n      }\n\n      function deleteHydratableInstance(returnFiber, instance) {\n        {\n          switch (returnFiber.tag) {\n            case HostRoot:\n              didNotHydrateContainerInstance(returnFiber.stateNode.containerInfo, instance);\n              break;\n\n            case HostComponent:\n              didNotHydrateInstance(returnFiber.type, returnFiber.memoizedProps, returnFiber.stateNode, instance);\n              break;\n          }\n        }\n        var childToDelete = createFiberFromHostInstanceForDeletion();\n        childToDelete.stateNode = instance;\n        childToDelete['return'] = returnFiber;\n        childToDelete.effectTag = Deletion; // This might seem like it belongs on progressedFirstDeletion. However,\n        // these children are not part of the reconciliation list of children.\n        // Even if we abort and rereconcile the children, that will try to hydrate\n        // again and the nodes are still in the host tree so these will be\n        // recreated.\n\n        if (returnFiber.lastEffect !== null) {\n          returnFiber.lastEffect.nextEffect = childToDelete;\n          returnFiber.lastEffect = childToDelete;\n        } else {\n          returnFiber.firstEffect = returnFiber.lastEffect = childToDelete;\n        }\n      }\n\n      function insertNonHydratedInstance(returnFiber, fiber) {\n        fiber.effectTag |= Placement;\n        {\n          switch (returnFiber.tag) {\n            case HostRoot:\n              {\n                var parentContainer = returnFiber.stateNode.containerInfo;\n\n                switch (fiber.tag) {\n                  case HostComponent:\n                    var type = fiber.type;\n                    var props = fiber.pendingProps;\n                    didNotFindHydratableContainerInstance(parentContainer, type, props);\n                    break;\n\n                  case HostText:\n                    var text = fiber.pendingProps;\n                    didNotFindHydratableContainerTextInstance(parentContainer, text);\n                    break;\n                }\n\n                break;\n              }\n\n            case HostComponent:\n              {\n                var parentType = returnFiber.type;\n                var parentProps = returnFiber.memoizedProps;\n                var parentInstance = returnFiber.stateNode;\n\n                switch (fiber.tag) {\n                  case HostComponent:\n                    var _type = fiber.type;\n                    var _props = fiber.pendingProps;\n                    didNotFindHydratableInstance(parentType, parentProps, parentInstance, _type, _props);\n                    break;\n\n                  case HostText:\n                    var _text = fiber.pendingProps;\n                    didNotFindHydratableTextInstance(parentType, parentProps, parentInstance, _text);\n                    break;\n                }\n\n                break;\n              }\n\n            default:\n              return;\n          }\n        }\n      }\n\n      function tryHydrate(fiber, nextInstance) {\n        switch (fiber.tag) {\n          case HostComponent:\n            {\n              var type = fiber.type;\n              var props = fiber.pendingProps;\n              var instance = canHydrateInstance(nextInstance, type, props);\n\n              if (instance !== null) {\n                fiber.stateNode = instance;\n                return true;\n              }\n\n              return false;\n            }\n\n          case HostText:\n            {\n              var text = fiber.pendingProps;\n              var textInstance = canHydrateTextInstance(nextInstance, text);\n\n              if (textInstance !== null) {\n                fiber.stateNode = textInstance;\n                return true;\n              }\n\n              return false;\n            }\n\n          default:\n            return false;\n        }\n      }\n\n      function tryToClaimNextHydratableInstance(fiber) {\n        if (!isHydrating) {\n          return;\n        }\n\n        var nextInstance = nextHydratableInstance;\n\n        if (!nextInstance) {\n          // Nothing to hydrate. Make it an insertion.\n          insertNonHydratedInstance(hydrationParentFiber, fiber);\n          isHydrating = false;\n          hydrationParentFiber = fiber;\n          return;\n        }\n\n        if (!tryHydrate(fiber, nextInstance)) {\n          // If we can't hydrate this instance let's try the next one.\n          // We use this as a heuristic. It's based on intuition and not data so it\n          // might be flawed or unnecessary.\n          nextInstance = getNextHydratableSibling(nextInstance);\n\n          if (!nextInstance || !tryHydrate(fiber, nextInstance)) {\n            // Nothing to hydrate. Make it an insertion.\n            insertNonHydratedInstance(hydrationParentFiber, fiber);\n            isHydrating = false;\n            hydrationParentFiber = fiber;\n            return;\n          } // We matched the next one, we'll now assume that the first one was\n          // superfluous and we'll delete it. Since we can't eagerly delete it\n          // we'll have to schedule a deletion. To do that, this node needs a dummy\n          // fiber associated with it.\n\n\n          deleteHydratableInstance(hydrationParentFiber, nextHydratableInstance);\n        }\n\n        hydrationParentFiber = fiber;\n        nextHydratableInstance = getFirstHydratableChild(nextInstance);\n      }\n\n      function prepareToHydrateHostInstance(fiber, rootContainerInstance, hostContext) {\n        var instance = fiber.stateNode;\n        var updatePayload = hydrateInstance(instance, fiber.type, fiber.memoizedProps, rootContainerInstance, hostContext, fiber); // TODO: Type this specific to this type of component.\n\n        fiber.updateQueue = updatePayload; // If the update payload indicates that there is a change or if there\n        // is a new ref we mark this as an update.\n\n        if (updatePayload !== null) {\n          return true;\n        }\n\n        return false;\n      }\n\n      function prepareToHydrateHostTextInstance(fiber) {\n        var textInstance = fiber.stateNode;\n        var textContent = fiber.memoizedProps;\n        var shouldUpdate = hydrateTextInstance(textInstance, textContent, fiber);\n        {\n          if (shouldUpdate) {\n            // We assume that prepareToHydrateHostTextInstance is called in a context where the\n            // hydration parent is the parent host component of this host text.\n            var returnFiber = hydrationParentFiber;\n\n            if (returnFiber !== null) {\n              switch (returnFiber.tag) {\n                case HostRoot:\n                  {\n                    var parentContainer = returnFiber.stateNode.containerInfo;\n                    didNotMatchHydratedContainerTextInstance(parentContainer, textInstance, textContent);\n                    break;\n                  }\n\n                case HostComponent:\n                  {\n                    var parentType = returnFiber.type;\n                    var parentProps = returnFiber.memoizedProps;\n                    var parentInstance = returnFiber.stateNode;\n                    didNotMatchHydratedTextInstance(parentType, parentProps, parentInstance, textInstance, textContent);\n                    break;\n                  }\n              }\n            }\n          }\n        }\n        return shouldUpdate;\n      }\n\n      function popToNextHostParent(fiber) {\n        var parent = fiber['return'];\n\n        while (parent !== null && parent.tag !== HostComponent && parent.tag !== HostRoot) {\n          parent = parent['return'];\n        }\n\n        hydrationParentFiber = parent;\n      }\n\n      function popHydrationState(fiber) {\n        if (fiber !== hydrationParentFiber) {\n          // We're deeper than the current hydration context, inside an inserted\n          // tree.\n          return false;\n        }\n\n        if (!isHydrating) {\n          // If we're not currently hydrating but we're in a hydration context, then\n          // we were an insertion and now need to pop up reenter hydration of our\n          // siblings.\n          popToNextHostParent(fiber);\n          isHydrating = true;\n          return false;\n        }\n\n        var type = fiber.type; // If we have any remaining hydratable nodes, we need to delete them now.\n        // We only do this deeper than head and body since they tend to have random\n        // other nodes in them. We also ignore components with pure text content in\n        // side of them.\n        // TODO: Better heuristic.\n\n        if (fiber.tag !== HostComponent || type !== 'head' && type !== 'body' && !shouldSetTextContent(type, fiber.memoizedProps)) {\n          var nextInstance = nextHydratableInstance;\n\n          while (nextInstance) {\n            deleteHydratableInstance(fiber, nextInstance);\n            nextInstance = getNextHydratableSibling(nextInstance);\n          }\n        }\n\n        popToNextHostParent(fiber);\n        nextHydratableInstance = hydrationParentFiber ? getNextHydratableSibling(fiber.stateNode) : null;\n        return true;\n      }\n\n      function resetHydrationState() {\n        hydrationParentFiber = null;\n        nextHydratableInstance = null;\n        isHydrating = false;\n      }\n\n      return {\n        enterHydrationState: enterHydrationState,\n        resetHydrationState: resetHydrationState,\n        tryToClaimNextHydratableInstance: tryToClaimNextHydratableInstance,\n        prepareToHydrateHostInstance: prepareToHydrateHostInstance,\n        prepareToHydrateHostTextInstance: prepareToHydrateHostTextInstance,\n        popHydrationState: popHydrationState\n      };\n    }; // This lets us hook into Fiber to debug what it's doing.\n    // See https://github.com/facebook/react/pull/8033.\n    // This is not part of the public API, not even for React DevTools.\n    // You may only inject a debugTool if you work on React Fiber itself.\n\n\n    var ReactFiberInstrumentation = {\n      debugTool: null\n    };\n    var ReactFiberInstrumentation_1 = ReactFiberInstrumentation;\n\n    var defaultShowDialog = function (capturedError) {\n      return true;\n    };\n\n    var showDialog = defaultShowDialog;\n\n    function logCapturedError(capturedError) {\n      var logError = showDialog(capturedError); // Allow injected showDialog() to prevent default console.error logging.\n      // This enables renderers like ReactNative to better manage redbox behavior.\n\n      if (logError === false) {\n        return;\n      }\n\n      var error = capturedError.error;\n      var suppressLogging = error && error.suppressReactErrorLogging;\n\n      if (suppressLogging) {\n        return;\n      }\n\n      {\n        var componentName = capturedError.componentName,\n            componentStack = capturedError.componentStack,\n            errorBoundaryName = capturedError.errorBoundaryName,\n            errorBoundaryFound = capturedError.errorBoundaryFound,\n            willRetry = capturedError.willRetry;\n        var componentNameMessage = componentName ? 'The above error occurred in the <' + componentName + '> component:' : 'The above error occurred in one of your React components:';\n        var errorBoundaryMessage = void 0; // errorBoundaryFound check is sufficient; errorBoundaryName check is to satisfy Flow.\n\n        if (errorBoundaryFound && errorBoundaryName) {\n          if (willRetry) {\n            errorBoundaryMessage = 'React will try to recreate this component tree from scratch ' + ('using the error boundary you provided, ' + errorBoundaryName + '.');\n          } else {\n            errorBoundaryMessage = 'This error was initially handled by the error boundary ' + errorBoundaryName + '.\\n' + 'Recreating the tree from scratch failed so React will unmount the tree.';\n          }\n        } else {\n          errorBoundaryMessage = 'Consider adding an error boundary to your tree to customize error handling behavior.\\n' + 'Visit https://fb.me/react-error-boundaries to learn more about error boundaries.';\n        }\n\n        var combinedMessage = '' + componentNameMessage + componentStack + '\\n\\n' + ('' + errorBoundaryMessage); // In development, we provide our own message with just the component stack.\n        // We don't include the original error message and JS stack because the browser\n        // has already printed it. Even if the application swallows the error, it is still\n        // displayed by the browser thanks to the DEV-only fake event trick in ReactErrorUtils.\n\n        console.error(combinedMessage);\n      }\n    }\n\n    var invokeGuardedCallback = ReactErrorUtils.invokeGuardedCallback;\n    var hasCaughtError = ReactErrorUtils.hasCaughtError;\n    var clearCaughtError = ReactErrorUtils.clearCaughtError;\n    {\n      var didWarnAboutStateTransition = false;\n      var didWarnSetStateChildContext = false;\n      var didWarnStateUpdateForUnmountedComponent = {};\n\n      var warnAboutUpdateOnUnmounted = function (fiber) {\n        var componentName = getComponentName(fiber) || 'ReactClass';\n\n        if (didWarnStateUpdateForUnmountedComponent[componentName]) {\n          return;\n        }\n\n        warning(false, 'Can only update a mounted or mounting ' + 'component. This usually means you called setState, replaceState, ' + 'or forceUpdate on an unmounted component. This is a no-op.\\n\\nPlease ' + 'check the code for the %s component.', componentName);\n        didWarnStateUpdateForUnmountedComponent[componentName] = true;\n      };\n\n      var warnAboutInvalidUpdates = function (instance) {\n        switch (ReactDebugCurrentFiber.phase) {\n          case 'getChildContext':\n            if (didWarnSetStateChildContext) {\n              return;\n            }\n\n            warning(false, 'setState(...): Cannot call setState() inside getChildContext()');\n            didWarnSetStateChildContext = true;\n            break;\n\n          case 'render':\n            if (didWarnAboutStateTransition) {\n              return;\n            }\n\n            warning(false, 'Cannot update during an existing state transition (such as within ' + \"`render` or another component's constructor). Render methods should \" + 'be a pure function of props and state; constructor side-effects are ' + 'an anti-pattern, but can be moved to `componentWillMount`.');\n            didWarnAboutStateTransition = true;\n            break;\n        }\n      };\n    }\n\n    var ReactFiberScheduler = function (config) {\n      var hostContext = ReactFiberHostContext(config);\n      var hydrationContext = ReactFiberHydrationContext(config);\n      var popHostContainer = hostContext.popHostContainer,\n          popHostContext = hostContext.popHostContext,\n          resetHostContainer = hostContext.resetHostContainer;\n\n      var _ReactFiberBeginWork = ReactFiberBeginWork(config, hostContext, hydrationContext, scheduleWork, computeExpirationForFiber),\n          beginWork = _ReactFiberBeginWork.beginWork,\n          beginFailedWork = _ReactFiberBeginWork.beginFailedWork;\n\n      var _ReactFiberCompleteWo = ReactFiberCompleteWork(config, hostContext, hydrationContext),\n          completeWork = _ReactFiberCompleteWo.completeWork;\n\n      var _ReactFiberCommitWork = ReactFiberCommitWork(config, captureError),\n          commitResetTextContent = _ReactFiberCommitWork.commitResetTextContent,\n          commitPlacement = _ReactFiberCommitWork.commitPlacement,\n          commitDeletion = _ReactFiberCommitWork.commitDeletion,\n          commitWork = _ReactFiberCommitWork.commitWork,\n          commitLifeCycles = _ReactFiberCommitWork.commitLifeCycles,\n          commitAttachRef = _ReactFiberCommitWork.commitAttachRef,\n          commitDetachRef = _ReactFiberCommitWork.commitDetachRef;\n\n      var now = config.now,\n          scheduleDeferredCallback = config.scheduleDeferredCallback,\n          cancelDeferredCallback = config.cancelDeferredCallback,\n          useSyncScheduling = config.useSyncScheduling,\n          prepareForCommit = config.prepareForCommit,\n          resetAfterCommit = config.resetAfterCommit; // Represents the current time in ms.\n\n      var startTime = now();\n      var mostRecentCurrentTime = msToExpirationTime(0); // Represents the expiration time that incoming updates should use. (If this\n      // is NoWork, use the default strategy: async updates in async mode, sync\n      // updates in sync mode.)\n\n      var expirationContext = NoWork;\n      var isWorking = false; // The next work in progress fiber that we're currently working on.\n\n      var nextUnitOfWork = null;\n      var nextRoot = null; // The time at which we're currently rendering work.\n\n      var nextRenderExpirationTime = NoWork; // The next fiber with an effect that we're currently committing.\n\n      var nextEffect = null; // Keep track of which fibers have captured an error that need to be handled.\n      // Work is removed from this collection after componentDidCatch is called.\n\n      var capturedErrors = null; // Keep track of which fibers have failed during the current batch of work.\n      // This is a different set than capturedErrors, because it is not reset until\n      // the end of the batch. This is needed to propagate errors correctly if a\n      // subtree fails more than once.\n\n      var failedBoundaries = null; // Error boundaries that captured an error during the current commit.\n\n      var commitPhaseBoundaries = null;\n      var firstUncaughtError = null;\n      var didFatal = false;\n      var isCommitting = false;\n      var isUnmounting = false; // Used for performance tracking.\n\n      var interruptedBy = null;\n\n      function resetContextStack() {\n        // Reset the stack\n        reset(); // Reset the cursors\n\n        resetContext();\n        resetHostContainer();\n      }\n\n      function commitAllHostEffects() {\n        while (nextEffect !== null) {\n          {\n            ReactDebugCurrentFiber.setCurrentFiber(nextEffect);\n          }\n          recordEffect();\n          var effectTag = nextEffect.effectTag;\n\n          if (effectTag & ContentReset) {\n            commitResetTextContent(nextEffect);\n          }\n\n          if (effectTag & Ref) {\n            var current = nextEffect.alternate;\n\n            if (current !== null) {\n              commitDetachRef(current);\n            }\n          } // The following switch statement is only concerned about placement,\n          // updates, and deletions. To avoid needing to add a case for every\n          // possible bitmap value, we remove the secondary effects from the\n          // effect tag and switch on that value.\n\n\n          var primaryEffectTag = effectTag & ~(Callback | Err | ContentReset | Ref | PerformedWork);\n\n          switch (primaryEffectTag) {\n            case Placement:\n              {\n                commitPlacement(nextEffect); // Clear the \"placement\" from effect tag so that we know that this is inserted, before\n                // any life-cycles like componentDidMount gets called.\n                // TODO: findDOMNode doesn't rely on this any more but isMounted\n                // does and isMounted is deprecated anyway so we should be able\n                // to kill this.\n\n                nextEffect.effectTag &= ~Placement;\n                break;\n              }\n\n            case PlacementAndUpdate:\n              {\n                // Placement\n                commitPlacement(nextEffect); // Clear the \"placement\" from effect tag so that we know that this is inserted, before\n                // any life-cycles like componentDidMount gets called.\n\n                nextEffect.effectTag &= ~Placement; // Update\n\n                var _current = nextEffect.alternate;\n                commitWork(_current, nextEffect);\n                break;\n              }\n\n            case Update:\n              {\n                var _current2 = nextEffect.alternate;\n                commitWork(_current2, nextEffect);\n                break;\n              }\n\n            case Deletion:\n              {\n                isUnmounting = true;\n                commitDeletion(nextEffect);\n                isUnmounting = false;\n                break;\n              }\n          }\n\n          nextEffect = nextEffect.nextEffect;\n        }\n\n        {\n          ReactDebugCurrentFiber.resetCurrentFiber();\n        }\n      }\n\n      function commitAllLifeCycles() {\n        while (nextEffect !== null) {\n          var effectTag = nextEffect.effectTag;\n\n          if (effectTag & (Update | Callback)) {\n            recordEffect();\n            var current = nextEffect.alternate;\n            commitLifeCycles(current, nextEffect);\n          }\n\n          if (effectTag & Ref) {\n            recordEffect();\n            commitAttachRef(nextEffect);\n          }\n\n          if (effectTag & Err) {\n            recordEffect();\n            commitErrorHandling(nextEffect);\n          }\n\n          var next = nextEffect.nextEffect; // Ensure that we clean these up so that we don't accidentally keep them.\n          // I'm not actually sure this matters because we can't reset firstEffect\n          // and lastEffect since they're on every node, not just the effectful\n          // ones. So we have to clean everything as we reuse nodes anyway.\n\n          nextEffect.nextEffect = null; // Ensure that we reset the effectTag here so that we can rely on effect\n          // tags to reason about the current life-cycle.\n\n          nextEffect = next;\n        }\n      }\n\n      function commitRoot(finishedWork) {\n        // We keep track of this so that captureError can collect any boundaries\n        // that capture an error during the commit phase. The reason these aren't\n        // local to this function is because errors that occur during cWU are\n        // captured elsewhere, to prevent the unmount from being interrupted.\n        isWorking = true;\n        isCommitting = true;\n        startCommitTimer();\n        var root = finishedWork.stateNode;\n        !(root.current !== finishedWork) ? invariant(false, 'Cannot commit the same tree as before. This is probably a bug related to the return field. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n        root.isReadyForCommit = false; // Reset this to null before calling lifecycles\n\n        ReactCurrentOwner.current = null;\n        var firstEffect = void 0;\n\n        if (finishedWork.effectTag > PerformedWork) {\n          // A fiber's effect list consists only of its children, not itself. So if\n          // the root has an effect, we need to add it to the end of the list. The\n          // resulting list is the set that would belong to the root's parent, if\n          // it had one; that is, all the effects in the tree including the root.\n          if (finishedWork.lastEffect !== null) {\n            finishedWork.lastEffect.nextEffect = finishedWork;\n            firstEffect = finishedWork.firstEffect;\n          } else {\n            firstEffect = finishedWork;\n          }\n        } else {\n          // There is no effect on the root.\n          firstEffect = finishedWork.firstEffect;\n        }\n\n        prepareForCommit(); // Commit all the side-effects within a tree. We'll do this in two passes.\n        // The first pass performs all the host insertions, updates, deletions and\n        // ref unmounts.\n\n        nextEffect = firstEffect;\n        startCommitHostEffectsTimer();\n\n        while (nextEffect !== null) {\n          var didError = false;\n\n          var _error = void 0;\n\n          {\n            invokeGuardedCallback(null, commitAllHostEffects, null);\n\n            if (hasCaughtError()) {\n              didError = true;\n              _error = clearCaughtError();\n            }\n          }\n\n          if (didError) {\n            !(nextEffect !== null) ? invariant(false, 'Should have next effect. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n            captureError(nextEffect, _error); // Clean-up\n\n            if (nextEffect !== null) {\n              nextEffect = nextEffect.nextEffect;\n            }\n          }\n        }\n\n        stopCommitHostEffectsTimer();\n        resetAfterCommit(); // The work-in-progress tree is now the current tree. This must come after\n        // the first pass of the commit phase, so that the previous tree is still\n        // current during componentWillUnmount, but before the second pass, so that\n        // the finished work is current during componentDidMount/Update.\n\n        root.current = finishedWork; // In the second pass we'll perform all life-cycles and ref callbacks.\n        // Life-cycles happen as a separate pass so that all placements, updates,\n        // and deletions in the entire tree have already been invoked.\n        // This pass also triggers any renderer-specific initial effects.\n\n        nextEffect = firstEffect;\n        startCommitLifeCyclesTimer();\n\n        while (nextEffect !== null) {\n          var _didError = false;\n\n          var _error2 = void 0;\n\n          {\n            invokeGuardedCallback(null, commitAllLifeCycles, null);\n\n            if (hasCaughtError()) {\n              _didError = true;\n              _error2 = clearCaughtError();\n            }\n          }\n\n          if (_didError) {\n            !(nextEffect !== null) ? invariant(false, 'Should have next effect. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n            captureError(nextEffect, _error2);\n\n            if (nextEffect !== null) {\n              nextEffect = nextEffect.nextEffect;\n            }\n          }\n        }\n\n        isCommitting = false;\n        isWorking = false;\n        stopCommitLifeCyclesTimer();\n        stopCommitTimer();\n\n        if (typeof onCommitRoot === 'function') {\n          onCommitRoot(finishedWork.stateNode);\n        }\n\n        if (true && ReactFiberInstrumentation_1.debugTool) {\n          ReactFiberInstrumentation_1.debugTool.onCommitWork(finishedWork);\n        } // If we caught any errors during this commit, schedule their boundaries\n        // to update.\n\n\n        if (commitPhaseBoundaries) {\n          commitPhaseBoundaries.forEach(scheduleErrorRecovery);\n          commitPhaseBoundaries = null;\n        }\n\n        if (firstUncaughtError !== null) {\n          var _error3 = firstUncaughtError;\n          firstUncaughtError = null;\n          onUncaughtError(_error3);\n        }\n\n        var remainingTime = root.current.expirationTime;\n\n        if (remainingTime === NoWork) {\n          capturedErrors = null;\n          failedBoundaries = null;\n        }\n\n        return remainingTime;\n      }\n\n      function resetExpirationTime(workInProgress, renderTime) {\n        if (renderTime !== Never && workInProgress.expirationTime === Never) {\n          // The children of this component are hidden. Don't bubble their\n          // expiration times.\n          return;\n        } // Check for pending updates.\n\n\n        var newExpirationTime = getUpdateExpirationTime(workInProgress); // TODO: Calls need to visit stateNode\n        // Bubble up the earliest expiration time.\n\n        var child = workInProgress.child;\n\n        while (child !== null) {\n          if (child.expirationTime !== NoWork && (newExpirationTime === NoWork || newExpirationTime > child.expirationTime)) {\n            newExpirationTime = child.expirationTime;\n          }\n\n          child = child.sibling;\n        }\n\n        workInProgress.expirationTime = newExpirationTime;\n      }\n\n      function completeUnitOfWork(workInProgress) {\n        while (true) {\n          // The current, flushed, state of this fiber is the alternate.\n          // Ideally nothing should rely on this, but relying on it here\n          // means that we don't need an additional field on the work in\n          // progress.\n          var current = workInProgress.alternate;\n          {\n            ReactDebugCurrentFiber.setCurrentFiber(workInProgress);\n          }\n          var next = completeWork(current, workInProgress, nextRenderExpirationTime);\n          {\n            ReactDebugCurrentFiber.resetCurrentFiber();\n          }\n          var returnFiber = workInProgress['return'];\n          var siblingFiber = workInProgress.sibling;\n          resetExpirationTime(workInProgress, nextRenderExpirationTime);\n\n          if (next !== null) {\n            stopWorkTimer(workInProgress);\n\n            if (true && ReactFiberInstrumentation_1.debugTool) {\n              ReactFiberInstrumentation_1.debugTool.onCompleteWork(workInProgress);\n            } // If completing this work spawned new work, do that next. We'll come\n            // back here again.\n\n\n            return next;\n          }\n\n          if (returnFiber !== null) {\n            // Append all the effects of the subtree and this fiber onto the effect\n            // list of the parent. The completion order of the children affects the\n            // side-effect order.\n            if (returnFiber.firstEffect === null) {\n              returnFiber.firstEffect = workInProgress.firstEffect;\n            }\n\n            if (workInProgress.lastEffect !== null) {\n              if (returnFiber.lastEffect !== null) {\n                returnFiber.lastEffect.nextEffect = workInProgress.firstEffect;\n              }\n\n              returnFiber.lastEffect = workInProgress.lastEffect;\n            } // If this fiber had side-effects, we append it AFTER the children's\n            // side-effects. We can perform certain side-effects earlier if\n            // needed, by doing multiple passes over the effect list. We don't want\n            // to schedule our own side-effect on our own list because if end up\n            // reusing children we'll schedule this effect onto itself since we're\n            // at the end.\n\n\n            var effectTag = workInProgress.effectTag; // Skip both NoWork and PerformedWork tags when creating the effect list.\n            // PerformedWork effect is read by React DevTools but shouldn't be committed.\n\n            if (effectTag > PerformedWork) {\n              if (returnFiber.lastEffect !== null) {\n                returnFiber.lastEffect.nextEffect = workInProgress;\n              } else {\n                returnFiber.firstEffect = workInProgress;\n              }\n\n              returnFiber.lastEffect = workInProgress;\n            }\n          }\n\n          stopWorkTimer(workInProgress);\n\n          if (true && ReactFiberInstrumentation_1.debugTool) {\n            ReactFiberInstrumentation_1.debugTool.onCompleteWork(workInProgress);\n          }\n\n          if (siblingFiber !== null) {\n            // If there is more work to do in this returnFiber, do that next.\n            return siblingFiber;\n          } else if (returnFiber !== null) {\n            // If there's no more work in this returnFiber. Complete the returnFiber.\n            workInProgress = returnFiber;\n            continue;\n          } else {\n            // We've reached the root.\n            var root = workInProgress.stateNode;\n            root.isReadyForCommit = true;\n            return null;\n          }\n        } // Without this explicit null return Flow complains of invalid return type\n        // TODO Remove the above while(true) loop\n        // eslint-disable-next-line no-unreachable\n\n\n        return null;\n      }\n\n      function performUnitOfWork(workInProgress) {\n        // The current, flushed, state of this fiber is the alternate.\n        // Ideally nothing should rely on this, but relying on it here\n        // means that we don't need an additional field on the work in\n        // progress.\n        var current = workInProgress.alternate; // See if beginning this work spawns more work.\n\n        startWorkTimer(workInProgress);\n        {\n          ReactDebugCurrentFiber.setCurrentFiber(workInProgress);\n        }\n        var next = beginWork(current, workInProgress, nextRenderExpirationTime);\n        {\n          ReactDebugCurrentFiber.resetCurrentFiber();\n        }\n\n        if (true && ReactFiberInstrumentation_1.debugTool) {\n          ReactFiberInstrumentation_1.debugTool.onBeginWork(workInProgress);\n        }\n\n        if (next === null) {\n          // If this doesn't spawn new work, complete the current work.\n          next = completeUnitOfWork(workInProgress);\n        }\n\n        ReactCurrentOwner.current = null;\n        return next;\n      }\n\n      function performFailedUnitOfWork(workInProgress) {\n        // The current, flushed, state of this fiber is the alternate.\n        // Ideally nothing should rely on this, but relying on it here\n        // means that we don't need an additional field on the work in\n        // progress.\n        var current = workInProgress.alternate; // See if beginning this work spawns more work.\n\n        startWorkTimer(workInProgress);\n        {\n          ReactDebugCurrentFiber.setCurrentFiber(workInProgress);\n        }\n        var next = beginFailedWork(current, workInProgress, nextRenderExpirationTime);\n        {\n          ReactDebugCurrentFiber.resetCurrentFiber();\n        }\n\n        if (true && ReactFiberInstrumentation_1.debugTool) {\n          ReactFiberInstrumentation_1.debugTool.onBeginWork(workInProgress);\n        }\n\n        if (next === null) {\n          // If this doesn't spawn new work, complete the current work.\n          next = completeUnitOfWork(workInProgress);\n        }\n\n        ReactCurrentOwner.current = null;\n        return next;\n      }\n\n      function workLoop(expirationTime) {\n        if (capturedErrors !== null) {\n          // If there are unhandled errors, switch to the slow work loop.\n          // TODO: How to avoid this check in the fast path? Maybe the renderer\n          // could keep track of which roots have unhandled errors and call a\n          // forked version of renderRoot.\n          slowWorkLoopThatChecksForFailedWork(expirationTime);\n          return;\n        }\n\n        if (nextRenderExpirationTime === NoWork || nextRenderExpirationTime > expirationTime) {\n          return;\n        }\n\n        if (nextRenderExpirationTime <= mostRecentCurrentTime) {\n          // Flush all expired work.\n          while (nextUnitOfWork !== null) {\n            nextUnitOfWork = performUnitOfWork(nextUnitOfWork);\n          }\n        } else {\n          // Flush asynchronous work until the deadline runs out of time.\n          while (nextUnitOfWork !== null && !shouldYield()) {\n            nextUnitOfWork = performUnitOfWork(nextUnitOfWork);\n          }\n        }\n      }\n\n      function slowWorkLoopThatChecksForFailedWork(expirationTime) {\n        if (nextRenderExpirationTime === NoWork || nextRenderExpirationTime > expirationTime) {\n          return;\n        }\n\n        if (nextRenderExpirationTime <= mostRecentCurrentTime) {\n          // Flush all expired work.\n          while (nextUnitOfWork !== null) {\n            if (hasCapturedError(nextUnitOfWork)) {\n              // Use a forked version of performUnitOfWork\n              nextUnitOfWork = performFailedUnitOfWork(nextUnitOfWork);\n            } else {\n              nextUnitOfWork = performUnitOfWork(nextUnitOfWork);\n            }\n          }\n        } else {\n          // Flush asynchronous work until the deadline runs out of time.\n          while (nextUnitOfWork !== null && !shouldYield()) {\n            if (hasCapturedError(nextUnitOfWork)) {\n              // Use a forked version of performUnitOfWork\n              nextUnitOfWork = performFailedUnitOfWork(nextUnitOfWork);\n            } else {\n              nextUnitOfWork = performUnitOfWork(nextUnitOfWork);\n            }\n          }\n        }\n      }\n\n      function renderRootCatchBlock(root, failedWork, boundary, expirationTime) {\n        // We're going to restart the error boundary that captured the error.\n        // Conceptually, we're unwinding the stack. We need to unwind the\n        // context stack, too.\n        unwindContexts(failedWork, boundary); // Restart the error boundary using a forked version of\n        // performUnitOfWork that deletes the boundary's children. The entire\n        // failed subree will be unmounted. During the commit phase, a special\n        // lifecycle method is called on the error boundary, which triggers\n        // a re-render.\n\n        nextUnitOfWork = performFailedUnitOfWork(boundary); // Continue working.\n\n        workLoop(expirationTime);\n      }\n\n      function renderRoot(root, expirationTime) {\n        !!isWorking ? invariant(false, 'renderRoot was called recursively. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n        isWorking = true; // We're about to mutate the work-in-progress tree. If the root was pending\n        // commit, it no longer is: we'll need to complete it again.\n\n        root.isReadyForCommit = false; // Check if we're starting from a fresh stack, or if we're resuming from\n        // previously yielded work.\n\n        if (root !== nextRoot || expirationTime !== nextRenderExpirationTime || nextUnitOfWork === null) {\n          // Reset the stack and start working from the root.\n          resetContextStack();\n          nextRoot = root;\n          nextRenderExpirationTime = expirationTime;\n          nextUnitOfWork = createWorkInProgress(nextRoot.current, null, expirationTime);\n        }\n\n        startWorkLoopTimer(nextUnitOfWork);\n        var didError = false;\n        var error = null;\n        {\n          invokeGuardedCallback(null, workLoop, null, expirationTime);\n\n          if (hasCaughtError()) {\n            didError = true;\n            error = clearCaughtError();\n          }\n        } // An error was thrown during the render phase.\n\n        while (didError) {\n          if (didFatal) {\n            // This was a fatal error. Don't attempt to recover from it.\n            firstUncaughtError = error;\n            break;\n          }\n\n          var failedWork = nextUnitOfWork;\n\n          if (failedWork === null) {\n            // An error was thrown but there's no current unit of work. This can\n            // happen during the commit phase if there's a bug in the renderer.\n            didFatal = true;\n            continue;\n          } // \"Capture\" the error by finding the nearest boundary. If there is no\n          // error boundary, we use the root.\n\n\n          var boundary = captureError(failedWork, error);\n          !(boundary !== null) ? invariant(false, 'Should have found an error boundary. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n\n          if (didFatal) {\n            // The error we just captured was a fatal error. This happens\n            // when the error propagates to the root more than once.\n            continue;\n          }\n\n          didError = false;\n          error = null;\n          {\n            invokeGuardedCallback(null, renderRootCatchBlock, null, root, failedWork, boundary, expirationTime);\n\n            if (hasCaughtError()) {\n              didError = true;\n              error = clearCaughtError();\n              continue;\n            }\n          } // We're finished working. Exit the error loop.\n\n          break;\n        }\n\n        var uncaughtError = firstUncaughtError; // We're done performing work. Time to clean up.\n\n        stopWorkLoopTimer(interruptedBy);\n        interruptedBy = null;\n        isWorking = false;\n        didFatal = false;\n        firstUncaughtError = null;\n\n        if (uncaughtError !== null) {\n          onUncaughtError(uncaughtError);\n        }\n\n        return root.isReadyForCommit ? root.current.alternate : null;\n      } // Returns the boundary that captured the error, or null if the error is ignored\n\n\n      function captureError(failedWork, error) {\n        // It is no longer valid because we exited the user code.\n        ReactCurrentOwner.current = null;\n        {\n          ReactDebugCurrentFiber.resetCurrentFiber();\n        } // Search for the nearest error boundary.\n\n        var boundary = null; // Passed to logCapturedError()\n\n        var errorBoundaryFound = false;\n        var willRetry = false;\n        var errorBoundaryName = null; // Host containers are a special case. If the failed work itself is a host\n        // container, then it acts as its own boundary. In all other cases, we\n        // ignore the work itself and only search through the parents.\n\n        if (failedWork.tag === HostRoot) {\n          boundary = failedWork;\n\n          if (isFailedBoundary(failedWork)) {\n            // If this root already failed, there must have been an error when\n            // attempting to unmount it. This is a worst-case scenario and\n            // should only be possible if there's a bug in the renderer.\n            didFatal = true;\n          }\n        } else {\n          var node = failedWork['return'];\n\n          while (node !== null && boundary === null) {\n            if (node.tag === ClassComponent) {\n              var instance = node.stateNode;\n\n              if (typeof instance.componentDidCatch === 'function') {\n                errorBoundaryFound = true;\n                errorBoundaryName = getComponentName(node); // Found an error boundary!\n\n                boundary = node;\n                willRetry = true;\n              }\n            } else if (node.tag === HostRoot) {\n              // Treat the root like a no-op error boundary\n              boundary = node;\n            }\n\n            if (isFailedBoundary(node)) {\n              // This boundary is already in a failed state.\n              // If we're currently unmounting, that means this error was\n              // thrown while unmounting a failed subtree. We should ignore\n              // the error.\n              if (isUnmounting) {\n                return null;\n              } // If we're in the commit phase, we should check to see if\n              // this boundary already captured an error during this commit.\n              // This case exists because multiple errors can be thrown during\n              // a single commit without interruption.\n\n\n              if (commitPhaseBoundaries !== null && (commitPhaseBoundaries.has(node) || node.alternate !== null && commitPhaseBoundaries.has(node.alternate))) {\n                // If so, we should ignore this error.\n                return null;\n              } // The error should propagate to the next boundary - we keep looking.\n\n\n              boundary = null;\n              willRetry = false;\n            }\n\n            node = node['return'];\n          }\n        }\n\n        if (boundary !== null) {\n          // Add to the collection of failed boundaries. This lets us know that\n          // subsequent errors in this subtree should propagate to the next boundary.\n          if (failedBoundaries === null) {\n            failedBoundaries = new Set();\n          }\n\n          failedBoundaries.add(boundary); // This method is unsafe outside of the begin and complete phases.\n          // We might be in the commit phase when an error is captured.\n          // The risk is that the return path from this Fiber may not be accurate.\n          // That risk is acceptable given the benefit of providing users more context.\n\n          var _componentStack = getStackAddendumByWorkInProgressFiber(failedWork);\n\n          var _componentName = getComponentName(failedWork); // Add to the collection of captured errors. This is stored as a global\n          // map of errors and their component stack location keyed by the boundaries\n          // that capture them. We mostly use this Map as a Set; it's a Map only to\n          // avoid adding a field to Fiber to store the error.\n\n\n          if (capturedErrors === null) {\n            capturedErrors = new Map();\n          }\n\n          var capturedError = {\n            componentName: _componentName,\n            componentStack: _componentStack,\n            error: error,\n            errorBoundary: errorBoundaryFound ? boundary.stateNode : null,\n            errorBoundaryFound: errorBoundaryFound,\n            errorBoundaryName: errorBoundaryName,\n            willRetry: willRetry\n          };\n          capturedErrors.set(boundary, capturedError);\n\n          try {\n            logCapturedError(capturedError);\n          } catch (e) {\n            // Prevent cycle if logCapturedError() throws.\n            // A cycle may still occur if logCapturedError renders a component that throws.\n            var suppressLogging = e && e.suppressReactErrorLogging;\n\n            if (!suppressLogging) {\n              console.error(e);\n            }\n          } // If we're in the commit phase, defer scheduling an update on the\n          // boundary until after the commit is complete\n\n\n          if (isCommitting) {\n            if (commitPhaseBoundaries === null) {\n              commitPhaseBoundaries = new Set();\n            }\n\n            commitPhaseBoundaries.add(boundary);\n          } else {\n            // Otherwise, schedule an update now.\n            // TODO: Is this actually necessary during the render phase? Is it\n            // possible to unwind and continue rendering at the same priority,\n            // without corrupting internal state?\n            scheduleErrorRecovery(boundary);\n          }\n\n          return boundary;\n        } else if (firstUncaughtError === null) {\n          // If no boundary is found, we'll need to throw the error\n          firstUncaughtError = error;\n        }\n\n        return null;\n      }\n\n      function hasCapturedError(fiber) {\n        // TODO: capturedErrors should store the boundary instance, to avoid needing\n        // to check the alternate.\n        return capturedErrors !== null && (capturedErrors.has(fiber) || fiber.alternate !== null && capturedErrors.has(fiber.alternate));\n      }\n\n      function isFailedBoundary(fiber) {\n        // TODO: failedBoundaries should store the boundary instance, to avoid\n        // needing to check the alternate.\n        return failedBoundaries !== null && (failedBoundaries.has(fiber) || fiber.alternate !== null && failedBoundaries.has(fiber.alternate));\n      }\n\n      function commitErrorHandling(effectfulFiber) {\n        var capturedError = void 0;\n\n        if (capturedErrors !== null) {\n          capturedError = capturedErrors.get(effectfulFiber);\n          capturedErrors['delete'](effectfulFiber);\n\n          if (capturedError == null) {\n            if (effectfulFiber.alternate !== null) {\n              effectfulFiber = effectfulFiber.alternate;\n              capturedError = capturedErrors.get(effectfulFiber);\n              capturedErrors['delete'](effectfulFiber);\n            }\n          }\n        }\n\n        !(capturedError != null) ? invariant(false, 'No error for given unit of work. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n\n        switch (effectfulFiber.tag) {\n          case ClassComponent:\n            var instance = effectfulFiber.stateNode;\n            var info = {\n              componentStack: capturedError.componentStack\n            }; // Allow the boundary to handle the error, usually by scheduling\n            // an update to itself\n\n            instance.componentDidCatch(capturedError.error, info);\n            return;\n\n          case HostRoot:\n            if (firstUncaughtError === null) {\n              firstUncaughtError = capturedError.error;\n            }\n\n            return;\n\n          default:\n            invariant(false, 'Invalid type of work. This error is likely caused by a bug in React. Please file an issue.');\n        }\n      }\n\n      function unwindContexts(from, to) {\n        var node = from;\n\n        while (node !== null) {\n          switch (node.tag) {\n            case ClassComponent:\n              popContextProvider(node);\n              break;\n\n            case HostComponent:\n              popHostContext(node);\n              break;\n\n            case HostRoot:\n              popHostContainer(node);\n              break;\n\n            case HostPortal:\n              popHostContainer(node);\n              break;\n          }\n\n          if (node === to || node.alternate === to) {\n            stopFailedWorkTimer(node);\n            break;\n          } else {\n            stopWorkTimer(node);\n          }\n\n          node = node['return'];\n        }\n      }\n\n      function computeAsyncExpiration() {\n        // Given the current clock time, returns an expiration time. We use rounding\n        // to batch like updates together.\n        // Should complete within ~1000ms. 1200ms max.\n        var currentTime = recalculateCurrentTime();\n        var expirationMs = 1000;\n        var bucketSizeMs = 200;\n        return computeExpirationBucket(currentTime, expirationMs, bucketSizeMs);\n      }\n\n      function computeExpirationForFiber(fiber) {\n        var expirationTime = void 0;\n\n        if (expirationContext !== NoWork) {\n          // An explicit expiration context was set;\n          expirationTime = expirationContext;\n        } else if (isWorking) {\n          if (isCommitting) {\n            // Updates that occur during the commit phase should have sync priority\n            // by default.\n            expirationTime = Sync;\n          } else {\n            // Updates during the render phase should expire at the same time as\n            // the work that is being rendered.\n            expirationTime = nextRenderExpirationTime;\n          }\n        } else {\n          // No explicit expiration context was set, and we're not currently\n          // performing work. Calculate a new expiration time.\n          if (useSyncScheduling && !(fiber.internalContextTag & AsyncUpdates)) {\n            // This is a sync update\n            expirationTime = Sync;\n          } else {\n            // This is an async update\n            expirationTime = computeAsyncExpiration();\n          }\n        }\n\n        return expirationTime;\n      }\n\n      function scheduleWork(fiber, expirationTime) {\n        return scheduleWorkImpl(fiber, expirationTime, false);\n      }\n\n      function checkRootNeedsClearing(root, fiber, expirationTime) {\n        if (!isWorking && root === nextRoot && expirationTime < nextRenderExpirationTime) {\n          // Restart the root from the top.\n          if (nextUnitOfWork !== null) {\n            // This is an interruption. (Used for performance tracking.)\n            interruptedBy = fiber;\n          }\n\n          nextRoot = null;\n          nextUnitOfWork = null;\n          nextRenderExpirationTime = NoWork;\n        }\n      }\n\n      function scheduleWorkImpl(fiber, expirationTime, isErrorRecovery) {\n        recordScheduleUpdate();\n        {\n          if (!isErrorRecovery && fiber.tag === ClassComponent) {\n            var instance = fiber.stateNode;\n            warnAboutInvalidUpdates(instance);\n          }\n        }\n        var node = fiber;\n\n        while (node !== null) {\n          // Walk the parent path to the root and update each node's\n          // expiration time.\n          if (node.expirationTime === NoWork || node.expirationTime > expirationTime) {\n            node.expirationTime = expirationTime;\n          }\n\n          if (node.alternate !== null) {\n            if (node.alternate.expirationTime === NoWork || node.alternate.expirationTime > expirationTime) {\n              node.alternate.expirationTime = expirationTime;\n            }\n          }\n\n          if (node['return'] === null) {\n            if (node.tag === HostRoot) {\n              var root = node.stateNode;\n              checkRootNeedsClearing(root, fiber, expirationTime);\n              requestWork(root, expirationTime);\n              checkRootNeedsClearing(root, fiber, expirationTime);\n            } else {\n              {\n                if (!isErrorRecovery && fiber.tag === ClassComponent) {\n                  warnAboutUpdateOnUnmounted(fiber);\n                }\n              }\n              return;\n            }\n          }\n\n          node = node['return'];\n        }\n      }\n\n      function scheduleErrorRecovery(fiber) {\n        scheduleWorkImpl(fiber, Sync, true);\n      }\n\n      function recalculateCurrentTime() {\n        // Subtract initial time so it fits inside 32bits\n        var ms = now() - startTime;\n        mostRecentCurrentTime = msToExpirationTime(ms);\n        return mostRecentCurrentTime;\n      }\n\n      function deferredUpdates(fn) {\n        var previousExpirationContext = expirationContext;\n        expirationContext = computeAsyncExpiration();\n\n        try {\n          return fn();\n        } finally {\n          expirationContext = previousExpirationContext;\n        }\n      }\n\n      function syncUpdates(fn) {\n        var previousExpirationContext = expirationContext;\n        expirationContext = Sync;\n\n        try {\n          return fn();\n        } finally {\n          expirationContext = previousExpirationContext;\n        }\n      } // TODO: Everything below this is written as if it has been lifted to the\n      // renderers. I'll do this in a follow-up.\n      // Linked-list of roots\n\n\n      var firstScheduledRoot = null;\n      var lastScheduledRoot = null;\n      var callbackExpirationTime = NoWork;\n      var callbackID = -1;\n      var isRendering = false;\n      var nextFlushedRoot = null;\n      var nextFlushedExpirationTime = NoWork;\n      var deadlineDidExpire = false;\n      var hasUnhandledError = false;\n      var unhandledError = null;\n      var deadline = null;\n      var isBatchingUpdates = false;\n      var isUnbatchingUpdates = false; // Use these to prevent an infinite loop of nested updates\n\n      var NESTED_UPDATE_LIMIT = 1000;\n      var nestedUpdateCount = 0;\n      var timeHeuristicForUnitOfWork = 1;\n\n      function scheduleCallbackWithExpiration(expirationTime) {\n        if (callbackExpirationTime !== NoWork) {\n          // A callback is already scheduled. Check its expiration time (timeout).\n          if (expirationTime > callbackExpirationTime) {\n            // Existing callback has sufficient timeout. Exit.\n            return;\n          } else {\n            // Existing callback has insufficient timeout. Cancel and schedule a\n            // new one.\n            cancelDeferredCallback(callbackID);\n          } // The request callback timer is already running. Don't start a new one.\n\n        } else {\n          startRequestCallbackTimer();\n        } // Compute a timeout for the given expiration time.\n\n\n        var currentMs = now() - startTime;\n        var expirationMs = expirationTimeToMs(expirationTime);\n        var timeout = expirationMs - currentMs;\n        callbackExpirationTime = expirationTime;\n        callbackID = scheduleDeferredCallback(performAsyncWork, {\n          timeout: timeout\n        });\n      } // requestWork is called by the scheduler whenever a root receives an update.\n      // It's up to the renderer to call renderRoot at some point in the future.\n\n\n      function requestWork(root, expirationTime) {\n        if (nestedUpdateCount > NESTED_UPDATE_LIMIT) {\n          invariant(false, 'Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.');\n        } // Add the root to the schedule.\n        // Check if this root is already part of the schedule.\n\n\n        if (root.nextScheduledRoot === null) {\n          // This root is not already scheduled. Add it.\n          root.remainingExpirationTime = expirationTime;\n\n          if (lastScheduledRoot === null) {\n            firstScheduledRoot = lastScheduledRoot = root;\n            root.nextScheduledRoot = root;\n          } else {\n            lastScheduledRoot.nextScheduledRoot = root;\n            lastScheduledRoot = root;\n            lastScheduledRoot.nextScheduledRoot = firstScheduledRoot;\n          }\n        } else {\n          // This root is already scheduled, but its priority may have increased.\n          var remainingExpirationTime = root.remainingExpirationTime;\n\n          if (remainingExpirationTime === NoWork || expirationTime < remainingExpirationTime) {\n            // Update the priority.\n            root.remainingExpirationTime = expirationTime;\n          }\n        }\n\n        if (isRendering) {\n          // Prevent reentrancy. Remaining work will be scheduled at the end of\n          // the currently rendering batch.\n          return;\n        }\n\n        if (isBatchingUpdates) {\n          // Flush work at the end of the batch.\n          if (isUnbatchingUpdates) {\n            // ...unless we're inside unbatchedUpdates, in which case we should\n            // flush it now.\n            nextFlushedRoot = root;\n            nextFlushedExpirationTime = Sync;\n            performWorkOnRoot(nextFlushedRoot, nextFlushedExpirationTime);\n          }\n\n          return;\n        } // TODO: Get rid of Sync and use current time?\n\n\n        if (expirationTime === Sync) {\n          performWork(Sync, null);\n        } else {\n          scheduleCallbackWithExpiration(expirationTime);\n        }\n      }\n\n      function findHighestPriorityRoot() {\n        var highestPriorityWork = NoWork;\n        var highestPriorityRoot = null;\n\n        if (lastScheduledRoot !== null) {\n          var previousScheduledRoot = lastScheduledRoot;\n          var root = firstScheduledRoot;\n\n          while (root !== null) {\n            var remainingExpirationTime = root.remainingExpirationTime;\n\n            if (remainingExpirationTime === NoWork) {\n              // This root no longer has work. Remove it from the scheduler.\n              // TODO: This check is redudant, but Flow is confused by the branch\n              // below where we set lastScheduledRoot to null, even though we break\n              // from the loop right after.\n              !(previousScheduledRoot !== null && lastScheduledRoot !== null) ? invariant(false, 'Should have a previous and last root. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n\n              if (root === root.nextScheduledRoot) {\n                // This is the only root in the list.\n                root.nextScheduledRoot = null;\n                firstScheduledRoot = lastScheduledRoot = null;\n                break;\n              } else if (root === firstScheduledRoot) {\n                // This is the first root in the list.\n                var next = root.nextScheduledRoot;\n                firstScheduledRoot = next;\n                lastScheduledRoot.nextScheduledRoot = next;\n                root.nextScheduledRoot = null;\n              } else if (root === lastScheduledRoot) {\n                // This is the last root in the list.\n                lastScheduledRoot = previousScheduledRoot;\n                lastScheduledRoot.nextScheduledRoot = firstScheduledRoot;\n                root.nextScheduledRoot = null;\n                break;\n              } else {\n                previousScheduledRoot.nextScheduledRoot = root.nextScheduledRoot;\n                root.nextScheduledRoot = null;\n              }\n\n              root = previousScheduledRoot.nextScheduledRoot;\n            } else {\n              if (highestPriorityWork === NoWork || remainingExpirationTime < highestPriorityWork) {\n                // Update the priority, if it's higher\n                highestPriorityWork = remainingExpirationTime;\n                highestPriorityRoot = root;\n              }\n\n              if (root === lastScheduledRoot) {\n                break;\n              }\n\n              previousScheduledRoot = root;\n              root = root.nextScheduledRoot;\n            }\n          }\n        } // If the next root is the same as the previous root, this is a nested\n        // update. To prevent an infinite loop, increment the nested update count.\n\n\n        var previousFlushedRoot = nextFlushedRoot;\n\n        if (previousFlushedRoot !== null && previousFlushedRoot === highestPriorityRoot) {\n          nestedUpdateCount++;\n        } else {\n          // Reset whenever we switch roots.\n          nestedUpdateCount = 0;\n        }\n\n        nextFlushedRoot = highestPriorityRoot;\n        nextFlushedExpirationTime = highestPriorityWork;\n      }\n\n      function performAsyncWork(dl) {\n        performWork(NoWork, dl);\n      }\n\n      function performWork(minExpirationTime, dl) {\n        deadline = dl; // Keep working on roots until there's no more work, or until the we reach\n        // the deadline.\n\n        findHighestPriorityRoot();\n\n        if (enableUserTimingAPI && deadline !== null) {\n          var didExpire = nextFlushedExpirationTime < recalculateCurrentTime();\n          stopRequestCallbackTimer(didExpire);\n        }\n\n        while (nextFlushedRoot !== null && nextFlushedExpirationTime !== NoWork && (minExpirationTime === NoWork || nextFlushedExpirationTime <= minExpirationTime) && !deadlineDidExpire) {\n          performWorkOnRoot(nextFlushedRoot, nextFlushedExpirationTime); // Find the next highest priority work.\n\n          findHighestPriorityRoot();\n        } // We're done flushing work. Either we ran out of time in this callback,\n        // or there's no more work left with sufficient priority.\n        // If we're inside a callback, set this to false since we just completed it.\n\n\n        if (deadline !== null) {\n          callbackExpirationTime = NoWork;\n          callbackID = -1;\n        } // If there's work left over, schedule a new callback.\n\n\n        if (nextFlushedExpirationTime !== NoWork) {\n          scheduleCallbackWithExpiration(nextFlushedExpirationTime);\n        } // Clean-up.\n\n\n        deadline = null;\n        deadlineDidExpire = false;\n        nestedUpdateCount = 0;\n\n        if (hasUnhandledError) {\n          var _error4 = unhandledError;\n          unhandledError = null;\n          hasUnhandledError = false;\n          throw _error4;\n        }\n      }\n\n      function performWorkOnRoot(root, expirationTime) {\n        !!isRendering ? invariant(false, 'performWorkOnRoot was called recursively. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n        isRendering = true; // Check if this is async work or sync/expired work.\n        // TODO: Pass current time as argument to renderRoot, commitRoot\n\n        if (expirationTime <= recalculateCurrentTime()) {\n          // Flush sync work.\n          var finishedWork = root.finishedWork;\n\n          if (finishedWork !== null) {\n            // This root is already complete. We can commit it.\n            root.finishedWork = null;\n            root.remainingExpirationTime = commitRoot(finishedWork);\n          } else {\n            root.finishedWork = null;\n            finishedWork = renderRoot(root, expirationTime);\n\n            if (finishedWork !== null) {\n              // We've completed the root. Commit it.\n              root.remainingExpirationTime = commitRoot(finishedWork);\n            }\n          }\n        } else {\n          // Flush async work.\n          var _finishedWork = root.finishedWork;\n\n          if (_finishedWork !== null) {\n            // This root is already complete. We can commit it.\n            root.finishedWork = null;\n            root.remainingExpirationTime = commitRoot(_finishedWork);\n          } else {\n            root.finishedWork = null;\n            _finishedWork = renderRoot(root, expirationTime);\n\n            if (_finishedWork !== null) {\n              // We've completed the root. Check the deadline one more time\n              // before committing.\n              if (!shouldYield()) {\n                // Still time left. Commit the root.\n                root.remainingExpirationTime = commitRoot(_finishedWork);\n              } else {\n                // There's no time left. Mark this root as complete. We'll come\n                // back and commit it later.\n                root.finishedWork = _finishedWork;\n              }\n            }\n          }\n        }\n\n        isRendering = false;\n      } // When working on async work, the reconciler asks the renderer if it should\n      // yield execution. For DOM, we implement this with requestIdleCallback.\n\n\n      function shouldYield() {\n        if (deadline === null) {\n          return false;\n        }\n\n        if (deadline.timeRemaining() > timeHeuristicForUnitOfWork) {\n          // Disregard deadline.didTimeout. Only expired work should be flushed\n          // during a timeout. This path is only hit for non-expired work.\n          return false;\n        }\n\n        deadlineDidExpire = true;\n        return true;\n      } // TODO: Not happy about this hook. Conceptually, renderRoot should return a\n      // tuple of (isReadyForCommit, didError, error)\n\n\n      function onUncaughtError(error) {\n        !(nextFlushedRoot !== null) ? invariant(false, 'Should be working on a root. This error is likely caused by a bug in React. Please file an issue.') : void 0; // Unschedule this root so we don't work on it again until there's\n        // another update.\n\n        nextFlushedRoot.remainingExpirationTime = NoWork;\n\n        if (!hasUnhandledError) {\n          hasUnhandledError = true;\n          unhandledError = error;\n        }\n      } // TODO: Batching should be implemented at the renderer level, not inside\n      // the reconciler.\n\n\n      function batchedUpdates(fn, a) {\n        var previousIsBatchingUpdates = isBatchingUpdates;\n        isBatchingUpdates = true;\n\n        try {\n          return fn(a);\n        } finally {\n          isBatchingUpdates = previousIsBatchingUpdates;\n\n          if (!isBatchingUpdates && !isRendering) {\n            performWork(Sync, null);\n          }\n        }\n      } // TODO: Batching should be implemented at the renderer level, not inside\n      // the reconciler.\n\n\n      function unbatchedUpdates(fn) {\n        if (isBatchingUpdates && !isUnbatchingUpdates) {\n          isUnbatchingUpdates = true;\n\n          try {\n            return fn();\n          } finally {\n            isUnbatchingUpdates = false;\n          }\n        }\n\n        return fn();\n      } // TODO: Batching should be implemented at the renderer level, not within\n      // the reconciler.\n\n\n      function flushSync(fn) {\n        var previousIsBatchingUpdates = isBatchingUpdates;\n        isBatchingUpdates = true;\n\n        try {\n          return syncUpdates(fn);\n        } finally {\n          isBatchingUpdates = previousIsBatchingUpdates;\n          !!isRendering ? invariant(false, 'flushSync was called from inside a lifecycle method. It cannot be called when React is already rendering.') : void 0;\n          performWork(Sync, null);\n        }\n      }\n\n      return {\n        computeAsyncExpiration: computeAsyncExpiration,\n        computeExpirationForFiber: computeExpirationForFiber,\n        scheduleWork: scheduleWork,\n        batchedUpdates: batchedUpdates,\n        unbatchedUpdates: unbatchedUpdates,\n        flushSync: flushSync,\n        deferredUpdates: deferredUpdates\n      };\n    };\n\n    {\n      var didWarnAboutNestedUpdates = false;\n    } // 0 is PROD, 1 is DEV.\n    // Might add PROFILE later.\n\n    function getContextForSubtree(parentComponent) {\n      if (!parentComponent) {\n        return emptyObject;\n      }\n\n      var fiber = get(parentComponent);\n      var parentContext = findCurrentUnmaskedContext(fiber);\n      return isContextProvider(fiber) ? processChildContext(fiber, parentContext) : parentContext;\n    }\n\n    var ReactFiberReconciler = function (config) {\n      var getPublicInstance = config.getPublicInstance;\n\n      var _ReactFiberScheduler = ReactFiberScheduler(config),\n          computeAsyncExpiration = _ReactFiberScheduler.computeAsyncExpiration,\n          computeExpirationForFiber = _ReactFiberScheduler.computeExpirationForFiber,\n          scheduleWork = _ReactFiberScheduler.scheduleWork,\n          batchedUpdates = _ReactFiberScheduler.batchedUpdates,\n          unbatchedUpdates = _ReactFiberScheduler.unbatchedUpdates,\n          flushSync = _ReactFiberScheduler.flushSync,\n          deferredUpdates = _ReactFiberScheduler.deferredUpdates;\n\n      function scheduleTopLevelUpdate(current, element, callback) {\n        {\n          if (ReactDebugCurrentFiber.phase === 'render' && ReactDebugCurrentFiber.current !== null && !didWarnAboutNestedUpdates) {\n            didWarnAboutNestedUpdates = true;\n            warning(false, 'Render methods should be a pure function of props and state; ' + 'triggering nested component updates from render is not allowed. ' + 'If necessary, trigger nested updates in componentDidUpdate.\\n\\n' + 'Check the render method of %s.', getComponentName(ReactDebugCurrentFiber.current) || 'Unknown');\n          }\n        }\n        callback = callback === undefined ? null : callback;\n        {\n          warning(callback === null || typeof callback === 'function', 'render(...): Expected the last optional `callback` argument to be a ' + 'function. Instead received: %s.', callback);\n        }\n        var expirationTime = void 0; // Check if the top-level element is an async wrapper component. If so,\n        // treat updates to the root as async. This is a bit weird but lets us\n        // avoid a separate `renderAsync` API.\n\n        if (enableAsyncSubtreeAPI && element != null && element.type != null && element.type.prototype != null && element.type.prototype.unstable_isAsyncReactComponent === true) {\n          expirationTime = computeAsyncExpiration();\n        } else {\n          expirationTime = computeExpirationForFiber(current);\n        }\n\n        var update = {\n          expirationTime: expirationTime,\n          partialState: {\n            element: element\n          },\n          callback: callback,\n          isReplace: false,\n          isForced: false,\n          nextCallback: null,\n          next: null\n        };\n        insertUpdateIntoFiber(current, update);\n        scheduleWork(current, expirationTime);\n      }\n\n      function findHostInstance(fiber) {\n        var hostFiber = findCurrentHostFiber(fiber);\n\n        if (hostFiber === null) {\n          return null;\n        }\n\n        return hostFiber.stateNode;\n      }\n\n      return {\n        createContainer: function (containerInfo, hydrate) {\n          return createFiberRoot(containerInfo, hydrate);\n        },\n        updateContainer: function (element, container, parentComponent, callback) {\n          // TODO: If this is a nested container, this won't be the root.\n          var current = container.current;\n          {\n            if (ReactFiberInstrumentation_1.debugTool) {\n              if (current.alternate === null) {\n                ReactFiberInstrumentation_1.debugTool.onMountContainer(container);\n              } else if (element === null) {\n                ReactFiberInstrumentation_1.debugTool.onUnmountContainer(container);\n              } else {\n                ReactFiberInstrumentation_1.debugTool.onUpdateContainer(container);\n              }\n            }\n          }\n          var context = getContextForSubtree(parentComponent);\n\n          if (container.context === null) {\n            container.context = context;\n          } else {\n            container.pendingContext = context;\n          }\n\n          scheduleTopLevelUpdate(current, element, callback);\n        },\n        batchedUpdates: batchedUpdates,\n        unbatchedUpdates: unbatchedUpdates,\n        deferredUpdates: deferredUpdates,\n        flushSync: flushSync,\n        getPublicRootInstance: function (container) {\n          var containerFiber = container.current;\n\n          if (!containerFiber.child) {\n            return null;\n          }\n\n          switch (containerFiber.child.tag) {\n            case HostComponent:\n              return getPublicInstance(containerFiber.child.stateNode);\n\n            default:\n              return containerFiber.child.stateNode;\n          }\n        },\n        findHostInstance: findHostInstance,\n        findHostInstanceWithNoPortals: function (fiber) {\n          var hostFiber = findCurrentHostFiberWithNoPortals(fiber);\n\n          if (hostFiber === null) {\n            return null;\n          }\n\n          return hostFiber.stateNode;\n        },\n        injectIntoDevTools: function (devToolsConfig) {\n          var findFiberByHostInstance = devToolsConfig.findFiberByHostInstance;\n          return injectInternals(_assign({}, devToolsConfig, {\n            findHostInstanceByFiber: function (fiber) {\n              return findHostInstance(fiber);\n            },\n            findFiberByHostInstance: function (instance) {\n              if (!findFiberByHostInstance) {\n                // Might not be implemented by the renderer.\n                return null;\n              }\n\n              return findFiberByHostInstance(instance);\n            }\n          }));\n        }\n      };\n    };\n\n    var ReactFiberReconciler$1 = Object.freeze({\n      default: ReactFiberReconciler\n    });\n    var ReactFiberReconciler$2 = ReactFiberReconciler$1 && ReactFiberReconciler || ReactFiberReconciler$1; // TODO: bundle Flow types with the package.\n    // TODO: decide on the top-level export form.\n    // This is hacky but makes it work with both Rollup and Jest.\n\n    var reactReconciler = ReactFiberReconciler$2['default'] ? ReactFiberReconciler$2['default'] : ReactFiberReconciler$2;\n    module.exports = reactReconciler;\n    return ($$$reconciler || ($$$reconciler = module.exports))(config);\n  };\n}","map":{"version":3,"sources":["/Users/kaja/Code/mallar/node_modules/react-reconciler/cjs/react-reconciler.development.js"],"names":["process","env","NODE_ENV","$$$reconciler","module","exports","config","_assign","require","invariant","warning","React","emptyObject","checkPropTypes","shallowEqual","enableAsyncSubtreeAPI","enableUserTimingAPI","enableMutatingReconciler","enableNoopReconciler","enablePersistentReconciler","debugRenderPhaseSideEffects","get","key","_reactInternalFiber","set","value","ReactInternals","__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED","ReactCurrentOwner","ReactDebugCurrentFrame","getComponentName","fiber","type","displayName","name","IndeterminateComponent","FunctionalComponent","ClassComponent","HostRoot","HostPortal","HostComponent","HostText","CallComponent","CallHandlerPhase","ReturnComponent","Fragment","NoEffect","PerformedWork","Placement","Update","PlacementAndUpdate","Deletion","ContentReset","Callback","Err","Ref","MOUNTING","MOUNTED","UNMOUNTED","isFiberMountedImpl","node","alternate","effectTag","tag","isFiberMounted","isMounted","component","owner","current","ownerFiber","instance","stateNode","_warnedAboutRefsInRender","assertIsMounted","findCurrentFiberUsingSlowPath","state","a","b","parentA","parentB","child","sibling","didFindChild","_child","findCurrentHostFiber","parent","currentParent","findCurrentHostFiberWithNoPortals","valueStack","fiberStack","index","createCursor","defaultValue","pop","cursor","push","reset","describeComponentFrame","source","ownerName","fileName","replace","lineNumber","describeFiber","_debugOwner","_debugSource","getStackAddendumByWorkInProgressFiber","workInProgress","info","getCurrentFiberOwnerName","ReactDebugCurrentFiber","getCurrentFiberStackAddendum","resetCurrentFiber","getCurrentStack","phase","setCurrentFiber","setCurrentPhase","reactEmoji","warningEmoji","supportsUserTiming","performance","mark","clearMarks","measure","clearMeasures","currentFiber","currentPhase","currentPhaseFiber","isCommitting","hasScheduledUpdateInCurrentCommit","hasScheduledUpdateInCurrentPhase","commitCountInCurrentWorkLoop","effectCountInCurrentCommit","isWaitingForCallback","labelsInCurrentCommit","Set","formatMarkName","markName","formatLabel","label","warning$$1","prefix","suffix","beginMark","clearMark","endMark","formattedMarkName","formattedLabel","err","getFiberMarkName","debugID","getFiberLabel","componentName","beginFiberMark","_debugID","has","add","clearFiberMark","endFiberMark","shouldIgnoreFiber","clearPendingPhaseMeasurement","pauseTimers","_debugIsCurrentlyTiming","resumeTimersRecursively","resumeTimers","recordEffect","recordScheduleUpdate","startRequestCallbackTimer","stopRequestCallbackTimer","didExpire","startWorkTimer","cancelWorkTimer","stopWorkTimer","stopFailedWorkTimer","startPhaseTimer","stopPhaseTimer","startWorkLoopTimer","nextUnitOfWork","stopWorkLoopTimer","interruptedBy","startCommitTimer","clear","stopCommitTimer","startCommitHostEffectsTimer","stopCommitHostEffectsTimer","count","startCommitLifeCyclesTimer","stopCommitLifeCyclesTimer","warnedAboutMissingGetChildContext","contextStackCursor","didPerformWorkStackCursor","previousContext","getUnmaskedContext","hasOwnContext","isContextProvider","cacheContext","unmaskedContext","maskedContext","__reactInternalMemoizedUnmaskedChildContext","__reactInternalMemoizedMaskedChildContext","getMaskedContext","contextTypes","context","hasContextChanged","isContextConsumer","childContextTypes","popContextProvider","popTopLevelContextObject","pushTopLevelContextObject","didChange","processChildContext","parentContext","getChildContext","childContext","contextKey","pushContextProvider","memoizedMergedChildContext","__reactInternalMemoizedMergedChildContext","invalidateContextProvider","mergedContext","resetContext","findCurrentUnmaskedContext","NoWork","Sync","Never","UNIT_SIZE","MAGIC_NUMBER_OFFSET","msToExpirationTime","ms","expirationTimeToMs","expirationTime","ceiling","num","precision","computeExpirationBucket","currentTime","expirationInMs","bucketSizeMs","NoContext","AsyncUpdates","hasBadMapPolyfill","nonExtensibleObject","Object","preventExtensions","e","debugCounter","FiberNode","internalContextTag","ref","pendingProps","memoizedProps","updateQueue","memoizedState","nextEffect","firstEffect","lastEffect","createFiber","shouldConstruct","Component","prototype","isReactComponent","createWorkInProgress","createHostRootFiber","createFiberFromElement","element","_owner","props","undefined","keys","length","_source","createFiberFromFragment","elements","createFiberFromText","content","createFiberFromHostInstanceForDeletion","createFiberFromCall","call","handler","createFiberFromReturn","returnNode","createFiberFromPortal","portal","children","containerInfo","pendingChildren","implementation","createFiberRoot","hydrate","uninitializedFiber","root","remainingExpirationTime","isReadyForCommit","finishedWork","pendingContext","nextScheduledRoot","onCommitFiberRoot","onCommitFiberUnmount","hasLoggedError","catchErrors","fn","arg","injectInternals","internals","__REACT_DEVTOOLS_GLOBAL_HOOK__","hook","isDisabled","supportsFiber","rendererID","inject","onCommitRoot","onCommitUnmount","ReactErrorUtils","_caughtError","_hasCaughtError","_rethrowError","_hasRethrowError","injection","injectErrorUtils","injectedErrorUtils","invokeGuardedCallback","invokeGuardedCallback$1","func","c","d","f","apply","arguments","invokeGuardedCallbackAndCatchFirstError","hasCaughtError","error","clearCaughtError","rethrowCaughtError","funcArgs","Array","slice","window","dispatchEvent","document","createEvent","fakeNode","createElement","invokeGuardedCallbackDev","didError","callCallback","removeEventListener","evtType","didSetError","isCrossOriginError","onError","event","colno","lineno","addEventListener","evt","initEvent","Error","didWarnUpdateInsideUpdate","createUpdateQueue","baseState","queue","first","last","callbackList","hasForceUpdate","isInitialized","isProcessing","insertUpdateIntoQueue","update","next","insertUpdateIntoFiber","alternateFiber","queue1","queue2","getUpdateExpirationTime","getStateFromUpdate","prevState","partialState","updateFn","processUpdateQueue","renderExpirationTime","currentQueue","dontMutatePrevState","didSkip","updateExpirationTime","_partialState","isReplace","isForced","callback","_callbackList","commitCallbacks","i","_callback","fakeInternalInstance","isArray","didWarnAboutStateAssignmentForComponent","warnOnInvalidCallback","callerName","defineProperty","enumerable","freeze","ReactFiberClassComponent","scheduleWork","computeExpirationForFiber","memoizeProps","memoizeState","updater","enqueueSetState","nextCallback","enqueueReplaceState","enqueueForceUpdate","checkShouldComponentUpdate","oldProps","newProps","oldState","newState","newContext","shouldComponentUpdate","shouldUpdate","isPureReactComponent","checkClassInstance","renderPresent","render","noGetInitialStateOnES6","getInitialState","isReactClassApproved","noGetDefaultPropsOnES6","getDefaultProps","noInstancePropTypes","propTypes","noInstanceContextTypes","noComponentShouldUpdate","componentShouldUpdate","noComponentDidUnmount","componentDidUnmount","noComponentDidReceiveProps","componentDidReceiveProps","noComponentWillRecieveProps","componentWillRecieveProps","hasMutatedProps","noInstanceDefaultProps","defaultProps","resetInputPointers","adoptClassInstance","_reactInternalInstance","constructClassInstance","ctor","needsContext","callComponentWillMount","componentWillMount","callComponentWillReceiveProps","componentWillReceiveProps","mountClassInstance","refs","unstable_isAsyncReactComponent","componentDidMount","updateClassInstance","oldContext","newUnmaskedContext","componentDidUpdate","componentWillUpdate","hasSymbol","Symbol","REACT_ELEMENT_TYPE","REACT_CALL_TYPE","REACT_RETURN_TYPE","REACT_PORTAL_TYPE","REACT_FRAGMENT_TYPE","MAYBE_ITERATOR_SYMBOL","iterator","FAUX_ITERATOR_SYMBOL","getIteratorFn","maybeIterable","maybeIterator","getCurrentFiberStackAddendum$1","didWarnAboutMaps","ownerHasKeyUseWarning","ownerHasFunctionTypeWarning","warnForMissingKey","_store","validated","currentComponentErrorInfo","isArray$1","coerceRef","mixedRef","inst","stringRef","_stringRef","throwOnInvalidObjectType","returnFiber","newChild","addendum","toString","join","warnOnFunctionType","ChildReconciler","shouldTrackSideEffects","deleteChild","childToDelete","deleteRemainingChildren","currentFirstChild","mapRemainingChildren","existingChildren","Map","existingChild","useFiber","clone","placeChild","newFiber","lastPlacedIndex","newIndex","oldIndex","placeSingleChild","updateTextNode","textContent","created","existing","updateElement","updateCall","updateReturn","updatePortal","updateFragment","fragment","createChild","$$typeof","_created","_created2","_created3","_created4","_created5","_created6","updateSlot","oldFiber","updateFromMap","newIdx","matchedFiber","_matchedFiber","_matchedFiber2","_matchedFiber3","_matchedFiber4","_matchedFiber5","warnOnInvalidKey","knownKeys","reconcileChildrenArray","newChildren","resultingFirstChild","previousNewFiber","nextOldFiber","_newFiber","_newFiber2","forEach","reconcileChildrenIterator","newChildrenIterable","iteratorFn","entries","possibleMap","_newChildren","_step","done","step","_newFiber3","_newFiber4","reconcileSingleTextNode","reconcileSingleElement","_created7","reconcileSingleCall","reconcileSingleReturn","reconcileSinglePortal","reconcileChildFibers","isObject","_isMockFunction","mountChildFibers","cloneChildFibers","currentChild","warnedAboutStatelessRefs","ReactFiberBeginWork","hostContext","hydrationContext","shouldSetTextContent","useSyncScheduling","shouldDeprioritizeSubtree","pushHostContext","pushHostContainer","enterHydrationState","resetHydrationState","tryToClaimNextHydratableInstance","_ReactFiberClassCompo","reconcileChildren","nextChildren","reconcileChildrenAtExpirationTime","bailoutOnAlreadyFinishedWork","markRef","updateFunctionalComponent","nextProps","updateClassComponent","hasContext","finishClassComponent","pushHostRootContext","updateHostRoot","updateHostComponent","prevProps","isDirectTextChild","updateHostText","mountIndeterminateComponent","warningKey","debugSource","updateCallComponent","nextCall","updatePortalComponent","bailoutOnLowPriority","nextState","beginWork","beginFailedWork","ReactFiberCompleteWork","createInstance","createTextInstance","appendInitialChild","finalizeInitialChildren","prepareUpdate","mutation","persistence","getRootHostContainer","popHostContext","getHostContext","popHostContainer","prepareToHydrateHostInstance","prepareToHydrateHostTextInstance","popHydrationState","markUpdate","appendAllReturns","returns","moveCallToHandlerPhase","appendAllChildren","updateHostContainer","updatePayload","rootContainerInstance","oldText","newText","cloneInstance","createContainerChildSet","appendChildToContainerChildSet","finalizeContainerChildren","appendAllChildrenToContainer","containerChildSet","portalOrRoot","childrenUnchanged","container","newChildSet","currentInstance","recyclableInstance","newInstance","currentHostContext","completeWork","fiberRoot","_currentHostContext","wasHydrated","_instance","_rootContainerInstance","_currentHostContext2","_wasHydrated","invokeGuardedCallback$2","hasCaughtError$1","clearCaughtError$1","ReactFiberCommitWork","captureError","getPublicInstance","callComponentWillUnmountWithTimer","componentWillUnmount","safelyCallComponentWillUnmount","unmountError","safelyDetachRef","refError","commitLifeCycles","_updateQueue","_instance2","commitMount","commitAttachRef","commitDetachRef","currentRef","commitUnmount","commitNestedUnmounts","unmountHostComponents","emptyPortalContainer","detachFiber","commitContainer","replaceContainerChildren","emptyChildSet","_pendingChildren","commitResetTextContent","commitPlacement","commitDeletion","commitWork","commitUpdate","resetTextContent","commitTextUpdate","appendChild","appendChildToContainer","insertBefore","insertInContainerBefore","removeChild","removeChildFromContainer","getHostParentFiber","isHostParent","getHostSibling","siblings","parentFiber","isContainer","before","currentParentIsValid","currentParentIsContainer","findParent","textInstance","NO_CONTEXT","ReactFiberHostContext","getChildHostContext","getRootHostContext","contextFiberStackCursor","rootInstanceStackCursor","requiredContext","rootInstance","nextRootInstance","nextRootContext","nextContext","resetHostContainer","ReactFiberHydrationContext","hydration","canHydrateInstance","canHydrateTextInstance","getNextHydratableSibling","getFirstHydratableChild","hydrateInstance","hydrateTextInstance","didNotMatchHydratedContainerTextInstance","didNotMatchHydratedTextInstance","didNotHydrateContainerInstance","didNotHydrateInstance","didNotFindHydratableContainerInstance","didNotFindHydratableContainerTextInstance","didNotFindHydratableInstance","didNotFindHydratableTextInstance","hydrationParentFiber","nextHydratableInstance","isHydrating","parentInstance","deleteHydratableInstance","insertNonHydratedInstance","parentContainer","text","parentType","parentProps","_type","_props","_text","tryHydrate","nextInstance","popToNextHostParent","ReactFiberInstrumentation","debugTool","ReactFiberInstrumentation_1","defaultShowDialog","capturedError","showDialog","logCapturedError","logError","suppressLogging","suppressReactErrorLogging","componentStack","errorBoundaryName","errorBoundaryFound","willRetry","componentNameMessage","errorBoundaryMessage","combinedMessage","console","didWarnAboutStateTransition","didWarnSetStateChildContext","didWarnStateUpdateForUnmountedComponent","warnAboutUpdateOnUnmounted","warnAboutInvalidUpdates","ReactFiberScheduler","_ReactFiberBeginWork","_ReactFiberCompleteWo","_ReactFiberCommitWork","now","scheduleDeferredCallback","cancelDeferredCallback","prepareForCommit","resetAfterCommit","startTime","mostRecentCurrentTime","expirationContext","isWorking","nextRoot","nextRenderExpirationTime","capturedErrors","failedBoundaries","commitPhaseBoundaries","firstUncaughtError","didFatal","isUnmounting","resetContextStack","commitAllHostEffects","primaryEffectTag","_current","_current2","commitAllLifeCycles","commitErrorHandling","commitRoot","_error","_didError","_error2","onCommitWork","scheduleErrorRecovery","_error3","onUncaughtError","remainingTime","resetExpirationTime","renderTime","newExpirationTime","completeUnitOfWork","siblingFiber","onCompleteWork","performUnitOfWork","onBeginWork","performFailedUnitOfWork","workLoop","slowWorkLoopThatChecksForFailedWork","shouldYield","hasCapturedError","renderRootCatchBlock","failedWork","boundary","unwindContexts","renderRoot","uncaughtError","isFailedBoundary","componentDidCatch","_componentStack","_componentName","errorBoundary","effectfulFiber","from","to","computeAsyncExpiration","recalculateCurrentTime","expirationMs","scheduleWorkImpl","checkRootNeedsClearing","isErrorRecovery","requestWork","deferredUpdates","previousExpirationContext","syncUpdates","firstScheduledRoot","lastScheduledRoot","callbackExpirationTime","callbackID","isRendering","nextFlushedRoot","nextFlushedExpirationTime","deadlineDidExpire","hasUnhandledError","unhandledError","deadline","isBatchingUpdates","isUnbatchingUpdates","NESTED_UPDATE_LIMIT","nestedUpdateCount","timeHeuristicForUnitOfWork","scheduleCallbackWithExpiration","currentMs","timeout","performAsyncWork","performWorkOnRoot","performWork","findHighestPriorityRoot","highestPriorityWork","highestPriorityRoot","previousScheduledRoot","previousFlushedRoot","dl","minExpirationTime","_error4","_finishedWork","timeRemaining","batchedUpdates","previousIsBatchingUpdates","unbatchedUpdates","flushSync","didWarnAboutNestedUpdates","getContextForSubtree","parentComponent","ReactFiberReconciler","_ReactFiberScheduler","scheduleTopLevelUpdate","findHostInstance","hostFiber","createContainer","updateContainer","onMountContainer","onUnmountContainer","onUpdateContainer","getPublicRootInstance","containerFiber","findHostInstanceWithNoPortals","injectIntoDevTools","devToolsConfig","findFiberByHostInstance","findHostInstanceByFiber","ReactFiberReconciler$1","default","ReactFiberReconciler$2","reactReconciler"],"mappings":"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","sourcesContent":["/** @license React v16.2.0\n * react-reconciler.development.js\n *\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\nif (process.env.NODE_ENV !== \"production\") {\n  // This is a hacky way to ensure third party renderers don't share\n  // top-level module state inside the reconciler. Ideally we should\n  // remove this hack by putting all top-level state into the closures\n  // and then forbidding adding more of it in the reconciler.\n  var $$$reconciler;\n  module.exports = function(config) {\n'use strict';\n\nvar _assign = require('object-assign');\nvar invariant = require('fbjs/lib/invariant');\nvar warning = require('fbjs/lib/warning');\nvar React = require('react');\nvar emptyObject = require('fbjs/lib/emptyObject');\nvar checkPropTypes = require('prop-types/checkPropTypes');\nvar shallowEqual = require('fbjs/lib/shallowEqual');\n\n/**\n * WARNING: DO NOT manually require this module.\n * This is a replacement for `invariant(...)` used by the error code system\n * and will _only_ be required by the corresponding babel pass.\n * It always throws.\n */\n\nvar enableAsyncSubtreeAPI = true;\n\n// Exports ReactDOM.createRoot\n\nvar enableUserTimingAPI = true;\n\n// Mutating mode (React DOM, React ART, React Native):\nvar enableMutatingReconciler = true;\n// Experimental noop mode (currently unused):\nvar enableNoopReconciler = false;\n// Experimental persistent mode (CS):\nvar enablePersistentReconciler = false;\n\n// Helps identify side effects in begin-phase lifecycle hooks and setState reducers:\nvar debugRenderPhaseSideEffects = false;\n\n// Only used in www builds.\n\n/**\n * `ReactInstanceMap` maintains a mapping from a public facing stateful\n * instance (key) and the internal representation (value). This allows public\n * methods to accept the user facing instance as an argument and map them back\n * to internal methods.\n *\n * Note that this module is currently shared and assumed to be stateless.\n * If this becomes an actual Map, that will break.\n */\n\n/**\n * This API should be called `delete` but we'd have to make sure to always\n * transform these to strings for IE support. When this transform is fully\n * supported we can rename it.\n */\n\n\nfunction get(key) {\n  return key._reactInternalFiber;\n}\n\n\n\nfunction set(key, value) {\n  key._reactInternalFiber = value;\n}\n\nvar ReactInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n\nvar ReactCurrentOwner = ReactInternals.ReactCurrentOwner;\nvar ReactDebugCurrentFrame = ReactInternals.ReactDebugCurrentFrame;\n\nfunction getComponentName(fiber) {\n  var type = fiber.type;\n\n  if (typeof type === 'string') {\n    return type;\n  }\n  if (typeof type === 'function') {\n    return type.displayName || type.name;\n  }\n  return null;\n}\n\nvar IndeterminateComponent = 0; // Before we know whether it is functional or class\nvar FunctionalComponent = 1;\nvar ClassComponent = 2;\nvar HostRoot = 3; // Root of a host tree. Could be nested inside another node.\nvar HostPortal = 4; // A subtree. Could be an entry point to a different renderer.\nvar HostComponent = 5;\nvar HostText = 6;\nvar CallComponent = 7;\nvar CallHandlerPhase = 8;\nvar ReturnComponent = 9;\nvar Fragment = 10;\n\n// Don't change these two values:\nvar NoEffect = 0; //           0b00000000\nvar PerformedWork = 1; //      0b00000001\n\n// You can change the rest (and add more).\nvar Placement = 2; //          0b00000010\nvar Update = 4; //             0b00000100\nvar PlacementAndUpdate = 6; // 0b00000110\nvar Deletion = 8; //           0b00001000\nvar ContentReset = 16; //      0b00010000\nvar Callback = 32; //          0b00100000\nvar Err = 64; //               0b01000000\nvar Ref = 128; //              0b10000000\n\nvar MOUNTING = 1;\nvar MOUNTED = 2;\nvar UNMOUNTED = 3;\n\nfunction isFiberMountedImpl(fiber) {\n  var node = fiber;\n  if (!fiber.alternate) {\n    // If there is no alternate, this might be a new tree that isn't inserted\n    // yet. If it is, then it will have a pending insertion effect on it.\n    if ((node.effectTag & Placement) !== NoEffect) {\n      return MOUNTING;\n    }\n    while (node['return']) {\n      node = node['return'];\n      if ((node.effectTag & Placement) !== NoEffect) {\n        return MOUNTING;\n      }\n    }\n  } else {\n    while (node['return']) {\n      node = node['return'];\n    }\n  }\n  if (node.tag === HostRoot) {\n    // TODO: Check if this was a nested HostRoot when used with\n    // renderContainerIntoSubtree.\n    return MOUNTED;\n  }\n  // If we didn't hit the root, that means that we're in an disconnected tree\n  // that has been unmounted.\n  return UNMOUNTED;\n}\n\nfunction isFiberMounted(fiber) {\n  return isFiberMountedImpl(fiber) === MOUNTED;\n}\n\nfunction isMounted(component) {\n  {\n    var owner = ReactCurrentOwner.current;\n    if (owner !== null && owner.tag === ClassComponent) {\n      var ownerFiber = owner;\n      var instance = ownerFiber.stateNode;\n      warning(instance._warnedAboutRefsInRender, '%s is accessing isMounted inside its render() function. ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', getComponentName(ownerFiber) || 'A component');\n      instance._warnedAboutRefsInRender = true;\n    }\n  }\n\n  var fiber = get(component);\n  if (!fiber) {\n    return false;\n  }\n  return isFiberMountedImpl(fiber) === MOUNTED;\n}\n\nfunction assertIsMounted(fiber) {\n  !(isFiberMountedImpl(fiber) === MOUNTED) ? invariant(false, 'Unable to find node on an unmounted component.') : void 0;\n}\n\nfunction findCurrentFiberUsingSlowPath(fiber) {\n  var alternate = fiber.alternate;\n  if (!alternate) {\n    // If there is no alternate, then we only need to check if it is mounted.\n    var state = isFiberMountedImpl(fiber);\n    !(state !== UNMOUNTED) ? invariant(false, 'Unable to find node on an unmounted component.') : void 0;\n    if (state === MOUNTING) {\n      return null;\n    }\n    return fiber;\n  }\n  // If we have two possible branches, we'll walk backwards up to the root\n  // to see what path the root points to. On the way we may hit one of the\n  // special cases and we'll deal with them.\n  var a = fiber;\n  var b = alternate;\n  while (true) {\n    var parentA = a['return'];\n    var parentB = parentA ? parentA.alternate : null;\n    if (!parentA || !parentB) {\n      // We're at the root.\n      break;\n    }\n\n    // If both copies of the parent fiber point to the same child, we can\n    // assume that the child is current. This happens when we bailout on low\n    // priority: the bailed out fiber's child reuses the current child.\n    if (parentA.child === parentB.child) {\n      var child = parentA.child;\n      while (child) {\n        if (child === a) {\n          // We've determined that A is the current branch.\n          assertIsMounted(parentA);\n          return fiber;\n        }\n        if (child === b) {\n          // We've determined that B is the current branch.\n          assertIsMounted(parentA);\n          return alternate;\n        }\n        child = child.sibling;\n      }\n      // We should never have an alternate for any mounting node. So the only\n      // way this could possibly happen is if this was unmounted, if at all.\n      invariant(false, 'Unable to find node on an unmounted component.');\n    }\n\n    if (a['return'] !== b['return']) {\n      // The return pointer of A and the return pointer of B point to different\n      // fibers. We assume that return pointers never criss-cross, so A must\n      // belong to the child set of A.return, and B must belong to the child\n      // set of B.return.\n      a = parentA;\n      b = parentB;\n    } else {\n      // The return pointers point to the same fiber. We'll have to use the\n      // default, slow path: scan the child sets of each parent alternate to see\n      // which child belongs to which set.\n      //\n      // Search parent A's child set\n      var didFindChild = false;\n      var _child = parentA.child;\n      while (_child) {\n        if (_child === a) {\n          didFindChild = true;\n          a = parentA;\n          b = parentB;\n          break;\n        }\n        if (_child === b) {\n          didFindChild = true;\n          b = parentA;\n          a = parentB;\n          break;\n        }\n        _child = _child.sibling;\n      }\n      if (!didFindChild) {\n        // Search parent B's child set\n        _child = parentB.child;\n        while (_child) {\n          if (_child === a) {\n            didFindChild = true;\n            a = parentB;\n            b = parentA;\n            break;\n          }\n          if (_child === b) {\n            didFindChild = true;\n            b = parentB;\n            a = parentA;\n            break;\n          }\n          _child = _child.sibling;\n        }\n        !didFindChild ? invariant(false, 'Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue.') : void 0;\n      }\n    }\n\n    !(a.alternate === b) ? invariant(false, 'Return fibers should always be each others\\' alternates. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n  }\n  // If the root is not a host container, we're in a disconnected tree. I.e.\n  // unmounted.\n  !(a.tag === HostRoot) ? invariant(false, 'Unable to find node on an unmounted component.') : void 0;\n  if (a.stateNode.current === a) {\n    // We've determined that A is the current branch.\n    return fiber;\n  }\n  // Otherwise B has to be current branch.\n  return alternate;\n}\n\nfunction findCurrentHostFiber(parent) {\n  var currentParent = findCurrentFiberUsingSlowPath(parent);\n  if (!currentParent) {\n    return null;\n  }\n\n  // Next we'll drill down this component to find the first HostComponent/Text.\n  var node = currentParent;\n  while (true) {\n    if (node.tag === HostComponent || node.tag === HostText) {\n      return node;\n    } else if (node.child) {\n      node.child['return'] = node;\n      node = node.child;\n      continue;\n    }\n    if (node === currentParent) {\n      return null;\n    }\n    while (!node.sibling) {\n      if (!node['return'] || node['return'] === currentParent) {\n        return null;\n      }\n      node = node['return'];\n    }\n    node.sibling['return'] = node['return'];\n    node = node.sibling;\n  }\n  // Flow needs the return null here, but ESLint complains about it.\n  // eslint-disable-next-line no-unreachable\n  return null;\n}\n\nfunction findCurrentHostFiberWithNoPortals(parent) {\n  var currentParent = findCurrentFiberUsingSlowPath(parent);\n  if (!currentParent) {\n    return null;\n  }\n\n  // Next we'll drill down this component to find the first HostComponent/Text.\n  var node = currentParent;\n  while (true) {\n    if (node.tag === HostComponent || node.tag === HostText) {\n      return node;\n    } else if (node.child && node.tag !== HostPortal) {\n      node.child['return'] = node;\n      node = node.child;\n      continue;\n    }\n    if (node === currentParent) {\n      return null;\n    }\n    while (!node.sibling) {\n      if (!node['return'] || node['return'] === currentParent) {\n        return null;\n      }\n      node = node['return'];\n    }\n    node.sibling['return'] = node['return'];\n    node = node.sibling;\n  }\n  // Flow needs the return null here, but ESLint complains about it.\n  // eslint-disable-next-line no-unreachable\n  return null;\n}\n\nvar valueStack = [];\n\n{\n  var fiberStack = [];\n}\n\nvar index = -1;\n\nfunction createCursor(defaultValue) {\n  return {\n    current: defaultValue\n  };\n}\n\n\n\nfunction pop(cursor, fiber) {\n  if (index < 0) {\n    {\n      warning(false, 'Unexpected pop.');\n    }\n    return;\n  }\n\n  {\n    if (fiber !== fiberStack[index]) {\n      warning(false, 'Unexpected Fiber popped.');\n    }\n  }\n\n  cursor.current = valueStack[index];\n\n  valueStack[index] = null;\n\n  {\n    fiberStack[index] = null;\n  }\n\n  index--;\n}\n\nfunction push(cursor, value, fiber) {\n  index++;\n\n  valueStack[index] = cursor.current;\n\n  {\n    fiberStack[index] = fiber;\n  }\n\n  cursor.current = value;\n}\n\nfunction reset() {\n  while (index > -1) {\n    valueStack[index] = null;\n\n    {\n      fiberStack[index] = null;\n    }\n\n    index--;\n  }\n}\n\nvar describeComponentFrame = function (name, source, ownerName) {\n  return '\\n    in ' + (name || 'Unknown') + (source ? ' (at ' + source.fileName.replace(/^.*[\\\\\\/]/, '') + ':' + source.lineNumber + ')' : ownerName ? ' (created by ' + ownerName + ')' : '');\n};\n\nfunction describeFiber(fiber) {\n  switch (fiber.tag) {\n    case IndeterminateComponent:\n    case FunctionalComponent:\n    case ClassComponent:\n    case HostComponent:\n      var owner = fiber._debugOwner;\n      var source = fiber._debugSource;\n      var name = getComponentName(fiber);\n      var ownerName = null;\n      if (owner) {\n        ownerName = getComponentName(owner);\n      }\n      return describeComponentFrame(name, source, ownerName);\n    default:\n      return '';\n  }\n}\n\n// This function can only be called with a work-in-progress fiber and\n// only during begin or complete phase. Do not call it under any other\n// circumstances.\nfunction getStackAddendumByWorkInProgressFiber(workInProgress) {\n  var info = '';\n  var node = workInProgress;\n  do {\n    info += describeFiber(node);\n    // Otherwise this return pointer might point to the wrong tree:\n    node = node['return'];\n  } while (node);\n  return info;\n}\n\nfunction getCurrentFiberOwnerName() {\n  {\n    var fiber = ReactDebugCurrentFiber.current;\n    if (fiber === null) {\n      return null;\n    }\n    var owner = fiber._debugOwner;\n    if (owner !== null && typeof owner !== 'undefined') {\n      return getComponentName(owner);\n    }\n  }\n  return null;\n}\n\nfunction getCurrentFiberStackAddendum() {\n  {\n    var fiber = ReactDebugCurrentFiber.current;\n    if (fiber === null) {\n      return null;\n    }\n    // Safe because if current fiber exists, we are reconciling,\n    // and it is guaranteed to be the work-in-progress version.\n    return getStackAddendumByWorkInProgressFiber(fiber);\n  }\n  return null;\n}\n\nfunction resetCurrentFiber() {\n  ReactDebugCurrentFrame.getCurrentStack = null;\n  ReactDebugCurrentFiber.current = null;\n  ReactDebugCurrentFiber.phase = null;\n}\n\nfunction setCurrentFiber(fiber) {\n  ReactDebugCurrentFrame.getCurrentStack = getCurrentFiberStackAddendum;\n  ReactDebugCurrentFiber.current = fiber;\n  ReactDebugCurrentFiber.phase = null;\n}\n\nfunction setCurrentPhase(phase) {\n  ReactDebugCurrentFiber.phase = phase;\n}\n\nvar ReactDebugCurrentFiber = {\n  current: null,\n  phase: null,\n  resetCurrentFiber: resetCurrentFiber,\n  setCurrentFiber: setCurrentFiber,\n  setCurrentPhase: setCurrentPhase,\n  getCurrentFiberOwnerName: getCurrentFiberOwnerName,\n  getCurrentFiberStackAddendum: getCurrentFiberStackAddendum\n};\n\n// Prefix measurements so that it's possible to filter them.\n// Longer prefixes are hard to read in DevTools.\nvar reactEmoji = '\\u269B';\nvar warningEmoji = '\\u26D4';\nvar supportsUserTiming = typeof performance !== 'undefined' && typeof performance.mark === 'function' && typeof performance.clearMarks === 'function' && typeof performance.measure === 'function' && typeof performance.clearMeasures === 'function';\n\n// Keep track of current fiber so that we know the path to unwind on pause.\n// TODO: this looks the same as nextUnitOfWork in scheduler. Can we unify them?\nvar currentFiber = null;\n// If we're in the middle of user code, which fiber and method is it?\n// Reusing `currentFiber` would be confusing for this because user code fiber\n// can change during commit phase too, but we don't need to unwind it (since\n// lifecycles in the commit phase don't resemble a tree).\nvar currentPhase = null;\nvar currentPhaseFiber = null;\n// Did lifecycle hook schedule an update? This is often a performance problem,\n// so we will keep track of it, and include it in the report.\n// Track commits caused by cascading updates.\nvar isCommitting = false;\nvar hasScheduledUpdateInCurrentCommit = false;\nvar hasScheduledUpdateInCurrentPhase = false;\nvar commitCountInCurrentWorkLoop = 0;\nvar effectCountInCurrentCommit = 0;\nvar isWaitingForCallback = false;\n// During commits, we only show a measurement once per method name\n// to avoid stretch the commit phase with measurement overhead.\nvar labelsInCurrentCommit = new Set();\n\nvar formatMarkName = function (markName) {\n  return reactEmoji + ' ' + markName;\n};\n\nvar formatLabel = function (label, warning$$1) {\n  var prefix = warning$$1 ? warningEmoji + ' ' : reactEmoji + ' ';\n  var suffix = warning$$1 ? ' Warning: ' + warning$$1 : '';\n  return '' + prefix + label + suffix;\n};\n\nvar beginMark = function (markName) {\n  performance.mark(formatMarkName(markName));\n};\n\nvar clearMark = function (markName) {\n  performance.clearMarks(formatMarkName(markName));\n};\n\nvar endMark = function (label, markName, warning$$1) {\n  var formattedMarkName = formatMarkName(markName);\n  var formattedLabel = formatLabel(label, warning$$1);\n  try {\n    performance.measure(formattedLabel, formattedMarkName);\n  } catch (err) {}\n  // If previous mark was missing for some reason, this will throw.\n  // This could only happen if React crashed in an unexpected place earlier.\n  // Don't pile on with more errors.\n\n  // Clear marks immediately to avoid growing buffer.\n  performance.clearMarks(formattedMarkName);\n  performance.clearMeasures(formattedLabel);\n};\n\nvar getFiberMarkName = function (label, debugID) {\n  return label + ' (#' + debugID + ')';\n};\n\nvar getFiberLabel = function (componentName, isMounted, phase) {\n  if (phase === null) {\n    // These are composite component total time measurements.\n    return componentName + ' [' + (isMounted ? 'update' : 'mount') + ']';\n  } else {\n    // Composite component methods.\n    return componentName + '.' + phase;\n  }\n};\n\nvar beginFiberMark = function (fiber, phase) {\n  var componentName = getComponentName(fiber) || 'Unknown';\n  var debugID = fiber._debugID;\n  var isMounted = fiber.alternate !== null;\n  var label = getFiberLabel(componentName, isMounted, phase);\n\n  if (isCommitting && labelsInCurrentCommit.has(label)) {\n    // During the commit phase, we don't show duplicate labels because\n    // there is a fixed overhead for every measurement, and we don't\n    // want to stretch the commit phase beyond necessary.\n    return false;\n  }\n  labelsInCurrentCommit.add(label);\n\n  var markName = getFiberMarkName(label, debugID);\n  beginMark(markName);\n  return true;\n};\n\nvar clearFiberMark = function (fiber, phase) {\n  var componentName = getComponentName(fiber) || 'Unknown';\n  var debugID = fiber._debugID;\n  var isMounted = fiber.alternate !== null;\n  var label = getFiberLabel(componentName, isMounted, phase);\n  var markName = getFiberMarkName(label, debugID);\n  clearMark(markName);\n};\n\nvar endFiberMark = function (fiber, phase, warning$$1) {\n  var componentName = getComponentName(fiber) || 'Unknown';\n  var debugID = fiber._debugID;\n  var isMounted = fiber.alternate !== null;\n  var label = getFiberLabel(componentName, isMounted, phase);\n  var markName = getFiberMarkName(label, debugID);\n  endMark(label, markName, warning$$1);\n};\n\nvar shouldIgnoreFiber = function (fiber) {\n  // Host components should be skipped in the timeline.\n  // We could check typeof fiber.type, but does this work with RN?\n  switch (fiber.tag) {\n    case HostRoot:\n    case HostComponent:\n    case HostText:\n    case HostPortal:\n    case ReturnComponent:\n    case Fragment:\n      return true;\n    default:\n      return false;\n  }\n};\n\nvar clearPendingPhaseMeasurement = function () {\n  if (currentPhase !== null && currentPhaseFiber !== null) {\n    clearFiberMark(currentPhaseFiber, currentPhase);\n  }\n  currentPhaseFiber = null;\n  currentPhase = null;\n  hasScheduledUpdateInCurrentPhase = false;\n};\n\nvar pauseTimers = function () {\n  // Stops all currently active measurements so that they can be resumed\n  // if we continue in a later deferred loop from the same unit of work.\n  var fiber = currentFiber;\n  while (fiber) {\n    if (fiber._debugIsCurrentlyTiming) {\n      endFiberMark(fiber, null, null);\n    }\n    fiber = fiber['return'];\n  }\n};\n\nvar resumeTimersRecursively = function (fiber) {\n  if (fiber['return'] !== null) {\n    resumeTimersRecursively(fiber['return']);\n  }\n  if (fiber._debugIsCurrentlyTiming) {\n    beginFiberMark(fiber, null);\n  }\n};\n\nvar resumeTimers = function () {\n  // Resumes all measurements that were active during the last deferred loop.\n  if (currentFiber !== null) {\n    resumeTimersRecursively(currentFiber);\n  }\n};\n\nfunction recordEffect() {\n  if (enableUserTimingAPI) {\n    effectCountInCurrentCommit++;\n  }\n}\n\nfunction recordScheduleUpdate() {\n  if (enableUserTimingAPI) {\n    if (isCommitting) {\n      hasScheduledUpdateInCurrentCommit = true;\n    }\n    if (currentPhase !== null && currentPhase !== 'componentWillMount' && currentPhase !== 'componentWillReceiveProps') {\n      hasScheduledUpdateInCurrentPhase = true;\n    }\n  }\n}\n\nfunction startRequestCallbackTimer() {\n  if (enableUserTimingAPI) {\n    if (supportsUserTiming && !isWaitingForCallback) {\n      isWaitingForCallback = true;\n      beginMark('(Waiting for async callback...)');\n    }\n  }\n}\n\nfunction stopRequestCallbackTimer(didExpire) {\n  if (enableUserTimingAPI) {\n    if (supportsUserTiming) {\n      isWaitingForCallback = false;\n      var warning$$1 = didExpire ? 'React was blocked by main thread' : null;\n      endMark('(Waiting for async callback...)', '(Waiting for async callback...)', warning$$1);\n    }\n  }\n}\n\nfunction startWorkTimer(fiber) {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {\n      return;\n    }\n    // If we pause, this is the fiber to unwind from.\n    currentFiber = fiber;\n    if (!beginFiberMark(fiber, null)) {\n      return;\n    }\n    fiber._debugIsCurrentlyTiming = true;\n  }\n}\n\nfunction cancelWorkTimer(fiber) {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {\n      return;\n    }\n    // Remember we shouldn't complete measurement for this fiber.\n    // Otherwise flamechart will be deep even for small updates.\n    fiber._debugIsCurrentlyTiming = false;\n    clearFiberMark(fiber, null);\n  }\n}\n\nfunction stopWorkTimer(fiber) {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {\n      return;\n    }\n    // If we pause, its parent is the fiber to unwind from.\n    currentFiber = fiber['return'];\n    if (!fiber._debugIsCurrentlyTiming) {\n      return;\n    }\n    fiber._debugIsCurrentlyTiming = false;\n    endFiberMark(fiber, null, null);\n  }\n}\n\nfunction stopFailedWorkTimer(fiber) {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {\n      return;\n    }\n    // If we pause, its parent is the fiber to unwind from.\n    currentFiber = fiber['return'];\n    if (!fiber._debugIsCurrentlyTiming) {\n      return;\n    }\n    fiber._debugIsCurrentlyTiming = false;\n    var warning$$1 = 'An error was thrown inside this error boundary';\n    endFiberMark(fiber, null, warning$$1);\n  }\n}\n\nfunction startPhaseTimer(fiber, phase) {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n    clearPendingPhaseMeasurement();\n    if (!beginFiberMark(fiber, phase)) {\n      return;\n    }\n    currentPhaseFiber = fiber;\n    currentPhase = phase;\n  }\n}\n\nfunction stopPhaseTimer() {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n    if (currentPhase !== null && currentPhaseFiber !== null) {\n      var warning$$1 = hasScheduledUpdateInCurrentPhase ? 'Scheduled a cascading update' : null;\n      endFiberMark(currentPhaseFiber, currentPhase, warning$$1);\n    }\n    currentPhase = null;\n    currentPhaseFiber = null;\n  }\n}\n\nfunction startWorkLoopTimer(nextUnitOfWork) {\n  if (enableUserTimingAPI) {\n    currentFiber = nextUnitOfWork;\n    if (!supportsUserTiming) {\n      return;\n    }\n    commitCountInCurrentWorkLoop = 0;\n    // This is top level call.\n    // Any other measurements are performed within.\n    beginMark('(React Tree Reconciliation)');\n    // Resume any measurements that were in progress during the last loop.\n    resumeTimers();\n  }\n}\n\nfunction stopWorkLoopTimer(interruptedBy) {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n    var warning$$1 = null;\n    if (interruptedBy !== null) {\n      if (interruptedBy.tag === HostRoot) {\n        warning$$1 = 'A top-level update interrupted the previous render';\n      } else {\n        var componentName = getComponentName(interruptedBy) || 'Unknown';\n        warning$$1 = 'An update to ' + componentName + ' interrupted the previous render';\n      }\n    } else if (commitCountInCurrentWorkLoop > 1) {\n      warning$$1 = 'There were cascading updates';\n    }\n    commitCountInCurrentWorkLoop = 0;\n    // Pause any measurements until the next loop.\n    pauseTimers();\n    endMark('(React Tree Reconciliation)', '(React Tree Reconciliation)', warning$$1);\n  }\n}\n\nfunction startCommitTimer() {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n    isCommitting = true;\n    hasScheduledUpdateInCurrentCommit = false;\n    labelsInCurrentCommit.clear();\n    beginMark('(Committing Changes)');\n  }\n}\n\nfunction stopCommitTimer() {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n\n    var warning$$1 = null;\n    if (hasScheduledUpdateInCurrentCommit) {\n      warning$$1 = 'Lifecycle hook scheduled a cascading update';\n    } else if (commitCountInCurrentWorkLoop > 0) {\n      warning$$1 = 'Caused by a cascading update in earlier commit';\n    }\n    hasScheduledUpdateInCurrentCommit = false;\n    commitCountInCurrentWorkLoop++;\n    isCommitting = false;\n    labelsInCurrentCommit.clear();\n\n    endMark('(Committing Changes)', '(Committing Changes)', warning$$1);\n  }\n}\n\nfunction startCommitHostEffectsTimer() {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n    effectCountInCurrentCommit = 0;\n    beginMark('(Committing Host Effects)');\n  }\n}\n\nfunction stopCommitHostEffectsTimer() {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n    var count = effectCountInCurrentCommit;\n    effectCountInCurrentCommit = 0;\n    endMark('(Committing Host Effects: ' + count + ' Total)', '(Committing Host Effects)', null);\n  }\n}\n\nfunction startCommitLifeCyclesTimer() {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n    effectCountInCurrentCommit = 0;\n    beginMark('(Calling Lifecycle Methods)');\n  }\n}\n\nfunction stopCommitLifeCyclesTimer() {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n    var count = effectCountInCurrentCommit;\n    effectCountInCurrentCommit = 0;\n    endMark('(Calling Lifecycle Methods: ' + count + ' Total)', '(Calling Lifecycle Methods)', null);\n  }\n}\n\n{\n  var warnedAboutMissingGetChildContext = {};\n}\n\n// A cursor to the current merged context object on the stack.\nvar contextStackCursor = createCursor(emptyObject);\n// A cursor to a boolean indicating whether the context has changed.\nvar didPerformWorkStackCursor = createCursor(false);\n// Keep track of the previous context object that was on the stack.\n// We use this to get access to the parent context after we have already\n// pushed the next context provider, and now need to merge their contexts.\nvar previousContext = emptyObject;\n\nfunction getUnmaskedContext(workInProgress) {\n  var hasOwnContext = isContextProvider(workInProgress);\n  if (hasOwnContext) {\n    // If the fiber is a context provider itself, when we read its context\n    // we have already pushed its own child context on the stack. A context\n    // provider should not \"see\" its own child context. Therefore we read the\n    // previous (parent) context instead for a context provider.\n    return previousContext;\n  }\n  return contextStackCursor.current;\n}\n\nfunction cacheContext(workInProgress, unmaskedContext, maskedContext) {\n  var instance = workInProgress.stateNode;\n  instance.__reactInternalMemoizedUnmaskedChildContext = unmaskedContext;\n  instance.__reactInternalMemoizedMaskedChildContext = maskedContext;\n}\n\nfunction getMaskedContext(workInProgress, unmaskedContext) {\n  var type = workInProgress.type;\n  var contextTypes = type.contextTypes;\n  if (!contextTypes) {\n    return emptyObject;\n  }\n\n  // Avoid recreating masked context unless unmasked context has changed.\n  // Failing to do this will result in unnecessary calls to componentWillReceiveProps.\n  // This may trigger infinite loops if componentWillReceiveProps calls setState.\n  var instance = workInProgress.stateNode;\n  if (instance && instance.__reactInternalMemoizedUnmaskedChildContext === unmaskedContext) {\n    return instance.__reactInternalMemoizedMaskedChildContext;\n  }\n\n  var context = {};\n  for (var key in contextTypes) {\n    context[key] = unmaskedContext[key];\n  }\n\n  {\n    var name = getComponentName(workInProgress) || 'Unknown';\n    checkPropTypes(contextTypes, context, 'context', name, ReactDebugCurrentFiber.getCurrentFiberStackAddendum);\n  }\n\n  // Cache unmasked context so we can avoid recreating masked context unless necessary.\n  // Context is created before the class component is instantiated so check for instance.\n  if (instance) {\n    cacheContext(workInProgress, unmaskedContext, context);\n  }\n\n  return context;\n}\n\nfunction hasContextChanged() {\n  return didPerformWorkStackCursor.current;\n}\n\nfunction isContextConsumer(fiber) {\n  return fiber.tag === ClassComponent && fiber.type.contextTypes != null;\n}\n\nfunction isContextProvider(fiber) {\n  return fiber.tag === ClassComponent && fiber.type.childContextTypes != null;\n}\n\nfunction popContextProvider(fiber) {\n  if (!isContextProvider(fiber)) {\n    return;\n  }\n\n  pop(didPerformWorkStackCursor, fiber);\n  pop(contextStackCursor, fiber);\n}\n\nfunction popTopLevelContextObject(fiber) {\n  pop(didPerformWorkStackCursor, fiber);\n  pop(contextStackCursor, fiber);\n}\n\nfunction pushTopLevelContextObject(fiber, context, didChange) {\n  !(contextStackCursor.cursor == null) ? invariant(false, 'Unexpected context found on stack. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n\n  push(contextStackCursor, context, fiber);\n  push(didPerformWorkStackCursor, didChange, fiber);\n}\n\nfunction processChildContext(fiber, parentContext) {\n  var instance = fiber.stateNode;\n  var childContextTypes = fiber.type.childContextTypes;\n\n  // TODO (bvaughn) Replace this behavior with an invariant() in the future.\n  // It has only been added in Fiber to match the (unintentional) behavior in Stack.\n  if (typeof instance.getChildContext !== 'function') {\n    {\n      var componentName = getComponentName(fiber) || 'Unknown';\n\n      if (!warnedAboutMissingGetChildContext[componentName]) {\n        warnedAboutMissingGetChildContext[componentName] = true;\n        warning(false, '%s.childContextTypes is specified but there is no getChildContext() method ' + 'on the instance. You can either define getChildContext() on %s or remove ' + 'childContextTypes from it.', componentName, componentName);\n      }\n    }\n    return parentContext;\n  }\n\n  var childContext = void 0;\n  {\n    ReactDebugCurrentFiber.setCurrentPhase('getChildContext');\n  }\n  startPhaseTimer(fiber, 'getChildContext');\n  childContext = instance.getChildContext();\n  stopPhaseTimer();\n  {\n    ReactDebugCurrentFiber.setCurrentPhase(null);\n  }\n  for (var contextKey in childContext) {\n    !(contextKey in childContextTypes) ? invariant(false, '%s.getChildContext(): key \"%s\" is not defined in childContextTypes.', getComponentName(fiber) || 'Unknown', contextKey) : void 0;\n  }\n  {\n    var name = getComponentName(fiber) || 'Unknown';\n    checkPropTypes(childContextTypes, childContext, 'child context', name,\n    // In practice, there is one case in which we won't get a stack. It's when\n    // somebody calls unstable_renderSubtreeIntoContainer() and we process\n    // context from the parent component instance. The stack will be missing\n    // because it's outside of the reconciliation, and so the pointer has not\n    // been set. This is rare and doesn't matter. We'll also remove that API.\n    ReactDebugCurrentFiber.getCurrentFiberStackAddendum);\n  }\n\n  return _assign({}, parentContext, childContext);\n}\n\nfunction pushContextProvider(workInProgress) {\n  if (!isContextProvider(workInProgress)) {\n    return false;\n  }\n\n  var instance = workInProgress.stateNode;\n  // We push the context as early as possible to ensure stack integrity.\n  // If the instance does not exist yet, we will push null at first,\n  // and replace it on the stack later when invalidating the context.\n  var memoizedMergedChildContext = instance && instance.__reactInternalMemoizedMergedChildContext || emptyObject;\n\n  // Remember the parent context so we can merge with it later.\n  // Inherit the parent's did-perform-work value to avoid inadvertently blocking updates.\n  previousContext = contextStackCursor.current;\n  push(contextStackCursor, memoizedMergedChildContext, workInProgress);\n  push(didPerformWorkStackCursor, didPerformWorkStackCursor.current, workInProgress);\n\n  return true;\n}\n\nfunction invalidateContextProvider(workInProgress, didChange) {\n  var instance = workInProgress.stateNode;\n  !instance ? invariant(false, 'Expected to have an instance by this point. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n\n  if (didChange) {\n    // Merge parent and own context.\n    // Skip this if we're not updating due to sCU.\n    // This avoids unnecessarily recomputing memoized values.\n    var mergedContext = processChildContext(workInProgress, previousContext);\n    instance.__reactInternalMemoizedMergedChildContext = mergedContext;\n\n    // Replace the old (or empty) context with the new one.\n    // It is important to unwind the context in the reverse order.\n    pop(didPerformWorkStackCursor, workInProgress);\n    pop(contextStackCursor, workInProgress);\n    // Now push the new context and mark that it has changed.\n    push(contextStackCursor, mergedContext, workInProgress);\n    push(didPerformWorkStackCursor, didChange, workInProgress);\n  } else {\n    pop(didPerformWorkStackCursor, workInProgress);\n    push(didPerformWorkStackCursor, didChange, workInProgress);\n  }\n}\n\nfunction resetContext() {\n  previousContext = emptyObject;\n  contextStackCursor.current = emptyObject;\n  didPerformWorkStackCursor.current = false;\n}\n\nfunction findCurrentUnmaskedContext(fiber) {\n  // Currently this is only used with renderSubtreeIntoContainer; not sure if it\n  // makes sense elsewhere\n  !(isFiberMounted(fiber) && fiber.tag === ClassComponent) ? invariant(false, 'Expected subtree parent to be a mounted class component. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n\n  var node = fiber;\n  while (node.tag !== HostRoot) {\n    if (isContextProvider(node)) {\n      return node.stateNode.__reactInternalMemoizedMergedChildContext;\n    }\n    var parent = node['return'];\n    !parent ? invariant(false, 'Found unexpected detached subtree parent. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n    node = parent;\n  }\n  return node.stateNode.context;\n}\n\nvar NoWork = 0; // TODO: Use an opaque type once ESLint et al support the syntax\n\nvar Sync = 1;\nvar Never = 2147483647; // Max int32: Math.pow(2, 31) - 1\n\nvar UNIT_SIZE = 10;\nvar MAGIC_NUMBER_OFFSET = 2;\n\n// 1 unit of expiration time represents 10ms.\nfunction msToExpirationTime(ms) {\n  // Always add an offset so that we don't clash with the magic number for NoWork.\n  return (ms / UNIT_SIZE | 0) + MAGIC_NUMBER_OFFSET;\n}\n\nfunction expirationTimeToMs(expirationTime) {\n  return (expirationTime - MAGIC_NUMBER_OFFSET) * UNIT_SIZE;\n}\n\nfunction ceiling(num, precision) {\n  return ((num / precision | 0) + 1) * precision;\n}\n\nfunction computeExpirationBucket(currentTime, expirationInMs, bucketSizeMs) {\n  return ceiling(currentTime + expirationInMs / UNIT_SIZE, bucketSizeMs / UNIT_SIZE);\n}\n\nvar NoContext = 0;\nvar AsyncUpdates = 1;\n\n{\n  var hasBadMapPolyfill = false;\n  try {\n    var nonExtensibleObject = Object.preventExtensions({});\n    /* eslint-disable no-new */\n    \n    /* eslint-enable no-new */\n  } catch (e) {\n    // TODO: Consider warning about bad polyfills\n    hasBadMapPolyfill = true;\n  }\n}\n\n// A Fiber is work on a Component that needs to be done or was done. There can\n// be more than one per component.\n\n\n{\n  var debugCounter = 1;\n}\n\nfunction FiberNode(tag, key, internalContextTag) {\n  // Instance\n  this.tag = tag;\n  this.key = key;\n  this.type = null;\n  this.stateNode = null;\n\n  // Fiber\n  this['return'] = null;\n  this.child = null;\n  this.sibling = null;\n  this.index = 0;\n\n  this.ref = null;\n\n  this.pendingProps = null;\n  this.memoizedProps = null;\n  this.updateQueue = null;\n  this.memoizedState = null;\n\n  this.internalContextTag = internalContextTag;\n\n  // Effects\n  this.effectTag = NoEffect;\n  this.nextEffect = null;\n\n  this.firstEffect = null;\n  this.lastEffect = null;\n\n  this.expirationTime = NoWork;\n\n  this.alternate = null;\n\n  {\n    this._debugID = debugCounter++;\n    this._debugSource = null;\n    this._debugOwner = null;\n    this._debugIsCurrentlyTiming = false;\n    if (!hasBadMapPolyfill && typeof Object.preventExtensions === 'function') {\n      Object.preventExtensions(this);\n    }\n  }\n}\n\n// This is a constructor function, rather than a POJO constructor, still\n// please ensure we do the following:\n// 1) Nobody should add any instance methods on this. Instance methods can be\n//    more difficult to predict when they get optimized and they are almost\n//    never inlined properly in static compilers.\n// 2) Nobody should rely on `instanceof Fiber` for type testing. We should\n//    always know when it is a fiber.\n// 3) We might want to experiment with using numeric keys since they are easier\n//    to optimize in a non-JIT environment.\n// 4) We can easily go from a constructor to a createFiber object literal if that\n//    is faster.\n// 5) It should be easy to port this to a C struct and keep a C implementation\n//    compatible.\nvar createFiber = function (tag, key, internalContextTag) {\n  // $FlowFixMe: the shapes are exact here but Flow doesn't like constructors\n  return new FiberNode(tag, key, internalContextTag);\n};\n\nfunction shouldConstruct(Component) {\n  return !!(Component.prototype && Component.prototype.isReactComponent);\n}\n\n// This is used to create an alternate fiber to do work on.\nfunction createWorkInProgress(current, pendingProps, expirationTime) {\n  var workInProgress = current.alternate;\n  if (workInProgress === null) {\n    // We use a double buffering pooling technique because we know that we'll\n    // only ever need at most two versions of a tree. We pool the \"other\" unused\n    // node that we're free to reuse. This is lazily created to avoid allocating\n    // extra objects for things that are never updated. It also allow us to\n    // reclaim the extra memory if needed.\n    workInProgress = createFiber(current.tag, current.key, current.internalContextTag);\n    workInProgress.type = current.type;\n    workInProgress.stateNode = current.stateNode;\n\n    {\n      // DEV-only fields\n      workInProgress._debugID = current._debugID;\n      workInProgress._debugSource = current._debugSource;\n      workInProgress._debugOwner = current._debugOwner;\n    }\n\n    workInProgress.alternate = current;\n    current.alternate = workInProgress;\n  } else {\n    // We already have an alternate.\n    // Reset the effect tag.\n    workInProgress.effectTag = NoEffect;\n\n    // The effect list is no longer valid.\n    workInProgress.nextEffect = null;\n    workInProgress.firstEffect = null;\n    workInProgress.lastEffect = null;\n  }\n\n  workInProgress.expirationTime = expirationTime;\n  workInProgress.pendingProps = pendingProps;\n\n  workInProgress.child = current.child;\n  workInProgress.memoizedProps = current.memoizedProps;\n  workInProgress.memoizedState = current.memoizedState;\n  workInProgress.updateQueue = current.updateQueue;\n\n  // These will be overridden during the parent's reconciliation\n  workInProgress.sibling = current.sibling;\n  workInProgress.index = current.index;\n  workInProgress.ref = current.ref;\n\n  return workInProgress;\n}\n\nfunction createHostRootFiber() {\n  var fiber = createFiber(HostRoot, null, NoContext);\n  return fiber;\n}\n\nfunction createFiberFromElement(element, internalContextTag, expirationTime) {\n  var owner = null;\n  {\n    owner = element._owner;\n  }\n\n  var fiber = void 0;\n  var type = element.type,\n      key = element.key;\n\n  if (typeof type === 'function') {\n    fiber = shouldConstruct(type) ? createFiber(ClassComponent, key, internalContextTag) : createFiber(IndeterminateComponent, key, internalContextTag);\n    fiber.type = type;\n    fiber.pendingProps = element.props;\n  } else if (typeof type === 'string') {\n    fiber = createFiber(HostComponent, key, internalContextTag);\n    fiber.type = type;\n    fiber.pendingProps = element.props;\n  } else if (typeof type === 'object' && type !== null && typeof type.tag === 'number') {\n    // Currently assumed to be a continuation and therefore is a fiber already.\n    // TODO: The yield system is currently broken for updates in some cases.\n    // The reified yield stores a fiber, but we don't know which fiber that is;\n    // the current or a workInProgress? When the continuation gets rendered here\n    // we don't know if we can reuse that fiber or if we need to clone it.\n    // There is probably a clever way to restructure this.\n    fiber = type;\n    fiber.pendingProps = element.props;\n  } else {\n    var info = '';\n    {\n      if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {\n        info += ' You likely forgot to export your component from the file ' + \"it's defined in, or you might have mixed up default and named imports.\";\n      }\n      var ownerName = owner ? getComponentName(owner) : null;\n      if (ownerName) {\n        info += '\\n\\nCheck the render method of `' + ownerName + '`.';\n      }\n    }\n    invariant(false, 'Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s', type == null ? type : typeof type, info);\n  }\n\n  {\n    fiber._debugSource = element._source;\n    fiber._debugOwner = element._owner;\n  }\n\n  fiber.expirationTime = expirationTime;\n\n  return fiber;\n}\n\nfunction createFiberFromFragment(elements, internalContextTag, expirationTime, key) {\n  var fiber = createFiber(Fragment, key, internalContextTag);\n  fiber.pendingProps = elements;\n  fiber.expirationTime = expirationTime;\n  return fiber;\n}\n\nfunction createFiberFromText(content, internalContextTag, expirationTime) {\n  var fiber = createFiber(HostText, null, internalContextTag);\n  fiber.pendingProps = content;\n  fiber.expirationTime = expirationTime;\n  return fiber;\n}\n\nfunction createFiberFromHostInstanceForDeletion() {\n  var fiber = createFiber(HostComponent, null, NoContext);\n  fiber.type = 'DELETED';\n  return fiber;\n}\n\nfunction createFiberFromCall(call, internalContextTag, expirationTime) {\n  var fiber = createFiber(CallComponent, call.key, internalContextTag);\n  fiber.type = call.handler;\n  fiber.pendingProps = call;\n  fiber.expirationTime = expirationTime;\n  return fiber;\n}\n\nfunction createFiberFromReturn(returnNode, internalContextTag, expirationTime) {\n  var fiber = createFiber(ReturnComponent, null, internalContextTag);\n  fiber.expirationTime = expirationTime;\n  return fiber;\n}\n\nfunction createFiberFromPortal(portal, internalContextTag, expirationTime) {\n  var fiber = createFiber(HostPortal, portal.key, internalContextTag);\n  fiber.pendingProps = portal.children || [];\n  fiber.expirationTime = expirationTime;\n  fiber.stateNode = {\n    containerInfo: portal.containerInfo,\n    pendingChildren: null, // Used by persistent updates\n    implementation: portal.implementation\n  };\n  return fiber;\n}\n\nfunction createFiberRoot(containerInfo, hydrate) {\n  // Cyclic construction. This cheats the type system right now because\n  // stateNode is any.\n  var uninitializedFiber = createHostRootFiber();\n  var root = {\n    current: uninitializedFiber,\n    containerInfo: containerInfo,\n    pendingChildren: null,\n    remainingExpirationTime: NoWork,\n    isReadyForCommit: false,\n    finishedWork: null,\n    context: null,\n    pendingContext: null,\n    hydrate: hydrate,\n    nextScheduledRoot: null\n  };\n  uninitializedFiber.stateNode = root;\n  return root;\n}\n\nvar onCommitFiberRoot = null;\nvar onCommitFiberUnmount = null;\nvar hasLoggedError = false;\n\nfunction catchErrors(fn) {\n  return function (arg) {\n    try {\n      return fn(arg);\n    } catch (err) {\n      if (true && !hasLoggedError) {\n        hasLoggedError = true;\n        warning(false, 'React DevTools encountered an error: %s', err);\n      }\n    }\n  };\n}\n\nfunction injectInternals(internals) {\n  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined') {\n    // No DevTools\n    return false;\n  }\n  var hook = __REACT_DEVTOOLS_GLOBAL_HOOK__;\n  if (hook.isDisabled) {\n    // This isn't a real property on the hook, but it can be set to opt out\n    // of DevTools integration and associated warnings and logs.\n    // https://github.com/facebook/react/issues/3877\n    return true;\n  }\n  if (!hook.supportsFiber) {\n    {\n      warning(false, 'The installed version of React DevTools is too old and will not work ' + 'with the current version of React. Please update React DevTools. ' + 'https://fb.me/react-devtools');\n    }\n    // DevTools exists, even though it doesn't support Fiber.\n    return true;\n  }\n  try {\n    var rendererID = hook.inject(internals);\n    // We have successfully injected, so now it is safe to set up hooks.\n    onCommitFiberRoot = catchErrors(function (root) {\n      return hook.onCommitFiberRoot(rendererID, root);\n    });\n    onCommitFiberUnmount = catchErrors(function (fiber) {\n      return hook.onCommitFiberUnmount(rendererID, fiber);\n    });\n  } catch (err) {\n    // Catch all errors because it is unsafe to throw during initialization.\n    {\n      warning(false, 'React DevTools encountered an error: %s.', err);\n    }\n  }\n  // DevTools exists\n  return true;\n}\n\nfunction onCommitRoot(root) {\n  if (typeof onCommitFiberRoot === 'function') {\n    onCommitFiberRoot(root);\n  }\n}\n\nfunction onCommitUnmount(fiber) {\n  if (typeof onCommitFiberUnmount === 'function') {\n    onCommitFiberUnmount(fiber);\n  }\n}\n\nvar ReactErrorUtils = {\n  // Used by Fiber to simulate a try-catch.\n  _caughtError: null,\n  _hasCaughtError: false,\n\n  // Used by event system to capture/rethrow the first error.\n  _rethrowError: null,\n  _hasRethrowError: false,\n\n  injection: {\n    injectErrorUtils: function (injectedErrorUtils) {\n      !(typeof injectedErrorUtils.invokeGuardedCallback === 'function') ? invariant(false, 'Injected invokeGuardedCallback() must be a function.') : void 0;\n      invokeGuardedCallback$1 = injectedErrorUtils.invokeGuardedCallback;\n    }\n  },\n\n  /**\n   * Call a function while guarding against errors that happens within it.\n   * Returns an error if it throws, otherwise null.\n   *\n   * In production, this is implemented using a try-catch. The reason we don't\n   * use a try-catch directly is so that we can swap out a different\n   * implementation in DEV mode.\n   *\n   * @param {String} name of the guard to use for logging or debugging\n   * @param {Function} func The function to invoke\n   * @param {*} context The context to use when calling the function\n   * @param {...*} args Arguments for function\n   */\n  invokeGuardedCallback: function (name, func, context, a, b, c, d, e, f) {\n    invokeGuardedCallback$1.apply(ReactErrorUtils, arguments);\n  },\n\n  /**\n   * Same as invokeGuardedCallback, but instead of returning an error, it stores\n   * it in a global so it can be rethrown by `rethrowCaughtError` later.\n   * TODO: See if _caughtError and _rethrowError can be unified.\n   *\n   * @param {String} name of the guard to use for logging or debugging\n   * @param {Function} func The function to invoke\n   * @param {*} context The context to use when calling the function\n   * @param {...*} args Arguments for function\n   */\n  invokeGuardedCallbackAndCatchFirstError: function (name, func, context, a, b, c, d, e, f) {\n    ReactErrorUtils.invokeGuardedCallback.apply(this, arguments);\n    if (ReactErrorUtils.hasCaughtError()) {\n      var error = ReactErrorUtils.clearCaughtError();\n      if (!ReactErrorUtils._hasRethrowError) {\n        ReactErrorUtils._hasRethrowError = true;\n        ReactErrorUtils._rethrowError = error;\n      }\n    }\n  },\n\n  /**\n   * During execution of guarded functions we will capture the first error which\n   * we will rethrow to be handled by the top level error handler.\n   */\n  rethrowCaughtError: function () {\n    return rethrowCaughtError.apply(ReactErrorUtils, arguments);\n  },\n\n  hasCaughtError: function () {\n    return ReactErrorUtils._hasCaughtError;\n  },\n\n  clearCaughtError: function () {\n    if (ReactErrorUtils._hasCaughtError) {\n      var error = ReactErrorUtils._caughtError;\n      ReactErrorUtils._caughtError = null;\n      ReactErrorUtils._hasCaughtError = false;\n      return error;\n    } else {\n      invariant(false, 'clearCaughtError was called but no error was captured. This error is likely caused by a bug in React. Please file an issue.');\n    }\n  }\n};\n\nvar invokeGuardedCallback$1 = function (name, func, context, a, b, c, d, e, f) {\n  ReactErrorUtils._hasCaughtError = false;\n  ReactErrorUtils._caughtError = null;\n  var funcArgs = Array.prototype.slice.call(arguments, 3);\n  try {\n    func.apply(context, funcArgs);\n  } catch (error) {\n    ReactErrorUtils._caughtError = error;\n    ReactErrorUtils._hasCaughtError = true;\n  }\n};\n\n{\n  // In DEV mode, we swap out invokeGuardedCallback for a special version\n  // that plays more nicely with the browser's DevTools. The idea is to preserve\n  // \"Pause on exceptions\" behavior. Because React wraps all user-provided\n  // functions in invokeGuardedCallback, and the production version of\n  // invokeGuardedCallback uses a try-catch, all user exceptions are treated\n  // like caught exceptions, and the DevTools won't pause unless the developer\n  // takes the extra step of enabling pause on caught exceptions. This is\n  // untintuitive, though, because even though React has caught the error, from\n  // the developer's perspective, the error is uncaught.\n  //\n  // To preserve the expected \"Pause on exceptions\" behavior, we don't use a\n  // try-catch in DEV. Instead, we synchronously dispatch a fake event to a fake\n  // DOM node, and call the user-provided callback from inside an event handler\n  // for that fake event. If the callback throws, the error is \"captured\" using\n  // a global event handler. But because the error happens in a different\n  // event loop context, it does not interrupt the normal program flow.\n  // Effectively, this gives us try-catch behavior without actually using\n  // try-catch. Neat!\n\n  // Check that the browser supports the APIs we need to implement our special\n  // DEV version of invokeGuardedCallback\n  if (typeof window !== 'undefined' && typeof window.dispatchEvent === 'function' && typeof document !== 'undefined' && typeof document.createEvent === 'function') {\n    var fakeNode = document.createElement('react');\n\n    var invokeGuardedCallbackDev = function (name, func, context, a, b, c, d, e, f) {\n      // Keeps track of whether the user-provided callback threw an error. We\n      // set this to true at the beginning, then set it to false right after\n      // calling the function. If the function errors, `didError` will never be\n      // set to false. This strategy works even if the browser is flaky and\n      // fails to call our global error handler, because it doesn't rely on\n      // the error event at all.\n      var didError = true;\n\n      // Create an event handler for our fake event. We will synchronously\n      // dispatch our fake event using `dispatchEvent`. Inside the handler, we\n      // call the user-provided callback.\n      var funcArgs = Array.prototype.slice.call(arguments, 3);\n      function callCallback() {\n        // We immediately remove the callback from event listeners so that\n        // nested `invokeGuardedCallback` calls do not clash. Otherwise, a\n        // nested call would trigger the fake event handlers of any call higher\n        // in the stack.\n        fakeNode.removeEventListener(evtType, callCallback, false);\n        func.apply(context, funcArgs);\n        didError = false;\n      }\n\n      // Create a global error event handler. We use this to capture the value\n      // that was thrown. It's possible that this error handler will fire more\n      // than once; for example, if non-React code also calls `dispatchEvent`\n      // and a handler for that event throws. We should be resilient to most of\n      // those cases. Even if our error event handler fires more than once, the\n      // last error event is always used. If the callback actually does error,\n      // we know that the last error event is the correct one, because it's not\n      // possible for anything else to have happened in between our callback\n      // erroring and the code that follows the `dispatchEvent` call below. If\n      // the callback doesn't error, but the error event was fired, we know to\n      // ignore it because `didError` will be false, as described above.\n      var error = void 0;\n      // Use this to track whether the error event is ever called.\n      var didSetError = false;\n      var isCrossOriginError = false;\n\n      function onError(event) {\n        error = event.error;\n        didSetError = true;\n        if (error === null && event.colno === 0 && event.lineno === 0) {\n          isCrossOriginError = true;\n        }\n      }\n\n      // Create a fake event type.\n      var evtType = 'react-' + (name ? name : 'invokeguardedcallback');\n\n      // Attach our event handlers\n      window.addEventListener('error', onError);\n      fakeNode.addEventListener(evtType, callCallback, false);\n\n      // Synchronously dispatch our fake event. If the user-provided function\n      // errors, it will trigger our global error handler.\n      var evt = document.createEvent('Event');\n      evt.initEvent(evtType, false, false);\n      fakeNode.dispatchEvent(evt);\n\n      if (didError) {\n        if (!didSetError) {\n          // The callback errored, but the error event never fired.\n          error = new Error('An error was thrown inside one of your components, but React ' + \"doesn't know what it was. This is likely due to browser \" + 'flakiness. React does its best to preserve the \"Pause on ' + 'exceptions\" behavior of the DevTools, which requires some ' + \"DEV-mode only tricks. It's possible that these don't work in \" + 'your browser. Try triggering the error in production mode, ' + 'or switching to a modern browser. If you suspect that this is ' + 'actually an issue with React, please file an issue.');\n        } else if (isCrossOriginError) {\n          error = new Error(\"A cross-origin error was thrown. React doesn't have access to \" + 'the actual error object in development. ' + 'See https://fb.me/react-crossorigin-error for more information.');\n        }\n        ReactErrorUtils._hasCaughtError = true;\n        ReactErrorUtils._caughtError = error;\n      } else {\n        ReactErrorUtils._hasCaughtError = false;\n        ReactErrorUtils._caughtError = null;\n      }\n\n      // Remove our event listeners\n      window.removeEventListener('error', onError);\n    };\n\n    invokeGuardedCallback$1 = invokeGuardedCallbackDev;\n  }\n}\n\nvar rethrowCaughtError = function () {\n  if (ReactErrorUtils._hasRethrowError) {\n    var error = ReactErrorUtils._rethrowError;\n    ReactErrorUtils._rethrowError = null;\n    ReactErrorUtils._hasRethrowError = false;\n    throw error;\n  }\n};\n\n{\n  var didWarnUpdateInsideUpdate = false;\n}\n\n// Callbacks are not validated until invocation\n\n\n// Singly linked-list of updates. When an update is scheduled, it is added to\n// the queue of the current fiber and the work-in-progress fiber. The two queues\n// are separate but they share a persistent structure.\n//\n// During reconciliation, updates are removed from the work-in-progress fiber,\n// but they remain on the current fiber. That ensures that if a work-in-progress\n// is aborted, the aborted updates are recovered by cloning from current.\n//\n// The work-in-progress queue is always a subset of the current queue.\n//\n// When the tree is committed, the work-in-progress becomes the current.\n\n\nfunction createUpdateQueue(baseState) {\n  var queue = {\n    baseState: baseState,\n    expirationTime: NoWork,\n    first: null,\n    last: null,\n    callbackList: null,\n    hasForceUpdate: false,\n    isInitialized: false\n  };\n  {\n    queue.isProcessing = false;\n  }\n  return queue;\n}\n\nfunction insertUpdateIntoQueue(queue, update) {\n  // Append the update to the end of the list.\n  if (queue.last === null) {\n    // Queue is empty\n    queue.first = queue.last = update;\n  } else {\n    queue.last.next = update;\n    queue.last = update;\n  }\n  if (queue.expirationTime === NoWork || queue.expirationTime > update.expirationTime) {\n    queue.expirationTime = update.expirationTime;\n  }\n}\n\nfunction insertUpdateIntoFiber(fiber, update) {\n  // We'll have at least one and at most two distinct update queues.\n  var alternateFiber = fiber.alternate;\n  var queue1 = fiber.updateQueue;\n  if (queue1 === null) {\n    // TODO: We don't know what the base state will be until we begin work.\n    // It depends on which fiber is the next current. Initialize with an empty\n    // base state, then set to the memoizedState when rendering. Not super\n    // happy with this approach.\n    queue1 = fiber.updateQueue = createUpdateQueue(null);\n  }\n\n  var queue2 = void 0;\n  if (alternateFiber !== null) {\n    queue2 = alternateFiber.updateQueue;\n    if (queue2 === null) {\n      queue2 = alternateFiber.updateQueue = createUpdateQueue(null);\n    }\n  } else {\n    queue2 = null;\n  }\n  queue2 = queue2 !== queue1 ? queue2 : null;\n\n  // Warn if an update is scheduled from inside an updater function.\n  {\n    if ((queue1.isProcessing || queue2 !== null && queue2.isProcessing) && !didWarnUpdateInsideUpdate) {\n      warning(false, 'An update (setState, replaceState, or forceUpdate) was scheduled ' + 'from inside an update function. Update functions should be pure, ' + 'with zero side-effects. Consider using componentDidUpdate or a ' + 'callback.');\n      didWarnUpdateInsideUpdate = true;\n    }\n  }\n\n  // If there's only one queue, add the update to that queue and exit.\n  if (queue2 === null) {\n    insertUpdateIntoQueue(queue1, update);\n    return;\n  }\n\n  // If either queue is empty, we need to add to both queues.\n  if (queue1.last === null || queue2.last === null) {\n    insertUpdateIntoQueue(queue1, update);\n    insertUpdateIntoQueue(queue2, update);\n    return;\n  }\n\n  // If both lists are not empty, the last update is the same for both lists\n  // because of structural sharing. So, we should only append to one of\n  // the lists.\n  insertUpdateIntoQueue(queue1, update);\n  // But we still need to update the `last` pointer of queue2.\n  queue2.last = update;\n}\n\nfunction getUpdateExpirationTime(fiber) {\n  if (fiber.tag !== ClassComponent && fiber.tag !== HostRoot) {\n    return NoWork;\n  }\n  var updateQueue = fiber.updateQueue;\n  if (updateQueue === null) {\n    return NoWork;\n  }\n  return updateQueue.expirationTime;\n}\n\nfunction getStateFromUpdate(update, instance, prevState, props) {\n  var partialState = update.partialState;\n  if (typeof partialState === 'function') {\n    var updateFn = partialState;\n\n    // Invoke setState callback an extra time to help detect side-effects.\n    if (debugRenderPhaseSideEffects) {\n      updateFn.call(instance, prevState, props);\n    }\n\n    return updateFn.call(instance, prevState, props);\n  } else {\n    return partialState;\n  }\n}\n\nfunction processUpdateQueue(current, workInProgress, queue, instance, props, renderExpirationTime) {\n  if (current !== null && current.updateQueue === queue) {\n    // We need to create a work-in-progress queue, by cloning the current queue.\n    var currentQueue = queue;\n    queue = workInProgress.updateQueue = {\n      baseState: currentQueue.baseState,\n      expirationTime: currentQueue.expirationTime,\n      first: currentQueue.first,\n      last: currentQueue.last,\n      isInitialized: currentQueue.isInitialized,\n      // These fields are no longer valid because they were already committed.\n      // Reset them.\n      callbackList: null,\n      hasForceUpdate: false\n    };\n  }\n\n  {\n    // Set this flag so we can warn if setState is called inside the update\n    // function of another setState.\n    queue.isProcessing = true;\n  }\n\n  // Reset the remaining expiration time. If we skip over any updates, we'll\n  // increase this accordingly.\n  queue.expirationTime = NoWork;\n\n  // TODO: We don't know what the base state will be until we begin work.\n  // It depends on which fiber is the next current. Initialize with an empty\n  // base state, then set to the memoizedState when rendering. Not super\n  // happy with this approach.\n  var state = void 0;\n  if (queue.isInitialized) {\n    state = queue.baseState;\n  } else {\n    state = queue.baseState = workInProgress.memoizedState;\n    queue.isInitialized = true;\n  }\n  var dontMutatePrevState = true;\n  var update = queue.first;\n  var didSkip = false;\n  while (update !== null) {\n    var updateExpirationTime = update.expirationTime;\n    if (updateExpirationTime > renderExpirationTime) {\n      // This update does not have sufficient priority. Skip it.\n      var remainingExpirationTime = queue.expirationTime;\n      if (remainingExpirationTime === NoWork || remainingExpirationTime > updateExpirationTime) {\n        // Update the remaining expiration time.\n        queue.expirationTime = updateExpirationTime;\n      }\n      if (!didSkip) {\n        didSkip = true;\n        queue.baseState = state;\n      }\n      // Continue to the next update.\n      update = update.next;\n      continue;\n    }\n\n    // This update does have sufficient priority.\n\n    // If no previous updates were skipped, drop this update from the queue by\n    // advancing the head of the list.\n    if (!didSkip) {\n      queue.first = update.next;\n      if (queue.first === null) {\n        queue.last = null;\n      }\n    }\n\n    // Process the update\n    var _partialState = void 0;\n    if (update.isReplace) {\n      state = getStateFromUpdate(update, instance, state, props);\n      dontMutatePrevState = true;\n    } else {\n      _partialState = getStateFromUpdate(update, instance, state, props);\n      if (_partialState) {\n        if (dontMutatePrevState) {\n          // $FlowFixMe: Idk how to type this properly.\n          state = _assign({}, state, _partialState);\n        } else {\n          state = _assign(state, _partialState);\n        }\n        dontMutatePrevState = false;\n      }\n    }\n    if (update.isForced) {\n      queue.hasForceUpdate = true;\n    }\n    if (update.callback !== null) {\n      // Append to list of callbacks.\n      var _callbackList = queue.callbackList;\n      if (_callbackList === null) {\n        _callbackList = queue.callbackList = [];\n      }\n      _callbackList.push(update);\n    }\n    update = update.next;\n  }\n\n  if (queue.callbackList !== null) {\n    workInProgress.effectTag |= Callback;\n  } else if (queue.first === null && !queue.hasForceUpdate) {\n    // The queue is empty. We can reset it.\n    workInProgress.updateQueue = null;\n  }\n\n  if (!didSkip) {\n    didSkip = true;\n    queue.baseState = state;\n  }\n\n  {\n    // No longer processing.\n    queue.isProcessing = false;\n  }\n\n  return state;\n}\n\nfunction commitCallbacks(queue, context) {\n  var callbackList = queue.callbackList;\n  if (callbackList === null) {\n    return;\n  }\n  // Set the list to null to make sure they don't get called more than once.\n  queue.callbackList = null;\n  for (var i = 0; i < callbackList.length; i++) {\n    var update = callbackList[i];\n    var _callback = update.callback;\n    // This update might be processed again. Clear the callback so it's only\n    // called once.\n    update.callback = null;\n    !(typeof _callback === 'function') ? invariant(false, 'Invalid argument passed as callback. Expected a function. Instead received: %s', _callback) : void 0;\n    _callback.call(context);\n  }\n}\n\nvar fakeInternalInstance = {};\nvar isArray = Array.isArray;\n\n{\n  var didWarnAboutStateAssignmentForComponent = {};\n\n  var warnOnInvalidCallback = function (callback, callerName) {\n    warning(callback === null || typeof callback === 'function', '%s(...): Expected the last optional `callback` argument to be a ' + 'function. Instead received: %s.', callerName, callback);\n  };\n\n  // This is so gross but it's at least non-critical and can be removed if\n  // it causes problems. This is meant to give a nicer error message for\n  // ReactDOM15.unstable_renderSubtreeIntoContainer(reactDOM16Component,\n  // ...)) which otherwise throws a \"_processChildContext is not a function\"\n  // exception.\n  Object.defineProperty(fakeInternalInstance, '_processChildContext', {\n    enumerable: false,\n    value: function () {\n      invariant(false, '_processChildContext is not available in React 16+. This likely means you have multiple copies of React and are attempting to nest a React 15 tree inside a React 16 tree using unstable_renderSubtreeIntoContainer, which isn\\'t supported. Try to make sure you have only one copy of React (and ideally, switch to ReactDOM.createPortal).');\n    }\n  });\n  Object.freeze(fakeInternalInstance);\n}\n\nvar ReactFiberClassComponent = function (scheduleWork, computeExpirationForFiber, memoizeProps, memoizeState) {\n  // Class component state updater\n  var updater = {\n    isMounted: isMounted,\n    enqueueSetState: function (instance, partialState, callback) {\n      var fiber = get(instance);\n      callback = callback === undefined ? null : callback;\n      {\n        warnOnInvalidCallback(callback, 'setState');\n      }\n      var expirationTime = computeExpirationForFiber(fiber);\n      var update = {\n        expirationTime: expirationTime,\n        partialState: partialState,\n        callback: callback,\n        isReplace: false,\n        isForced: false,\n        nextCallback: null,\n        next: null\n      };\n      insertUpdateIntoFiber(fiber, update);\n      scheduleWork(fiber, expirationTime);\n    },\n    enqueueReplaceState: function (instance, state, callback) {\n      var fiber = get(instance);\n      callback = callback === undefined ? null : callback;\n      {\n        warnOnInvalidCallback(callback, 'replaceState');\n      }\n      var expirationTime = computeExpirationForFiber(fiber);\n      var update = {\n        expirationTime: expirationTime,\n        partialState: state,\n        callback: callback,\n        isReplace: true,\n        isForced: false,\n        nextCallback: null,\n        next: null\n      };\n      insertUpdateIntoFiber(fiber, update);\n      scheduleWork(fiber, expirationTime);\n    },\n    enqueueForceUpdate: function (instance, callback) {\n      var fiber = get(instance);\n      callback = callback === undefined ? null : callback;\n      {\n        warnOnInvalidCallback(callback, 'forceUpdate');\n      }\n      var expirationTime = computeExpirationForFiber(fiber);\n      var update = {\n        expirationTime: expirationTime,\n        partialState: null,\n        callback: callback,\n        isReplace: false,\n        isForced: true,\n        nextCallback: null,\n        next: null\n      };\n      insertUpdateIntoFiber(fiber, update);\n      scheduleWork(fiber, expirationTime);\n    }\n  };\n\n  function checkShouldComponentUpdate(workInProgress, oldProps, newProps, oldState, newState, newContext) {\n    if (oldProps === null || workInProgress.updateQueue !== null && workInProgress.updateQueue.hasForceUpdate) {\n      // If the workInProgress already has an Update effect, return true\n      return true;\n    }\n\n    var instance = workInProgress.stateNode;\n    var type = workInProgress.type;\n    if (typeof instance.shouldComponentUpdate === 'function') {\n      startPhaseTimer(workInProgress, 'shouldComponentUpdate');\n      var shouldUpdate = instance.shouldComponentUpdate(newProps, newState, newContext);\n      stopPhaseTimer();\n\n      // Simulate an async bailout/interruption by invoking lifecycle twice.\n      if (debugRenderPhaseSideEffects) {\n        instance.shouldComponentUpdate(newProps, newState, newContext);\n      }\n\n      {\n        warning(shouldUpdate !== undefined, '%s.shouldComponentUpdate(): Returned undefined instead of a ' + 'boolean value. Make sure to return true or false.', getComponentName(workInProgress) || 'Unknown');\n      }\n\n      return shouldUpdate;\n    }\n\n    if (type.prototype && type.prototype.isPureReactComponent) {\n      return !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState);\n    }\n\n    return true;\n  }\n\n  function checkClassInstance(workInProgress) {\n    var instance = workInProgress.stateNode;\n    var type = workInProgress.type;\n    {\n      var name = getComponentName(workInProgress);\n      var renderPresent = instance.render;\n\n      if (!renderPresent) {\n        if (type.prototype && typeof type.prototype.render === 'function') {\n          warning(false, '%s(...): No `render` method found on the returned component ' + 'instance: did you accidentally return an object from the constructor?', name);\n        } else {\n          warning(false, '%s(...): No `render` method found on the returned component ' + 'instance: you may have forgotten to define `render`.', name);\n        }\n      }\n\n      var noGetInitialStateOnES6 = !instance.getInitialState || instance.getInitialState.isReactClassApproved || instance.state;\n      warning(noGetInitialStateOnES6, 'getInitialState was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Did you mean to define a state property instead?', name);\n      var noGetDefaultPropsOnES6 = !instance.getDefaultProps || instance.getDefaultProps.isReactClassApproved;\n      warning(noGetDefaultPropsOnES6, 'getDefaultProps was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Use a static property to define defaultProps instead.', name);\n      var noInstancePropTypes = !instance.propTypes;\n      warning(noInstancePropTypes, 'propTypes was defined as an instance property on %s. Use a static ' + 'property to define propTypes instead.', name);\n      var noInstanceContextTypes = !instance.contextTypes;\n      warning(noInstanceContextTypes, 'contextTypes was defined as an instance property on %s. Use a static ' + 'property to define contextTypes instead.', name);\n      var noComponentShouldUpdate = typeof instance.componentShouldUpdate !== 'function';\n      warning(noComponentShouldUpdate, '%s has a method called ' + 'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' + 'The name is phrased as a question because the function is ' + 'expected to return a value.', name);\n      if (type.prototype && type.prototype.isPureReactComponent && typeof instance.shouldComponentUpdate !== 'undefined') {\n        warning(false, '%s has a method called shouldComponentUpdate(). ' + 'shouldComponentUpdate should not be used when extending React.PureComponent. ' + 'Please extend React.Component if shouldComponentUpdate is used.', getComponentName(workInProgress) || 'A pure component');\n      }\n      var noComponentDidUnmount = typeof instance.componentDidUnmount !== 'function';\n      warning(noComponentDidUnmount, '%s has a method called ' + 'componentDidUnmount(). But there is no such lifecycle method. ' + 'Did you mean componentWillUnmount()?', name);\n      var noComponentDidReceiveProps = typeof instance.componentDidReceiveProps !== 'function';\n      warning(noComponentDidReceiveProps, '%s has a method called ' + 'componentDidReceiveProps(). But there is no such lifecycle method. ' + 'If you meant to update the state in response to changing props, ' + 'use componentWillReceiveProps(). If you meant to fetch data or ' + 'run side-effects or mutations after React has updated the UI, use componentDidUpdate().', name);\n      var noComponentWillRecieveProps = typeof instance.componentWillRecieveProps !== 'function';\n      warning(noComponentWillRecieveProps, '%s has a method called ' + 'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?', name);\n      var hasMutatedProps = instance.props !== workInProgress.pendingProps;\n      warning(instance.props === undefined || !hasMutatedProps, '%s(...): When calling super() in `%s`, make sure to pass ' + \"up the same props that your component's constructor was passed.\", name, name);\n      var noInstanceDefaultProps = !instance.defaultProps;\n      warning(noInstanceDefaultProps, 'Setting defaultProps as an instance property on %s is not supported and will be ignored.' + ' Instead, define defaultProps as a static property on %s.', name, name);\n    }\n\n    var state = instance.state;\n    if (state && (typeof state !== 'object' || isArray(state))) {\n      warning(false, '%s.state: must be set to an object or null', getComponentName(workInProgress));\n    }\n    if (typeof instance.getChildContext === 'function') {\n      warning(typeof workInProgress.type.childContextTypes === 'object', '%s.getChildContext(): childContextTypes must be defined in order to ' + 'use getChildContext().', getComponentName(workInProgress));\n    }\n  }\n\n  function resetInputPointers(workInProgress, instance) {\n    instance.props = workInProgress.memoizedProps;\n    instance.state = workInProgress.memoizedState;\n  }\n\n  function adoptClassInstance(workInProgress, instance) {\n    instance.updater = updater;\n    workInProgress.stateNode = instance;\n    // The instance needs access to the fiber so that it can schedule updates\n    set(instance, workInProgress);\n    {\n      instance._reactInternalInstance = fakeInternalInstance;\n    }\n  }\n\n  function constructClassInstance(workInProgress, props) {\n    var ctor = workInProgress.type;\n    var unmaskedContext = getUnmaskedContext(workInProgress);\n    var needsContext = isContextConsumer(workInProgress);\n    var context = needsContext ? getMaskedContext(workInProgress, unmaskedContext) : emptyObject;\n    var instance = new ctor(props, context);\n    adoptClassInstance(workInProgress, instance);\n\n    // Cache unmasked context so we can avoid recreating masked context unless necessary.\n    // ReactFiberContext usually updates this cache but can't for newly-created instances.\n    if (needsContext) {\n      cacheContext(workInProgress, unmaskedContext, context);\n    }\n\n    return instance;\n  }\n\n  function callComponentWillMount(workInProgress, instance) {\n    startPhaseTimer(workInProgress, 'componentWillMount');\n    var oldState = instance.state;\n    instance.componentWillMount();\n    stopPhaseTimer();\n\n    // Simulate an async bailout/interruption by invoking lifecycle twice.\n    if (debugRenderPhaseSideEffects) {\n      instance.componentWillMount();\n    }\n\n    if (oldState !== instance.state) {\n      {\n        warning(false, '%s.componentWillMount(): Assigning directly to this.state is ' + \"deprecated (except inside a component's \" + 'constructor). Use setState instead.', getComponentName(workInProgress));\n      }\n      updater.enqueueReplaceState(instance, instance.state, null);\n    }\n  }\n\n  function callComponentWillReceiveProps(workInProgress, instance, newProps, newContext) {\n    startPhaseTimer(workInProgress, 'componentWillReceiveProps');\n    var oldState = instance.state;\n    instance.componentWillReceiveProps(newProps, newContext);\n    stopPhaseTimer();\n\n    // Simulate an async bailout/interruption by invoking lifecycle twice.\n    if (debugRenderPhaseSideEffects) {\n      instance.componentWillReceiveProps(newProps, newContext);\n    }\n\n    if (instance.state !== oldState) {\n      {\n        var componentName = getComponentName(workInProgress) || 'Component';\n        if (!didWarnAboutStateAssignmentForComponent[componentName]) {\n          warning(false, '%s.componentWillReceiveProps(): Assigning directly to ' + \"this.state is deprecated (except inside a component's \" + 'constructor). Use setState instead.', componentName);\n          didWarnAboutStateAssignmentForComponent[componentName] = true;\n        }\n      }\n      updater.enqueueReplaceState(instance, instance.state, null);\n    }\n  }\n\n  // Invokes the mount life-cycles on a previously never rendered instance.\n  function mountClassInstance(workInProgress, renderExpirationTime) {\n    var current = workInProgress.alternate;\n\n    {\n      checkClassInstance(workInProgress);\n    }\n\n    var instance = workInProgress.stateNode;\n    var state = instance.state || null;\n\n    var props = workInProgress.pendingProps;\n    !props ? invariant(false, 'There must be pending props for an initial mount. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n\n    var unmaskedContext = getUnmaskedContext(workInProgress);\n\n    instance.props = props;\n    instance.state = workInProgress.memoizedState = state;\n    instance.refs = emptyObject;\n    instance.context = getMaskedContext(workInProgress, unmaskedContext);\n\n    if (enableAsyncSubtreeAPI && workInProgress.type != null && workInProgress.type.prototype != null && workInProgress.type.prototype.unstable_isAsyncReactComponent === true) {\n      workInProgress.internalContextTag |= AsyncUpdates;\n    }\n\n    if (typeof instance.componentWillMount === 'function') {\n      callComponentWillMount(workInProgress, instance);\n      // If we had additional state updates during this life-cycle, let's\n      // process them now.\n      var updateQueue = workInProgress.updateQueue;\n      if (updateQueue !== null) {\n        instance.state = processUpdateQueue(current, workInProgress, updateQueue, instance, props, renderExpirationTime);\n      }\n    }\n    if (typeof instance.componentDidMount === 'function') {\n      workInProgress.effectTag |= Update;\n    }\n  }\n\n  // Called on a preexisting class instance. Returns false if a resumed render\n  // could be reused.\n  // function resumeMountClassInstance(\n  //   workInProgress: Fiber,\n  //   priorityLevel: PriorityLevel,\n  // ): boolean {\n  //   const instance = workInProgress.stateNode;\n  //   resetInputPointers(workInProgress, instance);\n\n  //   let newState = workInProgress.memoizedState;\n  //   let newProps = workInProgress.pendingProps;\n  //   if (!newProps) {\n  //     // If there isn't any new props, then we'll reuse the memoized props.\n  //     // This could be from already completed work.\n  //     newProps = workInProgress.memoizedProps;\n  //     invariant(\n  //       newProps != null,\n  //       'There should always be pending or memoized props. This error is ' +\n  //         'likely caused by a bug in React. Please file an issue.',\n  //     );\n  //   }\n  //   const newUnmaskedContext = getUnmaskedContext(workInProgress);\n  //   const newContext = getMaskedContext(workInProgress, newUnmaskedContext);\n\n  //   const oldContext = instance.context;\n  //   const oldProps = workInProgress.memoizedProps;\n\n  //   if (\n  //     typeof instance.componentWillReceiveProps === 'function' &&\n  //     (oldProps !== newProps || oldContext !== newContext)\n  //   ) {\n  //     callComponentWillReceiveProps(\n  //       workInProgress,\n  //       instance,\n  //       newProps,\n  //       newContext,\n  //     );\n  //   }\n\n  //   // Process the update queue before calling shouldComponentUpdate\n  //   const updateQueue = workInProgress.updateQueue;\n  //   if (updateQueue !== null) {\n  //     newState = processUpdateQueue(\n  //       workInProgress,\n  //       updateQueue,\n  //       instance,\n  //       newState,\n  //       newProps,\n  //       priorityLevel,\n  //     );\n  //   }\n\n  //   // TODO: Should we deal with a setState that happened after the last\n  //   // componentWillMount and before this componentWillMount? Probably\n  //   // unsupported anyway.\n\n  //   if (\n  //     !checkShouldComponentUpdate(\n  //       workInProgress,\n  //       workInProgress.memoizedProps,\n  //       newProps,\n  //       workInProgress.memoizedState,\n  //       newState,\n  //       newContext,\n  //     )\n  //   ) {\n  //     // Update the existing instance's state, props, and context pointers even\n  //     // though we're bailing out.\n  //     instance.props = newProps;\n  //     instance.state = newState;\n  //     instance.context = newContext;\n  //     return false;\n  //   }\n\n  //   // Update the input pointers now so that they are correct when we call\n  //   // componentWillMount\n  //   instance.props = newProps;\n  //   instance.state = newState;\n  //   instance.context = newContext;\n\n  //   if (typeof instance.componentWillMount === 'function') {\n  //     callComponentWillMount(workInProgress, instance);\n  //     // componentWillMount may have called setState. Process the update queue.\n  //     const newUpdateQueue = workInProgress.updateQueue;\n  //     if (newUpdateQueue !== null) {\n  //       newState = processUpdateQueue(\n  //         workInProgress,\n  //         newUpdateQueue,\n  //         instance,\n  //         newState,\n  //         newProps,\n  //         priorityLevel,\n  //       );\n  //     }\n  //   }\n\n  //   if (typeof instance.componentDidMount === 'function') {\n  //     workInProgress.effectTag |= Update;\n  //   }\n\n  //   instance.state = newState;\n\n  //   return true;\n  // }\n\n  // Invokes the update life-cycles and returns false if it shouldn't rerender.\n  function updateClassInstance(current, workInProgress, renderExpirationTime) {\n    var instance = workInProgress.stateNode;\n    resetInputPointers(workInProgress, instance);\n\n    var oldProps = workInProgress.memoizedProps;\n    var newProps = workInProgress.pendingProps;\n    if (!newProps) {\n      // If there aren't any new props, then we'll reuse the memoized props.\n      // This could be from already completed work.\n      newProps = oldProps;\n      !(newProps != null) ? invariant(false, 'There should always be pending or memoized props. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n    }\n    var oldContext = instance.context;\n    var newUnmaskedContext = getUnmaskedContext(workInProgress);\n    var newContext = getMaskedContext(workInProgress, newUnmaskedContext);\n\n    // Note: During these life-cycles, instance.props/instance.state are what\n    // ever the previously attempted to render - not the \"current\". However,\n    // during componentDidUpdate we pass the \"current\" props.\n\n    if (typeof instance.componentWillReceiveProps === 'function' && (oldProps !== newProps || oldContext !== newContext)) {\n      callComponentWillReceiveProps(workInProgress, instance, newProps, newContext);\n    }\n\n    // Compute the next state using the memoized state and the update queue.\n    var oldState = workInProgress.memoizedState;\n    // TODO: Previous state can be null.\n    var newState = void 0;\n    if (workInProgress.updateQueue !== null) {\n      newState = processUpdateQueue(current, workInProgress, workInProgress.updateQueue, instance, newProps, renderExpirationTime);\n    } else {\n      newState = oldState;\n    }\n\n    if (oldProps === newProps && oldState === newState && !hasContextChanged() && !(workInProgress.updateQueue !== null && workInProgress.updateQueue.hasForceUpdate)) {\n      // If an update was already in progress, we should schedule an Update\n      // effect even though we're bailing out, so that cWU/cDU are called.\n      if (typeof instance.componentDidUpdate === 'function') {\n        if (oldProps !== current.memoizedProps || oldState !== current.memoizedState) {\n          workInProgress.effectTag |= Update;\n        }\n      }\n      return false;\n    }\n\n    var shouldUpdate = checkShouldComponentUpdate(workInProgress, oldProps, newProps, oldState, newState, newContext);\n\n    if (shouldUpdate) {\n      if (typeof instance.componentWillUpdate === 'function') {\n        startPhaseTimer(workInProgress, 'componentWillUpdate');\n        instance.componentWillUpdate(newProps, newState, newContext);\n        stopPhaseTimer();\n\n        // Simulate an async bailout/interruption by invoking lifecycle twice.\n        if (debugRenderPhaseSideEffects) {\n          instance.componentWillUpdate(newProps, newState, newContext);\n        }\n      }\n      if (typeof instance.componentDidUpdate === 'function') {\n        workInProgress.effectTag |= Update;\n      }\n    } else {\n      // If an update was already in progress, we should schedule an Update\n      // effect even though we're bailing out, so that cWU/cDU are called.\n      if (typeof instance.componentDidUpdate === 'function') {\n        if (oldProps !== current.memoizedProps || oldState !== current.memoizedState) {\n          workInProgress.effectTag |= Update;\n        }\n      }\n\n      // If shouldComponentUpdate returned false, we should still update the\n      // memoized props/state to indicate that this work can be reused.\n      memoizeProps(workInProgress, newProps);\n      memoizeState(workInProgress, newState);\n    }\n\n    // Update the existing instance's state, props, and context pointers even\n    // if shouldComponentUpdate returns false.\n    instance.props = newProps;\n    instance.state = newState;\n    instance.context = newContext;\n\n    return shouldUpdate;\n  }\n\n  return {\n    adoptClassInstance: adoptClassInstance,\n    constructClassInstance: constructClassInstance,\n    mountClassInstance: mountClassInstance,\n    // resumeMountClassInstance,\n    updateClassInstance: updateClassInstance\n  };\n};\n\n// The Symbol used to tag the ReactElement-like types. If there is no native Symbol\n// nor polyfill, then a plain number is used for performance.\nvar hasSymbol = typeof Symbol === 'function' && Symbol['for'];\n\nvar REACT_ELEMENT_TYPE = hasSymbol ? Symbol['for']('react.element') : 0xeac7;\nvar REACT_CALL_TYPE = hasSymbol ? Symbol['for']('react.call') : 0xeac8;\nvar REACT_RETURN_TYPE = hasSymbol ? Symbol['for']('react.return') : 0xeac9;\nvar REACT_PORTAL_TYPE = hasSymbol ? Symbol['for']('react.portal') : 0xeaca;\nvar REACT_FRAGMENT_TYPE = hasSymbol ? Symbol['for']('react.fragment') : 0xeacb;\n\nvar MAYBE_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;\nvar FAUX_ITERATOR_SYMBOL = '@@iterator';\n\nfunction getIteratorFn(maybeIterable) {\n  if (maybeIterable === null || typeof maybeIterable === 'undefined') {\n    return null;\n  }\n  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n  if (typeof maybeIterator === 'function') {\n    return maybeIterator;\n  }\n  return null;\n}\n\nvar getCurrentFiberStackAddendum$1 = ReactDebugCurrentFiber.getCurrentFiberStackAddendum;\n\n\n{\n  var didWarnAboutMaps = false;\n  /**\n   * Warn if there's no key explicitly set on dynamic arrays of children or\n   * object keys are not valid. This allows us to keep track of children between\n   * updates.\n   */\n  var ownerHasKeyUseWarning = {};\n  var ownerHasFunctionTypeWarning = {};\n\n  var warnForMissingKey = function (child) {\n    if (child === null || typeof child !== 'object') {\n      return;\n    }\n    if (!child._store || child._store.validated || child.key != null) {\n      return;\n    }\n    !(typeof child._store === 'object') ? invariant(false, 'React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n    child._store.validated = true;\n\n    var currentComponentErrorInfo = 'Each child in an array or iterator should have a unique ' + '\"key\" prop. See https://fb.me/react-warning-keys for ' + 'more information.' + (getCurrentFiberStackAddendum$1() || '');\n    if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n      return;\n    }\n    ownerHasKeyUseWarning[currentComponentErrorInfo] = true;\n\n    warning(false, 'Each child in an array or iterator should have a unique ' + '\"key\" prop. See https://fb.me/react-warning-keys for ' + 'more information.%s', getCurrentFiberStackAddendum$1());\n  };\n}\n\nvar isArray$1 = Array.isArray;\n\nfunction coerceRef(current, element) {\n  var mixedRef = element.ref;\n  if (mixedRef !== null && typeof mixedRef !== 'function') {\n    if (element._owner) {\n      var owner = element._owner;\n      var inst = void 0;\n      if (owner) {\n        var ownerFiber = owner;\n        !(ownerFiber.tag === ClassComponent) ? invariant(false, 'Stateless function components cannot have refs.') : void 0;\n        inst = ownerFiber.stateNode;\n      }\n      !inst ? invariant(false, 'Missing owner for string ref %s. This error is likely caused by a bug in React. Please file an issue.', mixedRef) : void 0;\n      var stringRef = '' + mixedRef;\n      // Check if previous string ref matches new string ref\n      if (current !== null && current.ref !== null && current.ref._stringRef === stringRef) {\n        return current.ref;\n      }\n      var ref = function (value) {\n        var refs = inst.refs === emptyObject ? inst.refs = {} : inst.refs;\n        if (value === null) {\n          delete refs[stringRef];\n        } else {\n          refs[stringRef] = value;\n        }\n      };\n      ref._stringRef = stringRef;\n      return ref;\n    } else {\n      !(typeof mixedRef === 'string') ? invariant(false, 'Expected ref to be a function or a string.') : void 0;\n      !element._owner ? invariant(false, 'Element ref was specified as a string (%s) but no owner was set. You may have multiple copies of React loaded. (details: https://fb.me/react-refs-must-have-owner).', mixedRef) : void 0;\n    }\n  }\n  return mixedRef;\n}\n\nfunction throwOnInvalidObjectType(returnFiber, newChild) {\n  if (returnFiber.type !== 'textarea') {\n    var addendum = '';\n    {\n      addendum = ' If you meant to render a collection of children, use an array ' + 'instead.' + (getCurrentFiberStackAddendum$1() || '');\n    }\n    invariant(false, 'Objects are not valid as a React child (found: %s).%s', Object.prototype.toString.call(newChild) === '[object Object]' ? 'object with keys {' + Object.keys(newChild).join(', ') + '}' : newChild, addendum);\n  }\n}\n\nfunction warnOnFunctionType() {\n  var currentComponentErrorInfo = 'Functions are not valid as a React child. This may happen if ' + 'you return a Component instead of <Component /> from render. ' + 'Or maybe you meant to call this function rather than return it.' + (getCurrentFiberStackAddendum$1() || '');\n\n  if (ownerHasFunctionTypeWarning[currentComponentErrorInfo]) {\n    return;\n  }\n  ownerHasFunctionTypeWarning[currentComponentErrorInfo] = true;\n\n  warning(false, 'Functions are not valid as a React child. This may happen if ' + 'you return a Component instead of <Component /> from render. ' + 'Or maybe you meant to call this function rather than return it.%s', getCurrentFiberStackAddendum$1() || '');\n}\n\n// This wrapper function exists because I expect to clone the code in each path\n// to be able to optimize each path individually by branching early. This needs\n// a compiler or we can do it manually. Helpers that don't need this branching\n// live outside of this function.\nfunction ChildReconciler(shouldTrackSideEffects) {\n  function deleteChild(returnFiber, childToDelete) {\n    if (!shouldTrackSideEffects) {\n      // Noop.\n      return;\n    }\n    // Deletions are added in reversed order so we add it to the front.\n    // At this point, the return fiber's effect list is empty except for\n    // deletions, so we can just append the deletion to the list. The remaining\n    // effects aren't added until the complete phase. Once we implement\n    // resuming, this may not be true.\n    var last = returnFiber.lastEffect;\n    if (last !== null) {\n      last.nextEffect = childToDelete;\n      returnFiber.lastEffect = childToDelete;\n    } else {\n      returnFiber.firstEffect = returnFiber.lastEffect = childToDelete;\n    }\n    childToDelete.nextEffect = null;\n    childToDelete.effectTag = Deletion;\n  }\n\n  function deleteRemainingChildren(returnFiber, currentFirstChild) {\n    if (!shouldTrackSideEffects) {\n      // Noop.\n      return null;\n    }\n\n    // TODO: For the shouldClone case, this could be micro-optimized a bit by\n    // assuming that after the first child we've already added everything.\n    var childToDelete = currentFirstChild;\n    while (childToDelete !== null) {\n      deleteChild(returnFiber, childToDelete);\n      childToDelete = childToDelete.sibling;\n    }\n    return null;\n  }\n\n  function mapRemainingChildren(returnFiber, currentFirstChild) {\n    // Add the remaining children to a temporary map so that we can find them by\n    // keys quickly. Implicit (null) keys get added to this set with their index\n    var existingChildren = new Map();\n\n    var existingChild = currentFirstChild;\n    while (existingChild !== null) {\n      if (existingChild.key !== null) {\n        existingChildren.set(existingChild.key, existingChild);\n      } else {\n        existingChildren.set(existingChild.index, existingChild);\n      }\n      existingChild = existingChild.sibling;\n    }\n    return existingChildren;\n  }\n\n  function useFiber(fiber, pendingProps, expirationTime) {\n    // We currently set sibling to null and index to 0 here because it is easy\n    // to forget to do before returning it. E.g. for the single child case.\n    var clone = createWorkInProgress(fiber, pendingProps, expirationTime);\n    clone.index = 0;\n    clone.sibling = null;\n    return clone;\n  }\n\n  function placeChild(newFiber, lastPlacedIndex, newIndex) {\n    newFiber.index = newIndex;\n    if (!shouldTrackSideEffects) {\n      // Noop.\n      return lastPlacedIndex;\n    }\n    var current = newFiber.alternate;\n    if (current !== null) {\n      var oldIndex = current.index;\n      if (oldIndex < lastPlacedIndex) {\n        // This is a move.\n        newFiber.effectTag = Placement;\n        return lastPlacedIndex;\n      } else {\n        // This item can stay in place.\n        return oldIndex;\n      }\n    } else {\n      // This is an insertion.\n      newFiber.effectTag = Placement;\n      return lastPlacedIndex;\n    }\n  }\n\n  function placeSingleChild(newFiber) {\n    // This is simpler for the single child case. We only need to do a\n    // placement for inserting new children.\n    if (shouldTrackSideEffects && newFiber.alternate === null) {\n      newFiber.effectTag = Placement;\n    }\n    return newFiber;\n  }\n\n  function updateTextNode(returnFiber, current, textContent, expirationTime) {\n    if (current === null || current.tag !== HostText) {\n      // Insert\n      var created = createFiberFromText(textContent, returnFiber.internalContextTag, expirationTime);\n      created['return'] = returnFiber;\n      return created;\n    } else {\n      // Update\n      var existing = useFiber(current, textContent, expirationTime);\n      existing['return'] = returnFiber;\n      return existing;\n    }\n  }\n\n  function updateElement(returnFiber, current, element, expirationTime) {\n    if (current !== null && current.type === element.type) {\n      // Move based on index\n      var existing = useFiber(current, element.props, expirationTime);\n      existing.ref = coerceRef(current, element);\n      existing['return'] = returnFiber;\n      {\n        existing._debugSource = element._source;\n        existing._debugOwner = element._owner;\n      }\n      return existing;\n    } else {\n      // Insert\n      var created = createFiberFromElement(element, returnFiber.internalContextTag, expirationTime);\n      created.ref = coerceRef(current, element);\n      created['return'] = returnFiber;\n      return created;\n    }\n  }\n\n  function updateCall(returnFiber, current, call, expirationTime) {\n    // TODO: Should this also compare handler to determine whether to reuse?\n    if (current === null || current.tag !== CallComponent) {\n      // Insert\n      var created = createFiberFromCall(call, returnFiber.internalContextTag, expirationTime);\n      created['return'] = returnFiber;\n      return created;\n    } else {\n      // Move based on index\n      var existing = useFiber(current, call, expirationTime);\n      existing['return'] = returnFiber;\n      return existing;\n    }\n  }\n\n  function updateReturn(returnFiber, current, returnNode, expirationTime) {\n    if (current === null || current.tag !== ReturnComponent) {\n      // Insert\n      var created = createFiberFromReturn(returnNode, returnFiber.internalContextTag, expirationTime);\n      created.type = returnNode.value;\n      created['return'] = returnFiber;\n      return created;\n    } else {\n      // Move based on index\n      var existing = useFiber(current, null, expirationTime);\n      existing.type = returnNode.value;\n      existing['return'] = returnFiber;\n      return existing;\n    }\n  }\n\n  function updatePortal(returnFiber, current, portal, expirationTime) {\n    if (current === null || current.tag !== HostPortal || current.stateNode.containerInfo !== portal.containerInfo || current.stateNode.implementation !== portal.implementation) {\n      // Insert\n      var created = createFiberFromPortal(portal, returnFiber.internalContextTag, expirationTime);\n      created['return'] = returnFiber;\n      return created;\n    } else {\n      // Update\n      var existing = useFiber(current, portal.children || [], expirationTime);\n      existing['return'] = returnFiber;\n      return existing;\n    }\n  }\n\n  function updateFragment(returnFiber, current, fragment, expirationTime, key) {\n    if (current === null || current.tag !== Fragment) {\n      // Insert\n      var created = createFiberFromFragment(fragment, returnFiber.internalContextTag, expirationTime, key);\n      created['return'] = returnFiber;\n      return created;\n    } else {\n      // Update\n      var existing = useFiber(current, fragment, expirationTime);\n      existing['return'] = returnFiber;\n      return existing;\n    }\n  }\n\n  function createChild(returnFiber, newChild, expirationTime) {\n    if (typeof newChild === 'string' || typeof newChild === 'number') {\n      // Text nodes don't have keys. If the previous node is implicitly keyed\n      // we can continue to replace it without aborting even if it is not a text\n      // node.\n      var created = createFiberFromText('' + newChild, returnFiber.internalContextTag, expirationTime);\n      created['return'] = returnFiber;\n      return created;\n    }\n\n    if (typeof newChild === 'object' && newChild !== null) {\n      switch (newChild.$$typeof) {\n        case REACT_ELEMENT_TYPE:\n          {\n            if (newChild.type === REACT_FRAGMENT_TYPE) {\n              var _created = createFiberFromFragment(newChild.props.children, returnFiber.internalContextTag, expirationTime, newChild.key);\n              _created['return'] = returnFiber;\n              return _created;\n            } else {\n              var _created2 = createFiberFromElement(newChild, returnFiber.internalContextTag, expirationTime);\n              _created2.ref = coerceRef(null, newChild);\n              _created2['return'] = returnFiber;\n              return _created2;\n            }\n          }\n\n        case REACT_CALL_TYPE:\n          {\n            var _created3 = createFiberFromCall(newChild, returnFiber.internalContextTag, expirationTime);\n            _created3['return'] = returnFiber;\n            return _created3;\n          }\n\n        case REACT_RETURN_TYPE:\n          {\n            var _created4 = createFiberFromReturn(newChild, returnFiber.internalContextTag, expirationTime);\n            _created4.type = newChild.value;\n            _created4['return'] = returnFiber;\n            return _created4;\n          }\n\n        case REACT_PORTAL_TYPE:\n          {\n            var _created5 = createFiberFromPortal(newChild, returnFiber.internalContextTag, expirationTime);\n            _created5['return'] = returnFiber;\n            return _created5;\n          }\n      }\n\n      if (isArray$1(newChild) || getIteratorFn(newChild)) {\n        var _created6 = createFiberFromFragment(newChild, returnFiber.internalContextTag, expirationTime, null);\n        _created6['return'] = returnFiber;\n        return _created6;\n      }\n\n      throwOnInvalidObjectType(returnFiber, newChild);\n    }\n\n    {\n      if (typeof newChild === 'function') {\n        warnOnFunctionType();\n      }\n    }\n\n    return null;\n  }\n\n  function updateSlot(returnFiber, oldFiber, newChild, expirationTime) {\n    // Update the fiber if the keys match, otherwise return null.\n\n    var key = oldFiber !== null ? oldFiber.key : null;\n\n    if (typeof newChild === 'string' || typeof newChild === 'number') {\n      // Text nodes don't have keys. If the previous node is implicitly keyed\n      // we can continue to replace it without aborting even if it is not a text\n      // node.\n      if (key !== null) {\n        return null;\n      }\n      return updateTextNode(returnFiber, oldFiber, '' + newChild, expirationTime);\n    }\n\n    if (typeof newChild === 'object' && newChild !== null) {\n      switch (newChild.$$typeof) {\n        case REACT_ELEMENT_TYPE:\n          {\n            if (newChild.key === key) {\n              if (newChild.type === REACT_FRAGMENT_TYPE) {\n                return updateFragment(returnFiber, oldFiber, newChild.props.children, expirationTime, key);\n              }\n              return updateElement(returnFiber, oldFiber, newChild, expirationTime);\n            } else {\n              return null;\n            }\n          }\n\n        case REACT_CALL_TYPE:\n          {\n            if (newChild.key === key) {\n              return updateCall(returnFiber, oldFiber, newChild, expirationTime);\n            } else {\n              return null;\n            }\n          }\n\n        case REACT_RETURN_TYPE:\n          {\n            // Returns don't have keys. If the previous node is implicitly keyed\n            // we can continue to replace it without aborting even if it is not a\n            // yield.\n            if (key === null) {\n              return updateReturn(returnFiber, oldFiber, newChild, expirationTime);\n            } else {\n              return null;\n            }\n          }\n\n        case REACT_PORTAL_TYPE:\n          {\n            if (newChild.key === key) {\n              return updatePortal(returnFiber, oldFiber, newChild, expirationTime);\n            } else {\n              return null;\n            }\n          }\n      }\n\n      if (isArray$1(newChild) || getIteratorFn(newChild)) {\n        if (key !== null) {\n          return null;\n        }\n\n        return updateFragment(returnFiber, oldFiber, newChild, expirationTime, null);\n      }\n\n      throwOnInvalidObjectType(returnFiber, newChild);\n    }\n\n    {\n      if (typeof newChild === 'function') {\n        warnOnFunctionType();\n      }\n    }\n\n    return null;\n  }\n\n  function updateFromMap(existingChildren, returnFiber, newIdx, newChild, expirationTime) {\n    if (typeof newChild === 'string' || typeof newChild === 'number') {\n      // Text nodes don't have keys, so we neither have to check the old nor\n      // new node for the key. If both are text nodes, they match.\n      var matchedFiber = existingChildren.get(newIdx) || null;\n      return updateTextNode(returnFiber, matchedFiber, '' + newChild, expirationTime);\n    }\n\n    if (typeof newChild === 'object' && newChild !== null) {\n      switch (newChild.$$typeof) {\n        case REACT_ELEMENT_TYPE:\n          {\n            var _matchedFiber = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;\n            if (newChild.type === REACT_FRAGMENT_TYPE) {\n              return updateFragment(returnFiber, _matchedFiber, newChild.props.children, expirationTime, newChild.key);\n            }\n            return updateElement(returnFiber, _matchedFiber, newChild, expirationTime);\n          }\n\n        case REACT_CALL_TYPE:\n          {\n            var _matchedFiber2 = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;\n            return updateCall(returnFiber, _matchedFiber2, newChild, expirationTime);\n          }\n\n        case REACT_RETURN_TYPE:\n          {\n            // Returns don't have keys, so we neither have to check the old nor\n            // new node for the key. If both are returns, they match.\n            var _matchedFiber3 = existingChildren.get(newIdx) || null;\n            return updateReturn(returnFiber, _matchedFiber3, newChild, expirationTime);\n          }\n\n        case REACT_PORTAL_TYPE:\n          {\n            var _matchedFiber4 = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;\n            return updatePortal(returnFiber, _matchedFiber4, newChild, expirationTime);\n          }\n      }\n\n      if (isArray$1(newChild) || getIteratorFn(newChild)) {\n        var _matchedFiber5 = existingChildren.get(newIdx) || null;\n        return updateFragment(returnFiber, _matchedFiber5, newChild, expirationTime, null);\n      }\n\n      throwOnInvalidObjectType(returnFiber, newChild);\n    }\n\n    {\n      if (typeof newChild === 'function') {\n        warnOnFunctionType();\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Warns if there is a duplicate or missing key\n   */\n  function warnOnInvalidKey(child, knownKeys) {\n    {\n      if (typeof child !== 'object' || child === null) {\n        return knownKeys;\n      }\n      switch (child.$$typeof) {\n        case REACT_ELEMENT_TYPE:\n        case REACT_CALL_TYPE:\n        case REACT_PORTAL_TYPE:\n          warnForMissingKey(child);\n          var key = child.key;\n          if (typeof key !== 'string') {\n            break;\n          }\n          if (knownKeys === null) {\n            knownKeys = new Set();\n            knownKeys.add(key);\n            break;\n          }\n          if (!knownKeys.has(key)) {\n            knownKeys.add(key);\n            break;\n          }\n          warning(false, 'Encountered two children with the same key, `%s`. ' + 'Keys should be unique so that components maintain their identity ' + 'across updates. Non-unique keys may cause children to be ' + 'duplicated and/or omitted  the behavior is unsupported and ' + 'could change in a future version.%s', key, getCurrentFiberStackAddendum$1());\n          break;\n        default:\n          break;\n      }\n    }\n    return knownKeys;\n  }\n\n  function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren, expirationTime) {\n    // This algorithm can't optimize by searching from boths ends since we\n    // don't have backpointers on fibers. I'm trying to see how far we can get\n    // with that model. If it ends up not being worth the tradeoffs, we can\n    // add it later.\n\n    // Even with a two ended optimization, we'd want to optimize for the case\n    // where there are few changes and brute force the comparison instead of\n    // going for the Map. It'd like to explore hitting that path first in\n    // forward-only mode and only go for the Map once we notice that we need\n    // lots of look ahead. This doesn't handle reversal as well as two ended\n    // search but that's unusual. Besides, for the two ended optimization to\n    // work on Iterables, we'd need to copy the whole set.\n\n    // In this first iteration, we'll just live with hitting the bad case\n    // (adding everything to a Map) in for every insert/move.\n\n    // If you change this code, also update reconcileChildrenIterator() which\n    // uses the same algorithm.\n\n    {\n      // First, validate keys.\n      var knownKeys = null;\n      for (var i = 0; i < newChildren.length; i++) {\n        var child = newChildren[i];\n        knownKeys = warnOnInvalidKey(child, knownKeys);\n      }\n    }\n\n    var resultingFirstChild = null;\n    var previousNewFiber = null;\n\n    var oldFiber = currentFirstChild;\n    var lastPlacedIndex = 0;\n    var newIdx = 0;\n    var nextOldFiber = null;\n    for (; oldFiber !== null && newIdx < newChildren.length; newIdx++) {\n      if (oldFiber.index > newIdx) {\n        nextOldFiber = oldFiber;\n        oldFiber = null;\n      } else {\n        nextOldFiber = oldFiber.sibling;\n      }\n      var newFiber = updateSlot(returnFiber, oldFiber, newChildren[newIdx], expirationTime);\n      if (newFiber === null) {\n        // TODO: This breaks on empty slots like null children. That's\n        // unfortunate because it triggers the slow path all the time. We need\n        // a better way to communicate whether this was a miss or null,\n        // boolean, undefined, etc.\n        if (oldFiber === null) {\n          oldFiber = nextOldFiber;\n        }\n        break;\n      }\n      if (shouldTrackSideEffects) {\n        if (oldFiber && newFiber.alternate === null) {\n          // We matched the slot, but we didn't reuse the existing fiber, so we\n          // need to delete the existing child.\n          deleteChild(returnFiber, oldFiber);\n        }\n      }\n      lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);\n      if (previousNewFiber === null) {\n        // TODO: Move out of the loop. This only happens for the first run.\n        resultingFirstChild = newFiber;\n      } else {\n        // TODO: Defer siblings if we're not at the right index for this slot.\n        // I.e. if we had null values before, then we want to defer this\n        // for each null value. However, we also don't want to call updateSlot\n        // with the previous one.\n        previousNewFiber.sibling = newFiber;\n      }\n      previousNewFiber = newFiber;\n      oldFiber = nextOldFiber;\n    }\n\n    if (newIdx === newChildren.length) {\n      // We've reached the end of the new children. We can delete the rest.\n      deleteRemainingChildren(returnFiber, oldFiber);\n      return resultingFirstChild;\n    }\n\n    if (oldFiber === null) {\n      // If we don't have any more existing children we can choose a fast path\n      // since the rest will all be insertions.\n      for (; newIdx < newChildren.length; newIdx++) {\n        var _newFiber = createChild(returnFiber, newChildren[newIdx], expirationTime);\n        if (!_newFiber) {\n          continue;\n        }\n        lastPlacedIndex = placeChild(_newFiber, lastPlacedIndex, newIdx);\n        if (previousNewFiber === null) {\n          // TODO: Move out of the loop. This only happens for the first run.\n          resultingFirstChild = _newFiber;\n        } else {\n          previousNewFiber.sibling = _newFiber;\n        }\n        previousNewFiber = _newFiber;\n      }\n      return resultingFirstChild;\n    }\n\n    // Add all children to a key map for quick lookups.\n    var existingChildren = mapRemainingChildren(returnFiber, oldFiber);\n\n    // Keep scanning and use the map to restore deleted items as moves.\n    for (; newIdx < newChildren.length; newIdx++) {\n      var _newFiber2 = updateFromMap(existingChildren, returnFiber, newIdx, newChildren[newIdx], expirationTime);\n      if (_newFiber2) {\n        if (shouldTrackSideEffects) {\n          if (_newFiber2.alternate !== null) {\n            // The new fiber is a work in progress, but if there exists a\n            // current, that means that we reused the fiber. We need to delete\n            // it from the child list so that we don't add it to the deletion\n            // list.\n            existingChildren['delete'](_newFiber2.key === null ? newIdx : _newFiber2.key);\n          }\n        }\n        lastPlacedIndex = placeChild(_newFiber2, lastPlacedIndex, newIdx);\n        if (previousNewFiber === null) {\n          resultingFirstChild = _newFiber2;\n        } else {\n          previousNewFiber.sibling = _newFiber2;\n        }\n        previousNewFiber = _newFiber2;\n      }\n    }\n\n    if (shouldTrackSideEffects) {\n      // Any existing children that weren't consumed above were deleted. We need\n      // to add them to the deletion list.\n      existingChildren.forEach(function (child) {\n        return deleteChild(returnFiber, child);\n      });\n    }\n\n    return resultingFirstChild;\n  }\n\n  function reconcileChildrenIterator(returnFiber, currentFirstChild, newChildrenIterable, expirationTime) {\n    // This is the same implementation as reconcileChildrenArray(),\n    // but using the iterator instead.\n\n    var iteratorFn = getIteratorFn(newChildrenIterable);\n    !(typeof iteratorFn === 'function') ? invariant(false, 'An object is not an iterable. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n\n    {\n      // Warn about using Maps as children\n      if (typeof newChildrenIterable.entries === 'function') {\n        var possibleMap = newChildrenIterable;\n        if (possibleMap.entries === iteratorFn) {\n          warning(didWarnAboutMaps, 'Using Maps as children is unsupported and will likely yield ' + 'unexpected results. Convert it to a sequence/iterable of keyed ' + 'ReactElements instead.%s', getCurrentFiberStackAddendum$1());\n          didWarnAboutMaps = true;\n        }\n      }\n\n      // First, validate keys.\n      // We'll get a different iterator later for the main pass.\n      var _newChildren = iteratorFn.call(newChildrenIterable);\n      if (_newChildren) {\n        var knownKeys = null;\n        var _step = _newChildren.next();\n        for (; !_step.done; _step = _newChildren.next()) {\n          var child = _step.value;\n          knownKeys = warnOnInvalidKey(child, knownKeys);\n        }\n      }\n    }\n\n    var newChildren = iteratorFn.call(newChildrenIterable);\n    !(newChildren != null) ? invariant(false, 'An iterable object provided no iterator.') : void 0;\n\n    var resultingFirstChild = null;\n    var previousNewFiber = null;\n\n    var oldFiber = currentFirstChild;\n    var lastPlacedIndex = 0;\n    var newIdx = 0;\n    var nextOldFiber = null;\n\n    var step = newChildren.next();\n    for (; oldFiber !== null && !step.done; newIdx++, step = newChildren.next()) {\n      if (oldFiber.index > newIdx) {\n        nextOldFiber = oldFiber;\n        oldFiber = null;\n      } else {\n        nextOldFiber = oldFiber.sibling;\n      }\n      var newFiber = updateSlot(returnFiber, oldFiber, step.value, expirationTime);\n      if (newFiber === null) {\n        // TODO: This breaks on empty slots like null children. That's\n        // unfortunate because it triggers the slow path all the time. We need\n        // a better way to communicate whether this was a miss or null,\n        // boolean, undefined, etc.\n        if (!oldFiber) {\n          oldFiber = nextOldFiber;\n        }\n        break;\n      }\n      if (shouldTrackSideEffects) {\n        if (oldFiber && newFiber.alternate === null) {\n          // We matched the slot, but we didn't reuse the existing fiber, so we\n          // need to delete the existing child.\n          deleteChild(returnFiber, oldFiber);\n        }\n      }\n      lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);\n      if (previousNewFiber === null) {\n        // TODO: Move out of the loop. This only happens for the first run.\n        resultingFirstChild = newFiber;\n      } else {\n        // TODO: Defer siblings if we're not at the right index for this slot.\n        // I.e. if we had null values before, then we want to defer this\n        // for each null value. However, we also don't want to call updateSlot\n        // with the previous one.\n        previousNewFiber.sibling = newFiber;\n      }\n      previousNewFiber = newFiber;\n      oldFiber = nextOldFiber;\n    }\n\n    if (step.done) {\n      // We've reached the end of the new children. We can delete the rest.\n      deleteRemainingChildren(returnFiber, oldFiber);\n      return resultingFirstChild;\n    }\n\n    if (oldFiber === null) {\n      // If we don't have any more existing children we can choose a fast path\n      // since the rest will all be insertions.\n      for (; !step.done; newIdx++, step = newChildren.next()) {\n        var _newFiber3 = createChild(returnFiber, step.value, expirationTime);\n        if (_newFiber3 === null) {\n          continue;\n        }\n        lastPlacedIndex = placeChild(_newFiber3, lastPlacedIndex, newIdx);\n        if (previousNewFiber === null) {\n          // TODO: Move out of the loop. This only happens for the first run.\n          resultingFirstChild = _newFiber3;\n        } else {\n          previousNewFiber.sibling = _newFiber3;\n        }\n        previousNewFiber = _newFiber3;\n      }\n      return resultingFirstChild;\n    }\n\n    // Add all children to a key map for quick lookups.\n    var existingChildren = mapRemainingChildren(returnFiber, oldFiber);\n\n    // Keep scanning and use the map to restore deleted items as moves.\n    for (; !step.done; newIdx++, step = newChildren.next()) {\n      var _newFiber4 = updateFromMap(existingChildren, returnFiber, newIdx, step.value, expirationTime);\n      if (_newFiber4 !== null) {\n        if (shouldTrackSideEffects) {\n          if (_newFiber4.alternate !== null) {\n            // The new fiber is a work in progress, but if there exists a\n            // current, that means that we reused the fiber. We need to delete\n            // it from the child list so that we don't add it to the deletion\n            // list.\n            existingChildren['delete'](_newFiber4.key === null ? newIdx : _newFiber4.key);\n          }\n        }\n        lastPlacedIndex = placeChild(_newFiber4, lastPlacedIndex, newIdx);\n        if (previousNewFiber === null) {\n          resultingFirstChild = _newFiber4;\n        } else {\n          previousNewFiber.sibling = _newFiber4;\n        }\n        previousNewFiber = _newFiber4;\n      }\n    }\n\n    if (shouldTrackSideEffects) {\n      // Any existing children that weren't consumed above were deleted. We need\n      // to add them to the deletion list.\n      existingChildren.forEach(function (child) {\n        return deleteChild(returnFiber, child);\n      });\n    }\n\n    return resultingFirstChild;\n  }\n\n  function reconcileSingleTextNode(returnFiber, currentFirstChild, textContent, expirationTime) {\n    // There's no need to check for keys on text nodes since we don't have a\n    // way to define them.\n    if (currentFirstChild !== null && currentFirstChild.tag === HostText) {\n      // We already have an existing node so let's just update it and delete\n      // the rest.\n      deleteRemainingChildren(returnFiber, currentFirstChild.sibling);\n      var existing = useFiber(currentFirstChild, textContent, expirationTime);\n      existing['return'] = returnFiber;\n      return existing;\n    }\n    // The existing first child is not a text node so we need to create one\n    // and delete the existing ones.\n    deleteRemainingChildren(returnFiber, currentFirstChild);\n    var created = createFiberFromText(textContent, returnFiber.internalContextTag, expirationTime);\n    created['return'] = returnFiber;\n    return created;\n  }\n\n  function reconcileSingleElement(returnFiber, currentFirstChild, element, expirationTime) {\n    var key = element.key;\n    var child = currentFirstChild;\n    while (child !== null) {\n      // TODO: If key === null and child.key === null, then this only applies to\n      // the first item in the list.\n      if (child.key === key) {\n        if (child.tag === Fragment ? element.type === REACT_FRAGMENT_TYPE : child.type === element.type) {\n          deleteRemainingChildren(returnFiber, child.sibling);\n          var existing = useFiber(child, element.type === REACT_FRAGMENT_TYPE ? element.props.children : element.props, expirationTime);\n          existing.ref = coerceRef(child, element);\n          existing['return'] = returnFiber;\n          {\n            existing._debugSource = element._source;\n            existing._debugOwner = element._owner;\n          }\n          return existing;\n        } else {\n          deleteRemainingChildren(returnFiber, child);\n          break;\n        }\n      } else {\n        deleteChild(returnFiber, child);\n      }\n      child = child.sibling;\n    }\n\n    if (element.type === REACT_FRAGMENT_TYPE) {\n      var created = createFiberFromFragment(element.props.children, returnFiber.internalContextTag, expirationTime, element.key);\n      created['return'] = returnFiber;\n      return created;\n    } else {\n      var _created7 = createFiberFromElement(element, returnFiber.internalContextTag, expirationTime);\n      _created7.ref = coerceRef(currentFirstChild, element);\n      _created7['return'] = returnFiber;\n      return _created7;\n    }\n  }\n\n  function reconcileSingleCall(returnFiber, currentFirstChild, call, expirationTime) {\n    var key = call.key;\n    var child = currentFirstChild;\n    while (child !== null) {\n      // TODO: If key === null and child.key === null, then this only applies to\n      // the first item in the list.\n      if (child.key === key) {\n        if (child.tag === CallComponent) {\n          deleteRemainingChildren(returnFiber, child.sibling);\n          var existing = useFiber(child, call, expirationTime);\n          existing['return'] = returnFiber;\n          return existing;\n        } else {\n          deleteRemainingChildren(returnFiber, child);\n          break;\n        }\n      } else {\n        deleteChild(returnFiber, child);\n      }\n      child = child.sibling;\n    }\n\n    var created = createFiberFromCall(call, returnFiber.internalContextTag, expirationTime);\n    created['return'] = returnFiber;\n    return created;\n  }\n\n  function reconcileSingleReturn(returnFiber, currentFirstChild, returnNode, expirationTime) {\n    // There's no need to check for keys on yields since they're stateless.\n    var child = currentFirstChild;\n    if (child !== null) {\n      if (child.tag === ReturnComponent) {\n        deleteRemainingChildren(returnFiber, child.sibling);\n        var existing = useFiber(child, null, expirationTime);\n        existing.type = returnNode.value;\n        existing['return'] = returnFiber;\n        return existing;\n      } else {\n        deleteRemainingChildren(returnFiber, child);\n      }\n    }\n\n    var created = createFiberFromReturn(returnNode, returnFiber.internalContextTag, expirationTime);\n    created.type = returnNode.value;\n    created['return'] = returnFiber;\n    return created;\n  }\n\n  function reconcileSinglePortal(returnFiber, currentFirstChild, portal, expirationTime) {\n    var key = portal.key;\n    var child = currentFirstChild;\n    while (child !== null) {\n      // TODO: If key === null and child.key === null, then this only applies to\n      // the first item in the list.\n      if (child.key === key) {\n        if (child.tag === HostPortal && child.stateNode.containerInfo === portal.containerInfo && child.stateNode.implementation === portal.implementation) {\n          deleteRemainingChildren(returnFiber, child.sibling);\n          var existing = useFiber(child, portal.children || [], expirationTime);\n          existing['return'] = returnFiber;\n          return existing;\n        } else {\n          deleteRemainingChildren(returnFiber, child);\n          break;\n        }\n      } else {\n        deleteChild(returnFiber, child);\n      }\n      child = child.sibling;\n    }\n\n    var created = createFiberFromPortal(portal, returnFiber.internalContextTag, expirationTime);\n    created['return'] = returnFiber;\n    return created;\n  }\n\n  // This API will tag the children with the side-effect of the reconciliation\n  // itself. They will be added to the side-effect list as we pass through the\n  // children and the parent.\n  function reconcileChildFibers(returnFiber, currentFirstChild, newChild, expirationTime) {\n    // This function is not recursive.\n    // If the top level item is an array, we treat it as a set of children,\n    // not as a fragment. Nested arrays on the other hand will be treated as\n    // fragment nodes. Recursion happens at the normal flow.\n\n    // Handle top level unkeyed fragments as if they were arrays.\n    // This leads to an ambiguity between <>{[...]}</> and <>...</>.\n    // We treat the ambiguous cases above the same.\n    if (typeof newChild === 'object' && newChild !== null && newChild.type === REACT_FRAGMENT_TYPE && newChild.key === null) {\n      newChild = newChild.props.children;\n    }\n\n    // Handle object types\n    var isObject = typeof newChild === 'object' && newChild !== null;\n\n    if (isObject) {\n      switch (newChild.$$typeof) {\n        case REACT_ELEMENT_TYPE:\n          return placeSingleChild(reconcileSingleElement(returnFiber, currentFirstChild, newChild, expirationTime));\n\n        case REACT_CALL_TYPE:\n          return placeSingleChild(reconcileSingleCall(returnFiber, currentFirstChild, newChild, expirationTime));\n        case REACT_RETURN_TYPE:\n          return placeSingleChild(reconcileSingleReturn(returnFiber, currentFirstChild, newChild, expirationTime));\n        case REACT_PORTAL_TYPE:\n          return placeSingleChild(reconcileSinglePortal(returnFiber, currentFirstChild, newChild, expirationTime));\n      }\n    }\n\n    if (typeof newChild === 'string' || typeof newChild === 'number') {\n      return placeSingleChild(reconcileSingleTextNode(returnFiber, currentFirstChild, '' + newChild, expirationTime));\n    }\n\n    if (isArray$1(newChild)) {\n      return reconcileChildrenArray(returnFiber, currentFirstChild, newChild, expirationTime);\n    }\n\n    if (getIteratorFn(newChild)) {\n      return reconcileChildrenIterator(returnFiber, currentFirstChild, newChild, expirationTime);\n    }\n\n    if (isObject) {\n      throwOnInvalidObjectType(returnFiber, newChild);\n    }\n\n    {\n      if (typeof newChild === 'function') {\n        warnOnFunctionType();\n      }\n    }\n    if (typeof newChild === 'undefined') {\n      // If the new child is undefined, and the return fiber is a composite\n      // component, throw an error. If Fiber return types are disabled,\n      // we already threw above.\n      switch (returnFiber.tag) {\n        case ClassComponent:\n          {\n            {\n              var instance = returnFiber.stateNode;\n              if (instance.render._isMockFunction) {\n                // We allow auto-mocks to proceed as if they're returning null.\n                break;\n              }\n            }\n          }\n        // Intentionally fall through to the next case, which handles both\n        // functions and classes\n        // eslint-disable-next-lined no-fallthrough\n        case FunctionalComponent:\n          {\n            var Component = returnFiber.type;\n            invariant(false, '%s(...): Nothing was returned from render. This usually means a return statement is missing. Or, to render nothing, return null.', Component.displayName || Component.name || 'Component');\n          }\n      }\n    }\n\n    // Remaining cases are all treated as empty.\n    return deleteRemainingChildren(returnFiber, currentFirstChild);\n  }\n\n  return reconcileChildFibers;\n}\n\nvar reconcileChildFibers = ChildReconciler(true);\nvar mountChildFibers = ChildReconciler(false);\n\nfunction cloneChildFibers(current, workInProgress) {\n  !(current === null || workInProgress.child === current.child) ? invariant(false, 'Resuming work not yet implemented.') : void 0;\n\n  if (workInProgress.child === null) {\n    return;\n  }\n\n  var currentChild = workInProgress.child;\n  var newChild = createWorkInProgress(currentChild, currentChild.pendingProps, currentChild.expirationTime);\n  workInProgress.child = newChild;\n\n  newChild['return'] = workInProgress;\n  while (currentChild.sibling !== null) {\n    currentChild = currentChild.sibling;\n    newChild = newChild.sibling = createWorkInProgress(currentChild, currentChild.pendingProps, currentChild.expirationTime);\n    newChild['return'] = workInProgress;\n  }\n  newChild.sibling = null;\n}\n\n{\n  var warnedAboutStatelessRefs = {};\n}\n\nvar ReactFiberBeginWork = function (config, hostContext, hydrationContext, scheduleWork, computeExpirationForFiber) {\n  var shouldSetTextContent = config.shouldSetTextContent,\n      useSyncScheduling = config.useSyncScheduling,\n      shouldDeprioritizeSubtree = config.shouldDeprioritizeSubtree;\n  var pushHostContext = hostContext.pushHostContext,\n      pushHostContainer = hostContext.pushHostContainer;\n  var enterHydrationState = hydrationContext.enterHydrationState,\n      resetHydrationState = hydrationContext.resetHydrationState,\n      tryToClaimNextHydratableInstance = hydrationContext.tryToClaimNextHydratableInstance;\n\n  var _ReactFiberClassCompo = ReactFiberClassComponent(scheduleWork, computeExpirationForFiber, memoizeProps, memoizeState),\n      adoptClassInstance = _ReactFiberClassCompo.adoptClassInstance,\n      constructClassInstance = _ReactFiberClassCompo.constructClassInstance,\n      mountClassInstance = _ReactFiberClassCompo.mountClassInstance,\n      updateClassInstance = _ReactFiberClassCompo.updateClassInstance;\n\n  // TODO: Remove this and use reconcileChildrenAtExpirationTime directly.\n\n\n  function reconcileChildren(current, workInProgress, nextChildren) {\n    reconcileChildrenAtExpirationTime(current, workInProgress, nextChildren, workInProgress.expirationTime);\n  }\n\n  function reconcileChildrenAtExpirationTime(current, workInProgress, nextChildren, renderExpirationTime) {\n    if (current === null) {\n      // If this is a fresh new component that hasn't been rendered yet, we\n      // won't update its child set by applying minimal side-effects. Instead,\n      // we will add them all to the child before it gets rendered. That means\n      // we can optimize this reconciliation pass by not tracking side-effects.\n      workInProgress.child = mountChildFibers(workInProgress, null, nextChildren, renderExpirationTime);\n    } else {\n      // If the current child is the same as the work in progress, it means that\n      // we haven't yet started any work on these children. Therefore, we use\n      // the clone algorithm to create a copy of all the current children.\n\n      // If we had any progressed work already, that is invalid at this point so\n      // let's throw it out.\n      workInProgress.child = reconcileChildFibers(workInProgress, current.child, nextChildren, renderExpirationTime);\n    }\n  }\n\n  function updateFragment(current, workInProgress) {\n    var nextChildren = workInProgress.pendingProps;\n    if (hasContextChanged()) {\n      // Normally we can bail out on props equality but if context has changed\n      // we don't do the bailout and we have to reuse existing props instead.\n      if (nextChildren === null) {\n        nextChildren = workInProgress.memoizedProps;\n      }\n    } else if (nextChildren === null || workInProgress.memoizedProps === nextChildren) {\n      return bailoutOnAlreadyFinishedWork(current, workInProgress);\n    }\n    reconcileChildren(current, workInProgress, nextChildren);\n    memoizeProps(workInProgress, nextChildren);\n    return workInProgress.child;\n  }\n\n  function markRef(current, workInProgress) {\n    var ref = workInProgress.ref;\n    if (ref !== null && (!current || current.ref !== ref)) {\n      // Schedule a Ref effect\n      workInProgress.effectTag |= Ref;\n    }\n  }\n\n  function updateFunctionalComponent(current, workInProgress) {\n    var fn = workInProgress.type;\n    var nextProps = workInProgress.pendingProps;\n\n    var memoizedProps = workInProgress.memoizedProps;\n    if (hasContextChanged()) {\n      // Normally we can bail out on props equality but if context has changed\n      // we don't do the bailout and we have to reuse existing props instead.\n      if (nextProps === null) {\n        nextProps = memoizedProps;\n      }\n    } else {\n      if (nextProps === null || memoizedProps === nextProps) {\n        return bailoutOnAlreadyFinishedWork(current, workInProgress);\n      }\n      // TODO: consider bringing fn.shouldComponentUpdate() back.\n      // It used to be here.\n    }\n\n    var unmaskedContext = getUnmaskedContext(workInProgress);\n    var context = getMaskedContext(workInProgress, unmaskedContext);\n\n    var nextChildren;\n\n    {\n      ReactCurrentOwner.current = workInProgress;\n      ReactDebugCurrentFiber.setCurrentPhase('render');\n      nextChildren = fn(nextProps, context);\n      ReactDebugCurrentFiber.setCurrentPhase(null);\n    }\n    // React DevTools reads this flag.\n    workInProgress.effectTag |= PerformedWork;\n    reconcileChildren(current, workInProgress, nextChildren);\n    memoizeProps(workInProgress, nextProps);\n    return workInProgress.child;\n  }\n\n  function updateClassComponent(current, workInProgress, renderExpirationTime) {\n    // Push context providers early to prevent context stack mismatches.\n    // During mounting we don't know the child context yet as the instance doesn't exist.\n    // We will invalidate the child context in finishClassComponent() right after rendering.\n    var hasContext = pushContextProvider(workInProgress);\n\n    var shouldUpdate = void 0;\n    if (current === null) {\n      if (!workInProgress.stateNode) {\n        // In the initial pass we might need to construct the instance.\n        constructClassInstance(workInProgress, workInProgress.pendingProps);\n        mountClassInstance(workInProgress, renderExpirationTime);\n        shouldUpdate = true;\n      } else {\n        invariant(false, 'Resuming work not yet implemented.');\n        // In a resume, we'll already have an instance we can reuse.\n        // shouldUpdate = resumeMountClassInstance(workInProgress, renderExpirationTime);\n      }\n    } else {\n      shouldUpdate = updateClassInstance(current, workInProgress, renderExpirationTime);\n    }\n    return finishClassComponent(current, workInProgress, shouldUpdate, hasContext);\n  }\n\n  function finishClassComponent(current, workInProgress, shouldUpdate, hasContext) {\n    // Refs should update even if shouldComponentUpdate returns false\n    markRef(current, workInProgress);\n\n    if (!shouldUpdate) {\n      // Context providers should defer to sCU for rendering\n      if (hasContext) {\n        invalidateContextProvider(workInProgress, false);\n      }\n\n      return bailoutOnAlreadyFinishedWork(current, workInProgress);\n    }\n\n    var instance = workInProgress.stateNode;\n\n    // Rerender\n    ReactCurrentOwner.current = workInProgress;\n    var nextChildren = void 0;\n    {\n      ReactDebugCurrentFiber.setCurrentPhase('render');\n      nextChildren = instance.render();\n      if (debugRenderPhaseSideEffects) {\n        instance.render();\n      }\n      ReactDebugCurrentFiber.setCurrentPhase(null);\n    }\n    // React DevTools reads this flag.\n    workInProgress.effectTag |= PerformedWork;\n    reconcileChildren(current, workInProgress, nextChildren);\n    // Memoize props and state using the values we just used to render.\n    // TODO: Restructure so we never read values from the instance.\n    memoizeState(workInProgress, instance.state);\n    memoizeProps(workInProgress, instance.props);\n\n    // The context might have changed so we need to recalculate it.\n    if (hasContext) {\n      invalidateContextProvider(workInProgress, true);\n    }\n\n    return workInProgress.child;\n  }\n\n  function pushHostRootContext(workInProgress) {\n    var root = workInProgress.stateNode;\n    if (root.pendingContext) {\n      pushTopLevelContextObject(workInProgress, root.pendingContext, root.pendingContext !== root.context);\n    } else if (root.context) {\n      // Should always be set\n      pushTopLevelContextObject(workInProgress, root.context, false);\n    }\n    pushHostContainer(workInProgress, root.containerInfo);\n  }\n\n  function updateHostRoot(current, workInProgress, renderExpirationTime) {\n    pushHostRootContext(workInProgress);\n    var updateQueue = workInProgress.updateQueue;\n    if (updateQueue !== null) {\n      var prevState = workInProgress.memoizedState;\n      var state = processUpdateQueue(current, workInProgress, updateQueue, null, null, renderExpirationTime);\n      if (prevState === state) {\n        // If the state is the same as before, that's a bailout because we had\n        // no work that expires at this time.\n        resetHydrationState();\n        return bailoutOnAlreadyFinishedWork(current, workInProgress);\n      }\n      var element = state.element;\n      var root = workInProgress.stateNode;\n      if ((current === null || current.child === null) && root.hydrate && enterHydrationState(workInProgress)) {\n        // If we don't have any current children this might be the first pass.\n        // We always try to hydrate. If this isn't a hydration pass there won't\n        // be any children to hydrate which is effectively the same thing as\n        // not hydrating.\n\n        // This is a bit of a hack. We track the host root as a placement to\n        // know that we're currently in a mounting state. That way isMounted\n        // works as expected. We must reset this before committing.\n        // TODO: Delete this when we delete isMounted and findDOMNode.\n        workInProgress.effectTag |= Placement;\n\n        // Ensure that children mount into this root without tracking\n        // side-effects. This ensures that we don't store Placement effects on\n        // nodes that will be hydrated.\n        workInProgress.child = mountChildFibers(workInProgress, null, element, renderExpirationTime);\n      } else {\n        // Otherwise reset hydration state in case we aborted and resumed another\n        // root.\n        resetHydrationState();\n        reconcileChildren(current, workInProgress, element);\n      }\n      memoizeState(workInProgress, state);\n      return workInProgress.child;\n    }\n    resetHydrationState();\n    // If there is no update queue, that's a bailout because the root has no props.\n    return bailoutOnAlreadyFinishedWork(current, workInProgress);\n  }\n\n  function updateHostComponent(current, workInProgress, renderExpirationTime) {\n    pushHostContext(workInProgress);\n\n    if (current === null) {\n      tryToClaimNextHydratableInstance(workInProgress);\n    }\n\n    var type = workInProgress.type;\n    var memoizedProps = workInProgress.memoizedProps;\n    var nextProps = workInProgress.pendingProps;\n    if (nextProps === null) {\n      nextProps = memoizedProps;\n      !(nextProps !== null) ? invariant(false, 'We should always have pending or current props. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n    }\n    var prevProps = current !== null ? current.memoizedProps : null;\n\n    if (hasContextChanged()) {\n      // Normally we can bail out on props equality but if context has changed\n      // we don't do the bailout and we have to reuse existing props instead.\n    } else if (nextProps === null || memoizedProps === nextProps) {\n      return bailoutOnAlreadyFinishedWork(current, workInProgress);\n    }\n\n    var nextChildren = nextProps.children;\n    var isDirectTextChild = shouldSetTextContent(type, nextProps);\n\n    if (isDirectTextChild) {\n      // We special case a direct text child of a host node. This is a common\n      // case. We won't handle it as a reified child. We will instead handle\n      // this in the host environment that also have access to this prop. That\n      // avoids allocating another HostText fiber and traversing it.\n      nextChildren = null;\n    } else if (prevProps && shouldSetTextContent(type, prevProps)) {\n      // If we're switching from a direct text child to a normal child, or to\n      // empty, we need to schedule the text content to be reset.\n      workInProgress.effectTag |= ContentReset;\n    }\n\n    markRef(current, workInProgress);\n\n    // Check the host config to see if the children are offscreen/hidden.\n    if (renderExpirationTime !== Never && !useSyncScheduling && shouldDeprioritizeSubtree(type, nextProps)) {\n      // Down-prioritize the children.\n      workInProgress.expirationTime = Never;\n      // Bailout and come back to this fiber later.\n      return null;\n    }\n\n    reconcileChildren(current, workInProgress, nextChildren);\n    memoizeProps(workInProgress, nextProps);\n    return workInProgress.child;\n  }\n\n  function updateHostText(current, workInProgress) {\n    if (current === null) {\n      tryToClaimNextHydratableInstance(workInProgress);\n    }\n    var nextProps = workInProgress.pendingProps;\n    if (nextProps === null) {\n      nextProps = workInProgress.memoizedProps;\n    }\n    memoizeProps(workInProgress, nextProps);\n    // Nothing to do here. This is terminal. We'll do the completion step\n    // immediately after.\n    return null;\n  }\n\n  function mountIndeterminateComponent(current, workInProgress, renderExpirationTime) {\n    !(current === null) ? invariant(false, 'An indeterminate component should never have mounted. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n    var fn = workInProgress.type;\n    var props = workInProgress.pendingProps;\n    var unmaskedContext = getUnmaskedContext(workInProgress);\n    var context = getMaskedContext(workInProgress, unmaskedContext);\n\n    var value;\n\n    {\n      if (fn.prototype && typeof fn.prototype.render === 'function') {\n        var componentName = getComponentName(workInProgress);\n        warning(false, \"The <%s /> component appears to have a render method, but doesn't extend React.Component. \" + 'This is likely to cause errors. Change %s to extend React.Component instead.', componentName, componentName);\n      }\n      ReactCurrentOwner.current = workInProgress;\n      value = fn(props, context);\n    }\n    // React DevTools reads this flag.\n    workInProgress.effectTag |= PerformedWork;\n\n    if (typeof value === 'object' && value !== null && typeof value.render === 'function') {\n      // Proceed under the assumption that this is a class instance\n      workInProgress.tag = ClassComponent;\n\n      // Push context providers early to prevent context stack mismatches.\n      // During mounting we don't know the child context yet as the instance doesn't exist.\n      // We will invalidate the child context in finishClassComponent() right after rendering.\n      var hasContext = pushContextProvider(workInProgress);\n      adoptClassInstance(workInProgress, value);\n      mountClassInstance(workInProgress, renderExpirationTime);\n      return finishClassComponent(current, workInProgress, true, hasContext);\n    } else {\n      // Proceed under the assumption that this is a functional component\n      workInProgress.tag = FunctionalComponent;\n      {\n        var Component = workInProgress.type;\n\n        if (Component) {\n          warning(!Component.childContextTypes, '%s(...): childContextTypes cannot be defined on a functional component.', Component.displayName || Component.name || 'Component');\n        }\n        if (workInProgress.ref !== null) {\n          var info = '';\n          var ownerName = ReactDebugCurrentFiber.getCurrentFiberOwnerName();\n          if (ownerName) {\n            info += '\\n\\nCheck the render method of `' + ownerName + '`.';\n          }\n\n          var warningKey = ownerName || workInProgress._debugID || '';\n          var debugSource = workInProgress._debugSource;\n          if (debugSource) {\n            warningKey = debugSource.fileName + ':' + debugSource.lineNumber;\n          }\n          if (!warnedAboutStatelessRefs[warningKey]) {\n            warnedAboutStatelessRefs[warningKey] = true;\n            warning(false, 'Stateless function components cannot be given refs. ' + 'Attempts to access this ref will fail.%s%s', info, ReactDebugCurrentFiber.getCurrentFiberStackAddendum());\n          }\n        }\n      }\n      reconcileChildren(current, workInProgress, value);\n      memoizeProps(workInProgress, props);\n      return workInProgress.child;\n    }\n  }\n\n  function updateCallComponent(current, workInProgress, renderExpirationTime) {\n    var nextCall = workInProgress.pendingProps;\n    if (hasContextChanged()) {\n      // Normally we can bail out on props equality but if context has changed\n      // we don't do the bailout and we have to reuse existing props instead.\n      if (nextCall === null) {\n        nextCall = current && current.memoizedProps;\n        !(nextCall !== null) ? invariant(false, 'We should always have pending or current props. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n      }\n    } else if (nextCall === null || workInProgress.memoizedProps === nextCall) {\n      nextCall = workInProgress.memoizedProps;\n      // TODO: When bailing out, we might need to return the stateNode instead\n      // of the child. To check it for work.\n      // return bailoutOnAlreadyFinishedWork(current, workInProgress);\n    }\n\n    var nextChildren = nextCall.children;\n\n    // The following is a fork of reconcileChildrenAtExpirationTime but using\n    // stateNode to store the child.\n    if (current === null) {\n      workInProgress.stateNode = mountChildFibers(workInProgress, workInProgress.stateNode, nextChildren, renderExpirationTime);\n    } else {\n      workInProgress.stateNode = reconcileChildFibers(workInProgress, workInProgress.stateNode, nextChildren, renderExpirationTime);\n    }\n\n    memoizeProps(workInProgress, nextCall);\n    // This doesn't take arbitrary time so we could synchronously just begin\n    // eagerly do the work of workInProgress.child as an optimization.\n    return workInProgress.stateNode;\n  }\n\n  function updatePortalComponent(current, workInProgress, renderExpirationTime) {\n    pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);\n    var nextChildren = workInProgress.pendingProps;\n    if (hasContextChanged()) {\n      // Normally we can bail out on props equality but if context has changed\n      // we don't do the bailout and we have to reuse existing props instead.\n      if (nextChildren === null) {\n        nextChildren = current && current.memoizedProps;\n        !(nextChildren != null) ? invariant(false, 'We should always have pending or current props. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n      }\n    } else if (nextChildren === null || workInProgress.memoizedProps === nextChildren) {\n      return bailoutOnAlreadyFinishedWork(current, workInProgress);\n    }\n\n    if (current === null) {\n      // Portals are special because we don't append the children during mount\n      // but at commit. Therefore we need to track insertions which the normal\n      // flow doesn't do during mount. This doesn't happen at the root because\n      // the root always starts with a \"current\" with a null child.\n      // TODO: Consider unifying this with how the root works.\n      workInProgress.child = reconcileChildFibers(workInProgress, null, nextChildren, renderExpirationTime);\n      memoizeProps(workInProgress, nextChildren);\n    } else {\n      reconcileChildren(current, workInProgress, nextChildren);\n      memoizeProps(workInProgress, nextChildren);\n    }\n    return workInProgress.child;\n  }\n\n  /*\n  function reuseChildrenEffects(returnFiber : Fiber, firstChild : Fiber) {\n    let child = firstChild;\n    do {\n      // Ensure that the first and last effect of the parent corresponds\n      // to the children's first and last effect.\n      if (!returnFiber.firstEffect) {\n        returnFiber.firstEffect = child.firstEffect;\n      }\n      if (child.lastEffect) {\n        if (returnFiber.lastEffect) {\n          returnFiber.lastEffect.nextEffect = child.firstEffect;\n        }\n        returnFiber.lastEffect = child.lastEffect;\n      }\n    } while (child = child.sibling);\n  }\n  */\n\n  function bailoutOnAlreadyFinishedWork(current, workInProgress) {\n    cancelWorkTimer(workInProgress);\n\n    // TODO: We should ideally be able to bail out early if the children have no\n    // more work to do. However, since we don't have a separation of this\n    // Fiber's priority and its children yet - we don't know without doing lots\n    // of the same work we do anyway. Once we have that separation we can just\n    // bail out here if the children has no more work at this priority level.\n    // if (workInProgress.priorityOfChildren <= priorityLevel) {\n    //   // If there are side-effects in these children that have not yet been\n    //   // committed we need to ensure that they get properly transferred up.\n    //   if (current && current.child !== workInProgress.child) {\n    //     reuseChildrenEffects(workInProgress, child);\n    //   }\n    //   return null;\n    // }\n\n    cloneChildFibers(current, workInProgress);\n    return workInProgress.child;\n  }\n\n  function bailoutOnLowPriority(current, workInProgress) {\n    cancelWorkTimer(workInProgress);\n\n    // TODO: Handle HostComponent tags here as well and call pushHostContext()?\n    // See PR 8590 discussion for context\n    switch (workInProgress.tag) {\n      case HostRoot:\n        pushHostRootContext(workInProgress);\n        break;\n      case ClassComponent:\n        pushContextProvider(workInProgress);\n        break;\n      case HostPortal:\n        pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);\n        break;\n    }\n    // TODO: What if this is currently in progress?\n    // How can that happen? How is this not being cloned?\n    return null;\n  }\n\n  // TODO: Delete memoizeProps/State and move to reconcile/bailout instead\n  function memoizeProps(workInProgress, nextProps) {\n    workInProgress.memoizedProps = nextProps;\n  }\n\n  function memoizeState(workInProgress, nextState) {\n    workInProgress.memoizedState = nextState;\n    // Don't reset the updateQueue, in case there are pending updates. Resetting\n    // is handled by processUpdateQueue.\n  }\n\n  function beginWork(current, workInProgress, renderExpirationTime) {\n    if (workInProgress.expirationTime === NoWork || workInProgress.expirationTime > renderExpirationTime) {\n      return bailoutOnLowPriority(current, workInProgress);\n    }\n\n    switch (workInProgress.tag) {\n      case IndeterminateComponent:\n        return mountIndeterminateComponent(current, workInProgress, renderExpirationTime);\n      case FunctionalComponent:\n        return updateFunctionalComponent(current, workInProgress);\n      case ClassComponent:\n        return updateClassComponent(current, workInProgress, renderExpirationTime);\n      case HostRoot:\n        return updateHostRoot(current, workInProgress, renderExpirationTime);\n      case HostComponent:\n        return updateHostComponent(current, workInProgress, renderExpirationTime);\n      case HostText:\n        return updateHostText(current, workInProgress);\n      case CallHandlerPhase:\n        // This is a restart. Reset the tag to the initial phase.\n        workInProgress.tag = CallComponent;\n      // Intentionally fall through since this is now the same.\n      case CallComponent:\n        return updateCallComponent(current, workInProgress, renderExpirationTime);\n      case ReturnComponent:\n        // A return component is just a placeholder, we can just run through the\n        // next one immediately.\n        return null;\n      case HostPortal:\n        return updatePortalComponent(current, workInProgress, renderExpirationTime);\n      case Fragment:\n        return updateFragment(current, workInProgress);\n      default:\n        invariant(false, 'Unknown unit of work tag. This error is likely caused by a bug in React. Please file an issue.');\n    }\n  }\n\n  function beginFailedWork(current, workInProgress, renderExpirationTime) {\n    // Push context providers here to avoid a push/pop context mismatch.\n    switch (workInProgress.tag) {\n      case ClassComponent:\n        pushContextProvider(workInProgress);\n        break;\n      case HostRoot:\n        pushHostRootContext(workInProgress);\n        break;\n      default:\n        invariant(false, 'Invalid type of work. This error is likely caused by a bug in React. Please file an issue.');\n    }\n\n    // Add an error effect so we can handle the error during the commit phase\n    workInProgress.effectTag |= Err;\n\n    // This is a weird case where we do \"resume\" work  work that failed on\n    // our first attempt. Because we no longer have a notion of \"progressed\n    // deletions,\" reset the child to the current child to make sure we delete\n    // it again. TODO: Find a better way to handle this, perhaps during a more\n    // general overhaul of error handling.\n    if (current === null) {\n      workInProgress.child = null;\n    } else if (workInProgress.child !== current.child) {\n      workInProgress.child = current.child;\n    }\n\n    if (workInProgress.expirationTime === NoWork || workInProgress.expirationTime > renderExpirationTime) {\n      return bailoutOnLowPriority(current, workInProgress);\n    }\n\n    // If we don't bail out, we're going be recomputing our children so we need\n    // to drop our effect list.\n    workInProgress.firstEffect = null;\n    workInProgress.lastEffect = null;\n\n    // Unmount the current children as if the component rendered null\n    var nextChildren = null;\n    reconcileChildrenAtExpirationTime(current, workInProgress, nextChildren, renderExpirationTime);\n\n    if (workInProgress.tag === ClassComponent) {\n      var instance = workInProgress.stateNode;\n      workInProgress.memoizedProps = instance.props;\n      workInProgress.memoizedState = instance.state;\n    }\n\n    return workInProgress.child;\n  }\n\n  return {\n    beginWork: beginWork,\n    beginFailedWork: beginFailedWork\n  };\n};\n\nvar ReactFiberCompleteWork = function (config, hostContext, hydrationContext) {\n  var createInstance = config.createInstance,\n      createTextInstance = config.createTextInstance,\n      appendInitialChild = config.appendInitialChild,\n      finalizeInitialChildren = config.finalizeInitialChildren,\n      prepareUpdate = config.prepareUpdate,\n      mutation = config.mutation,\n      persistence = config.persistence;\n  var getRootHostContainer = hostContext.getRootHostContainer,\n      popHostContext = hostContext.popHostContext,\n      getHostContext = hostContext.getHostContext,\n      popHostContainer = hostContext.popHostContainer;\n  var prepareToHydrateHostInstance = hydrationContext.prepareToHydrateHostInstance,\n      prepareToHydrateHostTextInstance = hydrationContext.prepareToHydrateHostTextInstance,\n      popHydrationState = hydrationContext.popHydrationState;\n\n\n  function markUpdate(workInProgress) {\n    // Tag the fiber with an update effect. This turns a Placement into\n    // an UpdateAndPlacement.\n    workInProgress.effectTag |= Update;\n  }\n\n  function markRef(workInProgress) {\n    workInProgress.effectTag |= Ref;\n  }\n\n  function appendAllReturns(returns, workInProgress) {\n    var node = workInProgress.stateNode;\n    if (node) {\n      node['return'] = workInProgress;\n    }\n    while (node !== null) {\n      if (node.tag === HostComponent || node.tag === HostText || node.tag === HostPortal) {\n        invariant(false, 'A call cannot have host component children.');\n      } else if (node.tag === ReturnComponent) {\n        returns.push(node.type);\n      } else if (node.child !== null) {\n        node.child['return'] = node;\n        node = node.child;\n        continue;\n      }\n      while (node.sibling === null) {\n        if (node['return'] === null || node['return'] === workInProgress) {\n          return;\n        }\n        node = node['return'];\n      }\n      node.sibling['return'] = node['return'];\n      node = node.sibling;\n    }\n  }\n\n  function moveCallToHandlerPhase(current, workInProgress, renderExpirationTime) {\n    var call = workInProgress.memoizedProps;\n    !call ? invariant(false, 'Should be resolved by now. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n\n    // First step of the call has completed. Now we need to do the second.\n    // TODO: It would be nice to have a multi stage call represented by a\n    // single component, or at least tail call optimize nested ones. Currently\n    // that requires additional fields that we don't want to add to the fiber.\n    // So this requires nested handlers.\n    // Note: This doesn't mutate the alternate node. I don't think it needs to\n    // since this stage is reset for every pass.\n    workInProgress.tag = CallHandlerPhase;\n\n    // Build up the returns.\n    // TODO: Compare this to a generator or opaque helpers like Children.\n    var returns = [];\n    appendAllReturns(returns, workInProgress);\n    var fn = call.handler;\n    var props = call.props;\n    var nextChildren = fn(props, returns);\n\n    var currentFirstChild = current !== null ? current.child : null;\n    workInProgress.child = reconcileChildFibers(workInProgress, currentFirstChild, nextChildren, renderExpirationTime);\n    return workInProgress.child;\n  }\n\n  function appendAllChildren(parent, workInProgress) {\n    // We only have the top Fiber that was created but we need recurse down its\n    // children to find all the terminal nodes.\n    var node = workInProgress.child;\n    while (node !== null) {\n      if (node.tag === HostComponent || node.tag === HostText) {\n        appendInitialChild(parent, node.stateNode);\n      } else if (node.tag === HostPortal) {\n        // If we have a portal child, then we don't want to traverse\n        // down its children. Instead, we'll get insertions from each child in\n        // the portal directly.\n      } else if (node.child !== null) {\n        node.child['return'] = node;\n        node = node.child;\n        continue;\n      }\n      if (node === workInProgress) {\n        return;\n      }\n      while (node.sibling === null) {\n        if (node['return'] === null || node['return'] === workInProgress) {\n          return;\n        }\n        node = node['return'];\n      }\n      node.sibling['return'] = node['return'];\n      node = node.sibling;\n    }\n  }\n\n  var updateHostContainer = void 0;\n  var updateHostComponent = void 0;\n  var updateHostText = void 0;\n  if (mutation) {\n    if (enableMutatingReconciler) {\n      // Mutation mode\n      updateHostContainer = function (workInProgress) {\n        // Noop\n      };\n      updateHostComponent = function (current, workInProgress, updatePayload, type, oldProps, newProps, rootContainerInstance) {\n        // TODO: Type this specific to this type of component.\n        workInProgress.updateQueue = updatePayload;\n        // If the update payload indicates that there is a change or if there\n        // is a new ref we mark this as an update. All the work is done in commitWork.\n        if (updatePayload) {\n          markUpdate(workInProgress);\n        }\n      };\n      updateHostText = function (current, workInProgress, oldText, newText) {\n        // If the text differs, mark it as an update. All the work in done in commitWork.\n        if (oldText !== newText) {\n          markUpdate(workInProgress);\n        }\n      };\n    } else {\n      invariant(false, 'Mutating reconciler is disabled.');\n    }\n  } else if (persistence) {\n    if (enablePersistentReconciler) {\n      // Persistent host tree mode\n      var cloneInstance = persistence.cloneInstance,\n          createContainerChildSet = persistence.createContainerChildSet,\n          appendChildToContainerChildSet = persistence.appendChildToContainerChildSet,\n          finalizeContainerChildren = persistence.finalizeContainerChildren;\n\n      // An unfortunate fork of appendAllChildren because we have two different parent types.\n\n      var appendAllChildrenToContainer = function (containerChildSet, workInProgress) {\n        // We only have the top Fiber that was created but we need recurse down its\n        // children to find all the terminal nodes.\n        var node = workInProgress.child;\n        while (node !== null) {\n          if (node.tag === HostComponent || node.tag === HostText) {\n            appendChildToContainerChildSet(containerChildSet, node.stateNode);\n          } else if (node.tag === HostPortal) {\n            // If we have a portal child, then we don't want to traverse\n            // down its children. Instead, we'll get insertions from each child in\n            // the portal directly.\n          } else if (node.child !== null) {\n            node.child['return'] = node;\n            node = node.child;\n            continue;\n          }\n          if (node === workInProgress) {\n            return;\n          }\n          while (node.sibling === null) {\n            if (node['return'] === null || node['return'] === workInProgress) {\n              return;\n            }\n            node = node['return'];\n          }\n          node.sibling['return'] = node['return'];\n          node = node.sibling;\n        }\n      };\n      updateHostContainer = function (workInProgress) {\n        var portalOrRoot = workInProgress.stateNode;\n        var childrenUnchanged = workInProgress.firstEffect === null;\n        if (childrenUnchanged) {\n          // No changes, just reuse the existing instance.\n        } else {\n          var container = portalOrRoot.containerInfo;\n          var newChildSet = createContainerChildSet(container);\n          if (finalizeContainerChildren(container, newChildSet)) {\n            markUpdate(workInProgress);\n          }\n          portalOrRoot.pendingChildren = newChildSet;\n          // If children might have changed, we have to add them all to the set.\n          appendAllChildrenToContainer(newChildSet, workInProgress);\n          // Schedule an update on the container to swap out the container.\n          markUpdate(workInProgress);\n        }\n      };\n      updateHostComponent = function (current, workInProgress, updatePayload, type, oldProps, newProps, rootContainerInstance) {\n        // If there are no effects associated with this node, then none of our children had any updates.\n        // This guarantees that we can reuse all of them.\n        var childrenUnchanged = workInProgress.firstEffect === null;\n        var currentInstance = current.stateNode;\n        if (childrenUnchanged && updatePayload === null) {\n          // No changes, just reuse the existing instance.\n          // Note that this might release a previous clone.\n          workInProgress.stateNode = currentInstance;\n        } else {\n          var recyclableInstance = workInProgress.stateNode;\n          var newInstance = cloneInstance(currentInstance, updatePayload, type, oldProps, newProps, workInProgress, childrenUnchanged, recyclableInstance);\n          if (finalizeInitialChildren(newInstance, type, newProps, rootContainerInstance)) {\n            markUpdate(workInProgress);\n          }\n          workInProgress.stateNode = newInstance;\n          if (childrenUnchanged) {\n            // If there are no other effects in this tree, we need to flag this node as having one.\n            // Even though we're not going to use it for anything.\n            // Otherwise parents won't know that there are new children to propagate upwards.\n            markUpdate(workInProgress);\n          } else {\n            // If children might have changed, we have to add them all to the set.\n            appendAllChildren(newInstance, workInProgress);\n          }\n        }\n      };\n      updateHostText = function (current, workInProgress, oldText, newText) {\n        if (oldText !== newText) {\n          // If the text content differs, we'll create a new text instance for it.\n          var rootContainerInstance = getRootHostContainer();\n          var currentHostContext = getHostContext();\n          workInProgress.stateNode = createTextInstance(newText, rootContainerInstance, currentHostContext, workInProgress);\n          // We'll have to mark it as having an effect, even though we won't use the effect for anything.\n          // This lets the parents know that at least one of their children has changed.\n          markUpdate(workInProgress);\n        }\n      };\n    } else {\n      invariant(false, 'Persistent reconciler is disabled.');\n    }\n  } else {\n    if (enableNoopReconciler) {\n      // No host operations\n      updateHostContainer = function (workInProgress) {\n        // Noop\n      };\n      updateHostComponent = function (current, workInProgress, updatePayload, type, oldProps, newProps, rootContainerInstance) {\n        // Noop\n      };\n      updateHostText = function (current, workInProgress, oldText, newText) {\n        // Noop\n      };\n    } else {\n      invariant(false, 'Noop reconciler is disabled.');\n    }\n  }\n\n  function completeWork(current, workInProgress, renderExpirationTime) {\n    // Get the latest props.\n    var newProps = workInProgress.pendingProps;\n    if (newProps === null) {\n      newProps = workInProgress.memoizedProps;\n    } else if (workInProgress.expirationTime !== Never || renderExpirationTime === Never) {\n      // Reset the pending props, unless this was a down-prioritization.\n      workInProgress.pendingProps = null;\n    }\n\n    switch (workInProgress.tag) {\n      case FunctionalComponent:\n        return null;\n      case ClassComponent:\n        {\n          // We are leaving this subtree, so pop context if any.\n          popContextProvider(workInProgress);\n          return null;\n        }\n      case HostRoot:\n        {\n          popHostContainer(workInProgress);\n          popTopLevelContextObject(workInProgress);\n          var fiberRoot = workInProgress.stateNode;\n          if (fiberRoot.pendingContext) {\n            fiberRoot.context = fiberRoot.pendingContext;\n            fiberRoot.pendingContext = null;\n          }\n\n          if (current === null || current.child === null) {\n            // If we hydrated, pop so that we can delete any remaining children\n            // that weren't hydrated.\n            popHydrationState(workInProgress);\n            // This resets the hacky state to fix isMounted before committing.\n            // TODO: Delete this when we delete isMounted and findDOMNode.\n            workInProgress.effectTag &= ~Placement;\n          }\n          updateHostContainer(workInProgress);\n          return null;\n        }\n      case HostComponent:\n        {\n          popHostContext(workInProgress);\n          var rootContainerInstance = getRootHostContainer();\n          var type = workInProgress.type;\n          if (current !== null && workInProgress.stateNode != null) {\n            // If we have an alternate, that means this is an update and we need to\n            // schedule a side-effect to do the updates.\n            var oldProps = current.memoizedProps;\n            // If we get updated because one of our children updated, we don't\n            // have newProps so we'll have to reuse them.\n            // TODO: Split the update API as separate for the props vs. children.\n            // Even better would be if children weren't special cased at all tho.\n            var instance = workInProgress.stateNode;\n            var currentHostContext = getHostContext();\n            var updatePayload = prepareUpdate(instance, type, oldProps, newProps, rootContainerInstance, currentHostContext);\n\n            updateHostComponent(current, workInProgress, updatePayload, type, oldProps, newProps, rootContainerInstance);\n\n            if (current.ref !== workInProgress.ref) {\n              markRef(workInProgress);\n            }\n          } else {\n            if (!newProps) {\n              !(workInProgress.stateNode !== null) ? invariant(false, 'We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n              // This can happen when we abort work.\n              return null;\n            }\n\n            var _currentHostContext = getHostContext();\n            // TODO: Move createInstance to beginWork and keep it on a context\n            // \"stack\" as the parent. Then append children as we go in beginWork\n            // or completeWork depending on we want to add then top->down or\n            // bottom->up. Top->down is faster in IE11.\n            var wasHydrated = popHydrationState(workInProgress);\n            if (wasHydrated) {\n              // TODO: Move this and createInstance step into the beginPhase\n              // to consolidate.\n              if (prepareToHydrateHostInstance(workInProgress, rootContainerInstance, _currentHostContext)) {\n                // If changes to the hydrated node needs to be applied at the\n                // commit-phase we mark this as such.\n                markUpdate(workInProgress);\n              }\n            } else {\n              var _instance = createInstance(type, newProps, rootContainerInstance, _currentHostContext, workInProgress);\n\n              appendAllChildren(_instance, workInProgress);\n\n              // Certain renderers require commit-time effects for initial mount.\n              // (eg DOM renderer supports auto-focus for certain elements).\n              // Make sure such renderers get scheduled for later work.\n              if (finalizeInitialChildren(_instance, type, newProps, rootContainerInstance)) {\n                markUpdate(workInProgress);\n              }\n              workInProgress.stateNode = _instance;\n            }\n\n            if (workInProgress.ref !== null) {\n              // If there is a ref on a host node we need to schedule a callback\n              markRef(workInProgress);\n            }\n          }\n          return null;\n        }\n      case HostText:\n        {\n          var newText = newProps;\n          if (current && workInProgress.stateNode != null) {\n            var oldText = current.memoizedProps;\n            // If we have an alternate, that means this is an update and we need\n            // to schedule a side-effect to do the updates.\n            updateHostText(current, workInProgress, oldText, newText);\n          } else {\n            if (typeof newText !== 'string') {\n              !(workInProgress.stateNode !== null) ? invariant(false, 'We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n              // This can happen when we abort work.\n              return null;\n            }\n            var _rootContainerInstance = getRootHostContainer();\n            var _currentHostContext2 = getHostContext();\n            var _wasHydrated = popHydrationState(workInProgress);\n            if (_wasHydrated) {\n              if (prepareToHydrateHostTextInstance(workInProgress)) {\n                markUpdate(workInProgress);\n              }\n            } else {\n              workInProgress.stateNode = createTextInstance(newText, _rootContainerInstance, _currentHostContext2, workInProgress);\n            }\n          }\n          return null;\n        }\n      case CallComponent:\n        return moveCallToHandlerPhase(current, workInProgress, renderExpirationTime);\n      case CallHandlerPhase:\n        // Reset the tag to now be a first phase call.\n        workInProgress.tag = CallComponent;\n        return null;\n      case ReturnComponent:\n        // Does nothing.\n        return null;\n      case Fragment:\n        return null;\n      case HostPortal:\n        popHostContainer(workInProgress);\n        updateHostContainer(workInProgress);\n        return null;\n      // Error cases\n      case IndeterminateComponent:\n        invariant(false, 'An indeterminate component should have become determinate before completing. This error is likely caused by a bug in React. Please file an issue.');\n      // eslint-disable-next-line no-fallthrough\n      default:\n        invariant(false, 'Unknown unit of work tag. This error is likely caused by a bug in React. Please file an issue.');\n    }\n  }\n\n  return {\n    completeWork: completeWork\n  };\n};\n\nvar invokeGuardedCallback$2 = ReactErrorUtils.invokeGuardedCallback;\nvar hasCaughtError$1 = ReactErrorUtils.hasCaughtError;\nvar clearCaughtError$1 = ReactErrorUtils.clearCaughtError;\n\n\nvar ReactFiberCommitWork = function (config, captureError) {\n  var getPublicInstance = config.getPublicInstance,\n      mutation = config.mutation,\n      persistence = config.persistence;\n\n\n  var callComponentWillUnmountWithTimer = function (current, instance) {\n    startPhaseTimer(current, 'componentWillUnmount');\n    instance.props = current.memoizedProps;\n    instance.state = current.memoizedState;\n    instance.componentWillUnmount();\n    stopPhaseTimer();\n  };\n\n  // Capture errors so they don't interrupt unmounting.\n  function safelyCallComponentWillUnmount(current, instance) {\n    {\n      invokeGuardedCallback$2(null, callComponentWillUnmountWithTimer, null, current, instance);\n      if (hasCaughtError$1()) {\n        var unmountError = clearCaughtError$1();\n        captureError(current, unmountError);\n      }\n    }\n  }\n\n  function safelyDetachRef(current) {\n    var ref = current.ref;\n    if (ref !== null) {\n      {\n        invokeGuardedCallback$2(null, ref, null, null);\n        if (hasCaughtError$1()) {\n          var refError = clearCaughtError$1();\n          captureError(current, refError);\n        }\n      }\n    }\n  }\n\n  function commitLifeCycles(current, finishedWork) {\n    switch (finishedWork.tag) {\n      case ClassComponent:\n        {\n          var instance = finishedWork.stateNode;\n          if (finishedWork.effectTag & Update) {\n            if (current === null) {\n              startPhaseTimer(finishedWork, 'componentDidMount');\n              instance.props = finishedWork.memoizedProps;\n              instance.state = finishedWork.memoizedState;\n              instance.componentDidMount();\n              stopPhaseTimer();\n            } else {\n              var prevProps = current.memoizedProps;\n              var prevState = current.memoizedState;\n              startPhaseTimer(finishedWork, 'componentDidUpdate');\n              instance.props = finishedWork.memoizedProps;\n              instance.state = finishedWork.memoizedState;\n              instance.componentDidUpdate(prevProps, prevState);\n              stopPhaseTimer();\n            }\n          }\n          var updateQueue = finishedWork.updateQueue;\n          if (updateQueue !== null) {\n            commitCallbacks(updateQueue, instance);\n          }\n          return;\n        }\n      case HostRoot:\n        {\n          var _updateQueue = finishedWork.updateQueue;\n          if (_updateQueue !== null) {\n            var _instance = finishedWork.child !== null ? finishedWork.child.stateNode : null;\n            commitCallbacks(_updateQueue, _instance);\n          }\n          return;\n        }\n      case HostComponent:\n        {\n          var _instance2 = finishedWork.stateNode;\n\n          // Renderers may schedule work to be done after host components are mounted\n          // (eg DOM renderer may schedule auto-focus for inputs and form controls).\n          // These effects should only be committed when components are first mounted,\n          // aka when there is no current/alternate.\n          if (current === null && finishedWork.effectTag & Update) {\n            var type = finishedWork.type;\n            var props = finishedWork.memoizedProps;\n            commitMount(_instance2, type, props, finishedWork);\n          }\n\n          return;\n        }\n      case HostText:\n        {\n          // We have no life-cycles associated with text.\n          return;\n        }\n      case HostPortal:\n        {\n          // We have no life-cycles associated with portals.\n          return;\n        }\n      default:\n        {\n          invariant(false, 'This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.');\n        }\n    }\n  }\n\n  function commitAttachRef(finishedWork) {\n    var ref = finishedWork.ref;\n    if (ref !== null) {\n      var instance = finishedWork.stateNode;\n      switch (finishedWork.tag) {\n        case HostComponent:\n          ref(getPublicInstance(instance));\n          break;\n        default:\n          ref(instance);\n      }\n    }\n  }\n\n  function commitDetachRef(current) {\n    var currentRef = current.ref;\n    if (currentRef !== null) {\n      currentRef(null);\n    }\n  }\n\n  // User-originating errors (lifecycles and refs) should not interrupt\n  // deletion, so don't let them throw. Host-originating errors should\n  // interrupt deletion, so it's okay\n  function commitUnmount(current) {\n    if (typeof onCommitUnmount === 'function') {\n      onCommitUnmount(current);\n    }\n\n    switch (current.tag) {\n      case ClassComponent:\n        {\n          safelyDetachRef(current);\n          var instance = current.stateNode;\n          if (typeof instance.componentWillUnmount === 'function') {\n            safelyCallComponentWillUnmount(current, instance);\n          }\n          return;\n        }\n      case HostComponent:\n        {\n          safelyDetachRef(current);\n          return;\n        }\n      case CallComponent:\n        {\n          commitNestedUnmounts(current.stateNode);\n          return;\n        }\n      case HostPortal:\n        {\n          // TODO: this is recursive.\n          // We are also not using this parent because\n          // the portal will get pushed immediately.\n          if (enableMutatingReconciler && mutation) {\n            unmountHostComponents(current);\n          } else if (enablePersistentReconciler && persistence) {\n            emptyPortalContainer(current);\n          }\n          return;\n        }\n    }\n  }\n\n  function commitNestedUnmounts(root) {\n    // While we're inside a removed host node we don't want to call\n    // removeChild on the inner nodes because they're removed by the top\n    // call anyway. We also want to call componentWillUnmount on all\n    // composites before this host node is removed from the tree. Therefore\n    var node = root;\n    while (true) {\n      commitUnmount(node);\n      // Visit children because they may contain more composite or host nodes.\n      // Skip portals because commitUnmount() currently visits them recursively.\n      if (node.child !== null && (\n      // If we use mutation we drill down into portals using commitUnmount above.\n      // If we don't use mutation we drill down into portals here instead.\n      !mutation || node.tag !== HostPortal)) {\n        node.child['return'] = node;\n        node = node.child;\n        continue;\n      }\n      if (node === root) {\n        return;\n      }\n      while (node.sibling === null) {\n        if (node['return'] === null || node['return'] === root) {\n          return;\n        }\n        node = node['return'];\n      }\n      node.sibling['return'] = node['return'];\n      node = node.sibling;\n    }\n  }\n\n  function detachFiber(current) {\n    // Cut off the return pointers to disconnect it from the tree. Ideally, we\n    // should clear the child pointer of the parent alternate to let this\n    // get GC:ed but we don't know which for sure which parent is the current\n    // one so we'll settle for GC:ing the subtree of this child. This child\n    // itself will be GC:ed when the parent updates the next time.\n    current['return'] = null;\n    current.child = null;\n    if (current.alternate) {\n      current.alternate.child = null;\n      current.alternate['return'] = null;\n    }\n  }\n\n  if (!mutation) {\n    var commitContainer = void 0;\n    if (persistence) {\n      var replaceContainerChildren = persistence.replaceContainerChildren,\n          createContainerChildSet = persistence.createContainerChildSet;\n\n      var emptyPortalContainer = function (current) {\n        var portal = current.stateNode;\n        var containerInfo = portal.containerInfo;\n\n        var emptyChildSet = createContainerChildSet(containerInfo);\n        replaceContainerChildren(containerInfo, emptyChildSet);\n      };\n      commitContainer = function (finishedWork) {\n        switch (finishedWork.tag) {\n          case ClassComponent:\n            {\n              return;\n            }\n          case HostComponent:\n            {\n              return;\n            }\n          case HostText:\n            {\n              return;\n            }\n          case HostRoot:\n          case HostPortal:\n            {\n              var portalOrRoot = finishedWork.stateNode;\n              var containerInfo = portalOrRoot.containerInfo,\n                  _pendingChildren = portalOrRoot.pendingChildren;\n\n              replaceContainerChildren(containerInfo, _pendingChildren);\n              return;\n            }\n          default:\n            {\n              invariant(false, 'This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.');\n            }\n        }\n      };\n    } else {\n      commitContainer = function (finishedWork) {\n        // Noop\n      };\n    }\n    if (enablePersistentReconciler || enableNoopReconciler) {\n      return {\n        commitResetTextContent: function (finishedWork) {},\n        commitPlacement: function (finishedWork) {},\n        commitDeletion: function (current) {\n          // Detach refs and call componentWillUnmount() on the whole subtree.\n          commitNestedUnmounts(current);\n          detachFiber(current);\n        },\n        commitWork: function (current, finishedWork) {\n          commitContainer(finishedWork);\n        },\n\n        commitLifeCycles: commitLifeCycles,\n        commitAttachRef: commitAttachRef,\n        commitDetachRef: commitDetachRef\n      };\n    } else if (persistence) {\n      invariant(false, 'Persistent reconciler is disabled.');\n    } else {\n      invariant(false, 'Noop reconciler is disabled.');\n    }\n  }\n  var commitMount = mutation.commitMount,\n      commitUpdate = mutation.commitUpdate,\n      resetTextContent = mutation.resetTextContent,\n      commitTextUpdate = mutation.commitTextUpdate,\n      appendChild = mutation.appendChild,\n      appendChildToContainer = mutation.appendChildToContainer,\n      insertBefore = mutation.insertBefore,\n      insertInContainerBefore = mutation.insertInContainerBefore,\n      removeChild = mutation.removeChild,\n      removeChildFromContainer = mutation.removeChildFromContainer;\n\n\n  function getHostParentFiber(fiber) {\n    var parent = fiber['return'];\n    while (parent !== null) {\n      if (isHostParent(parent)) {\n        return parent;\n      }\n      parent = parent['return'];\n    }\n    invariant(false, 'Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.');\n  }\n\n  function isHostParent(fiber) {\n    return fiber.tag === HostComponent || fiber.tag === HostRoot || fiber.tag === HostPortal;\n  }\n\n  function getHostSibling(fiber) {\n    // We're going to search forward into the tree until we find a sibling host\n    // node. Unfortunately, if multiple insertions are done in a row we have to\n    // search past them. This leads to exponential search for the next sibling.\n    var node = fiber;\n    siblings: while (true) {\n      // If we didn't find anything, let's try the next sibling.\n      while (node.sibling === null) {\n        if (node['return'] === null || isHostParent(node['return'])) {\n          // If we pop out of the root or hit the parent the fiber we are the\n          // last sibling.\n          return null;\n        }\n        node = node['return'];\n      }\n      node.sibling['return'] = node['return'];\n      node = node.sibling;\n      while (node.tag !== HostComponent && node.tag !== HostText) {\n        // If it is not host node and, we might have a host node inside it.\n        // Try to search down until we find one.\n        if (node.effectTag & Placement) {\n          // If we don't have a child, try the siblings instead.\n          continue siblings;\n        }\n        // If we don't have a child, try the siblings instead.\n        // We also skip portals because they are not part of this host tree.\n        if (node.child === null || node.tag === HostPortal) {\n          continue siblings;\n        } else {\n          node.child['return'] = node;\n          node = node.child;\n        }\n      }\n      // Check if this host node is stable or about to be placed.\n      if (!(node.effectTag & Placement)) {\n        // Found it!\n        return node.stateNode;\n      }\n    }\n  }\n\n  function commitPlacement(finishedWork) {\n    // Recursively insert all host nodes into the parent.\n    var parentFiber = getHostParentFiber(finishedWork);\n    var parent = void 0;\n    var isContainer = void 0;\n    switch (parentFiber.tag) {\n      case HostComponent:\n        parent = parentFiber.stateNode;\n        isContainer = false;\n        break;\n      case HostRoot:\n        parent = parentFiber.stateNode.containerInfo;\n        isContainer = true;\n        break;\n      case HostPortal:\n        parent = parentFiber.stateNode.containerInfo;\n        isContainer = true;\n        break;\n      default:\n        invariant(false, 'Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue.');\n    }\n    if (parentFiber.effectTag & ContentReset) {\n      // Reset the text content of the parent before doing any insertions\n      resetTextContent(parent);\n      // Clear ContentReset from the effect tag\n      parentFiber.effectTag &= ~ContentReset;\n    }\n\n    var before = getHostSibling(finishedWork);\n    // We only have the top Fiber that was inserted but we need recurse down its\n    // children to find all the terminal nodes.\n    var node = finishedWork;\n    while (true) {\n      if (node.tag === HostComponent || node.tag === HostText) {\n        if (before) {\n          if (isContainer) {\n            insertInContainerBefore(parent, node.stateNode, before);\n          } else {\n            insertBefore(parent, node.stateNode, before);\n          }\n        } else {\n          if (isContainer) {\n            appendChildToContainer(parent, node.stateNode);\n          } else {\n            appendChild(parent, node.stateNode);\n          }\n        }\n      } else if (node.tag === HostPortal) {\n        // If the insertion itself is a portal, then we don't want to traverse\n        // down its children. Instead, we'll get insertions from each child in\n        // the portal directly.\n      } else if (node.child !== null) {\n        node.child['return'] = node;\n        node = node.child;\n        continue;\n      }\n      if (node === finishedWork) {\n        return;\n      }\n      while (node.sibling === null) {\n        if (node['return'] === null || node['return'] === finishedWork) {\n          return;\n        }\n        node = node['return'];\n      }\n      node.sibling['return'] = node['return'];\n      node = node.sibling;\n    }\n  }\n\n  function unmountHostComponents(current) {\n    // We only have the top Fiber that was inserted but we need recurse down its\n    var node = current;\n\n    // Each iteration, currentParent is populated with node's host parent if not\n    // currentParentIsValid.\n    var currentParentIsValid = false;\n    var currentParent = void 0;\n    var currentParentIsContainer = void 0;\n\n    while (true) {\n      if (!currentParentIsValid) {\n        var parent = node['return'];\n        findParent: while (true) {\n          !(parent !== null) ? invariant(false, 'Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n          switch (parent.tag) {\n            case HostComponent:\n              currentParent = parent.stateNode;\n              currentParentIsContainer = false;\n              break findParent;\n            case HostRoot:\n              currentParent = parent.stateNode.containerInfo;\n              currentParentIsContainer = true;\n              break findParent;\n            case HostPortal:\n              currentParent = parent.stateNode.containerInfo;\n              currentParentIsContainer = true;\n              break findParent;\n          }\n          parent = parent['return'];\n        }\n        currentParentIsValid = true;\n      }\n\n      if (node.tag === HostComponent || node.tag === HostText) {\n        commitNestedUnmounts(node);\n        // After all the children have unmounted, it is now safe to remove the\n        // node from the tree.\n        if (currentParentIsContainer) {\n          removeChildFromContainer(currentParent, node.stateNode);\n        } else {\n          removeChild(currentParent, node.stateNode);\n        }\n        // Don't visit children because we already visited them.\n      } else if (node.tag === HostPortal) {\n        // When we go into a portal, it becomes the parent to remove from.\n        // We will reassign it back when we pop the portal on the way up.\n        currentParent = node.stateNode.containerInfo;\n        // Visit children because portals might contain host components.\n        if (node.child !== null) {\n          node.child['return'] = node;\n          node = node.child;\n          continue;\n        }\n      } else {\n        commitUnmount(node);\n        // Visit children because we may find more host components below.\n        if (node.child !== null) {\n          node.child['return'] = node;\n          node = node.child;\n          continue;\n        }\n      }\n      if (node === current) {\n        return;\n      }\n      while (node.sibling === null) {\n        if (node['return'] === null || node['return'] === current) {\n          return;\n        }\n        node = node['return'];\n        if (node.tag === HostPortal) {\n          // When we go out of the portal, we need to restore the parent.\n          // Since we don't keep a stack of them, we will search for it.\n          currentParentIsValid = false;\n        }\n      }\n      node.sibling['return'] = node['return'];\n      node = node.sibling;\n    }\n  }\n\n  function commitDeletion(current) {\n    // Recursively delete all host nodes from the parent.\n    // Detach refs and call componentWillUnmount() on the whole subtree.\n    unmountHostComponents(current);\n    detachFiber(current);\n  }\n\n  function commitWork(current, finishedWork) {\n    switch (finishedWork.tag) {\n      case ClassComponent:\n        {\n          return;\n        }\n      case HostComponent:\n        {\n          var instance = finishedWork.stateNode;\n          if (instance != null) {\n            // Commit the work prepared earlier.\n            var newProps = finishedWork.memoizedProps;\n            // For hydration we reuse the update path but we treat the oldProps\n            // as the newProps. The updatePayload will contain the real change in\n            // this case.\n            var oldProps = current !== null ? current.memoizedProps : newProps;\n            var type = finishedWork.type;\n            // TODO: Type the updateQueue to be specific to host components.\n            var updatePayload = finishedWork.updateQueue;\n            finishedWork.updateQueue = null;\n            if (updatePayload !== null) {\n              commitUpdate(instance, updatePayload, type, oldProps, newProps, finishedWork);\n            }\n          }\n          return;\n        }\n      case HostText:\n        {\n          !(finishedWork.stateNode !== null) ? invariant(false, 'This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n          var textInstance = finishedWork.stateNode;\n          var newText = finishedWork.memoizedProps;\n          // For hydration we reuse the update path but we treat the oldProps\n          // as the newProps. The updatePayload will contain the real change in\n          // this case.\n          var oldText = current !== null ? current.memoizedProps : newText;\n          commitTextUpdate(textInstance, oldText, newText);\n          return;\n        }\n      case HostRoot:\n        {\n          return;\n        }\n      default:\n        {\n          invariant(false, 'This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.');\n        }\n    }\n  }\n\n  function commitResetTextContent(current) {\n    resetTextContent(current.stateNode);\n  }\n\n  if (enableMutatingReconciler) {\n    return {\n      commitResetTextContent: commitResetTextContent,\n      commitPlacement: commitPlacement,\n      commitDeletion: commitDeletion,\n      commitWork: commitWork,\n      commitLifeCycles: commitLifeCycles,\n      commitAttachRef: commitAttachRef,\n      commitDetachRef: commitDetachRef\n    };\n  } else {\n    invariant(false, 'Mutating reconciler is disabled.');\n  }\n};\n\nvar NO_CONTEXT = {};\n\nvar ReactFiberHostContext = function (config) {\n  var getChildHostContext = config.getChildHostContext,\n      getRootHostContext = config.getRootHostContext;\n\n\n  var contextStackCursor = createCursor(NO_CONTEXT);\n  var contextFiberStackCursor = createCursor(NO_CONTEXT);\n  var rootInstanceStackCursor = createCursor(NO_CONTEXT);\n\n  function requiredContext(c) {\n    !(c !== NO_CONTEXT) ? invariant(false, 'Expected host context to exist. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n    return c;\n  }\n\n  function getRootHostContainer() {\n    var rootInstance = requiredContext(rootInstanceStackCursor.current);\n    return rootInstance;\n  }\n\n  function pushHostContainer(fiber, nextRootInstance) {\n    // Push current root instance onto the stack;\n    // This allows us to reset root when portals are popped.\n    push(rootInstanceStackCursor, nextRootInstance, fiber);\n\n    var nextRootContext = getRootHostContext(nextRootInstance);\n\n    // Track the context and the Fiber that provided it.\n    // This enables us to pop only Fibers that provide unique contexts.\n    push(contextFiberStackCursor, fiber, fiber);\n    push(contextStackCursor, nextRootContext, fiber);\n  }\n\n  function popHostContainer(fiber) {\n    pop(contextStackCursor, fiber);\n    pop(contextFiberStackCursor, fiber);\n    pop(rootInstanceStackCursor, fiber);\n  }\n\n  function getHostContext() {\n    var context = requiredContext(contextStackCursor.current);\n    return context;\n  }\n\n  function pushHostContext(fiber) {\n    var rootInstance = requiredContext(rootInstanceStackCursor.current);\n    var context = requiredContext(contextStackCursor.current);\n    var nextContext = getChildHostContext(context, fiber.type, rootInstance);\n\n    // Don't push this Fiber's context unless it's unique.\n    if (context === nextContext) {\n      return;\n    }\n\n    // Track the context and the Fiber that provided it.\n    // This enables us to pop only Fibers that provide unique contexts.\n    push(contextFiberStackCursor, fiber, fiber);\n    push(contextStackCursor, nextContext, fiber);\n  }\n\n  function popHostContext(fiber) {\n    // Do not pop unless this Fiber provided the current context.\n    // pushHostContext() only pushes Fibers that provide unique contexts.\n    if (contextFiberStackCursor.current !== fiber) {\n      return;\n    }\n\n    pop(contextStackCursor, fiber);\n    pop(contextFiberStackCursor, fiber);\n  }\n\n  function resetHostContainer() {\n    contextStackCursor.current = NO_CONTEXT;\n    rootInstanceStackCursor.current = NO_CONTEXT;\n  }\n\n  return {\n    getHostContext: getHostContext,\n    getRootHostContainer: getRootHostContainer,\n    popHostContainer: popHostContainer,\n    popHostContext: popHostContext,\n    pushHostContainer: pushHostContainer,\n    pushHostContext: pushHostContext,\n    resetHostContainer: resetHostContainer\n  };\n};\n\nvar ReactFiberHydrationContext = function (config) {\n  var shouldSetTextContent = config.shouldSetTextContent,\n      hydration = config.hydration;\n\n  // If this doesn't have hydration mode.\n\n  if (!hydration) {\n    return {\n      enterHydrationState: function () {\n        return false;\n      },\n      resetHydrationState: function () {},\n      tryToClaimNextHydratableInstance: function () {},\n      prepareToHydrateHostInstance: function () {\n        invariant(false, 'Expected prepareToHydrateHostInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.');\n      },\n      prepareToHydrateHostTextInstance: function () {\n        invariant(false, 'Expected prepareToHydrateHostTextInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.');\n      },\n      popHydrationState: function (fiber) {\n        return false;\n      }\n    };\n  }\n\n  var canHydrateInstance = hydration.canHydrateInstance,\n      canHydrateTextInstance = hydration.canHydrateTextInstance,\n      getNextHydratableSibling = hydration.getNextHydratableSibling,\n      getFirstHydratableChild = hydration.getFirstHydratableChild,\n      hydrateInstance = hydration.hydrateInstance,\n      hydrateTextInstance = hydration.hydrateTextInstance,\n      didNotMatchHydratedContainerTextInstance = hydration.didNotMatchHydratedContainerTextInstance,\n      didNotMatchHydratedTextInstance = hydration.didNotMatchHydratedTextInstance,\n      didNotHydrateContainerInstance = hydration.didNotHydrateContainerInstance,\n      didNotHydrateInstance = hydration.didNotHydrateInstance,\n      didNotFindHydratableContainerInstance = hydration.didNotFindHydratableContainerInstance,\n      didNotFindHydratableContainerTextInstance = hydration.didNotFindHydratableContainerTextInstance,\n      didNotFindHydratableInstance = hydration.didNotFindHydratableInstance,\n      didNotFindHydratableTextInstance = hydration.didNotFindHydratableTextInstance;\n\n  // The deepest Fiber on the stack involved in a hydration context.\n  // This may have been an insertion or a hydration.\n\n  var hydrationParentFiber = null;\n  var nextHydratableInstance = null;\n  var isHydrating = false;\n\n  function enterHydrationState(fiber) {\n    var parentInstance = fiber.stateNode.containerInfo;\n    nextHydratableInstance = getFirstHydratableChild(parentInstance);\n    hydrationParentFiber = fiber;\n    isHydrating = true;\n    return true;\n  }\n\n  function deleteHydratableInstance(returnFiber, instance) {\n    {\n      switch (returnFiber.tag) {\n        case HostRoot:\n          didNotHydrateContainerInstance(returnFiber.stateNode.containerInfo, instance);\n          break;\n        case HostComponent:\n          didNotHydrateInstance(returnFiber.type, returnFiber.memoizedProps, returnFiber.stateNode, instance);\n          break;\n      }\n    }\n\n    var childToDelete = createFiberFromHostInstanceForDeletion();\n    childToDelete.stateNode = instance;\n    childToDelete['return'] = returnFiber;\n    childToDelete.effectTag = Deletion;\n\n    // This might seem like it belongs on progressedFirstDeletion. However,\n    // these children are not part of the reconciliation list of children.\n    // Even if we abort and rereconcile the children, that will try to hydrate\n    // again and the nodes are still in the host tree so these will be\n    // recreated.\n    if (returnFiber.lastEffect !== null) {\n      returnFiber.lastEffect.nextEffect = childToDelete;\n      returnFiber.lastEffect = childToDelete;\n    } else {\n      returnFiber.firstEffect = returnFiber.lastEffect = childToDelete;\n    }\n  }\n\n  function insertNonHydratedInstance(returnFiber, fiber) {\n    fiber.effectTag |= Placement;\n    {\n      switch (returnFiber.tag) {\n        case HostRoot:\n          {\n            var parentContainer = returnFiber.stateNode.containerInfo;\n            switch (fiber.tag) {\n              case HostComponent:\n                var type = fiber.type;\n                var props = fiber.pendingProps;\n                didNotFindHydratableContainerInstance(parentContainer, type, props);\n                break;\n              case HostText:\n                var text = fiber.pendingProps;\n                didNotFindHydratableContainerTextInstance(parentContainer, text);\n                break;\n            }\n            break;\n          }\n        case HostComponent:\n          {\n            var parentType = returnFiber.type;\n            var parentProps = returnFiber.memoizedProps;\n            var parentInstance = returnFiber.stateNode;\n            switch (fiber.tag) {\n              case HostComponent:\n                var _type = fiber.type;\n                var _props = fiber.pendingProps;\n                didNotFindHydratableInstance(parentType, parentProps, parentInstance, _type, _props);\n                break;\n              case HostText:\n                var _text = fiber.pendingProps;\n                didNotFindHydratableTextInstance(parentType, parentProps, parentInstance, _text);\n                break;\n            }\n            break;\n          }\n        default:\n          return;\n      }\n    }\n  }\n\n  function tryHydrate(fiber, nextInstance) {\n    switch (fiber.tag) {\n      case HostComponent:\n        {\n          var type = fiber.type;\n          var props = fiber.pendingProps;\n          var instance = canHydrateInstance(nextInstance, type, props);\n          if (instance !== null) {\n            fiber.stateNode = instance;\n            return true;\n          }\n          return false;\n        }\n      case HostText:\n        {\n          var text = fiber.pendingProps;\n          var textInstance = canHydrateTextInstance(nextInstance, text);\n          if (textInstance !== null) {\n            fiber.stateNode = textInstance;\n            return true;\n          }\n          return false;\n        }\n      default:\n        return false;\n    }\n  }\n\n  function tryToClaimNextHydratableInstance(fiber) {\n    if (!isHydrating) {\n      return;\n    }\n    var nextInstance = nextHydratableInstance;\n    if (!nextInstance) {\n      // Nothing to hydrate. Make it an insertion.\n      insertNonHydratedInstance(hydrationParentFiber, fiber);\n      isHydrating = false;\n      hydrationParentFiber = fiber;\n      return;\n    }\n    if (!tryHydrate(fiber, nextInstance)) {\n      // If we can't hydrate this instance let's try the next one.\n      // We use this as a heuristic. It's based on intuition and not data so it\n      // might be flawed or unnecessary.\n      nextInstance = getNextHydratableSibling(nextInstance);\n      if (!nextInstance || !tryHydrate(fiber, nextInstance)) {\n        // Nothing to hydrate. Make it an insertion.\n        insertNonHydratedInstance(hydrationParentFiber, fiber);\n        isHydrating = false;\n        hydrationParentFiber = fiber;\n        return;\n      }\n      // We matched the next one, we'll now assume that the first one was\n      // superfluous and we'll delete it. Since we can't eagerly delete it\n      // we'll have to schedule a deletion. To do that, this node needs a dummy\n      // fiber associated with it.\n      deleteHydratableInstance(hydrationParentFiber, nextHydratableInstance);\n    }\n    hydrationParentFiber = fiber;\n    nextHydratableInstance = getFirstHydratableChild(nextInstance);\n  }\n\n  function prepareToHydrateHostInstance(fiber, rootContainerInstance, hostContext) {\n    var instance = fiber.stateNode;\n    var updatePayload = hydrateInstance(instance, fiber.type, fiber.memoizedProps, rootContainerInstance, hostContext, fiber);\n    // TODO: Type this specific to this type of component.\n    fiber.updateQueue = updatePayload;\n    // If the update payload indicates that there is a change or if there\n    // is a new ref we mark this as an update.\n    if (updatePayload !== null) {\n      return true;\n    }\n    return false;\n  }\n\n  function prepareToHydrateHostTextInstance(fiber) {\n    var textInstance = fiber.stateNode;\n    var textContent = fiber.memoizedProps;\n    var shouldUpdate = hydrateTextInstance(textInstance, textContent, fiber);\n    {\n      if (shouldUpdate) {\n        // We assume that prepareToHydrateHostTextInstance is called in a context where the\n        // hydration parent is the parent host component of this host text.\n        var returnFiber = hydrationParentFiber;\n        if (returnFiber !== null) {\n          switch (returnFiber.tag) {\n            case HostRoot:\n              {\n                var parentContainer = returnFiber.stateNode.containerInfo;\n                didNotMatchHydratedContainerTextInstance(parentContainer, textInstance, textContent);\n                break;\n              }\n            case HostComponent:\n              {\n                var parentType = returnFiber.type;\n                var parentProps = returnFiber.memoizedProps;\n                var parentInstance = returnFiber.stateNode;\n                didNotMatchHydratedTextInstance(parentType, parentProps, parentInstance, textInstance, textContent);\n                break;\n              }\n          }\n        }\n      }\n    }\n    return shouldUpdate;\n  }\n\n  function popToNextHostParent(fiber) {\n    var parent = fiber['return'];\n    while (parent !== null && parent.tag !== HostComponent && parent.tag !== HostRoot) {\n      parent = parent['return'];\n    }\n    hydrationParentFiber = parent;\n  }\n\n  function popHydrationState(fiber) {\n    if (fiber !== hydrationParentFiber) {\n      // We're deeper than the current hydration context, inside an inserted\n      // tree.\n      return false;\n    }\n    if (!isHydrating) {\n      // If we're not currently hydrating but we're in a hydration context, then\n      // we were an insertion and now need to pop up reenter hydration of our\n      // siblings.\n      popToNextHostParent(fiber);\n      isHydrating = true;\n      return false;\n    }\n\n    var type = fiber.type;\n\n    // If we have any remaining hydratable nodes, we need to delete them now.\n    // We only do this deeper than head and body since they tend to have random\n    // other nodes in them. We also ignore components with pure text content in\n    // side of them.\n    // TODO: Better heuristic.\n    if (fiber.tag !== HostComponent || type !== 'head' && type !== 'body' && !shouldSetTextContent(type, fiber.memoizedProps)) {\n      var nextInstance = nextHydratableInstance;\n      while (nextInstance) {\n        deleteHydratableInstance(fiber, nextInstance);\n        nextInstance = getNextHydratableSibling(nextInstance);\n      }\n    }\n\n    popToNextHostParent(fiber);\n    nextHydratableInstance = hydrationParentFiber ? getNextHydratableSibling(fiber.stateNode) : null;\n    return true;\n  }\n\n  function resetHydrationState() {\n    hydrationParentFiber = null;\n    nextHydratableInstance = null;\n    isHydrating = false;\n  }\n\n  return {\n    enterHydrationState: enterHydrationState,\n    resetHydrationState: resetHydrationState,\n    tryToClaimNextHydratableInstance: tryToClaimNextHydratableInstance,\n    prepareToHydrateHostInstance: prepareToHydrateHostInstance,\n    prepareToHydrateHostTextInstance: prepareToHydrateHostTextInstance,\n    popHydrationState: popHydrationState\n  };\n};\n\n// This lets us hook into Fiber to debug what it's doing.\n// See https://github.com/facebook/react/pull/8033.\n// This is not part of the public API, not even for React DevTools.\n// You may only inject a debugTool if you work on React Fiber itself.\nvar ReactFiberInstrumentation = {\n  debugTool: null\n};\n\nvar ReactFiberInstrumentation_1 = ReactFiberInstrumentation;\n\nvar defaultShowDialog = function (capturedError) {\n  return true;\n};\n\nvar showDialog = defaultShowDialog;\n\nfunction logCapturedError(capturedError) {\n  var logError = showDialog(capturedError);\n\n  // Allow injected showDialog() to prevent default console.error logging.\n  // This enables renderers like ReactNative to better manage redbox behavior.\n  if (logError === false) {\n    return;\n  }\n\n  var error = capturedError.error;\n  var suppressLogging = error && error.suppressReactErrorLogging;\n  if (suppressLogging) {\n    return;\n  }\n\n  {\n    var componentName = capturedError.componentName,\n        componentStack = capturedError.componentStack,\n        errorBoundaryName = capturedError.errorBoundaryName,\n        errorBoundaryFound = capturedError.errorBoundaryFound,\n        willRetry = capturedError.willRetry;\n\n\n    var componentNameMessage = componentName ? 'The above error occurred in the <' + componentName + '> component:' : 'The above error occurred in one of your React components:';\n\n    var errorBoundaryMessage = void 0;\n    // errorBoundaryFound check is sufficient; errorBoundaryName check is to satisfy Flow.\n    if (errorBoundaryFound && errorBoundaryName) {\n      if (willRetry) {\n        errorBoundaryMessage = 'React will try to recreate this component tree from scratch ' + ('using the error boundary you provided, ' + errorBoundaryName + '.');\n      } else {\n        errorBoundaryMessage = 'This error was initially handled by the error boundary ' + errorBoundaryName + '.\\n' + 'Recreating the tree from scratch failed so React will unmount the tree.';\n      }\n    } else {\n      errorBoundaryMessage = 'Consider adding an error boundary to your tree to customize error handling behavior.\\n' + 'Visit https://fb.me/react-error-boundaries to learn more about error boundaries.';\n    }\n    var combinedMessage = '' + componentNameMessage + componentStack + '\\n\\n' + ('' + errorBoundaryMessage);\n\n    // In development, we provide our own message with just the component stack.\n    // We don't include the original error message and JS stack because the browser\n    // has already printed it. Even if the application swallows the error, it is still\n    // displayed by the browser thanks to the DEV-only fake event trick in ReactErrorUtils.\n    console.error(combinedMessage);\n  }\n}\n\nvar invokeGuardedCallback = ReactErrorUtils.invokeGuardedCallback;\nvar hasCaughtError = ReactErrorUtils.hasCaughtError;\nvar clearCaughtError = ReactErrorUtils.clearCaughtError;\n\n\n{\n  var didWarnAboutStateTransition = false;\n  var didWarnSetStateChildContext = false;\n  var didWarnStateUpdateForUnmountedComponent = {};\n\n  var warnAboutUpdateOnUnmounted = function (fiber) {\n    var componentName = getComponentName(fiber) || 'ReactClass';\n    if (didWarnStateUpdateForUnmountedComponent[componentName]) {\n      return;\n    }\n    warning(false, 'Can only update a mounted or mounting ' + 'component. This usually means you called setState, replaceState, ' + 'or forceUpdate on an unmounted component. This is a no-op.\\n\\nPlease ' + 'check the code for the %s component.', componentName);\n    didWarnStateUpdateForUnmountedComponent[componentName] = true;\n  };\n\n  var warnAboutInvalidUpdates = function (instance) {\n    switch (ReactDebugCurrentFiber.phase) {\n      case 'getChildContext':\n        if (didWarnSetStateChildContext) {\n          return;\n        }\n        warning(false, 'setState(...): Cannot call setState() inside getChildContext()');\n        didWarnSetStateChildContext = true;\n        break;\n      case 'render':\n        if (didWarnAboutStateTransition) {\n          return;\n        }\n        warning(false, 'Cannot update during an existing state transition (such as within ' + \"`render` or another component's constructor). Render methods should \" + 'be a pure function of props and state; constructor side-effects are ' + 'an anti-pattern, but can be moved to `componentWillMount`.');\n        didWarnAboutStateTransition = true;\n        break;\n    }\n  };\n}\n\nvar ReactFiberScheduler = function (config) {\n  var hostContext = ReactFiberHostContext(config);\n  var hydrationContext = ReactFiberHydrationContext(config);\n  var popHostContainer = hostContext.popHostContainer,\n      popHostContext = hostContext.popHostContext,\n      resetHostContainer = hostContext.resetHostContainer;\n\n  var _ReactFiberBeginWork = ReactFiberBeginWork(config, hostContext, hydrationContext, scheduleWork, computeExpirationForFiber),\n      beginWork = _ReactFiberBeginWork.beginWork,\n      beginFailedWork = _ReactFiberBeginWork.beginFailedWork;\n\n  var _ReactFiberCompleteWo = ReactFiberCompleteWork(config, hostContext, hydrationContext),\n      completeWork = _ReactFiberCompleteWo.completeWork;\n\n  var _ReactFiberCommitWork = ReactFiberCommitWork(config, captureError),\n      commitResetTextContent = _ReactFiberCommitWork.commitResetTextContent,\n      commitPlacement = _ReactFiberCommitWork.commitPlacement,\n      commitDeletion = _ReactFiberCommitWork.commitDeletion,\n      commitWork = _ReactFiberCommitWork.commitWork,\n      commitLifeCycles = _ReactFiberCommitWork.commitLifeCycles,\n      commitAttachRef = _ReactFiberCommitWork.commitAttachRef,\n      commitDetachRef = _ReactFiberCommitWork.commitDetachRef;\n\n  var now = config.now,\n      scheduleDeferredCallback = config.scheduleDeferredCallback,\n      cancelDeferredCallback = config.cancelDeferredCallback,\n      useSyncScheduling = config.useSyncScheduling,\n      prepareForCommit = config.prepareForCommit,\n      resetAfterCommit = config.resetAfterCommit;\n\n  // Represents the current time in ms.\n\n  var startTime = now();\n  var mostRecentCurrentTime = msToExpirationTime(0);\n\n  // Represents the expiration time that incoming updates should use. (If this\n  // is NoWork, use the default strategy: async updates in async mode, sync\n  // updates in sync mode.)\n  var expirationContext = NoWork;\n\n  var isWorking = false;\n\n  // The next work in progress fiber that we're currently working on.\n  var nextUnitOfWork = null;\n  var nextRoot = null;\n  // The time at which we're currently rendering work.\n  var nextRenderExpirationTime = NoWork;\n\n  // The next fiber with an effect that we're currently committing.\n  var nextEffect = null;\n\n  // Keep track of which fibers have captured an error that need to be handled.\n  // Work is removed from this collection after componentDidCatch is called.\n  var capturedErrors = null;\n  // Keep track of which fibers have failed during the current batch of work.\n  // This is a different set than capturedErrors, because it is not reset until\n  // the end of the batch. This is needed to propagate errors correctly if a\n  // subtree fails more than once.\n  var failedBoundaries = null;\n  // Error boundaries that captured an error during the current commit.\n  var commitPhaseBoundaries = null;\n  var firstUncaughtError = null;\n  var didFatal = false;\n\n  var isCommitting = false;\n  var isUnmounting = false;\n\n  // Used for performance tracking.\n  var interruptedBy = null;\n\n  function resetContextStack() {\n    // Reset the stack\n    reset();\n    // Reset the cursors\n    resetContext();\n    resetHostContainer();\n  }\n\n  function commitAllHostEffects() {\n    while (nextEffect !== null) {\n      {\n        ReactDebugCurrentFiber.setCurrentFiber(nextEffect);\n      }\n      recordEffect();\n\n      var effectTag = nextEffect.effectTag;\n      if (effectTag & ContentReset) {\n        commitResetTextContent(nextEffect);\n      }\n\n      if (effectTag & Ref) {\n        var current = nextEffect.alternate;\n        if (current !== null) {\n          commitDetachRef(current);\n        }\n      }\n\n      // The following switch statement is only concerned about placement,\n      // updates, and deletions. To avoid needing to add a case for every\n      // possible bitmap value, we remove the secondary effects from the\n      // effect tag and switch on that value.\n      var primaryEffectTag = effectTag & ~(Callback | Err | ContentReset | Ref | PerformedWork);\n      switch (primaryEffectTag) {\n        case Placement:\n          {\n            commitPlacement(nextEffect);\n            // Clear the \"placement\" from effect tag so that we know that this is inserted, before\n            // any life-cycles like componentDidMount gets called.\n            // TODO: findDOMNode doesn't rely on this any more but isMounted\n            // does and isMounted is deprecated anyway so we should be able\n            // to kill this.\n            nextEffect.effectTag &= ~Placement;\n            break;\n          }\n        case PlacementAndUpdate:\n          {\n            // Placement\n            commitPlacement(nextEffect);\n            // Clear the \"placement\" from effect tag so that we know that this is inserted, before\n            // any life-cycles like componentDidMount gets called.\n            nextEffect.effectTag &= ~Placement;\n\n            // Update\n            var _current = nextEffect.alternate;\n            commitWork(_current, nextEffect);\n            break;\n          }\n        case Update:\n          {\n            var _current2 = nextEffect.alternate;\n            commitWork(_current2, nextEffect);\n            break;\n          }\n        case Deletion:\n          {\n            isUnmounting = true;\n            commitDeletion(nextEffect);\n            isUnmounting = false;\n            break;\n          }\n      }\n      nextEffect = nextEffect.nextEffect;\n    }\n\n    {\n      ReactDebugCurrentFiber.resetCurrentFiber();\n    }\n  }\n\n  function commitAllLifeCycles() {\n    while (nextEffect !== null) {\n      var effectTag = nextEffect.effectTag;\n\n      if (effectTag & (Update | Callback)) {\n        recordEffect();\n        var current = nextEffect.alternate;\n        commitLifeCycles(current, nextEffect);\n      }\n\n      if (effectTag & Ref) {\n        recordEffect();\n        commitAttachRef(nextEffect);\n      }\n\n      if (effectTag & Err) {\n        recordEffect();\n        commitErrorHandling(nextEffect);\n      }\n\n      var next = nextEffect.nextEffect;\n      // Ensure that we clean these up so that we don't accidentally keep them.\n      // I'm not actually sure this matters because we can't reset firstEffect\n      // and lastEffect since they're on every node, not just the effectful\n      // ones. So we have to clean everything as we reuse nodes anyway.\n      nextEffect.nextEffect = null;\n      // Ensure that we reset the effectTag here so that we can rely on effect\n      // tags to reason about the current life-cycle.\n      nextEffect = next;\n    }\n  }\n\n  function commitRoot(finishedWork) {\n    // We keep track of this so that captureError can collect any boundaries\n    // that capture an error during the commit phase. The reason these aren't\n    // local to this function is because errors that occur during cWU are\n    // captured elsewhere, to prevent the unmount from being interrupted.\n    isWorking = true;\n    isCommitting = true;\n    startCommitTimer();\n\n    var root = finishedWork.stateNode;\n    !(root.current !== finishedWork) ? invariant(false, 'Cannot commit the same tree as before. This is probably a bug related to the return field. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n    root.isReadyForCommit = false;\n\n    // Reset this to null before calling lifecycles\n    ReactCurrentOwner.current = null;\n\n    var firstEffect = void 0;\n    if (finishedWork.effectTag > PerformedWork) {\n      // A fiber's effect list consists only of its children, not itself. So if\n      // the root has an effect, we need to add it to the end of the list. The\n      // resulting list is the set that would belong to the root's parent, if\n      // it had one; that is, all the effects in the tree including the root.\n      if (finishedWork.lastEffect !== null) {\n        finishedWork.lastEffect.nextEffect = finishedWork;\n        firstEffect = finishedWork.firstEffect;\n      } else {\n        firstEffect = finishedWork;\n      }\n    } else {\n      // There is no effect on the root.\n      firstEffect = finishedWork.firstEffect;\n    }\n\n    prepareForCommit();\n\n    // Commit all the side-effects within a tree. We'll do this in two passes.\n    // The first pass performs all the host insertions, updates, deletions and\n    // ref unmounts.\n    nextEffect = firstEffect;\n    startCommitHostEffectsTimer();\n    while (nextEffect !== null) {\n      var didError = false;\n      var _error = void 0;\n      {\n        invokeGuardedCallback(null, commitAllHostEffects, null);\n        if (hasCaughtError()) {\n          didError = true;\n          _error = clearCaughtError();\n        }\n      }\n      if (didError) {\n        !(nextEffect !== null) ? invariant(false, 'Should have next effect. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n        captureError(nextEffect, _error);\n        // Clean-up\n        if (nextEffect !== null) {\n          nextEffect = nextEffect.nextEffect;\n        }\n      }\n    }\n    stopCommitHostEffectsTimer();\n\n    resetAfterCommit();\n\n    // The work-in-progress tree is now the current tree. This must come after\n    // the first pass of the commit phase, so that the previous tree is still\n    // current during componentWillUnmount, but before the second pass, so that\n    // the finished work is current during componentDidMount/Update.\n    root.current = finishedWork;\n\n    // In the second pass we'll perform all life-cycles and ref callbacks.\n    // Life-cycles happen as a separate pass so that all placements, updates,\n    // and deletions in the entire tree have already been invoked.\n    // This pass also triggers any renderer-specific initial effects.\n    nextEffect = firstEffect;\n    startCommitLifeCyclesTimer();\n    while (nextEffect !== null) {\n      var _didError = false;\n      var _error2 = void 0;\n      {\n        invokeGuardedCallback(null, commitAllLifeCycles, null);\n        if (hasCaughtError()) {\n          _didError = true;\n          _error2 = clearCaughtError();\n        }\n      }\n      if (_didError) {\n        !(nextEffect !== null) ? invariant(false, 'Should have next effect. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n        captureError(nextEffect, _error2);\n        if (nextEffect !== null) {\n          nextEffect = nextEffect.nextEffect;\n        }\n      }\n    }\n\n    isCommitting = false;\n    isWorking = false;\n    stopCommitLifeCyclesTimer();\n    stopCommitTimer();\n    if (typeof onCommitRoot === 'function') {\n      onCommitRoot(finishedWork.stateNode);\n    }\n    if (true && ReactFiberInstrumentation_1.debugTool) {\n      ReactFiberInstrumentation_1.debugTool.onCommitWork(finishedWork);\n    }\n\n    // If we caught any errors during this commit, schedule their boundaries\n    // to update.\n    if (commitPhaseBoundaries) {\n      commitPhaseBoundaries.forEach(scheduleErrorRecovery);\n      commitPhaseBoundaries = null;\n    }\n\n    if (firstUncaughtError !== null) {\n      var _error3 = firstUncaughtError;\n      firstUncaughtError = null;\n      onUncaughtError(_error3);\n    }\n\n    var remainingTime = root.current.expirationTime;\n\n    if (remainingTime === NoWork) {\n      capturedErrors = null;\n      failedBoundaries = null;\n    }\n\n    return remainingTime;\n  }\n\n  function resetExpirationTime(workInProgress, renderTime) {\n    if (renderTime !== Never && workInProgress.expirationTime === Never) {\n      // The children of this component are hidden. Don't bubble their\n      // expiration times.\n      return;\n    }\n\n    // Check for pending updates.\n    var newExpirationTime = getUpdateExpirationTime(workInProgress);\n\n    // TODO: Calls need to visit stateNode\n\n    // Bubble up the earliest expiration time.\n    var child = workInProgress.child;\n    while (child !== null) {\n      if (child.expirationTime !== NoWork && (newExpirationTime === NoWork || newExpirationTime > child.expirationTime)) {\n        newExpirationTime = child.expirationTime;\n      }\n      child = child.sibling;\n    }\n    workInProgress.expirationTime = newExpirationTime;\n  }\n\n  function completeUnitOfWork(workInProgress) {\n    while (true) {\n      // The current, flushed, state of this fiber is the alternate.\n      // Ideally nothing should rely on this, but relying on it here\n      // means that we don't need an additional field on the work in\n      // progress.\n      var current = workInProgress.alternate;\n      {\n        ReactDebugCurrentFiber.setCurrentFiber(workInProgress);\n      }\n      var next = completeWork(current, workInProgress, nextRenderExpirationTime);\n      {\n        ReactDebugCurrentFiber.resetCurrentFiber();\n      }\n\n      var returnFiber = workInProgress['return'];\n      var siblingFiber = workInProgress.sibling;\n\n      resetExpirationTime(workInProgress, nextRenderExpirationTime);\n\n      if (next !== null) {\n        stopWorkTimer(workInProgress);\n        if (true && ReactFiberInstrumentation_1.debugTool) {\n          ReactFiberInstrumentation_1.debugTool.onCompleteWork(workInProgress);\n        }\n        // If completing this work spawned new work, do that next. We'll come\n        // back here again.\n        return next;\n      }\n\n      if (returnFiber !== null) {\n        // Append all the effects of the subtree and this fiber onto the effect\n        // list of the parent. The completion order of the children affects the\n        // side-effect order.\n        if (returnFiber.firstEffect === null) {\n          returnFiber.firstEffect = workInProgress.firstEffect;\n        }\n        if (workInProgress.lastEffect !== null) {\n          if (returnFiber.lastEffect !== null) {\n            returnFiber.lastEffect.nextEffect = workInProgress.firstEffect;\n          }\n          returnFiber.lastEffect = workInProgress.lastEffect;\n        }\n\n        // If this fiber had side-effects, we append it AFTER the children's\n        // side-effects. We can perform certain side-effects earlier if\n        // needed, by doing multiple passes over the effect list. We don't want\n        // to schedule our own side-effect on our own list because if end up\n        // reusing children we'll schedule this effect onto itself since we're\n        // at the end.\n        var effectTag = workInProgress.effectTag;\n        // Skip both NoWork and PerformedWork tags when creating the effect list.\n        // PerformedWork effect is read by React DevTools but shouldn't be committed.\n        if (effectTag > PerformedWork) {\n          if (returnFiber.lastEffect !== null) {\n            returnFiber.lastEffect.nextEffect = workInProgress;\n          } else {\n            returnFiber.firstEffect = workInProgress;\n          }\n          returnFiber.lastEffect = workInProgress;\n        }\n      }\n\n      stopWorkTimer(workInProgress);\n      if (true && ReactFiberInstrumentation_1.debugTool) {\n        ReactFiberInstrumentation_1.debugTool.onCompleteWork(workInProgress);\n      }\n\n      if (siblingFiber !== null) {\n        // If there is more work to do in this returnFiber, do that next.\n        return siblingFiber;\n      } else if (returnFiber !== null) {\n        // If there's no more work in this returnFiber. Complete the returnFiber.\n        workInProgress = returnFiber;\n        continue;\n      } else {\n        // We've reached the root.\n        var root = workInProgress.stateNode;\n        root.isReadyForCommit = true;\n        return null;\n      }\n    }\n\n    // Without this explicit null return Flow complains of invalid return type\n    // TODO Remove the above while(true) loop\n    // eslint-disable-next-line no-unreachable\n    return null;\n  }\n\n  function performUnitOfWork(workInProgress) {\n    // The current, flushed, state of this fiber is the alternate.\n    // Ideally nothing should rely on this, but relying on it here\n    // means that we don't need an additional field on the work in\n    // progress.\n    var current = workInProgress.alternate;\n\n    // See if beginning this work spawns more work.\n    startWorkTimer(workInProgress);\n    {\n      ReactDebugCurrentFiber.setCurrentFiber(workInProgress);\n    }\n\n    var next = beginWork(current, workInProgress, nextRenderExpirationTime);\n    {\n      ReactDebugCurrentFiber.resetCurrentFiber();\n    }\n    if (true && ReactFiberInstrumentation_1.debugTool) {\n      ReactFiberInstrumentation_1.debugTool.onBeginWork(workInProgress);\n    }\n\n    if (next === null) {\n      // If this doesn't spawn new work, complete the current work.\n      next = completeUnitOfWork(workInProgress);\n    }\n\n    ReactCurrentOwner.current = null;\n\n    return next;\n  }\n\n  function performFailedUnitOfWork(workInProgress) {\n    // The current, flushed, state of this fiber is the alternate.\n    // Ideally nothing should rely on this, but relying on it here\n    // means that we don't need an additional field on the work in\n    // progress.\n    var current = workInProgress.alternate;\n\n    // See if beginning this work spawns more work.\n    startWorkTimer(workInProgress);\n    {\n      ReactDebugCurrentFiber.setCurrentFiber(workInProgress);\n    }\n    var next = beginFailedWork(current, workInProgress, nextRenderExpirationTime);\n    {\n      ReactDebugCurrentFiber.resetCurrentFiber();\n    }\n    if (true && ReactFiberInstrumentation_1.debugTool) {\n      ReactFiberInstrumentation_1.debugTool.onBeginWork(workInProgress);\n    }\n\n    if (next === null) {\n      // If this doesn't spawn new work, complete the current work.\n      next = completeUnitOfWork(workInProgress);\n    }\n\n    ReactCurrentOwner.current = null;\n\n    return next;\n  }\n\n  function workLoop(expirationTime) {\n    if (capturedErrors !== null) {\n      // If there are unhandled errors, switch to the slow work loop.\n      // TODO: How to avoid this check in the fast path? Maybe the renderer\n      // could keep track of which roots have unhandled errors and call a\n      // forked version of renderRoot.\n      slowWorkLoopThatChecksForFailedWork(expirationTime);\n      return;\n    }\n    if (nextRenderExpirationTime === NoWork || nextRenderExpirationTime > expirationTime) {\n      return;\n    }\n\n    if (nextRenderExpirationTime <= mostRecentCurrentTime) {\n      // Flush all expired work.\n      while (nextUnitOfWork !== null) {\n        nextUnitOfWork = performUnitOfWork(nextUnitOfWork);\n      }\n    } else {\n      // Flush asynchronous work until the deadline runs out of time.\n      while (nextUnitOfWork !== null && !shouldYield()) {\n        nextUnitOfWork = performUnitOfWork(nextUnitOfWork);\n      }\n    }\n  }\n\n  function slowWorkLoopThatChecksForFailedWork(expirationTime) {\n    if (nextRenderExpirationTime === NoWork || nextRenderExpirationTime > expirationTime) {\n      return;\n    }\n\n    if (nextRenderExpirationTime <= mostRecentCurrentTime) {\n      // Flush all expired work.\n      while (nextUnitOfWork !== null) {\n        if (hasCapturedError(nextUnitOfWork)) {\n          // Use a forked version of performUnitOfWork\n          nextUnitOfWork = performFailedUnitOfWork(nextUnitOfWork);\n        } else {\n          nextUnitOfWork = performUnitOfWork(nextUnitOfWork);\n        }\n      }\n    } else {\n      // Flush asynchronous work until the deadline runs out of time.\n      while (nextUnitOfWork !== null && !shouldYield()) {\n        if (hasCapturedError(nextUnitOfWork)) {\n          // Use a forked version of performUnitOfWork\n          nextUnitOfWork = performFailedUnitOfWork(nextUnitOfWork);\n        } else {\n          nextUnitOfWork = performUnitOfWork(nextUnitOfWork);\n        }\n      }\n    }\n  }\n\n  function renderRootCatchBlock(root, failedWork, boundary, expirationTime) {\n    // We're going to restart the error boundary that captured the error.\n    // Conceptually, we're unwinding the stack. We need to unwind the\n    // context stack, too.\n    unwindContexts(failedWork, boundary);\n\n    // Restart the error boundary using a forked version of\n    // performUnitOfWork that deletes the boundary's children. The entire\n    // failed subree will be unmounted. During the commit phase, a special\n    // lifecycle method is called on the error boundary, which triggers\n    // a re-render.\n    nextUnitOfWork = performFailedUnitOfWork(boundary);\n\n    // Continue working.\n    workLoop(expirationTime);\n  }\n\n  function renderRoot(root, expirationTime) {\n    !!isWorking ? invariant(false, 'renderRoot was called recursively. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n    isWorking = true;\n\n    // We're about to mutate the work-in-progress tree. If the root was pending\n    // commit, it no longer is: we'll need to complete it again.\n    root.isReadyForCommit = false;\n\n    // Check if we're starting from a fresh stack, or if we're resuming from\n    // previously yielded work.\n    if (root !== nextRoot || expirationTime !== nextRenderExpirationTime || nextUnitOfWork === null) {\n      // Reset the stack and start working from the root.\n      resetContextStack();\n      nextRoot = root;\n      nextRenderExpirationTime = expirationTime;\n      nextUnitOfWork = createWorkInProgress(nextRoot.current, null, expirationTime);\n    }\n\n    startWorkLoopTimer(nextUnitOfWork);\n\n    var didError = false;\n    var error = null;\n    {\n      invokeGuardedCallback(null, workLoop, null, expirationTime);\n      if (hasCaughtError()) {\n        didError = true;\n        error = clearCaughtError();\n      }\n    }\n\n    // An error was thrown during the render phase.\n    while (didError) {\n      if (didFatal) {\n        // This was a fatal error. Don't attempt to recover from it.\n        firstUncaughtError = error;\n        break;\n      }\n\n      var failedWork = nextUnitOfWork;\n      if (failedWork === null) {\n        // An error was thrown but there's no current unit of work. This can\n        // happen during the commit phase if there's a bug in the renderer.\n        didFatal = true;\n        continue;\n      }\n\n      // \"Capture\" the error by finding the nearest boundary. If there is no\n      // error boundary, we use the root.\n      var boundary = captureError(failedWork, error);\n      !(boundary !== null) ? invariant(false, 'Should have found an error boundary. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n\n      if (didFatal) {\n        // The error we just captured was a fatal error. This happens\n        // when the error propagates to the root more than once.\n        continue;\n      }\n\n      didError = false;\n      error = null;\n      {\n        invokeGuardedCallback(null, renderRootCatchBlock, null, root, failedWork, boundary, expirationTime);\n        if (hasCaughtError()) {\n          didError = true;\n          error = clearCaughtError();\n          continue;\n        }\n      }\n      // We're finished working. Exit the error loop.\n      break;\n    }\n\n    var uncaughtError = firstUncaughtError;\n\n    // We're done performing work. Time to clean up.\n    stopWorkLoopTimer(interruptedBy);\n    interruptedBy = null;\n    isWorking = false;\n    didFatal = false;\n    firstUncaughtError = null;\n\n    if (uncaughtError !== null) {\n      onUncaughtError(uncaughtError);\n    }\n\n    return root.isReadyForCommit ? root.current.alternate : null;\n  }\n\n  // Returns the boundary that captured the error, or null if the error is ignored\n  function captureError(failedWork, error) {\n    // It is no longer valid because we exited the user code.\n    ReactCurrentOwner.current = null;\n    {\n      ReactDebugCurrentFiber.resetCurrentFiber();\n    }\n\n    // Search for the nearest error boundary.\n    var boundary = null;\n\n    // Passed to logCapturedError()\n    var errorBoundaryFound = false;\n    var willRetry = false;\n    var errorBoundaryName = null;\n\n    // Host containers are a special case. If the failed work itself is a host\n    // container, then it acts as its own boundary. In all other cases, we\n    // ignore the work itself and only search through the parents.\n    if (failedWork.tag === HostRoot) {\n      boundary = failedWork;\n\n      if (isFailedBoundary(failedWork)) {\n        // If this root already failed, there must have been an error when\n        // attempting to unmount it. This is a worst-case scenario and\n        // should only be possible if there's a bug in the renderer.\n        didFatal = true;\n      }\n    } else {\n      var node = failedWork['return'];\n      while (node !== null && boundary === null) {\n        if (node.tag === ClassComponent) {\n          var instance = node.stateNode;\n          if (typeof instance.componentDidCatch === 'function') {\n            errorBoundaryFound = true;\n            errorBoundaryName = getComponentName(node);\n\n            // Found an error boundary!\n            boundary = node;\n            willRetry = true;\n          }\n        } else if (node.tag === HostRoot) {\n          // Treat the root like a no-op error boundary\n          boundary = node;\n        }\n\n        if (isFailedBoundary(node)) {\n          // This boundary is already in a failed state.\n\n          // If we're currently unmounting, that means this error was\n          // thrown while unmounting a failed subtree. We should ignore\n          // the error.\n          if (isUnmounting) {\n            return null;\n          }\n\n          // If we're in the commit phase, we should check to see if\n          // this boundary already captured an error during this commit.\n          // This case exists because multiple errors can be thrown during\n          // a single commit without interruption.\n          if (commitPhaseBoundaries !== null && (commitPhaseBoundaries.has(node) || node.alternate !== null && commitPhaseBoundaries.has(node.alternate))) {\n            // If so, we should ignore this error.\n            return null;\n          }\n\n          // The error should propagate to the next boundary - we keep looking.\n          boundary = null;\n          willRetry = false;\n        }\n\n        node = node['return'];\n      }\n    }\n\n    if (boundary !== null) {\n      // Add to the collection of failed boundaries. This lets us know that\n      // subsequent errors in this subtree should propagate to the next boundary.\n      if (failedBoundaries === null) {\n        failedBoundaries = new Set();\n      }\n      failedBoundaries.add(boundary);\n\n      // This method is unsafe outside of the begin and complete phases.\n      // We might be in the commit phase when an error is captured.\n      // The risk is that the return path from this Fiber may not be accurate.\n      // That risk is acceptable given the benefit of providing users more context.\n      var _componentStack = getStackAddendumByWorkInProgressFiber(failedWork);\n      var _componentName = getComponentName(failedWork);\n\n      // Add to the collection of captured errors. This is stored as a global\n      // map of errors and their component stack location keyed by the boundaries\n      // that capture them. We mostly use this Map as a Set; it's a Map only to\n      // avoid adding a field to Fiber to store the error.\n      if (capturedErrors === null) {\n        capturedErrors = new Map();\n      }\n\n      var capturedError = {\n        componentName: _componentName,\n        componentStack: _componentStack,\n        error: error,\n        errorBoundary: errorBoundaryFound ? boundary.stateNode : null,\n        errorBoundaryFound: errorBoundaryFound,\n        errorBoundaryName: errorBoundaryName,\n        willRetry: willRetry\n      };\n\n      capturedErrors.set(boundary, capturedError);\n\n      try {\n        logCapturedError(capturedError);\n      } catch (e) {\n        // Prevent cycle if logCapturedError() throws.\n        // A cycle may still occur if logCapturedError renders a component that throws.\n        var suppressLogging = e && e.suppressReactErrorLogging;\n        if (!suppressLogging) {\n          console.error(e);\n        }\n      }\n\n      // If we're in the commit phase, defer scheduling an update on the\n      // boundary until after the commit is complete\n      if (isCommitting) {\n        if (commitPhaseBoundaries === null) {\n          commitPhaseBoundaries = new Set();\n        }\n        commitPhaseBoundaries.add(boundary);\n      } else {\n        // Otherwise, schedule an update now.\n        // TODO: Is this actually necessary during the render phase? Is it\n        // possible to unwind and continue rendering at the same priority,\n        // without corrupting internal state?\n        scheduleErrorRecovery(boundary);\n      }\n      return boundary;\n    } else if (firstUncaughtError === null) {\n      // If no boundary is found, we'll need to throw the error\n      firstUncaughtError = error;\n    }\n    return null;\n  }\n\n  function hasCapturedError(fiber) {\n    // TODO: capturedErrors should store the boundary instance, to avoid needing\n    // to check the alternate.\n    return capturedErrors !== null && (capturedErrors.has(fiber) || fiber.alternate !== null && capturedErrors.has(fiber.alternate));\n  }\n\n  function isFailedBoundary(fiber) {\n    // TODO: failedBoundaries should store the boundary instance, to avoid\n    // needing to check the alternate.\n    return failedBoundaries !== null && (failedBoundaries.has(fiber) || fiber.alternate !== null && failedBoundaries.has(fiber.alternate));\n  }\n\n  function commitErrorHandling(effectfulFiber) {\n    var capturedError = void 0;\n    if (capturedErrors !== null) {\n      capturedError = capturedErrors.get(effectfulFiber);\n      capturedErrors['delete'](effectfulFiber);\n      if (capturedError == null) {\n        if (effectfulFiber.alternate !== null) {\n          effectfulFiber = effectfulFiber.alternate;\n          capturedError = capturedErrors.get(effectfulFiber);\n          capturedErrors['delete'](effectfulFiber);\n        }\n      }\n    }\n\n    !(capturedError != null) ? invariant(false, 'No error for given unit of work. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n\n    switch (effectfulFiber.tag) {\n      case ClassComponent:\n        var instance = effectfulFiber.stateNode;\n\n        var info = {\n          componentStack: capturedError.componentStack\n        };\n\n        // Allow the boundary to handle the error, usually by scheduling\n        // an update to itself\n        instance.componentDidCatch(capturedError.error, info);\n        return;\n      case HostRoot:\n        if (firstUncaughtError === null) {\n          firstUncaughtError = capturedError.error;\n        }\n        return;\n      default:\n        invariant(false, 'Invalid type of work. This error is likely caused by a bug in React. Please file an issue.');\n    }\n  }\n\n  function unwindContexts(from, to) {\n    var node = from;\n    while (node !== null) {\n      switch (node.tag) {\n        case ClassComponent:\n          popContextProvider(node);\n          break;\n        case HostComponent:\n          popHostContext(node);\n          break;\n        case HostRoot:\n          popHostContainer(node);\n          break;\n        case HostPortal:\n          popHostContainer(node);\n          break;\n      }\n      if (node === to || node.alternate === to) {\n        stopFailedWorkTimer(node);\n        break;\n      } else {\n        stopWorkTimer(node);\n      }\n      node = node['return'];\n    }\n  }\n\n  function computeAsyncExpiration() {\n    // Given the current clock time, returns an expiration time. We use rounding\n    // to batch like updates together.\n    // Should complete within ~1000ms. 1200ms max.\n    var currentTime = recalculateCurrentTime();\n    var expirationMs = 1000;\n    var bucketSizeMs = 200;\n    return computeExpirationBucket(currentTime, expirationMs, bucketSizeMs);\n  }\n\n  function computeExpirationForFiber(fiber) {\n    var expirationTime = void 0;\n    if (expirationContext !== NoWork) {\n      // An explicit expiration context was set;\n      expirationTime = expirationContext;\n    } else if (isWorking) {\n      if (isCommitting) {\n        // Updates that occur during the commit phase should have sync priority\n        // by default.\n        expirationTime = Sync;\n      } else {\n        // Updates during the render phase should expire at the same time as\n        // the work that is being rendered.\n        expirationTime = nextRenderExpirationTime;\n      }\n    } else {\n      // No explicit expiration context was set, and we're not currently\n      // performing work. Calculate a new expiration time.\n      if (useSyncScheduling && !(fiber.internalContextTag & AsyncUpdates)) {\n        // This is a sync update\n        expirationTime = Sync;\n      } else {\n        // This is an async update\n        expirationTime = computeAsyncExpiration();\n      }\n    }\n    return expirationTime;\n  }\n\n  function scheduleWork(fiber, expirationTime) {\n    return scheduleWorkImpl(fiber, expirationTime, false);\n  }\n\n  function checkRootNeedsClearing(root, fiber, expirationTime) {\n    if (!isWorking && root === nextRoot && expirationTime < nextRenderExpirationTime) {\n      // Restart the root from the top.\n      if (nextUnitOfWork !== null) {\n        // This is an interruption. (Used for performance tracking.)\n        interruptedBy = fiber;\n      }\n      nextRoot = null;\n      nextUnitOfWork = null;\n      nextRenderExpirationTime = NoWork;\n    }\n  }\n\n  function scheduleWorkImpl(fiber, expirationTime, isErrorRecovery) {\n    recordScheduleUpdate();\n\n    {\n      if (!isErrorRecovery && fiber.tag === ClassComponent) {\n        var instance = fiber.stateNode;\n        warnAboutInvalidUpdates(instance);\n      }\n    }\n\n    var node = fiber;\n    while (node !== null) {\n      // Walk the parent path to the root and update each node's\n      // expiration time.\n      if (node.expirationTime === NoWork || node.expirationTime > expirationTime) {\n        node.expirationTime = expirationTime;\n      }\n      if (node.alternate !== null) {\n        if (node.alternate.expirationTime === NoWork || node.alternate.expirationTime > expirationTime) {\n          node.alternate.expirationTime = expirationTime;\n        }\n      }\n      if (node['return'] === null) {\n        if (node.tag === HostRoot) {\n          var root = node.stateNode;\n\n          checkRootNeedsClearing(root, fiber, expirationTime);\n          requestWork(root, expirationTime);\n          checkRootNeedsClearing(root, fiber, expirationTime);\n        } else {\n          {\n            if (!isErrorRecovery && fiber.tag === ClassComponent) {\n              warnAboutUpdateOnUnmounted(fiber);\n            }\n          }\n          return;\n        }\n      }\n      node = node['return'];\n    }\n  }\n\n  function scheduleErrorRecovery(fiber) {\n    scheduleWorkImpl(fiber, Sync, true);\n  }\n\n  function recalculateCurrentTime() {\n    // Subtract initial time so it fits inside 32bits\n    var ms = now() - startTime;\n    mostRecentCurrentTime = msToExpirationTime(ms);\n    return mostRecentCurrentTime;\n  }\n\n  function deferredUpdates(fn) {\n    var previousExpirationContext = expirationContext;\n    expirationContext = computeAsyncExpiration();\n    try {\n      return fn();\n    } finally {\n      expirationContext = previousExpirationContext;\n    }\n  }\n\n  function syncUpdates(fn) {\n    var previousExpirationContext = expirationContext;\n    expirationContext = Sync;\n    try {\n      return fn();\n    } finally {\n      expirationContext = previousExpirationContext;\n    }\n  }\n\n  // TODO: Everything below this is written as if it has been lifted to the\n  // renderers. I'll do this in a follow-up.\n\n  // Linked-list of roots\n  var firstScheduledRoot = null;\n  var lastScheduledRoot = null;\n\n  var callbackExpirationTime = NoWork;\n  var callbackID = -1;\n  var isRendering = false;\n  var nextFlushedRoot = null;\n  var nextFlushedExpirationTime = NoWork;\n  var deadlineDidExpire = false;\n  var hasUnhandledError = false;\n  var unhandledError = null;\n  var deadline = null;\n\n  var isBatchingUpdates = false;\n  var isUnbatchingUpdates = false;\n\n  // Use these to prevent an infinite loop of nested updates\n  var NESTED_UPDATE_LIMIT = 1000;\n  var nestedUpdateCount = 0;\n\n  var timeHeuristicForUnitOfWork = 1;\n\n  function scheduleCallbackWithExpiration(expirationTime) {\n    if (callbackExpirationTime !== NoWork) {\n      // A callback is already scheduled. Check its expiration time (timeout).\n      if (expirationTime > callbackExpirationTime) {\n        // Existing callback has sufficient timeout. Exit.\n        return;\n      } else {\n        // Existing callback has insufficient timeout. Cancel and schedule a\n        // new one.\n        cancelDeferredCallback(callbackID);\n      }\n      // The request callback timer is already running. Don't start a new one.\n    } else {\n      startRequestCallbackTimer();\n    }\n\n    // Compute a timeout for the given expiration time.\n    var currentMs = now() - startTime;\n    var expirationMs = expirationTimeToMs(expirationTime);\n    var timeout = expirationMs - currentMs;\n\n    callbackExpirationTime = expirationTime;\n    callbackID = scheduleDeferredCallback(performAsyncWork, { timeout: timeout });\n  }\n\n  // requestWork is called by the scheduler whenever a root receives an update.\n  // It's up to the renderer to call renderRoot at some point in the future.\n  function requestWork(root, expirationTime) {\n    if (nestedUpdateCount > NESTED_UPDATE_LIMIT) {\n      invariant(false, 'Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.');\n    }\n\n    // Add the root to the schedule.\n    // Check if this root is already part of the schedule.\n    if (root.nextScheduledRoot === null) {\n      // This root is not already scheduled. Add it.\n      root.remainingExpirationTime = expirationTime;\n      if (lastScheduledRoot === null) {\n        firstScheduledRoot = lastScheduledRoot = root;\n        root.nextScheduledRoot = root;\n      } else {\n        lastScheduledRoot.nextScheduledRoot = root;\n        lastScheduledRoot = root;\n        lastScheduledRoot.nextScheduledRoot = firstScheduledRoot;\n      }\n    } else {\n      // This root is already scheduled, but its priority may have increased.\n      var remainingExpirationTime = root.remainingExpirationTime;\n      if (remainingExpirationTime === NoWork || expirationTime < remainingExpirationTime) {\n        // Update the priority.\n        root.remainingExpirationTime = expirationTime;\n      }\n    }\n\n    if (isRendering) {\n      // Prevent reentrancy. Remaining work will be scheduled at the end of\n      // the currently rendering batch.\n      return;\n    }\n\n    if (isBatchingUpdates) {\n      // Flush work at the end of the batch.\n      if (isUnbatchingUpdates) {\n        // ...unless we're inside unbatchedUpdates, in which case we should\n        // flush it now.\n        nextFlushedRoot = root;\n        nextFlushedExpirationTime = Sync;\n        performWorkOnRoot(nextFlushedRoot, nextFlushedExpirationTime);\n      }\n      return;\n    }\n\n    // TODO: Get rid of Sync and use current time?\n    if (expirationTime === Sync) {\n      performWork(Sync, null);\n    } else {\n      scheduleCallbackWithExpiration(expirationTime);\n    }\n  }\n\n  function findHighestPriorityRoot() {\n    var highestPriorityWork = NoWork;\n    var highestPriorityRoot = null;\n\n    if (lastScheduledRoot !== null) {\n      var previousScheduledRoot = lastScheduledRoot;\n      var root = firstScheduledRoot;\n      while (root !== null) {\n        var remainingExpirationTime = root.remainingExpirationTime;\n        if (remainingExpirationTime === NoWork) {\n          // This root no longer has work. Remove it from the scheduler.\n\n          // TODO: This check is redudant, but Flow is confused by the branch\n          // below where we set lastScheduledRoot to null, even though we break\n          // from the loop right after.\n          !(previousScheduledRoot !== null && lastScheduledRoot !== null) ? invariant(false, 'Should have a previous and last root. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n          if (root === root.nextScheduledRoot) {\n            // This is the only root in the list.\n            root.nextScheduledRoot = null;\n            firstScheduledRoot = lastScheduledRoot = null;\n            break;\n          } else if (root === firstScheduledRoot) {\n            // This is the first root in the list.\n            var next = root.nextScheduledRoot;\n            firstScheduledRoot = next;\n            lastScheduledRoot.nextScheduledRoot = next;\n            root.nextScheduledRoot = null;\n          } else if (root === lastScheduledRoot) {\n            // This is the last root in the list.\n            lastScheduledRoot = previousScheduledRoot;\n            lastScheduledRoot.nextScheduledRoot = firstScheduledRoot;\n            root.nextScheduledRoot = null;\n            break;\n          } else {\n            previousScheduledRoot.nextScheduledRoot = root.nextScheduledRoot;\n            root.nextScheduledRoot = null;\n          }\n          root = previousScheduledRoot.nextScheduledRoot;\n        } else {\n          if (highestPriorityWork === NoWork || remainingExpirationTime < highestPriorityWork) {\n            // Update the priority, if it's higher\n            highestPriorityWork = remainingExpirationTime;\n            highestPriorityRoot = root;\n          }\n          if (root === lastScheduledRoot) {\n            break;\n          }\n          previousScheduledRoot = root;\n          root = root.nextScheduledRoot;\n        }\n      }\n    }\n\n    // If the next root is the same as the previous root, this is a nested\n    // update. To prevent an infinite loop, increment the nested update count.\n    var previousFlushedRoot = nextFlushedRoot;\n    if (previousFlushedRoot !== null && previousFlushedRoot === highestPriorityRoot) {\n      nestedUpdateCount++;\n    } else {\n      // Reset whenever we switch roots.\n      nestedUpdateCount = 0;\n    }\n    nextFlushedRoot = highestPriorityRoot;\n    nextFlushedExpirationTime = highestPriorityWork;\n  }\n\n  function performAsyncWork(dl) {\n    performWork(NoWork, dl);\n  }\n\n  function performWork(minExpirationTime, dl) {\n    deadline = dl;\n\n    // Keep working on roots until there's no more work, or until the we reach\n    // the deadline.\n    findHighestPriorityRoot();\n\n    if (enableUserTimingAPI && deadline !== null) {\n      var didExpire = nextFlushedExpirationTime < recalculateCurrentTime();\n      stopRequestCallbackTimer(didExpire);\n    }\n\n    while (nextFlushedRoot !== null && nextFlushedExpirationTime !== NoWork && (minExpirationTime === NoWork || nextFlushedExpirationTime <= minExpirationTime) && !deadlineDidExpire) {\n      performWorkOnRoot(nextFlushedRoot, nextFlushedExpirationTime);\n      // Find the next highest priority work.\n      findHighestPriorityRoot();\n    }\n\n    // We're done flushing work. Either we ran out of time in this callback,\n    // or there's no more work left with sufficient priority.\n\n    // If we're inside a callback, set this to false since we just completed it.\n    if (deadline !== null) {\n      callbackExpirationTime = NoWork;\n      callbackID = -1;\n    }\n    // If there's work left over, schedule a new callback.\n    if (nextFlushedExpirationTime !== NoWork) {\n      scheduleCallbackWithExpiration(nextFlushedExpirationTime);\n    }\n\n    // Clean-up.\n    deadline = null;\n    deadlineDidExpire = false;\n    nestedUpdateCount = 0;\n\n    if (hasUnhandledError) {\n      var _error4 = unhandledError;\n      unhandledError = null;\n      hasUnhandledError = false;\n      throw _error4;\n    }\n  }\n\n  function performWorkOnRoot(root, expirationTime) {\n    !!isRendering ? invariant(false, 'performWorkOnRoot was called recursively. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n\n    isRendering = true;\n\n    // Check if this is async work or sync/expired work.\n    // TODO: Pass current time as argument to renderRoot, commitRoot\n    if (expirationTime <= recalculateCurrentTime()) {\n      // Flush sync work.\n      var finishedWork = root.finishedWork;\n      if (finishedWork !== null) {\n        // This root is already complete. We can commit it.\n        root.finishedWork = null;\n        root.remainingExpirationTime = commitRoot(finishedWork);\n      } else {\n        root.finishedWork = null;\n        finishedWork = renderRoot(root, expirationTime);\n        if (finishedWork !== null) {\n          // We've completed the root. Commit it.\n          root.remainingExpirationTime = commitRoot(finishedWork);\n        }\n      }\n    } else {\n      // Flush async work.\n      var _finishedWork = root.finishedWork;\n      if (_finishedWork !== null) {\n        // This root is already complete. We can commit it.\n        root.finishedWork = null;\n        root.remainingExpirationTime = commitRoot(_finishedWork);\n      } else {\n        root.finishedWork = null;\n        _finishedWork = renderRoot(root, expirationTime);\n        if (_finishedWork !== null) {\n          // We've completed the root. Check the deadline one more time\n          // before committing.\n          if (!shouldYield()) {\n            // Still time left. Commit the root.\n            root.remainingExpirationTime = commitRoot(_finishedWork);\n          } else {\n            // There's no time left. Mark this root as complete. We'll come\n            // back and commit it later.\n            root.finishedWork = _finishedWork;\n          }\n        }\n      }\n    }\n\n    isRendering = false;\n  }\n\n  // When working on async work, the reconciler asks the renderer if it should\n  // yield execution. For DOM, we implement this with requestIdleCallback.\n  function shouldYield() {\n    if (deadline === null) {\n      return false;\n    }\n    if (deadline.timeRemaining() > timeHeuristicForUnitOfWork) {\n      // Disregard deadline.didTimeout. Only expired work should be flushed\n      // during a timeout. This path is only hit for non-expired work.\n      return false;\n    }\n    deadlineDidExpire = true;\n    return true;\n  }\n\n  // TODO: Not happy about this hook. Conceptually, renderRoot should return a\n  // tuple of (isReadyForCommit, didError, error)\n  function onUncaughtError(error) {\n    !(nextFlushedRoot !== null) ? invariant(false, 'Should be working on a root. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n    // Unschedule this root so we don't work on it again until there's\n    // another update.\n    nextFlushedRoot.remainingExpirationTime = NoWork;\n    if (!hasUnhandledError) {\n      hasUnhandledError = true;\n      unhandledError = error;\n    }\n  }\n\n  // TODO: Batching should be implemented at the renderer level, not inside\n  // the reconciler.\n  function batchedUpdates(fn, a) {\n    var previousIsBatchingUpdates = isBatchingUpdates;\n    isBatchingUpdates = true;\n    try {\n      return fn(a);\n    } finally {\n      isBatchingUpdates = previousIsBatchingUpdates;\n      if (!isBatchingUpdates && !isRendering) {\n        performWork(Sync, null);\n      }\n    }\n  }\n\n  // TODO: Batching should be implemented at the renderer level, not inside\n  // the reconciler.\n  function unbatchedUpdates(fn) {\n    if (isBatchingUpdates && !isUnbatchingUpdates) {\n      isUnbatchingUpdates = true;\n      try {\n        return fn();\n      } finally {\n        isUnbatchingUpdates = false;\n      }\n    }\n    return fn();\n  }\n\n  // TODO: Batching should be implemented at the renderer level, not within\n  // the reconciler.\n  function flushSync(fn) {\n    var previousIsBatchingUpdates = isBatchingUpdates;\n    isBatchingUpdates = true;\n    try {\n      return syncUpdates(fn);\n    } finally {\n      isBatchingUpdates = previousIsBatchingUpdates;\n      !!isRendering ? invariant(false, 'flushSync was called from inside a lifecycle method. It cannot be called when React is already rendering.') : void 0;\n      performWork(Sync, null);\n    }\n  }\n\n  return {\n    computeAsyncExpiration: computeAsyncExpiration,\n    computeExpirationForFiber: computeExpirationForFiber,\n    scheduleWork: scheduleWork,\n    batchedUpdates: batchedUpdates,\n    unbatchedUpdates: unbatchedUpdates,\n    flushSync: flushSync,\n    deferredUpdates: deferredUpdates\n  };\n};\n\n{\n  var didWarnAboutNestedUpdates = false;\n}\n\n// 0 is PROD, 1 is DEV.\n// Might add PROFILE later.\n\n\nfunction getContextForSubtree(parentComponent) {\n  if (!parentComponent) {\n    return emptyObject;\n  }\n\n  var fiber = get(parentComponent);\n  var parentContext = findCurrentUnmaskedContext(fiber);\n  return isContextProvider(fiber) ? processChildContext(fiber, parentContext) : parentContext;\n}\n\nvar ReactFiberReconciler = function (config) {\n  var getPublicInstance = config.getPublicInstance;\n\n  var _ReactFiberScheduler = ReactFiberScheduler(config),\n      computeAsyncExpiration = _ReactFiberScheduler.computeAsyncExpiration,\n      computeExpirationForFiber = _ReactFiberScheduler.computeExpirationForFiber,\n      scheduleWork = _ReactFiberScheduler.scheduleWork,\n      batchedUpdates = _ReactFiberScheduler.batchedUpdates,\n      unbatchedUpdates = _ReactFiberScheduler.unbatchedUpdates,\n      flushSync = _ReactFiberScheduler.flushSync,\n      deferredUpdates = _ReactFiberScheduler.deferredUpdates;\n\n  function scheduleTopLevelUpdate(current, element, callback) {\n    {\n      if (ReactDebugCurrentFiber.phase === 'render' && ReactDebugCurrentFiber.current !== null && !didWarnAboutNestedUpdates) {\n        didWarnAboutNestedUpdates = true;\n        warning(false, 'Render methods should be a pure function of props and state; ' + 'triggering nested component updates from render is not allowed. ' + 'If necessary, trigger nested updates in componentDidUpdate.\\n\\n' + 'Check the render method of %s.', getComponentName(ReactDebugCurrentFiber.current) || 'Unknown');\n      }\n    }\n\n    callback = callback === undefined ? null : callback;\n    {\n      warning(callback === null || typeof callback === 'function', 'render(...): Expected the last optional `callback` argument to be a ' + 'function. Instead received: %s.', callback);\n    }\n\n    var expirationTime = void 0;\n    // Check if the top-level element is an async wrapper component. If so,\n    // treat updates to the root as async. This is a bit weird but lets us\n    // avoid a separate `renderAsync` API.\n    if (enableAsyncSubtreeAPI && element != null && element.type != null && element.type.prototype != null && element.type.prototype.unstable_isAsyncReactComponent === true) {\n      expirationTime = computeAsyncExpiration();\n    } else {\n      expirationTime = computeExpirationForFiber(current);\n    }\n\n    var update = {\n      expirationTime: expirationTime,\n      partialState: { element: element },\n      callback: callback,\n      isReplace: false,\n      isForced: false,\n      nextCallback: null,\n      next: null\n    };\n    insertUpdateIntoFiber(current, update);\n    scheduleWork(current, expirationTime);\n  }\n\n  function findHostInstance(fiber) {\n    var hostFiber = findCurrentHostFiber(fiber);\n    if (hostFiber === null) {\n      return null;\n    }\n    return hostFiber.stateNode;\n  }\n\n  return {\n    createContainer: function (containerInfo, hydrate) {\n      return createFiberRoot(containerInfo, hydrate);\n    },\n    updateContainer: function (element, container, parentComponent, callback) {\n      // TODO: If this is a nested container, this won't be the root.\n      var current = container.current;\n\n      {\n        if (ReactFiberInstrumentation_1.debugTool) {\n          if (current.alternate === null) {\n            ReactFiberInstrumentation_1.debugTool.onMountContainer(container);\n          } else if (element === null) {\n            ReactFiberInstrumentation_1.debugTool.onUnmountContainer(container);\n          } else {\n            ReactFiberInstrumentation_1.debugTool.onUpdateContainer(container);\n          }\n        }\n      }\n\n      var context = getContextForSubtree(parentComponent);\n      if (container.context === null) {\n        container.context = context;\n      } else {\n        container.pendingContext = context;\n      }\n\n      scheduleTopLevelUpdate(current, element, callback);\n    },\n\n\n    batchedUpdates: batchedUpdates,\n\n    unbatchedUpdates: unbatchedUpdates,\n\n    deferredUpdates: deferredUpdates,\n\n    flushSync: flushSync,\n\n    getPublicRootInstance: function (container) {\n      var containerFiber = container.current;\n      if (!containerFiber.child) {\n        return null;\n      }\n      switch (containerFiber.child.tag) {\n        case HostComponent:\n          return getPublicInstance(containerFiber.child.stateNode);\n        default:\n          return containerFiber.child.stateNode;\n      }\n    },\n\n\n    findHostInstance: findHostInstance,\n\n    findHostInstanceWithNoPortals: function (fiber) {\n      var hostFiber = findCurrentHostFiberWithNoPortals(fiber);\n      if (hostFiber === null) {\n        return null;\n      }\n      return hostFiber.stateNode;\n    },\n    injectIntoDevTools: function (devToolsConfig) {\n      var findFiberByHostInstance = devToolsConfig.findFiberByHostInstance;\n\n      return injectInternals(_assign({}, devToolsConfig, {\n        findHostInstanceByFiber: function (fiber) {\n          return findHostInstance(fiber);\n        },\n        findFiberByHostInstance: function (instance) {\n          if (!findFiberByHostInstance) {\n            // Might not be implemented by the renderer.\n            return null;\n          }\n          return findFiberByHostInstance(instance);\n        }\n      }));\n    }\n  };\n};\n\nvar ReactFiberReconciler$1 = Object.freeze({\n\tdefault: ReactFiberReconciler\n});\n\nvar ReactFiberReconciler$2 = ( ReactFiberReconciler$1 && ReactFiberReconciler ) || ReactFiberReconciler$1;\n\n// TODO: bundle Flow types with the package.\n\n\n\n// TODO: decide on the top-level export form.\n// This is hacky but makes it work with both Rollup and Jest.\nvar reactReconciler = ReactFiberReconciler$2['default'] ? ReactFiberReconciler$2['default'] : ReactFiberReconciler$2;\n\nmodule.exports = reactReconciler;\n    return ($$$reconciler || ($$$reconciler = module.exports))(config);\n  };\n}\n"]},"metadata":{},"sourceType":"script"}